{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":1,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/SETSUNAYANG.JPG","path":"images/SETSUNAYANG.JPG","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/beian.png","path":"images/beian.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/gitee.png","path":"images/gitee.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/github.png","path":"images/github.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","path":"images/hexo-tag-chart.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/hexo.png","path":"images/hexo.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/dz.js","path":"js/dz.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","path":"js/jquery-3.6.0.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","path":"css/fonts/remixicon.svg","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.css","path":"css/fonts/remixicon.css","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","path":"css/fonts/remixicon.eot","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","path":"css/fonts/remixicon.ttf","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","path":"css/fonts/remixicon.woff2","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","path":"css/fonts/remixicon.woff","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/C-程序内存分区.md","hash":"a53cceb914fbca385e055b0c9d7f962a71248dc3","modified":1693303227126},{"_id":"source/_posts/GC—全过程.md","hash":"de0d35c3308e274b2e799b1dba90fc6290dfd30a","modified":1693298806083},{"_id":"source/_posts/IP数据报.md","hash":"dd62852f75ded2a948b2864818223a43716b97f6","modified":1693464273778},{"_id":"source/_posts/GC—基础知识.md","hash":"8219b8ff1d2210e4b399beb15441db650d016723","modified":1693297892113},{"_id":"source/_posts/K8S架构图.md","hash":"122c7de78560ab48872bb396307af83fb2d7315c","modified":1693297946736},{"_id":"source/_posts/Innodb中的事务隔离级别和锁实现.md","hash":"fabf5ccf276bb4a920822527dfe96f5463336913","modified":1693270339195},{"_id":"source/_posts/GPM模型.md","hash":"80cf20f3a4e36c7a644283f66827e8e32a7eb831","modified":1693299342065},{"_id":"source/_posts/OSI-ISO七层网络.md","hash":"58575c413d9656236abd8031d34d16f2d3030515","modified":1693465520822},{"_id":"source/_posts/Qt简介.md","hash":"9c065482308d5a3f3893be53ca9d5291d7cf7ca6","modified":1693270271155},{"_id":"source/_posts/一次Mybatis升级引发的线上事故.md","hash":"db4501bae444e05cd4e4499f0aea5ad65ca1ee06","modified":1693563387910},{"_id":"source/_posts/Spring全景.md","hash":"bedf71622137fddf363040d0070c244cf1d8d536","modified":1693297967817},{"_id":"source/_posts/Tomcat启动流程.md","hash":"c46385ca4d413ab3bc63a2e6e3f1320bec08eaa6","modified":1693270322837},{"_id":"source/_posts/保持敬畏之心.md","hash":"176b275b17bc38a3aad181712fb45adb9caa8317","modified":1693309761957},{"_id":"source/_posts/内核页表设计.md","hash":"06cdb3cda566e8e882f452984b99dbfe760ddcb2","modified":1693297836275},{"_id":"source/_posts/命令行常用指令.md","hash":"d642cc060d167067aa1cf51636c4fc5fc5fe5e78","modified":1693442854377},{"_id":"source/_posts/本地调试Docker源码.md","hash":"dc8555351a31d323ce7016070c8e6432dade5872","modified":1693275776563},{"_id":"source/categories/index.md","hash":"f4d7281acde67e8ebc5ffe566d10cad2ca568468","modified":1693237447813},{"_id":"source/_posts/回调机制.md","hash":"9bdb58af3ef0c828d8647571f89f644f2642bf71","modified":1693322771706},{"_id":"source/tags/index.md","hash":"231b06c7394538c47cd161c9d171c94890467b58","modified":1693237837078},{"_id":"themes/ayer/_config.yml","hash":"e4d0b210a600a05b8e367c1f7fec33af71647b8f","modified":1693312310955},{"_id":"themes/ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1693144166197},{"_id":"themes/ayer/package.json","hash":"6f287150874e25757493857c564be64189c0c008","modified":1693145314875},{"_id":"themes/ayer/README.md","hash":"06421a758735285fcc9f6b605f3576a958ee1e8a","modified":1693145314875},{"_id":"themes/ayer/LICENSE","hash":"5f10900ed75022def5bf4c8639812671f0a6e2de","modified":1693145314875},{"_id":"themes/ayer/index.js","hash":"19292aa9df268dbab8ac51a2a3aa7a20ac1eb00a","modified":1693144166186},{"_id":"themes/ayer/move_config.js","hash":"e310bdb9a8738e506e53a40bd3cd895008d4cd61","modified":1693144166197},{"_id":"themes/ayer/languages/de.yml","hash":"cdeed93d1eb4e65195aaf97d8c517e97106ddfd5","modified":1693144166186},{"_id":"themes/ayer/rollup.config.js","hash":"13b61821acd9fc27131a34853037184b94ae8577","modified":1693144166197},{"_id":"themes/ayer/languages/default.yml","hash":"7e16c460c2c3d953c3bdebdef471ea747812b7a1","modified":1693144166186},{"_id":"themes/ayer/languages/en.yml","hash":"7e16c460c2c3d953c3bdebdef471ea747812b7a1","modified":1693144166187},{"_id":"themes/ayer/languages/fr.yml","hash":"4a3cb84884988624943c6b0f8c1754da34943092","modified":1693144166187},{"_id":"themes/ayer/languages/ja.yml","hash":"d2ccb7ac8c9ff2ee721843741bb30b019d0a8083","modified":1693144166187},{"_id":"themes/ayer/languages/ko.yml","hash":"7dc54c2db864e5b725b55e201030e92acc1c422e","modified":1693144166187},{"_id":"themes/ayer/.DS_Store","hash":"cf44a39e65f9f875509e24e4548cbc77adf58775","modified":1693283450829},{"_id":"themes/ayer/languages/nl.yml","hash":"2c289e97000c0c67636d96895aaa801c8abec0d4","modified":1693144166188},{"_id":"themes/ayer/languages/pt.yml","hash":"b137b9aead0dc4e2c2d9217ceb270460e41f5cb3","modified":1693144166188},{"_id":"themes/ayer/languages/no.yml","hash":"f8d7294f0d73ec35c37c050462cb725ea25a0fcc","modified":1693144166188},{"_id":"themes/ayer/languages/ru.yml","hash":"cdce73598db1aefb17b1c91658cfa4c906b98e24","modified":1693144166189},{"_id":"themes/ayer/languages/vi.yml","hash":"7d019ee795816a6a030a039d8238b71be04098fd","modified":1693144166189},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"edb2654bdb684fe0f21e8d6c841496c3506006ed","modified":1693144166189},{"_id":"themes/ayer/languages/es.yml","hash":"a3e8d81b99f62f86b3f34708253070b8806b31c8","modified":1693144166187},{"_id":"themes/ayer/layout/categories.ejs","hash":"c40f84aacdf7d33cfcb4eb9f78f331dad699abff","modified":1693144166195},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"68400b1859e58cba03b05020ac8f47b807933027","modified":1693144166189},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1693144166195},{"_id":"themes/ayer/layout/friends.ejs","hash":"18382cd4429588e58bf046beacaed06704832fe3","modified":1693144166195},{"_id":"themes/ayer/layout/index.ejs","hash":"77347cbb8635611d8b1fb84bde75f9dedaf8632d","modified":1693144166195},{"_id":"themes/ayer/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1693144166197},{"_id":"themes/ayer/layout/plain-page.ejs","hash":"39cce1936f5f0e2feb924a7af2f52a631d81b84f","modified":1693144166197},{"_id":"themes/ayer/scripts/default_config.js","hash":"70d6ee032d75410d540b6789b5949739a47f0125","modified":1693144166199},{"_id":"themes/ayer/layout/tags.ejs","hash":"88b34dd8d7b1e64fa27aa6ed72af996cf6700809","modified":1693144166197},{"_id":"themes/ayer/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1693144166197},{"_id":"themes/ayer/layout/layout.ejs","hash":"84864bd6b4fc92bdd0a8ccba491fe490a8ecbf9b","modified":1693283959738},{"_id":"themes/ayer/source-src/main.js","hash":"13c57a2cec878217a5a3ee9afb6705d4c3cc0d3c","modified":1693144166209},{"_id":"themes/ayer/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1693282854268},{"_id":"themes/ayer/layout/_partial/ads.ejs","hash":"d36962c66e3653aa94cc428731dd43a7ea4f979d","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"17ccda6fb61f1b6df94d23db936665c00a29a85b","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"9be7173badcca6582c1136204adb3aa432aada21","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"a56c8905987fa86657a9f081a89c12e5a5a5df54","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"3895f24a1ba9ef5d4a024b1f45a5f30bff9f9c7c","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"01ca257dde90dcadf1288a641401f6cf21a0ad43","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/float-btns.ejs","hash":"43ba0cd1f9e898bcbd873b1e9a2d47249d6aaf77","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1693144166190},{"_id":"themes/ayer/source/404.html","hash":"6e6ebc1161643ffa524c9ecf38af7cd8cf1c9ecc","modified":1693283423880},{"_id":"themes/ayer/layout/_partial/lock.ejs","hash":"bbb00715c204197e7790d08be9a29afe5976146e","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"61100fe248a744fab5dc71fb610992cbeff27e54","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/broadcast.ejs","hash":"c228fa93bcf2f8403729342854211ea976df9a9f","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"752666b28d5caed5e7d82d697d7546461e451d6f","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"d38a59e2316b8a9c233c2f41edc2a03eab2c0a2e","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"cf441365eff1f8143e3c9ae54954d0ebe0a358e5","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"80a159273db944026701fe5062403e0f17cb8277","modified":1693145314909},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"e3b411aef6e5f25f6c5c66b93d653ef70da8d4af","modified":1693144166194},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1693283423888},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"cde5caf73f120b1300ec7539bbf675597688c734","modified":1693144166191},{"_id":"themes/ayer/scripts/events/index.js","hash":"2c84d99e881f5cd1ee8a406b595a4365f3aea41e","modified":1693144166199},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e435b782178da75656f9616c7af564fb9ff0de50","modified":1693144166199},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"f9c8fceb2130929b8f11e22b1c3476c99d1574a8","modified":1693144166200},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"7b3df58faaa875d17afbf74ddef5601116f2ce3d","modified":1693144166200},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"58f4c93d22e4eb9743915223444335fb6fe06d21","modified":1693144166199},{"_id":"themes/ayer/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1693144166200},{"_id":"themes/ayer/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1693144166200},{"_id":"themes/ayer/scripts/lib/core.js","hash":"7908a82a86d63f35c6f785cacb1cfaf99ae7e0f9","modified":1693144166200},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"7bcde0d6384819fd4c975a6e6e24e0919fbb1593","modified":1693144166194},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"ca81abe75c80ab32d6b6c4fe65de8e74df07bef3","modified":1693144166190},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"017f9b628806eeb199da2e77485cd9ac8e2117b3","modified":1693283423880},{"_id":"themes/ayer/source/css/custom.styl","hash":"56276abe6cd7cbf49fbf4fd4c986733188374160","modified":1693283423880},{"_id":"themes/ayer/source/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1693283423888},{"_id":"themes/ayer/source/dist/main.js","hash":"158d69f927d1cee076a485e894f307fadbe9656c","modified":1693283423888},{"_id":"themes/ayer/source/images/SETSUNAYANG.JPG","hash":"b7612fc376c8afaccc1f6733a50bc35e8e897500","modified":1693283423889},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1693283423889},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1693283423891},{"_id":"themes/ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1693283423891},{"_id":"themes/ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1693283423891},{"_id":"themes/ayer/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1693283423891},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1693283423906},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1693283423906},{"_id":"themes/ayer/source/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1693283423906},{"_id":"themes/ayer/source/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1693283423906},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1693283423906},{"_id":"themes/ayer/source/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1693283423906},{"_id":"themes/ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1693283423908},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1693283423911},{"_id":"themes/ayer/source/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1693283423911},{"_id":"themes/ayer/source/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1693283423911},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1693283423911},{"_id":"themes/ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1693283423911},{"_id":"themes/ayer/source/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1693283423912},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1693283423912},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1693283423912},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"219753a5cf40cfbd557fbde01a71f589e6de4327","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"8dedef428b6ac7d629e1d1f6039b0f60dacc4c5e","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"630e719b9e805a26182a37152435d4787c0f1734","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"ce395318edf69766fe11161c4587a97f84521d85","modified":1693144166207},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"910dd0682971a616e1610daec23e7ff5a556df98","modified":1693144166207},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"66dc025b7f87fed31fabdba62a405f85ae443788","modified":1693145314905},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"cfb16c9dda7a609776a28702e0c3854a52e422a7","modified":1693144166191},{"_id":"themes/ayer/source-src/css/style.styl","hash":"3941939bdb95297488d19e3e3716d5925b6eed44","modified":1693144166208},{"_id":"themes/ayer/source-src/js/share.js","hash":"7edce2efe23e75e29765201dc8b00fd2a5b5c9d2","modified":1693144166209},{"_id":"themes/ayer/layout/_partial/post/author.ejs","hash":"57738b222e00bbd110be65d300d8bed34d73b3ea","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"9f86e3d222555181a3e631a09bcdabdd44507cb8","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"85f0ebeceee1c32623bfa1e4170dbe1e34442fea","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4647234e5c4529d754c9d0fc53ca9e9205f21443","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"5f8487fe7bed9a09001c6655244ff35f583cf1eb","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"bc540478d35780e142b069ba2adafd5d5ce8a7b0","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"4a21fd3d7335ffcd0661036fee81a927c125e2e2","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"3b076a65b9847cd6e0d424f5c2874046ef51d4d9","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"0a364766931f48df60b7c92fec8fde1067a93e00","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"e59198918e92ef92156aeefbf6023584ac1cae64","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"fea793e132f627a8148059a9aee8bc33550506d1","modified":1693144166193},{"_id":"themes/ayer/scripts/events/lib/merge-configs.js","hash":"54836a1b41ebb32acc41839f53e1892779f66bb2","modified":1693144166199},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"9898b0dd9237e21908ba40292a8a9f947bed44d2","modified":1693144166193},{"_id":"themes/ayer/scripts/events/lib/hello.js","hash":"96213218d7ce78eccf087d01038245be5169fee0","modified":1693145314889},{"_id":"themes/ayer/layout/_partial/post/twikoo.ejs","hash":"63bc5c056b2db2aca479705fc94eaa7fd26a7976","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"369396d0c5b669df7a26df95f7a1b8a52f4eea65","modified":1693144166194},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"4b8e8455709debd73fba6bf3aad63378c4156dc1","modified":1693144166194},{"_id":"themes/ayer/source-src/css/_partial/ads.styl","hash":"d4be39f60a81dd0e5bdd49671e7308deddc572de","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"3044bf059522e79a726265c9a2f603ec8dc4222d","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"39a0bc6c5cf85f0527d6ee81f6feebce8550c1dd","modified":1693144166202},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"94342884feac98e5ef58c9bd2781fc8f35220c1c","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"712cb4d8f3cef18dc33281bd8e9b6879efdb1687","modified":1693144166202},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"3b11d0c6c4439b0856ba81c50bd8867d5bb081da","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"1a4576c38ef19834a4d0a8ac887e7b55d21f2f13","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/friends.styl","hash":"9dd116846c92daee1c8f80b79cab231613b164b2","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"e894b3a1aff76e84137e1e6db59a75afd0a53f52","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"b81d13334cf39941792dff0e3af393fb7b8cc214","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"da8a82a48852411c10e279dfee43038d46f4f273","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"da34b6125de01938d11de6ad3c0fed2c75faf40a","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bde7bf3577c66a3ac829410d52fa2144212282ef","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"f2f43ae9831c3df017b35c68caa94f5eb911f697","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"87df748185edfba222c3f9a4b9ef8eee0e8e5ad3","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"007bca390ec685349add74e033ff2cb90a1701bc","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"9e9d8dc167ed2c332e4520cbf41244c34c1ebf64","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a8a069ea34a0fd043832890db5341405e9f462cd","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"f81076fc6d4a83be3371bcb79ab54d88e2605714","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"9ce2dd3ffdc4e170dfcb975a7158f913bc40b8d8","modified":1693144166205},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1693283423896},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1693283423912},{"_id":"themes/ayer/source/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1693283423880},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1693283423888},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1693283423887},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1693283423906},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1693144166199},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1693283423893},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1693283423898},{"_id":"themes/ayer/source/images/alipay.jpg","hash":"74e90e8757a66b03304fd6e2abb086e85dd72edf","modified":1693283423891},{"_id":"themes/ayer/source/images/wechat.jpg","hash":"d560cecf759485dfd385af9bad8f4f200aff21e5","modified":1693283423910},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1693283423882},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1693283423887},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1693283423901},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1693283423905},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","hash":"94144debfb5761d37d79336a10ef674f82baec1b","modified":1693283423885},{"_id":"public/search.xml","hash":"009e7e32d545bfd8c0e2c901233d7fa57f07567f","modified":1693563432770},{"_id":"public/tags/index.html","hash":"3b2fde7dec86b2e4d7e453545e9b7198452f5216","modified":1693563432770},{"_id":"public/categories/基本功/计算机网络/index.html","hash":"2e3bdc089c887dcaeb54f935c505f5bbe29ecd04","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/Go/index.html","hash":"f12fffda9dd45beb8f7e67f9e2cd078cb26ae1ac","modified":1693563432770},{"_id":"public/categories/思考/index.html","hash":"a9a4de18fa388d8f5d7aa48d37c176817c6aca5a","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/C/index.html","hash":"0f733c326d24433202955413d293737241d0a8ee","modified":1693563432770},{"_id":"public/categories/基本功/操作系统/index.html","hash":"f4febf700db2f0c16d49a39e355ee4c7a5609bbf","modified":1693563432770},{"_id":"public/categories/工程/服务端/index.html","hash":"bccdce0c09fd4e6bf6a008db7bed2bee88150683","modified":1693563432770},{"_id":"public/categories/其他/index.html","hash":"00c8457dfd5d00b01a38ba31b21c099f2f2ad311","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/编程理论/index.html","hash":"0d95439be2cfaec2854e7c696eb3874feede48c0","modified":1693563432770},{"_id":"public/categories/工程/云计算/index.html","hash":"dd34d1cf57b06ad192374da2c48cdbf49c1ab287","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/Java/index.html","hash":"cc09c3547366bbc972e21a717fd65f37d2cb97dd","modified":1693563432770},{"_id":"public/categories/工程/Qt/index.html","hash":"e573f46e75bff6c24b1e61f1ddc2436f1066755b","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/Go/GPM/index.html","hash":"8072e27a4873265cb446f6db50d6a493cfd0bf4e","modified":1693563432770},{"_id":"public/categories/思考/读书笔记/index.html","hash":"f91c8b77191d4fdde7afce179ff66da8bb9c78ea","modified":1693563432770},{"_id":"public/categories/工程/问题记录与事故复盘/index.html","hash":"0867ac73a201ec87cefdb7cb6df38016438c2156","modified":1693563432770},{"_id":"public/categories/工程/服务端/MySQL/index.html","hash":"7973704935d4328ddfb8036296d008d911f5e987","modified":1693563432770},{"_id":"public/categories/工程/云计算/K8S/index.html","hash":"5b0a260ed270bbb8e522c934d19c79f336ec8946","modified":1693563432770},{"_id":"public/categories/工程/云计算/Docker/index.html","hash":"d0e05d2bd5c2f2c430fe41eb67916d875708cc9c","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/Java/JVM/index.html","hash":"8fde9b8ff8c1407d6823eb472fdef9299a413cea","modified":1693563432770},{"_id":"public/categories/工程/服务端/Tomcat/index.html","hash":"52bcf40ebf59462e4f863eb68e78bf72c6250269","modified":1693563432770},{"_id":"public/categories/工程/服务端/Spring/index.html","hash":"adca2104f9e414eb2477937f9089e84692ec762b","modified":1693563432770},{"_id":"public/tags/C/index.html","hash":"058185563e1adac05ae2ba0144802a5fac2e7683","modified":1693563432770},{"_id":"public/tags/JVM/index.html","hash":"771ba04d28d2129b7f39596acfb1b9cb7c64f607","modified":1693563432770},{"_id":"public/tags/基础知识/index.html","hash":"03078dbd1f4f39b9ec0264b8b39031cc40240ffb","modified":1693563432770},{"_id":"public/tags/Go/index.html","hash":"e65918cbcd745b1e907aa41ff508fdc84e7a17a8","modified":1693563432770},{"_id":"public/tags/GPM/index.html","hash":"d620542c087664acb9d34aa2b21ab85f6a1d6563","modified":1693563432770},{"_id":"public/tags/数据库/index.html","hash":"a0d3e8070656347d74cb30fcb076fc0afca16059","modified":1693563432770},{"_id":"public/tags/云计算领域/index.html","hash":"e720433279292f79c0d3a6af9210edaf9b4b4fa3","modified":1693563432770},{"_id":"public/tags/K8S/index.html","hash":"2b8a4527bbae0d70bd456268fc0535d49cfebb69","modified":1693563432770},{"_id":"public/tags/计算机网络/index.html","hash":"598e08aaf95ae3577c303cb63f197eeae9ecc136","modified":1693563432770},{"_id":"public/tags/IP数据报/index.html","hash":"2ec5ddc8ab504525b3c8de8b6d970b567286a268","modified":1693563432770},{"_id":"public/tags/Qt/index.html","hash":"f9b54518c6dc799237b711a3394528ac1af69e30","modified":1693563432770},{"_id":"public/tags/桌面开发/index.html","hash":"41d037ef0ebd16f9f8c237067e1989a874a3d1bd","modified":1693563432770},{"_id":"public/tags/Tomcat/index.html","hash":"52fcb9fde04bfc2d0db7d5d995669fab4e2aef82","modified":1693563432770},{"_id":"public/tags/Java-Web/index.html","hash":"3baee75d364afa8f84e22ab17718192a3da8c0cc","modified":1693563432770},{"_id":"public/tags/Servlet/index.html","hash":"0be67ff2838bba70aa36625ae555644081d4f315","modified":1693563432770},{"_id":"public/tags/Java-EE/index.html","hash":"4d2e98c1b85365666964e40a82c7c4b549f7dde3","modified":1693563432770},{"_id":"public/tags/回调/index.html","hash":"b0c26691859b437dd8e89930b2f37b14fb810627","modified":1693563432770},{"_id":"public/tags/工作/index.html","hash":"af6665cdd62717470ccf76ae3a7fde74f4affe60","modified":1693563432770},{"_id":"public/tags/问题记录/index.html","hash":"67c381b2682ddae87dcac9cdde2b63178eed2130","modified":1693563432770},{"_id":"public/tags/线上事故/index.html","hash":"d4a9e9a8667d05c8d1b9bce9e60aa07d5d4ad78b","modified":1693563432770},{"_id":"public/tags/MyBatis/index.html","hash":"1f4569bcbc91fc35e6b9b9a85aeaa6de8e05e86f","modified":1693563432770},{"_id":"public/tags/Spring/index.html","hash":"ce0747039eed43f2804d6d983a89874b6f82f6fb","modified":1693563432770},{"_id":"public/tags/操作系统/index.html","hash":"0a8bc22147dd127b2be789e683b26e36cc2b023a","modified":1693563432770},{"_id":"public/tags/工具类/index.html","hash":"da95f7f4a0c23b0686c7940fd3d364b9db423134","modified":1693563432770},{"_id":"public/tags/Docker/index.html","hash":"3d099186e79e7f7fd8c9b92c1e3c976e027e70c6","modified":1693563432770},{"_id":"public/categories/index.html","hash":"215d48dbbe33cdf9e57bae5e4e1a32b9bfb60d50","modified":1693563432770},{"_id":"public/2023/08/31/OSI-ISO七层网络/index.html","hash":"df2e201a81b6a127e9f8607f3b0cb20af90da575","modified":1693563432770},{"_id":"public/2023/08/31/一次Mybatis升级引发的线上事故/index.html","hash":"078fbceef4e23697aca67ee8e2eb4cbcae6da618","modified":1693563432770},{"_id":"public/2023/08/29/GPM模型/index.html","hash":"351ddaff9e6f895e11f238155237f7ae444fd691","modified":1693563432770},{"_id":"public/2023/08/29/GC—全过程/index.html","hash":"c064aeeb1f4c2044609c55df48da6d4d9dc6be93","modified":1693563432770},{"_id":"public/2023/08/29/K8S架构图/index.html","hash":"b8216aa623f52c0cab7e8b20bd1e6d7057f8e3aa","modified":1693563432770},{"_id":"public/2023/08/29/本地调试Docker源码/index.html","hash":"efdf6483b74b4cd2214e112f1cc3e42b65e18011","modified":1693563432770},{"_id":"public/2023/08/29/Qt简介/index.html","hash":"36f314bb329d3b350b2eb1fb0399b6b3ec3cdd48","modified":1693563432770},{"_id":"public/2023/08/29/IP数据报/index.html","hash":"0b955ef07df044adaa91d40bf90037199ef31de2","modified":1693563432770},{"_id":"public/2023/08/29/Innodb中的事务隔离级别和锁实现/index.html","hash":"d7c1b571226538db9546c2f9df359e9fe5993551","modified":1693563432770},{"_id":"public/2023/08/29/Spring全景/index.html","hash":"d7e29e48bb2b12df55edbeb23a77d8e1457e38d6","modified":1693563432770},{"_id":"public/2023/08/29/保持敬畏之心/index.html","hash":"7fbba8cc2ffa676e75197a3a29993ac1d713407e","modified":1693563432770},{"_id":"public/2023/08/29/命令行常用指令/index.html","hash":"c32fdeffe2344771fd3de2a2b34026426f3ae745","modified":1693563432770},{"_id":"public/2023/08/29/Tomcat启动流程/index.html","hash":"56f96e5c2f3e1881aa3dafff4481185bf22340ef","modified":1693563432770},{"_id":"public/2023/08/29/C-程序内存分区/index.html","hash":"dfcad0b7f0f0afab4ab5289e8ef8cdaa38766ade","modified":1693563432770},{"_id":"public/2023/08/29/回调机制/index.html","hash":"26444e3c46f496032e808a9fdbe13d9b0c6595d2","modified":1693563432770},{"_id":"public/2023/08/28/GC—基础知识/index.html","hash":"520eb3e648422797acd3f9591418fa96da837d4f","modified":1693563432770},{"_id":"public/2023/08/28/内核页表设计/index.html","hash":"5368ad139594f4c09f85c0c9ae28400411997be3","modified":1693563432770},{"_id":"public/archives/index.html","hash":"4433bb56123636f4679222108d7d8b7d107568e2","modified":1693563432770},{"_id":"public/archives/page/2/index.html","hash":"59b4aba5f5377514d5f0dca803798d089915655f","modified":1693563432770},{"_id":"public/archives/2023/index.html","hash":"1dbde7881911834f2aa570d576e8b356d998aa89","modified":1693563432770},{"_id":"public/archives/2023/page/2/index.html","hash":"4a943300069eb7a1fec23862a8225a77c23f9cda","modified":1693563432770},{"_id":"public/archives/2023/08/index.html","hash":"d2e90282a498b46fea3b98ab9bdafc782c090c08","modified":1693563432770},{"_id":"public/archives/2023/08/page/2/index.html","hash":"8b04b67c7b93cc4c7cdb8c3c74ef79fc5c6edb48","modified":1693563432770},{"_id":"public/categories/基本功/index.html","hash":"cd4a5b5add761be58173d3cd4401b1986a7dcdc4","modified":1693563432770},{"_id":"public/categories/基本功/编程基础/index.html","hash":"5dbd79e5203a6ba43572f589f68aa4539f2c504f","modified":1693563432770},{"_id":"public/categories/工程/index.html","hash":"60dd4a9c5296d0952d2210687c2cb50abcd58ece","modified":1693563432770},{"_id":"public/index.html","hash":"d0c2de996617082d9e533f490bbe1e5c8e99a353","modified":1693563432770},{"_id":"public/page/2/index.html","hash":"f041f23b3ea0412b2bb4fdbc7d9c08d88962982e","modified":1693563432770},{"_id":"public/tags/Java/index.html","hash":"45558614558f219606f05976949121ea66303228","modified":1693563432770},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1693563432770},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1693563432770},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1693563432770},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1693563432770},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1693563432770},{"_id":"public/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1693563432770},{"_id":"public/images/SETSUNAYANG.JPG","hash":"b7612fc376c8afaccc1f6733a50bc35e8e897500","modified":1693563432770},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1693563432770},{"_id":"public/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1693563432770},{"_id":"public/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1693563432770},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1693563432770},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1693563432770},{"_id":"public/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1693563432770},{"_id":"public/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1693563432770},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1693563432770},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1693563432770},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1693563432770},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1693563432770},{"_id":"public/lib/hbe.js","hash":"fb05fcd82bb28d3b2887d388cabea7f9b1a318eb","modified":1693563432770},{"_id":"public/css/hbe.style.css","hash":"72959894400fd5c350106cb558c39fa51f722cbd","modified":1693563432770},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1693563432770},{"_id":"public/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1693563432770},{"_id":"public/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1693563432770},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1693563432770},{"_id":"public/404.html","hash":"6e6ebc1161643ffa524c9ecf38af7cd8cf1c9ecc","modified":1693563432770},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1693563432770},{"_id":"public/css/custom.css","hash":"58950a4f4cd82465f85428ec17b3bc05f8153b56","modified":1693563432770},{"_id":"public/dist/main.js","hash":"158d69f927d1cee076a485e894f307fadbe9656c","modified":1693563432770},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1693563432770},{"_id":"public/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1693563432770},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1693563432770},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1693563432770},{"_id":"public/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1693563432770},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1693563432770},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1693563432770},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1693563432770},{"_id":"public/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1693563432770},{"_id":"public/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1693563432770},{"_id":"public/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1693563432770},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1693563432770},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1693563432770},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1693563432770},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1693563432770},{"_id":"public/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1693563432770},{"_id":"public/images/wechat.jpg","hash":"d560cecf759485dfd385af9bad8f4f200aff21e5","modified":1693563432770},{"_id":"public/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1693563432770},{"_id":"public/assets/js/DPlayer.min.js","hash":"290283e41ac69bfd570c90800680097f998e4e0c","modified":1693563432770},{"_id":"public/images/alipay.jpg","hash":"74e90e8757a66b03304fd6e2abb086e85dd72edf","modified":1693563432770},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1693563432770},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1693563432770},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1693563432770},{"_id":"public/css/fonts/remixicon.svg","hash":"94144debfb5761d37d79336a10ef674f82baec1b","modified":1693563432770}],"Category":[{"name":"基本功","_id":"clm0fxw6q0004mwwx8eb542q1"},{"name":"编程基础","parent":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw6t000imwwxgulsho93"},{"name":"工程","_id":"clm0fxw6v000rmwwxcw8ngf8i"},{"name":"计算机网络","parent":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw6x0014mwwx3kfieur3"},{"name":"Go","parent":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw6z001omwwxg7ky66fm"},{"name":"思考","_id":"clm0fxw6z001rmwwx6o723hgb"},{"name":"C++","parent":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw6z001xmwwx6i7m6bxd"},{"name":"操作系统","parent":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw700023mwwxamy04hdq"},{"name":"服务端","parent":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw700029mwwxan3rfuh3"},{"name":"其他","_id":"clm0fxw71002dmwwxhuejdlo2"},{"name":"编程理论","parent":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw71002hmwwx3yhl9voc"},{"name":"云计算","parent":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw71002lmwwx5e4odskb"},{"name":"Java","parent":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw71002smwwx3qj9cc91"},{"name":"Qt","parent":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw72002zmwwx3i3z01k0"},{"name":"GPM","parent":"clm0fxw6z001omwwxg7ky66fm","_id":"clm0fxw720037mwwx281ah6bu"},{"name":"读书笔记","parent":"clm0fxw6z001rmwwx6o723hgb","_id":"clm0fxw73003bmwwxcoxl38pr"},{"name":"问题记录与事故复盘","parent":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw73003emwwx32bk9qql"},{"name":"MySQL","parent":"clm0fxw700029mwwxan3rfuh3","_id":"clm0fxw73003qmwwx3e0z0hue"},{"name":"K8S","parent":"clm0fxw71002lmwwx5e4odskb","_id":"clm0fxw74003wmwwx27zfa53e"},{"name":"Docker","parent":"clm0fxw71002lmwwx5e4odskb","_id":"clm0fxw740041mwwxhok02pba"},{"name":"JVM","parent":"clm0fxw71002smwwx3qj9cc91","_id":"clm0fxw740046mwwx1ixahwut"},{"name":"Tomcat","parent":"clm0fxw700029mwwxan3rfuh3","_id":"clm0fxw75004gmwwx9sko9aiy"},{"name":"Spring","parent":"clm0fxw700029mwwxan3rfuh3","_id":"clm0fxw75004lmwwxh9wn6k81"}],"Data":[],"Page":[{"title":"tags","date":"2023-08-28T15:23:28.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-08-28 23:23:28\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2023-08-28T15:50:37.078Z","path":"tags/index.html","comments":1,"_id":"clm0fxw6n0000mwwx2xvtdrjk","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2023-08-28T15:21:32.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-08-28 23:21:32\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2023-08-28T15:44:07.813Z","path":"categories/index.html","comments":1,"_id":"clm0fxw6p0002mwwxg7srao34","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++程序内存分区","date":"2023-08-28T17:14:22.000Z","_content":"\n__代码区：__ 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。\n\n__静态区：__ 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！\n\n__堆：__ 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。\n\n__栈：__ 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。\n\n__常量区：__ 常量字符串就是放在这⾥的。 程序结束后由系统释放。\n\n__BSS段：__ 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：\n\n```C++\n\nint a = 0; //全局初始化区（静态区）\nchar *p1; //全局未初始化区 （BSS段）\nint main() {\n    int b; //栈 6 char s[] = \"abc\"; //栈 7 char *p2; //栈 8 char *p3 = \"123456\"; //123456/0在常量区，p3在栈上。\n    static int c = 0; //全局（静态）初始化区 （静态区）\n    p1 = (char *) malloc(10); //分配得10和20字节的区域就在堆区。\n    // p2 = (char *) malloc(20);\n    strcpy(p1, \"123456\");\n    //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成⼀块。\n    return 0;\n}\n```\n\n","source":"_posts/C-程序内存分区.md","raw":"---\ntitle: C++程序内存分区\ndate: 2023-08-29 01:14:22\ncategories: \n- 基本功\n- 编程基础\n- C++\ntags:\n- C++\n- Java\n---\n\n__代码区：__ 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。\n\n__静态区：__ 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！\n\n__堆：__ 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。\n\n__栈：__ 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。\n\n__常量区：__ 常量字符串就是放在这⾥的。 程序结束后由系统释放。\n\n__BSS段：__ 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：\n\n```C++\n\nint a = 0; //全局初始化区（静态区）\nchar *p1; //全局未初始化区 （BSS段）\nint main() {\n    int b; //栈 6 char s[] = \"abc\"; //栈 7 char *p2; //栈 8 char *p3 = \"123456\"; //123456/0在常量区，p3在栈上。\n    static int c = 0; //全局（静态）初始化区 （静态区）\n    p1 = (char *) malloc(10); //分配得10和20字节的区域就在堆区。\n    // p2 = (char *) malloc(20);\n    strcpy(p1, \"123456\");\n    //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成⼀块。\n    return 0;\n}\n```\n\n","slug":"C-程序内存分区","published":1,"updated":"2023-08-29T10:00:27.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6o0001mwwxhkbfadk0","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>代码区：</strong> 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。</p>\n<p><strong>静态区：</strong> 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！</p>\n<p><strong>堆：</strong> 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。</p>\n<p><strong>栈：</strong> 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。</p>\n<p><strong>常量区：</strong> 常量字符串就是放在这⾥的。 程序结束后由系统释放。</p>\n<p><strong>BSS段：</strong> 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>; <span class=\"comment\">//全局初始化区（静态区）</span></span><br><span class=\"line\"><span class=\"type\">char</span> *p1; <span class=\"comment\">//全局未初始化区 （BSS段）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> b; <span class=\"comment\">//栈 6 char s[] = &quot;abc&quot;; //栈 7 char *p2; //栈 8 char *p3 = &quot;123456&quot;; //123456/0在常量区，p3在栈上。</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> c = <span class=\"number\">0</span>; <span class=\"comment\">//全局（静态）初始化区 （静态区）</span></span><br><span class=\"line\">    p1 = (<span class=\"type\">char</span> *) <span class=\"built_in\">malloc</span>(<span class=\"number\">10</span>); <span class=\"comment\">//分配得10和20字节的区域就在堆区。</span></span><br><span class=\"line\">    <span class=\"comment\">// p2 = (char *) malloc(20);</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(p1, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成⼀块。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>代码区：</strong> 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。</p>\n<p><strong>静态区：</strong> 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！</p>\n<p><strong>堆：</strong> 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。</p>\n<p><strong>栈：</strong> 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。</p>\n<p><strong>常量区：</strong> 常量字符串就是放在这⾥的。 程序结束后由系统释放。</p>\n<p><strong>BSS段：</strong> 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>; <span class=\"comment\">//全局初始化区（静态区）</span></span><br><span class=\"line\"><span class=\"type\">char</span> *p1; <span class=\"comment\">//全局未初始化区 （BSS段）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> b; <span class=\"comment\">//栈 6 char s[] = &quot;abc&quot;; //栈 7 char *p2; //栈 8 char *p3 = &quot;123456&quot;; //123456/0在常量区，p3在栈上。</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> c = <span class=\"number\">0</span>; <span class=\"comment\">//全局（静态）初始化区 （静态区）</span></span><br><span class=\"line\">    p1 = (<span class=\"type\">char</span> *) <span class=\"built_in\">malloc</span>(<span class=\"number\">10</span>); <span class=\"comment\">//分配得10和20字节的区域就在堆区。</span></span><br><span class=\"line\">    <span class=\"comment\">// p2 = (char *) malloc(20);</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(p1, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成⼀块。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"GC-全流程","date":"2023-08-29T07:46:59.000Z","_content":"\n\n#### __1、minorGC 和 Full GC 区别__\n&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n\n&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n#### __2、minorGC 过程详解__\n&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-\nXX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n#### __3、整体描述__\n&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -> Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。\n\n#### __4、GC 触发条件__\n&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：\n* 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；\n* 老年代空间不足；\n* 方法去空间不足；\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存；\n* 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n#### __5、对象进入老年代的四种情况__\n&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没\"熬过\"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。\n\n&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true)\n\n#### __6、空间分配担保__\n&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。\n\n&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。\n\n&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。\n\n\n\n\n\n\n\n","source":"_posts/GC—全过程.md","raw":"---\ntitle: GC-全流程\ndate: 2023-08-29 15:46:59\ncategories:\n- 基本功\n- 编程基础\n- Java\n- JVM\ntags:\n- Java\n- JVM\n- 基础知识\n---\n\n\n#### __1、minorGC 和 Full GC 区别__\n&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n\n&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n#### __2、minorGC 过程详解__\n&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-\nXX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n#### __3、整体描述__\n&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -> Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。\n\n#### __4、GC 触发条件__\n&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：\n* 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；\n* 老年代空间不足；\n* 方法去空间不足；\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存；\n* 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n#### __5、对象进入老年代的四种情况__\n&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没\"熬过\"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。\n\n&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true)\n\n#### __6、空间分配担保__\n&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。\n\n&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。\n\n&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。\n\n\n\n\n\n\n\n","slug":"GC—全过程","published":1,"updated":"2023-08-29T08:46:46.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6p0003mwwxfb721dgs","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"1、minorGC-和-Full-GC-区别\"><a href=\"#1、minorGC-和-Full-GC-区别\" class=\"headerlink\" title=\"1、minorGC 和 Full GC 区别\"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>\n<h4 id=\"2、minorGC-过程详解\"><a href=\"#2、minorGC-过程详解\" class=\"headerlink\" title=\"2、minorGC 过程详解\"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<h4 id=\"3、整体描述\"><a href=\"#3、整体描述\" class=\"headerlink\" title=\"3、整体描述\"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>\n<h4 id=\"4、GC-触发条件\"><a href=\"#4、GC-触发条件\" class=\"headerlink\" title=\"4、GC 触发条件\"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>\n<ul>\n<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>\n<li>老年代空间不足；</li>\n<li>方法去空间不足；</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>\n<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>\n</ul>\n<h4 id=\"5、对象进入老年代的四种情况\"><a href=\"#5、对象进入老年代的四种情况\" class=\"headerlink\" title=\"5、对象进入老年代的四种情况\"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true\"></p>\n<h4 id=\"6、空间分配担保\"><a href=\"#6、空间分配担保\" class=\"headerlink\" title=\"6、空间分配担保\"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、minorGC-和-Full-GC-区别\"><a href=\"#1、minorGC-和-Full-GC-区别\" class=\"headerlink\" title=\"1、minorGC 和 Full GC 区别\"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>\n<h4 id=\"2、minorGC-过程详解\"><a href=\"#2、minorGC-过程详解\" class=\"headerlink\" title=\"2、minorGC 过程详解\"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<h4 id=\"3、整体描述\"><a href=\"#3、整体描述\" class=\"headerlink\" title=\"3、整体描述\"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>\n<h4 id=\"4、GC-触发条件\"><a href=\"#4、GC-触发条件\" class=\"headerlink\" title=\"4、GC 触发条件\"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>\n<ul>\n<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>\n<li>老年代空间不足；</li>\n<li>方法去空间不足；</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>\n<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>\n</ul>\n<h4 id=\"5、对象进入老年代的四种情况\"><a href=\"#5、对象进入老年代的四种情况\" class=\"headerlink\" title=\"5、对象进入老年代的四种情况\"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true\"></p>\n<h4 id=\"6、空间分配担保\"><a href=\"#6、空间分配担保\" class=\"headerlink\" title=\"6、空间分配担保\"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>\n"},{"title":"GC—基础知识","date":"2023-08-28T15:31:37.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样\n的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？\n\n#### __1、可达性分析算法（GC Roots）__\n\n&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现\n方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之\n间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标\n记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下\n几种：\n* 虚拟机栈（本地变量表）中引用的对象\n* 方法区中类静态属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中引用的对象\n\n#### __2、JVM中的堆结构__\n&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：\n![JVM 分代比例](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to\n区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：\n![JVM 内存模型全景](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)\n\n#### __2.1、为何新生代要分为三个区__\n&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小\n相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。\n\n&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。\n\n&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。\n\n&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。\n\n#### __2.2、新生代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；\n\n&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；\n\n&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：\nfrom 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）\n\n#### __2.3、老年代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经\n过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-\nXX:PretenureSizeThreshold=30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。\n\n&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和\n大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己\n的晋升年龄。\n\n#### __3、JVM完整的GC流程__\n&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。\n\n&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重\n影响性能。\n\n&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。\n处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾\n回收器等。","source":"_posts/GC—基础知识.md","raw":"---\ntitle: GC—基础知识\ndate: 2023-08-28 23:31:37\ncategories: \n- 基本功\n- 编程基础\n- Java\n- JVM\ntags:\n- Java\n- JVM\n- 基础知识\n---\n\n&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样\n的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？\n\n#### __1、可达性分析算法（GC Roots）__\n\n&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现\n方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之\n间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标\n记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下\n几种：\n* 虚拟机栈（本地变量表）中引用的对象\n* 方法区中类静态属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中引用的对象\n\n#### __2、JVM中的堆结构__\n&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：\n![JVM 分代比例](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to\n区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：\n![JVM 内存模型全景](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)\n\n#### __2.1、为何新生代要分为三个区__\n&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小\n相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。\n\n&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。\n\n&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。\n\n&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。\n\n#### __2.2、新生代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；\n\n&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；\n\n&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：\nfrom 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）\n\n#### __2.3、老年代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经\n过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-\nXX:PretenureSizeThreshold=30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。\n\n&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和\n大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己\n的晋升年龄。\n\n#### __3、JVM完整的GC流程__\n&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。\n\n&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重\n影响性能。\n\n&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。\n处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾\n回收器等。","slug":"GC—基础知识","published":1,"updated":"2023-08-29T08:31:32.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6q0006mwwx9ao4h1ib","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>\n<h4 id=\"1、可达性分析算法（GC-Roots）\"><a href=\"#1、可达性分析算法（GC-Roots）\" class=\"headerlink\" title=\"1、可达性分析算法（GC Roots）\"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>\n<ul>\n<li>虚拟机栈（本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n</ul>\n<h4 id=\"2、JVM中的堆结构\"><a href=\"#2、JVM中的堆结构\" class=\"headerlink\" title=\"2、JVM中的堆结构\"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true\" alt=\"JVM 分代比例\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"JVM 内存模型全景\"></p>\n<h4 id=\"2-1、为何新生代要分为三个区\"><a href=\"#2-1、为何新生代要分为三个区\" class=\"headerlink\" title=\"2.1、为何新生代要分为三个区\"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>\n<h4 id=\"2-2、新生代对象的分配和回收\"><a href=\"#2-2、新生代对象的分配和回收\" class=\"headerlink\" title=\"2.2、新生代对象的分配和回收\"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>\n<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>\n<h4 id=\"2-3、老年代对象的分配和回收\"><a href=\"#2-3、老年代对象的分配和回收\" class=\"headerlink\" title=\"2.3、老年代对象的分配和回收\"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>\n<h4 id=\"3、JVM完整的GC流程\"><a href=\"#3、JVM完整的GC流程\" class=\"headerlink\" title=\"3、JVM完整的GC流程\"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>\n<h4 id=\"1、可达性分析算法（GC-Roots）\"><a href=\"#1、可达性分析算法（GC-Roots）\" class=\"headerlink\" title=\"1、可达性分析算法（GC Roots）\"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>\n<ul>\n<li>虚拟机栈（本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n</ul>\n<h4 id=\"2、JVM中的堆结构\"><a href=\"#2、JVM中的堆结构\" class=\"headerlink\" title=\"2、JVM中的堆结构\"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true\" alt=\"JVM 分代比例\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"JVM 内存模型全景\"></p>\n<h4 id=\"2-1、为何新生代要分为三个区\"><a href=\"#2-1、为何新生代要分为三个区\" class=\"headerlink\" title=\"2.1、为何新生代要分为三个区\"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>\n<h4 id=\"2-2、新生代对象的分配和回收\"><a href=\"#2-2、新生代对象的分配和回收\" class=\"headerlink\" title=\"2.2、新生代对象的分配和回收\"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>\n<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>\n<h4 id=\"2-3、老年代对象的分配和回收\"><a href=\"#2-3、老年代对象的分配和回收\" class=\"headerlink\" title=\"2.3、老年代对象的分配和回收\"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>\n<h4 id=\"3、JVM完整的GC流程\"><a href=\"#3、JVM完整的GC流程\" class=\"headerlink\" title=\"3、JVM完整的GC流程\"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>\n"},{"title":"GPM模型","date":"2023-08-29T08:54:42.000Z","_content":"","source":"_posts/GPM模型.md","raw":"---\ntitle: GPM模型\ndate: 2023-08-29 16:54:42\ncategories: \n- 基本功\n- 编程基础\n- Go\n- GPM\ntags:\n- Go\n- GPM\n- 基础知识\n---\n","slug":"GPM模型","published":1,"updated":"2023-08-29T08:55:42.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6r0007mwwx5f666muw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"Innodb中的事务隔离级别和锁实现","date":"2023-08-28T17:28:46.000Z","_content":"","source":"_posts/Innodb中的事务隔离级别和锁实现.md","raw":"---\ntitle: Innodb中的事务隔离级别和锁实现\ndate: 2023-08-29 01:28:46\ncategories: \n- 工程\n- 服务端\n- MySQL\ntags:\n- 数据库\n---\n","slug":"Innodb中的事务隔离级别和锁实现","published":1,"updated":"2023-08-29T00:52:19.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6r0008mwwx8uha7kqw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"K8S架构图","date":"2023-08-29T02:33:27.000Z","_content":"\n\n![K8S架构图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)","source":"_posts/K8S架构图.md","raw":"---\ntitle: K8S架构图\ndate: 2023-08-29 10:33:27\ncategories: \n- 工程\n- 云计算\n- K8S\ntags:\n- 云计算领域\n- K8S\n---\n\n\n![K8S架构图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)","slug":"K8S架构图","published":1,"updated":"2023-08-29T08:32:26.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6s000bmwwx7bbc6j6v","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"K8S架构图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"K8S架构图\"></p>\n"},{"title":"OSI/ISO七层网络","date":"2023-08-31T06:42:29.000Z","_content":"\n\n&ensp;&ensp; 七层网络的常见设备，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true)\n\n&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true)\n\n\n","source":"_posts/OSI-ISO七层网络.md","raw":"---\ntitle: OSI/ISO七层网络\ndate: 2023-08-31 14:42:29\ncategories: \n- 基本功\n- 计算机网络\ntags:\n- 计算机网络\n- IP数据报\n---\n\n\n&ensp;&ensp; 七层网络的常见设备，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true)\n\n&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true)\n\n\n","slug":"OSI-ISO七层网络","published":1,"updated":"2023-08-31T07:05:20.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6s000cmwwx7zo1e8y5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp; 七层网络的常见设备，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true\"></p>\n<p>&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp; 七层网络的常见设备，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true\"></p>\n<p>&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true\"></p>\n"},{"title":"IP数据报","date":"2023-08-28T17:29:54.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。\n\n\n![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### __1、固定部分__\n\n* 版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。\n* 首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。\n* 区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。\n* 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。\n* 标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。\n* 标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF=0 时才允许分片。\n* 片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。\n* 生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。\n* 协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。\n* 首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。\n* 源地址和目的地址：32位，IPV4 地址。\n\n#### __2、可变部分__\n\n&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：\n* 安全和处理限制（用于军事领域）。\n* 记录路径（让每个路由器都记下它的IP地址）。\n* 时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。\n* 宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。\n* 严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。\n\n&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。\n","source":"_posts/IP数据报.md","raw":"---\ntitle: IP数据报\ndate: 2023-08-29 01:29:54\ncategories: \n- 基本功\n- 计算机网络\ntags:\n- 计算机网络\n- IP数据报\n---\n\n&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。\n\n\n![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### __1、固定部分__\n\n* 版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。\n* 首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。\n* 区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。\n* 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。\n* 标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。\n* 标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF=0 时才允许分片。\n* 片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。\n* 生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。\n* 协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。\n* 首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。\n* 源地址和目的地址：32位，IPV4 地址。\n\n#### __2、可变部分__\n\n&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：\n* 安全和处理限制（用于军事领域）。\n* 记录路径（让每个路由器都记下它的IP地址）。\n* 时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。\n* 宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。\n* 严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。\n\n&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。\n","slug":"IP数据报","published":1,"updated":"2023-08-31T06:44:33.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6t000fmwwx6upwc62l","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"IP报文结构\"></p>\n<h4 id=\"1、固定部分\"><a href=\"#1、固定部分\" class=\"headerlink\" title=\"1、固定部分\"></a><strong>1、固定部分</strong></h4><ul>\n<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>\n<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>\n<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>\n<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>\n<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>\n<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>\n<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>\n<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>\n<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>\n<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址和目的地址：32位，IPV4 地址。</li>\n</ul>\n<h4 id=\"2、可变部分\"><a href=\"#2、可变部分\" class=\"headerlink\" title=\"2、可变部分\"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>\n<ul>\n<li>安全和处理限制（用于军事领域）。</li>\n<li>记录路径（让每个路由器都记下它的IP地址）。</li>\n<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>\n<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>\n<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"IP报文结构\"></p>\n<h4 id=\"1、固定部分\"><a href=\"#1、固定部分\" class=\"headerlink\" title=\"1、固定部分\"></a><strong>1、固定部分</strong></h4><ul>\n<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>\n<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>\n<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>\n<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>\n<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>\n<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>\n<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>\n<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>\n<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>\n<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址和目的地址：32位，IPV4 地址。</li>\n</ul>\n<h4 id=\"2、可变部分\"><a href=\"#2、可变部分\" class=\"headerlink\" title=\"2、可变部分\"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>\n<ul>\n<li>安全和处理限制（用于军事领域）。</li>\n<li>记录路径（让每个路由器都记下它的IP地址）。</li>\n<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>\n<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>\n<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</p>\n"},{"title":"Qt简介","date":"2023-08-29T00:49:39.000Z","_content":"","source":"_posts/Qt简介.md","raw":"---\ntitle: Qt简介\ndate: 2023-08-29 08:49:39\ncategories: \n- 工程\n- Qt\ntags:\n- Qt\n- 桌面开发\n---\n","slug":"Qt简介","published":1,"updated":"2023-08-29T00:51:11.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6t000hmwwxfxxo98i7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"Tomcat启动流程","date":"2023-08-28T17:16:02.000Z","_content":"","source":"_posts/Tomcat启动流程.md","raw":"---\ntitle: Tomcat启动流程\ndate: 2023-08-29 01:16:02\ncategories: \n- 工程\n- 服务端\n- Tomcat\ntags:\n- Tomcat\n- Java Web\n- Servlet\n- Java EE\n---\n","slug":"Tomcat启动流程","published":1,"updated":"2023-08-29T00:52:02.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6u000lmwwx51r71kne","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"保持敬畏之心","date":"2023-08-28T17:19:15.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。\n","source":"_posts/保持敬畏之心.md","raw":"---\ntitle: 保持敬畏之心\ndate: 2023-08-29 01:19:15\ncategories: \n- 思考\n- 读书笔记\ntags:\n- C++\n- Java\n- 回调\n---\n\n&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。\n","slug":"保持敬畏之心","published":1,"updated":"2023-08-29T11:49:21.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6u000mmwwx4hv04uxa","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。</p>\n"},{"title":"深入 OGNL 与  Mybatis 源代码分析一次 Mybatis 升级引发的线上事故","date":"2023-08-31T02:16:04.000Z","_content":"\n\n&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -> 3.4.4：\n\n![mybatis前后版本升级](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：\n\n![报错信息](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。\n\n&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:\n\n![分别引入两个版本的依赖](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:\n\n![数据库脚本](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：\n\n![dao层方法调用](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:\n\n```shell\ninvalid comparision:  java.util.HashMap and java.lang.String\n```\n\n&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!='' 将_parameter 与 '' 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 '' 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。\n\n&ensp;&ensp;&ensp;&ensp; 但是问题又来了，__为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？__ 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：\n\n![ifnode](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 ... && _parameter!='' 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：\n\n```shell\nmybatis-3.2.5  ->  ognl-2.6.9\nmybatis-3.4.4  ->  ognl-3.1.14\n```\n\n&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：\n\n![高版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：\n\n![低版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：\n\n![类型标记](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!='' 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ''）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：\n\n![调试信息如下](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 解释一下：t1 = t2 = 10，表示 _parameter 与 '' 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 = ''。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。\n\n&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：\n\n&ensp;&ensp;&ensp;&ensp; __如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -> String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务。__\n\n&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：\n\n&ensp;&ensp;&ensp;&ensp; __如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本__。接下来我们看方法外面这个 equals 的来源：\n\n![equals](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。\n\n&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： __低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 _parameter!='' 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。__\n\n&ensp;&ensp;&ensp;&ensp; __反思：__\n* __日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。__\n* __组件升级要慎之又慎，测试要充分。__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/一次Mybatis升级引发的线上事故.md","raw":"---\ntitle: 深入 OGNL 与  Mybatis 源代码分析一次 Mybatis 升级引发的线上事故\ndate: 2023-08-31 10:16:04\ncategories:\n- 工程\n- 问题记录与事故复盘\ntags:\n- 工作\n- 问题记录\n- 线上事故\n- MyBatis\n---\n\n\n&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -> 3.4.4：\n\n![mybatis前后版本升级](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：\n\n![报错信息](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。\n\n&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:\n\n![分别引入两个版本的依赖](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:\n\n![数据库脚本](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：\n\n![dao层方法调用](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:\n\n```shell\ninvalid comparision:  java.util.HashMap and java.lang.String\n```\n\n&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!='' 将_parameter 与 '' 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 '' 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。\n\n&ensp;&ensp;&ensp;&ensp; 但是问题又来了，__为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？__ 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：\n\n![ifnode](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 ... && _parameter!='' 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：\n\n```shell\nmybatis-3.2.5  ->  ognl-2.6.9\nmybatis-3.4.4  ->  ognl-3.1.14\n```\n\n&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：\n\n![高版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：\n\n![低版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：\n\n![类型标记](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!='' 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ''）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：\n\n![调试信息如下](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 解释一下：t1 = t2 = 10，表示 _parameter 与 '' 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 = ''。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。\n\n&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：\n\n&ensp;&ensp;&ensp;&ensp; __如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -> String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务。__\n\n&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：\n\n&ensp;&ensp;&ensp;&ensp; __如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本__。接下来我们看方法外面这个 equals 的来源：\n\n![equals](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。\n\n&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： __低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 _parameter!='' 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。__\n\n&ensp;&ensp;&ensp;&ensp; __反思：__\n* __日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。__\n* __组件升级要慎之又慎，测试要充分。__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"一次Mybatis升级引发的线上事故","published":1,"updated":"2023-09-01T10:16:27.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6v000pmwwx6f22fxnm","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -&gt; 3.4.4：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true\" alt=\"mybatis前后版本升级\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true\" alt=\"报错信息\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true\" alt=\"分别引入两个版本的依赖\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true\" alt=\"数据库脚本\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true\" alt=\"dao层方法调用\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invalid comparision:  java.util.HashMap and java.lang.String</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!&#x3D;’’ 将_parameter 与 ‘’ 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 ‘’ 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 但是问题又来了，<strong>为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？</strong> 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true\" alt=\"ifnode\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 … &amp;&amp; _parameter!&#x3D;’’ 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis-3.2.5  -&gt;  ognl-2.6.9</span><br><span class=\"line\">mybatis-3.4.4  -&gt;  ognl-3.1.14</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"高版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"低版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true\" alt=\"类型标记\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!&#x3D;’’ 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ‘’）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true\" alt=\"调试信息如下\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 解释一下：t1 &#x3D; t2 &#x3D; 10，表示 _parameter 与 ‘’ 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 &#x3D; ‘’。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：</p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -&gt; String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务。</strong></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：</p>\n<p>&ensp;&ensp;&ensp;&ensp; __如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本__。接下来我们看方法外面这个 equals 的来源：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true\" alt=\"equals\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： _<em>低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 <em>parameter!&#x3D;’’ 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。</em></em></p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>反思：</strong></p>\n<ul>\n<li><strong>日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。</strong></li>\n<li><strong>组件升级要慎之又慎，测试要充分。</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -&gt; 3.4.4：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true\" alt=\"mybatis前后版本升级\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true\" alt=\"报错信息\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true\" alt=\"分别引入两个版本的依赖\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true\" alt=\"数据库脚本\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true\" alt=\"dao层方法调用\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invalid comparision:  java.util.HashMap and java.lang.String</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!&#x3D;’’ 将_parameter 与 ‘’ 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 ‘’ 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 但是问题又来了，<strong>为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？</strong> 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true\" alt=\"ifnode\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 … &amp;&amp; _parameter!&#x3D;’’ 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis-3.2.5  -&gt;  ognl-2.6.9</span><br><span class=\"line\">mybatis-3.4.4  -&gt;  ognl-3.1.14</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"高版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"低版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true\" alt=\"类型标记\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!&#x3D;’’ 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ‘’）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true\" alt=\"调试信息如下\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 解释一下：t1 &#x3D; t2 &#x3D; 10，表示 _parameter 与 ‘’ 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 &#x3D; ‘’。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：</p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -&gt; String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务。</strong></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：</p>\n<p>&ensp;&ensp;&ensp;&ensp; __如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本__。接下来我们看方法外面这个 equals 的来源：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true\" alt=\"equals\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： _<em>低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 <em>parameter!&#x3D;’’ 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。</em></em></p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>反思：</strong></p>\n<ul>\n<li><strong>日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。</strong></li>\n<li><strong>组件升级要慎之又慎，测试要充分。</strong></li>\n</ul>\n"},{"title":"Spring全景","date":"2023-08-28T17:20:39.000Z","_content":"\n\n![Spring 全景图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true)","source":"_posts/Spring全景.md","raw":"---\ntitle: Spring全景\ndate: 2023-08-29 01:20:39\ncategories: \n- 工程\n- 服务端\n- Spring\ntags:\n- Spring\n- Java EE\n---\n\n\n![Spring 全景图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true)","slug":"Spring全景","published":1,"updated":"2023-08-29T08:32:47.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6v000qmwwx6kgncp45","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true\" alt=\"Spring 全景图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true\" alt=\"Spring 全景图\"></p>\n"},{"title":"内核页表设计","date":"2023-08-28T15:31:37.000Z","_content":"\n![内核页表设计](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true)\n","source":"_posts/内核页表设计.md","raw":"---\ntitle: 内核页表设计\ndate: 2023-08-28 23:31:37\ncategories: \n- 基本功\n- 操作系统\ntags:\n- 操作系统\n---\n\n![内核页表设计](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true)\n","slug":"内核页表设计","published":1,"updated":"2023-08-29T08:30:36.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6v000tmwwxbbzycpp3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true\" alt=\"内核页表设计\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true\" alt=\"内核页表设计\"></p>\n"},{"title":"命令行常用指令","date":"2023-08-28T17:17:53.000Z","_content":"\n\n&ensp;&ensp; MySQL 创建数据库并指定字符集：\n```xshell\ndrop schema if exists `test`;\nCREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\n```\n\n&ensp;&ensp; Brew 相关的\n\n```shell\n// 先卸载Homebrew\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n// 然后在安装\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n// 搜索包\nbrew search mysql\n// 安装包\nbrew install mysql\n// 查看包信息，比如目前的版本，依赖，安装后注意事项等\nbrew info mysql\n// 卸载包\nbrew uninstall wget\n// 显示已安装的包\nbrew list\n// 查看brew的帮助\nbrew –help\n// 更新， 这会更新 Homebrew 自己\nbrew update\n// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated mysql\n// 升级所有可以升级的软件们\nbrew upgrade\nbrew upgrade mysql\n// 清理不需要的版本极其安装包缓存\nbrew cleanup\nbrew cleanup mysql\n```\n&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)\n```shell\n-DCMAKE_BUILD_TYPE=Debug\n-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0\n-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build\n-DWITH_SSL=system\n\n./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\\n--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\\n--initialize-insecure --user=mysql\n```\n\n&ensp;&ensp; Git重新关联远程仓库\n```shell \ngit remote rm origin \ngit remote add origin [url]\ngit config --global user.name \"杨海波\"\ngit config --global user.email “3546514206@QQ.COM\"\n```\n\n&ensp;&ensp; 设置主机名称\n```shell\nsudo scutil --set HostName SetsunaYang\n```\n\n\n\n\n","source":"_posts/命令行常用指令.md","raw":"---\ntitle: 命令行常用指令\ndate: 2023-08-29 01:17:53\ncategories: \n- 其他\ntags:\n- 工具类\n---\n\n\n&ensp;&ensp; MySQL 创建数据库并指定字符集：\n```xshell\ndrop schema if exists `test`;\nCREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\n```\n\n&ensp;&ensp; Brew 相关的\n\n```shell\n// 先卸载Homebrew\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n// 然后在安装\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n// 搜索包\nbrew search mysql\n// 安装包\nbrew install mysql\n// 查看包信息，比如目前的版本，依赖，安装后注意事项等\nbrew info mysql\n// 卸载包\nbrew uninstall wget\n// 显示已安装的包\nbrew list\n// 查看brew的帮助\nbrew –help\n// 更新， 这会更新 Homebrew 自己\nbrew update\n// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated mysql\n// 升级所有可以升级的软件们\nbrew upgrade\nbrew upgrade mysql\n// 清理不需要的版本极其安装包缓存\nbrew cleanup\nbrew cleanup mysql\n```\n&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)\n```shell\n-DCMAKE_BUILD_TYPE=Debug\n-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0\n-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build\n-DWITH_SSL=system\n\n./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\\n--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\\n--initialize-insecure --user=mysql\n```\n\n&ensp;&ensp; Git重新关联远程仓库\n```shell \ngit remote rm origin \ngit remote add origin [url]\ngit config --global user.name \"杨海波\"\ngit config --global user.email “3546514206@QQ.COM\"\n```\n\n&ensp;&ensp; 设置主机名称\n```shell\nsudo scutil --set HostName SetsunaYang\n```\n\n\n\n\n","slug":"命令行常用指令","published":1,"updated":"2023-08-31T00:47:34.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6w000vmwwx3v52drph","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp; MySQL 创建数据库并指定字符集：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop schema if exists `test`;</span><br><span class=\"line\">CREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Brew 相关的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先卸载Homebrew</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class=\"line\">// 然后在安装</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class=\"line\">// 搜索包</span><br><span class=\"line\">brew search mysql</span><br><span class=\"line\">// 安装包</span><br><span class=\"line\">brew install mysql</span><br><span class=\"line\">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span><br><span class=\"line\">brew info mysql</span><br><span class=\"line\">// 卸载包</span><br><span class=\"line\">brew uninstall wget</span><br><span class=\"line\">// 显示已安装的包</span><br><span class=\"line\">brew list</span><br><span class=\"line\">// 查看brew的帮助</span><br><span class=\"line\">brew –help</span><br><span class=\"line\">// 更新， 这会更新 Homebrew 自己</span><br><span class=\"line\">brew update</span><br><span class=\"line\">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class=\"line\">brew outdated</span><br><span class=\"line\">brew outdated mysql</span><br><span class=\"line\">// 升级所有可以升级的软件们</span><br><span class=\"line\">brew upgrade</span><br><span class=\"line\">brew upgrade mysql</span><br><span class=\"line\">// 清理不需要的版本极其安装包缓存</span><br><span class=\"line\">brew cleanup</span><br><span class=\"line\">brew cleanup mysql</span><br></pre></td></tr></table></figure>\n<p>&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-DCMAKE_BUILD_TYPE=Debug</span><br><span class=\"line\">-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0</span><br><span class=\"line\">-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build</span><br><span class=\"line\">-DWITH_SSL=system</span><br><span class=\"line\"></span><br><span class=\"line\">./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\</span><br><span class=\"line\">--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\</span><br><span class=\"line\">--initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Git重新关联远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin </span><br><span class=\"line\">git remote add origin [url]</span><br><span class=\"line\">git config --global user.name &quot;杨海波&quot;</span><br><span class=\"line\">git config --global user.email “3546514206@QQ.COM&quot;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; 设置主机名称</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo scutil --set HostName SetsunaYang</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp; MySQL 创建数据库并指定字符集：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop schema if exists `test`;</span><br><span class=\"line\">CREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Brew 相关的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先卸载Homebrew</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class=\"line\">// 然后在安装</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class=\"line\">// 搜索包</span><br><span class=\"line\">brew search mysql</span><br><span class=\"line\">// 安装包</span><br><span class=\"line\">brew install mysql</span><br><span class=\"line\">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span><br><span class=\"line\">brew info mysql</span><br><span class=\"line\">// 卸载包</span><br><span class=\"line\">brew uninstall wget</span><br><span class=\"line\">// 显示已安装的包</span><br><span class=\"line\">brew list</span><br><span class=\"line\">// 查看brew的帮助</span><br><span class=\"line\">brew –help</span><br><span class=\"line\">// 更新， 这会更新 Homebrew 自己</span><br><span class=\"line\">brew update</span><br><span class=\"line\">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class=\"line\">brew outdated</span><br><span class=\"line\">brew outdated mysql</span><br><span class=\"line\">// 升级所有可以升级的软件们</span><br><span class=\"line\">brew upgrade</span><br><span class=\"line\">brew upgrade mysql</span><br><span class=\"line\">// 清理不需要的版本极其安装包缓存</span><br><span class=\"line\">brew cleanup</span><br><span class=\"line\">brew cleanup mysql</span><br></pre></td></tr></table></figure>\n<p>&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-DCMAKE_BUILD_TYPE=Debug</span><br><span class=\"line\">-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0</span><br><span class=\"line\">-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build</span><br><span class=\"line\">-DWITH_SSL=system</span><br><span class=\"line\"></span><br><span class=\"line\">./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\</span><br><span class=\"line\">--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\</span><br><span class=\"line\">--initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Git重新关联远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin </span><br><span class=\"line\">git remote add origin [url]</span><br><span class=\"line\">git config --global user.name &quot;杨海波&quot;</span><br><span class=\"line\">git config --global user.email “3546514206@QQ.COM&quot;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; 设置主机名称</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo scutil --set HostName SetsunaYang</span><br></pre></td></tr></table></figure>\n\n\n\n\n"},{"title":"回调机制","date":"2023-08-28T17:12:29.000Z","_content":"\n#### __1、C语言中的回调__ \n&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：\n\n```C++\nint max(int x, int y) { return x > y ? x : y; }\n\nint main(void) {\n    /* p 是函数指针 */\n    int (*p)(int, int) = &max; // &可以省略 \n    int a, b, c, d;\n    printf(\"请输入三个数字:\");\n    scanf(\"%d %d %d\", &a, &b, &c);\n    /* 与直接调用函数等价，d = max(max(a, b), c) */\n    d = p(p(a, b), c);\n    printf(\"最大的数字是: %d\\n\", d);\n    return 0;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp; 输出的结果：\n\n```shell\n请输入三个数字:1 2 3 \n最大的数字是: 3\n```\n\n&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： \n\n```shell\n16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709\n```\n\n#### __2、什么是回调__\n\n&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。\n\n&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。\n\n![程序调用的几种方式](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：\n\n* 属于工作流的一个部分； \n\n* 必须按照工作流指定的调用约定来申明（定义）； \n\n* 他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。","source":"_posts/回调机制.md","raw":"---\ntitle: 回调机制\ndate: 2023-08-29 01:12:29\ncategories: \n- 基本功\n- 编程基础\n- 编程理论\ntags:\n- C++\n- Java\n- 回调\n---\n\n#### __1、C语言中的回调__ \n&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：\n\n```C++\nint max(int x, int y) { return x > y ? x : y; }\n\nint main(void) {\n    /* p 是函数指针 */\n    int (*p)(int, int) = &max; // &可以省略 \n    int a, b, c, d;\n    printf(\"请输入三个数字:\");\n    scanf(\"%d %d %d\", &a, &b, &c);\n    /* 与直接调用函数等价，d = max(max(a, b), c) */\n    d = p(p(a, b), c);\n    printf(\"最大的数字是: %d\\n\", d);\n    return 0;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp; 输出的结果：\n\n```shell\n请输入三个数字:1 2 3 \n最大的数字是: 3\n```\n\n&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： \n\n```shell\n16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709\n```\n\n#### __2、什么是回调__\n\n&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。\n\n&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。\n\n![程序调用的几种方式](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：\n\n* 属于工作流的一个部分； \n\n* 必须按照工作流指定的调用约定来申明（定义）； \n\n* 他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。","slug":"回调机制","published":1,"updated":"2023-08-29T15:26:11.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6w000zmwwxgq9k70gr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"1、C语言中的回调\"><a href=\"#1、C语言中的回调\" class=\"headerlink\" title=\"1、C语言中的回调\"></a><strong>1、C语言中的回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* p 是函数指针 */</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>) = &amp;max; <span class=\"comment\">// &amp;可以省略 </span></span><br><span class=\"line\">    <span class=\"type\">int</span> a, b, c, d;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入三个数字:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">    <span class=\"comment\">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class=\"line\">    d = <span class=\"built_in\">p</span>(<span class=\"built_in\">p</span>(a, b), c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大的数字是: %d\\n&quot;</span>, d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 输出的结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入三个数字:1 2 3 </span><br><span class=\"line\">最大的数字是: 3</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、什么是回调\"><a href=\"#2、什么是回调\" class=\"headerlink\" title=\"2、什么是回调\"></a><strong>2、什么是回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true\" alt=\"程序调用的几种方式\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：</p>\n<ul>\n<li><p>属于工作流的一个部分； </p>\n</li>\n<li><p>必须按照工作流指定的调用约定来申明（定义）； </p>\n</li>\n<li><p>他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、C语言中的回调\"><a href=\"#1、C语言中的回调\" class=\"headerlink\" title=\"1、C语言中的回调\"></a><strong>1、C语言中的回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* p 是函数指针 */</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>) = &amp;max; <span class=\"comment\">// &amp;可以省略 </span></span><br><span class=\"line\">    <span class=\"type\">int</span> a, b, c, d;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入三个数字:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">    <span class=\"comment\">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class=\"line\">    d = <span class=\"built_in\">p</span>(<span class=\"built_in\">p</span>(a, b), c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大的数字是: %d\\n&quot;</span>, d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 输出的结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入三个数字:1 2 3 </span><br><span class=\"line\">最大的数字是: 3</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、什么是回调\"><a href=\"#2、什么是回调\" class=\"headerlink\" title=\"2、什么是回调\"></a><strong>2、什么是回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true\" alt=\"程序调用的几种方式\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：</p>\n<ul>\n<li><p>属于工作流的一个部分； </p>\n</li>\n<li><p>必须按照工作流指定的调用约定来申明（定义）； </p>\n</li>\n<li><p>他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。</p>\n</li>\n</ul>\n"},{"title":"本地调试Docker源码","date":"2023-08-29T00:50:52.000Z","_content":"","source":"_posts/本地调试Docker源码.md","raw":"---\ntitle: 本地调试Docker源码\ndate: 2023-08-29 08:50:52\ncategories: \n- 工程\n- 云计算\n- Docker\ntags:\n- 云计算领域\n- Docker\n---\n","slug":"本地调试Docker源码","published":1,"updated":"2023-08-29T02:22:56.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0fxw6w0011mwwx59yi6wrm","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"clm0fxw6s000cmwwx7zo1e8y5","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw6y001cmwwxasym31v6"},{"post_id":"clm0fxw6s000cmwwx7zo1e8y5","category_id":"clm0fxw6x0014mwwx3kfieur3","_id":"clm0fxw6y001emwwx3lg46qbp"},{"post_id":"clm0fxw6t000fmwwx6upwc62l","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw6y001gmwwx6opl84gn"},{"post_id":"clm0fxw6t000fmwwx6upwc62l","category_id":"clm0fxw6x0014mwwx3kfieur3","_id":"clm0fxw6z001imwwx526ydeiq"},{"post_id":"clm0fxw6o0001mwwxhkbfadk0","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw700024mwwx15x3c6cd"},{"post_id":"clm0fxw6o0001mwwxhkbfadk0","category_id":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw700025mwwxgt9gbzog"},{"post_id":"clm0fxw6o0001mwwxhkbfadk0","category_id":"clm0fxw6z001xmwwx6i7m6bxd","_id":"clm0fxw700028mwwxcd0g6edh"},{"post_id":"clm0fxw6v000tmwwxbbzycpp3","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw71002cmwwxakkpcv05"},{"post_id":"clm0fxw6v000tmwwxbbzycpp3","category_id":"clm0fxw700023mwwxamy04hdq","_id":"clm0fxw71002emwwx08j9eent"},{"post_id":"clm0fxw6w000vmwwx3v52drph","category_id":"clm0fxw71002dmwwxhuejdlo2","_id":"clm0fxw71002kmwwx5xkl1rm1"},{"post_id":"clm0fxw6w000zmwwxgq9k70gr","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw71002nmwwxhirqh7w1"},{"post_id":"clm0fxw6w000zmwwxgq9k70gr","category_id":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw71002pmwwxey4497i6"},{"post_id":"clm0fxw6w000zmwwxgq9k70gr","category_id":"clm0fxw71002hmwwx3yhl9voc","_id":"clm0fxw71002rmwwxfxxsg15k"},{"post_id":"clm0fxw6t000hmwwxfxxo98i7","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw720038mwwx71iw133z"},{"post_id":"clm0fxw6t000hmwwxfxxo98i7","category_id":"clm0fxw72002zmwwx3i3z01k0","_id":"clm0fxw720039mwwx3qfxe8o9"},{"post_id":"clm0fxw6r0007mwwx5f666muw","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw73003dmwwx0809ey2i"},{"post_id":"clm0fxw6r0007mwwx5f666muw","category_id":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw73003gmwwx3kjm77jy"},{"post_id":"clm0fxw6r0007mwwx5f666muw","category_id":"clm0fxw6z001omwwxg7ky66fm","_id":"clm0fxw73003imwwx6rnc6crz"},{"post_id":"clm0fxw6r0007mwwx5f666muw","category_id":"clm0fxw720037mwwx281ah6bu","_id":"clm0fxw73003mmwwx2wrv6x51"},{"post_id":"clm0fxw6u000mmwwx4hv04uxa","category_id":"clm0fxw6z001rmwwx6o723hgb","_id":"clm0fxw73003omwwxd1c546bg"},{"post_id":"clm0fxw6u000mmwwx4hv04uxa","category_id":"clm0fxw73003bmwwxcoxl38pr","_id":"clm0fxw73003smwwx80n2flkc"},{"post_id":"clm0fxw6v000pmwwx6f22fxnm","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw73003umwwx4epi4cb0"},{"post_id":"clm0fxw6v000pmwwx6f22fxnm","category_id":"clm0fxw73003emwwx32bk9qql","_id":"clm0fxw74003xmwwxdoeca3we"},{"post_id":"clm0fxw6r0008mwwx8uha7kqw","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw740040mwwxa1cggjzf"},{"post_id":"clm0fxw6r0008mwwx8uha7kqw","category_id":"clm0fxw700029mwwxan3rfuh3","_id":"clm0fxw740043mwwxbnw8h006"},{"post_id":"clm0fxw6r0008mwwx8uha7kqw","category_id":"clm0fxw73003qmwwx3e0z0hue","_id":"clm0fxw740045mwwx2wu71yap"},{"post_id":"clm0fxw6s000bmwwx7bbc6j6v","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw750048mwwx9lwec0vx"},{"post_id":"clm0fxw6s000bmwwx7bbc6j6v","category_id":"clm0fxw71002lmwwx5e4odskb","_id":"clm0fxw75004bmwwx4bftaiza"},{"post_id":"clm0fxw6s000bmwwx7bbc6j6v","category_id":"clm0fxw74003wmwwx27zfa53e","_id":"clm0fxw75004emwwx3r3b8bka"},{"post_id":"clm0fxw6w0011mwwx59yi6wrm","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw75004fmwwx3d5wb7y2"},{"post_id":"clm0fxw6w0011mwwx59yi6wrm","category_id":"clm0fxw71002lmwwx5e4odskb","_id":"clm0fxw75004imwwx2non4fok"},{"post_id":"clm0fxw6w0011mwwx59yi6wrm","category_id":"clm0fxw740041mwwxhok02pba","_id":"clm0fxw75004kmwwxfc5y3uns"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw75004mmwwx63m3h3zb"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","category_id":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw75004nmwwxavsl2gtd"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","category_id":"clm0fxw71002smwwx3qj9cc91","_id":"clm0fxw75004omwwxfzxbbzra"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","category_id":"clm0fxw740046mwwx1ixahwut","_id":"clm0fxw75004pmwwxgh657yp2"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","category_id":"clm0fxw6q0004mwwx8eb542q1","_id":"clm0fxw75004qmwwx04wy6tzl"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","category_id":"clm0fxw6t000imwwxgulsho93","_id":"clm0fxw75004rmwwxcf0zb2x7"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","category_id":"clm0fxw71002smwwx3qj9cc91","_id":"clm0fxw75004smwwxbhjah57o"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","category_id":"clm0fxw740046mwwx1ixahwut","_id":"clm0fxw75004tmwwxfazschy2"},{"post_id":"clm0fxw6u000lmwwx51r71kne","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw75004umwwx90uudq07"},{"post_id":"clm0fxw6u000lmwwx51r71kne","category_id":"clm0fxw700029mwwxan3rfuh3","_id":"clm0fxw75004vmwwxbeqscmqk"},{"post_id":"clm0fxw6u000lmwwx51r71kne","category_id":"clm0fxw75004gmwwx9sko9aiy","_id":"clm0fxw76004wmwwx8fki0jbn"},{"post_id":"clm0fxw6v000qmwwx6kgncp45","category_id":"clm0fxw6v000rmwwxcw8ngf8i","_id":"clm0fxw76004xmwwx19mcgu9n"},{"post_id":"clm0fxw6v000qmwwx6kgncp45","category_id":"clm0fxw700029mwwxan3rfuh3","_id":"clm0fxw76004ymwwxhqef0zjr"},{"post_id":"clm0fxw6v000qmwwx6kgncp45","category_id":"clm0fxw75004lmwwxh9wn6k81","_id":"clm0fxw76004zmwwxf5afba6e"}],"PostTag":[{"post_id":"clm0fxw6o0001mwwxhkbfadk0","tag_id":"clm0fxw6q0005mwwx6oyx0ud2","_id":"clm0fxw6t000gmwwxcw270uvz"},{"post_id":"clm0fxw6o0001mwwxhkbfadk0","tag_id":"clm0fxw6r000amwwx5an48in5","_id":"clm0fxw6t000jmwwxg2wq6lln"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","tag_id":"clm0fxw6r000amwwx5an48in5","_id":"clm0fxw6w000umwwxgjjpcwus"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","tag_id":"clm0fxw6t000kmwwxbhtzgsn3","_id":"clm0fxw6w000xmwwxauyw3o86"},{"post_id":"clm0fxw6p0003mwwxfb721dgs","tag_id":"clm0fxw6v000omwwxfm8m9m7f","_id":"clm0fxw6w0010mwwx6b4e12vb"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","tag_id":"clm0fxw6r000amwwx5an48in5","_id":"clm0fxw6y0016mwwx1eukehvt"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","tag_id":"clm0fxw6t000kmwwxbhtzgsn3","_id":"clm0fxw6y0017mwwx22ad90vy"},{"post_id":"clm0fxw6q0006mwwx9ao4h1ib","tag_id":"clm0fxw6v000omwwxfm8m9m7f","_id":"clm0fxw6y001amwwx7uvh93x6"},{"post_id":"clm0fxw6r0007mwwx5f666muw","tag_id":"clm0fxw6y0015mwwx0jyuefaw","_id":"clm0fxw6z001jmwwx2loo7mjg"},{"post_id":"clm0fxw6r0007mwwx5f666muw","tag_id":"clm0fxw6y0019mwwxc9a86jh2","_id":"clm0fxw6z001lmwwxfet37vd6"},{"post_id":"clm0fxw6r0007mwwx5f666muw","tag_id":"clm0fxw6v000omwwxfm8m9m7f","_id":"clm0fxw6z001nmwwxgnuq3jz1"},{"post_id":"clm0fxw6r0008mwwx8uha7kqw","tag_id":"clm0fxw6y001hmwwx9wqtal8j","_id":"clm0fxw6z001pmwwx67sd69a5"},{"post_id":"clm0fxw6s000bmwwx7bbc6j6v","tag_id":"clm0fxw6z001mmwwx6jwk73af","_id":"clm0fxw6z001tmwwx1j6uayai"},{"post_id":"clm0fxw6s000bmwwx7bbc6j6v","tag_id":"clm0fxw6z001qmwwx2jcgcpbk","_id":"clm0fxw6z001vmwwxfw6ye26b"},{"post_id":"clm0fxw6s000cmwwx7zo1e8y5","tag_id":"clm0fxw6z001smwwxhgow4ix3","_id":"clm0fxw6z001zmwwxhb0vbxa9"},{"post_id":"clm0fxw6s000cmwwx7zo1e8y5","tag_id":"clm0fxw6z001wmwwxggg42di8","_id":"clm0fxw700021mwwx0ias7czi"},{"post_id":"clm0fxw6t000fmwwx6upwc62l","tag_id":"clm0fxw6z001smwwxhgow4ix3","_id":"clm0fxw700027mwwx8r4j5ek9"},{"post_id":"clm0fxw6t000fmwwx6upwc62l","tag_id":"clm0fxw6z001wmwwxggg42di8","_id":"clm0fxw70002amwwx8eno8b50"},{"post_id":"clm0fxw6t000hmwwxfxxo98i7","tag_id":"clm0fxw700026mwwxfsi7emwo","_id":"clm0fxw71002gmwwxdsa0g3ka"},{"post_id":"clm0fxw6t000hmwwxfxxo98i7","tag_id":"clm0fxw70002bmwwx7tid9gkb","_id":"clm0fxw71002imwwx0hvx0c0u"},{"post_id":"clm0fxw6u000lmwwx51r71kne","tag_id":"clm0fxw71002fmwwx2sjrexfi","_id":"clm0fxw72002umwwx66378nk0"},{"post_id":"clm0fxw6u000lmwwx51r71kne","tag_id":"clm0fxw71002jmwwx8s3hccu5","_id":"clm0fxw72002wmwwxexwohn96"},{"post_id":"clm0fxw6u000lmwwx51r71kne","tag_id":"clm0fxw71002mmwwxbrz09o25","_id":"clm0fxw72002ymwwxem97cgk4"},{"post_id":"clm0fxw6u000lmwwx51r71kne","tag_id":"clm0fxw71002qmwwx7nlv0zi5","_id":"clm0fxw720030mwwx1in6b8x6"},{"post_id":"clm0fxw6u000mmwwx4hv04uxa","tag_id":"clm0fxw6q0005mwwx6oyx0ud2","_id":"clm0fxw720032mwwx3krlhng2"},{"post_id":"clm0fxw6u000mmwwx4hv04uxa","tag_id":"clm0fxw6r000amwwx5an48in5","_id":"clm0fxw720034mwwx687q1y8q"},{"post_id":"clm0fxw6u000mmwwx4hv04uxa","tag_id":"clm0fxw71002tmwwxckzngdam","_id":"clm0fxw720036mwwx8j3yfr60"},{"post_id":"clm0fxw6v000pmwwx6f22fxnm","tag_id":"clm0fxw72002xmwwx0isr3f9k","_id":"clm0fxw73003fmwwx19ji7esr"},{"post_id":"clm0fxw6v000pmwwx6f22fxnm","tag_id":"clm0fxw720031mwwx4jki6pb1","_id":"clm0fxw73003hmwwxcs2e7fye"},{"post_id":"clm0fxw6v000pmwwx6f22fxnm","tag_id":"clm0fxw720035mwwx216ebqat","_id":"clm0fxw73003lmwwx7lnzhled"},{"post_id":"clm0fxw6v000pmwwx6f22fxnm","tag_id":"clm0fxw72003amwwx2puc8em6","_id":"clm0fxw73003nmwwx5vd3ccry"},{"post_id":"clm0fxw6v000qmwwx6kgncp45","tag_id":"clm0fxw73003cmwwxc2eifcod","_id":"clm0fxw73003rmwwx19frby4r"},{"post_id":"clm0fxw6v000qmwwx6kgncp45","tag_id":"clm0fxw71002qmwwx7nlv0zi5","_id":"clm0fxw73003tmwwx4hj34x79"},{"post_id":"clm0fxw6v000tmwwxbbzycpp3","tag_id":"clm0fxw73003pmwwx1k196urg","_id":"clm0fxw74003ymwwxajrl0qkw"},{"post_id":"clm0fxw6w000vmwwx3v52drph","tag_id":"clm0fxw73003vmwwx0nk37dbj","_id":"clm0fxw740042mwwxgwxx2v7p"},{"post_id":"clm0fxw6w000zmwwxgq9k70gr","tag_id":"clm0fxw6q0005mwwx6oyx0ud2","_id":"clm0fxw750047mwwxfnwf15ug"},{"post_id":"clm0fxw6w000zmwwxgq9k70gr","tag_id":"clm0fxw6r000amwwx5an48in5","_id":"clm0fxw750049mwwx1shygi4c"},{"post_id":"clm0fxw6w000zmwwxgq9k70gr","tag_id":"clm0fxw71002tmwwxckzngdam","_id":"clm0fxw75004cmwwxdaj92jb4"},{"post_id":"clm0fxw6w0011mwwx59yi6wrm","tag_id":"clm0fxw6z001mmwwx6jwk73af","_id":"clm0fxw75004hmwwx405yehdp"},{"post_id":"clm0fxw6w0011mwwx59yi6wrm","tag_id":"clm0fxw75004amwwxbwdf2yn6","_id":"clm0fxw75004jmwwx93ujck07"}],"Tag":[{"name":"C++","_id":"clm0fxw6q0005mwwx6oyx0ud2"},{"name":"Java","_id":"clm0fxw6r000amwwx5an48in5"},{"name":"JVM","_id":"clm0fxw6t000kmwwxbhtzgsn3"},{"name":"基础知识","_id":"clm0fxw6v000omwwxfm8m9m7f"},{"name":"Go","_id":"clm0fxw6y0015mwwx0jyuefaw"},{"name":"GPM","_id":"clm0fxw6y0019mwwxc9a86jh2"},{"name":"数据库","_id":"clm0fxw6y001hmwwx9wqtal8j"},{"name":"云计算领域","_id":"clm0fxw6z001mmwwx6jwk73af"},{"name":"K8S","_id":"clm0fxw6z001qmwwx2jcgcpbk"},{"name":"计算机网络","_id":"clm0fxw6z001smwwxhgow4ix3"},{"name":"IP数据报","_id":"clm0fxw6z001wmwwxggg42di8"},{"name":"Qt","_id":"clm0fxw700026mwwxfsi7emwo"},{"name":"桌面开发","_id":"clm0fxw70002bmwwx7tid9gkb"},{"name":"Tomcat","_id":"clm0fxw71002fmwwx2sjrexfi"},{"name":"Java Web","_id":"clm0fxw71002jmwwx8s3hccu5"},{"name":"Servlet","_id":"clm0fxw71002mmwwxbrz09o25"},{"name":"Java EE","_id":"clm0fxw71002qmwwx7nlv0zi5"},{"name":"回调","_id":"clm0fxw71002tmwwxckzngdam"},{"name":"工作","_id":"clm0fxw72002xmwwx0isr3f9k"},{"name":"问题记录","_id":"clm0fxw720031mwwx4jki6pb1"},{"name":"线上事故","_id":"clm0fxw720035mwwx216ebqat"},{"name":"MyBatis","_id":"clm0fxw72003amwwx2puc8em6"},{"name":"Spring","_id":"clm0fxw73003cmwwxc2eifcod"},{"name":"操作系统","_id":"clm0fxw73003pmwwx1k196urg"},{"name":"工具类","_id":"clm0fxw73003vmwwx0nk37dbj"},{"name":"Docker","_id":"clm0fxw75004amwwxbwdf2yn6"}]}}