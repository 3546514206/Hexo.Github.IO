{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":1,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/SETSUNAYANG.JPG","path":"images/SETSUNAYANG.JPG","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/beian.png","path":"images/beian.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/gitee.png","path":"images/gitee.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/github.png","path":"images/github.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","path":"images/hexo-tag-chart.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/hexo.png","path":"images/hexo.png","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":1,"renderable":1},{"_id":"themes/ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/dz.js","path":"js/dz.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","path":"js/jquery-3.6.0.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","path":"css/fonts/remixicon.eot","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.css","path":"css/fonts/remixicon.css","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","path":"css/fonts/remixicon.svg","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","path":"css/fonts/remixicon.ttf","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","path":"css/fonts/remixicon.woff","modified":1,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","path":"css/fonts/remixicon.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/C-程序内存分区.md","hash":"a53cceb914fbca385e055b0c9d7f962a71248dc3","modified":1693303227126},{"_id":"source/_posts/IP数据报.md","hash":"dd62852f75ded2a948b2864818223a43716b97f6","modified":1693464273778},{"_id":"source/_posts/GPM模型.md","hash":"80cf20f3a4e36c7a644283f66827e8e32a7eb831","modified":1693299342065},{"_id":"source/_posts/GC—全过程.md","hash":"de0d35c3308e274b2e799b1dba90fc6290dfd30a","modified":1693298806083},{"_id":"source/_posts/GC—基础知识.md","hash":"8219b8ff1d2210e4b399beb15441db650d016723","modified":1693297892113},{"_id":"source/_posts/OSI-ISO七层网络.md","hash":"58575c413d9656236abd8031d34d16f2d3030515","modified":1693465520822},{"_id":"source/_posts/Spring全景.md","hash":"bedf71622137fddf363040d0070c244cf1d8d536","modified":1693297967817},{"_id":"source/_posts/Qt简介.md","hash":"9c065482308d5a3f3893be53ca9d5291d7cf7ca6","modified":1693270271155},{"_id":"source/_posts/Innodb中的事务隔离级别和锁实现.md","hash":"fabf5ccf276bb4a920822527dfe96f5463336913","modified":1693270339195},{"_id":"source/_posts/K8S架构图.md","hash":"122c7de78560ab48872bb396307af83fb2d7315c","modified":1693297946736},{"_id":"source/_posts/Tomcat启动流程.md","hash":"c46385ca4d413ab3bc63a2e6e3f1320bec08eaa6","modified":1693270322837},{"_id":"source/_posts/内核页表设计.md","hash":"06cdb3cda566e8e882f452984b99dbfe760ddcb2","modified":1693297836275},{"_id":"source/_posts/一次Mybatis升级引发的线上事故.md","hash":"0605c9ba94e587d19fe69c8f4a403773252d8c73","modified":1693578754689},{"_id":"source/_posts/保持敬畏之心.md","hash":"176b275b17bc38a3aad181712fb45adb9caa8317","modified":1693309761957},{"_id":"source/_posts/本地调试Docker源码.md","hash":"dc8555351a31d323ce7016070c8e6432dade5872","modified":1693275776563},{"_id":"source/_posts/回调机制.md","hash":"9bdb58af3ef0c828d8647571f89f644f2642bf71","modified":1693322771706},{"_id":"source/_posts/命令行常用指令.md","hash":"d642cc060d167067aa1cf51636c4fc5fc5fe5e78","modified":1693442854377},{"_id":"source/tags/index.md","hash":"231b06c7394538c47cd161c9d171c94890467b58","modified":1693237837078},{"_id":"source/categories/index.md","hash":"f4d7281acde67e8ebc5ffe566d10cad2ca568468","modified":1693237447813},{"_id":"source/_posts/C-基础教程.md","hash":"e2dc635e846e27d06b1fdacc94d7846c39310d5c","modified":1693627151592},{"_id":"themes/ayer/LICENSE","hash":"5f10900ed75022def5bf4c8639812671f0a6e2de","modified":1693145314875},{"_id":"themes/ayer/README.md","hash":"06421a758735285fcc9f6b605f3576a958ee1e8a","modified":1693145314875},{"_id":"themes/ayer/.DS_Store","hash":"cf44a39e65f9f875509e24e4548cbc77adf58775","modified":1693283450829},{"_id":"themes/ayer/index.js","hash":"19292aa9df268dbab8ac51a2a3aa7a20ac1eb00a","modified":1693144166186},{"_id":"themes/ayer/package.json","hash":"6f287150874e25757493857c564be64189c0c008","modified":1693145314875},{"_id":"themes/ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1693144166197},{"_id":"themes/ayer/move_config.js","hash":"e310bdb9a8738e506e53a40bd3cd895008d4cd61","modified":1693144166197},{"_id":"themes/ayer/rollup.config.js","hash":"13b61821acd9fc27131a34853037184b94ae8577","modified":1693144166197},{"_id":"themes/ayer/languages/de.yml","hash":"cdeed93d1eb4e65195aaf97d8c517e97106ddfd5","modified":1693144166186},{"_id":"themes/ayer/languages/en.yml","hash":"7e16c460c2c3d953c3bdebdef471ea747812b7a1","modified":1693144166187},{"_id":"themes/ayer/languages/es.yml","hash":"a3e8d81b99f62f86b3f34708253070b8806b31c8","modified":1693144166187},{"_id":"themes/ayer/languages/ko.yml","hash":"7dc54c2db864e5b725b55e201030e92acc1c422e","modified":1693144166187},{"_id":"themes/ayer/languages/ja.yml","hash":"d2ccb7ac8c9ff2ee721843741bb30b019d0a8083","modified":1693144166187},{"_id":"themes/ayer/languages/default.yml","hash":"7e16c460c2c3d953c3bdebdef471ea747812b7a1","modified":1693144166186},{"_id":"themes/ayer/languages/fr.yml","hash":"4a3cb84884988624943c6b0f8c1754da34943092","modified":1693144166187},{"_id":"themes/ayer/languages/no.yml","hash":"f8d7294f0d73ec35c37c050462cb725ea25a0fcc","modified":1693144166188},{"_id":"themes/ayer/_config.yml","hash":"e4d0b210a600a05b8e367c1f7fec33af71647b8f","modified":1693312310955},{"_id":"themes/ayer/languages/pt.yml","hash":"b137b9aead0dc4e2c2d9217ceb270460e41f5cb3","modified":1693144166188},{"_id":"themes/ayer/languages/nl.yml","hash":"2c289e97000c0c67636d96895aaa801c8abec0d4","modified":1693144166188},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"68400b1859e58cba03b05020ac8f47b807933027","modified":1693144166189},{"_id":"themes/ayer/languages/vi.yml","hash":"7d019ee795816a6a030a039d8238b71be04098fd","modified":1693144166189},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"edb2654bdb684fe0f21e8d6c841496c3506006ed","modified":1693144166189},{"_id":"themes/ayer/layout/categories.ejs","hash":"c40f84aacdf7d33cfcb4eb9f78f331dad699abff","modified":1693144166195},{"_id":"themes/ayer/languages/ru.yml","hash":"cdce73598db1aefb17b1c91658cfa4c906b98e24","modified":1693144166189},{"_id":"themes/ayer/layout/index.ejs","hash":"77347cbb8635611d8b1fb84bde75f9dedaf8632d","modified":1693144166195},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1693144166195},{"_id":"themes/ayer/layout/friends.ejs","hash":"18382cd4429588e58bf046beacaed06704832fe3","modified":1693144166195},{"_id":"themes/ayer/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1693144166197},{"_id":"themes/ayer/layout/plain-page.ejs","hash":"39cce1936f5f0e2feb924a7af2f52a631d81b84f","modified":1693144166197},{"_id":"themes/ayer/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1693144166197},{"_id":"themes/ayer/scripts/default_config.js","hash":"70d6ee032d75410d540b6789b5949739a47f0125","modified":1693144166199},{"_id":"themes/ayer/layout/tags.ejs","hash":"88b34dd8d7b1e64fa27aa6ed72af996cf6700809","modified":1693144166197},{"_id":"themes/ayer/source/404.html","hash":"6e6ebc1161643ffa524c9ecf38af7cd8cf1c9ecc","modified":1693283423880},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1693283423888},{"_id":"themes/ayer/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1693282854268},{"_id":"themes/ayer/layout/_partial/ads.ejs","hash":"d36962c66e3653aa94cc428731dd43a7ea4f979d","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"17ccda6fb61f1b6df94d23db936665c00a29a85b","modified":1693144166189},{"_id":"themes/ayer/source-src/main.js","hash":"13c57a2cec878217a5a3ee9afb6705d4c3cc0d3c","modified":1693144166209},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"9be7173badcca6582c1136204adb3aa432aada21","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"01ca257dde90dcadf1288a641401f6cf21a0ad43","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/broadcast.ejs","hash":"c228fa93bcf2f8403729342854211ea976df9a9f","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/float-btns.ejs","hash":"43ba0cd1f9e898bcbd873b1e9a2d47249d6aaf77","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"80a159273db944026701fe5062403e0f17cb8277","modified":1693145314909},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"ca81abe75c80ab32d6b6c4fe65de8e74df07bef3","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"61100fe248a744fab5dc71fb610992cbeff27e54","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"752666b28d5caed5e7d82d697d7546461e451d6f","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/lock.ejs","hash":"bbb00715c204197e7790d08be9a29afe5976146e","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"d38a59e2316b8a9c233c2f41edc2a03eab2c0a2e","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"cf441365eff1f8143e3c9ae54954d0ebe0a358e5","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"a56c8905987fa86657a9f081a89c12e5a5a5df54","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"cde5caf73f120b1300ec7539bbf675597688c734","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"7bcde0d6384819fd4c975a6e6e24e0919fbb1593","modified":1693144166194},{"_id":"themes/ayer/scripts/events/index.js","hash":"2c84d99e881f5cd1ee8a406b595a4365f3aea41e","modified":1693144166199},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e435b782178da75656f9616c7af564fb9ff0de50","modified":1693144166199},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"58f4c93d22e4eb9743915223444335fb6fe06d21","modified":1693144166199},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"7b3df58faaa875d17afbf74ddef5601116f2ce3d","modified":1693144166200},{"_id":"themes/ayer/scripts/lib/core.js","hash":"7908a82a86d63f35c6f785cacb1cfaf99ae7e0f9","modified":1693144166200},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"f9c8fceb2130929b8f11e22b1c3476c99d1574a8","modified":1693144166200},{"_id":"themes/ayer/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1693144166200},{"_id":"themes/ayer/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1693144166200},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"017f9b628806eeb199da2e77485cd9ac8e2117b3","modified":1693283423880},{"_id":"themes/ayer/source/css/custom.styl","hash":"56276abe6cd7cbf49fbf4fd4c986733188374160","modified":1693283423880},{"_id":"themes/ayer/source/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1693283423888},{"_id":"themes/ayer/layout/layout.ejs","hash":"84864bd6b4fc92bdd0a8ccba491fe490a8ecbf9b","modified":1693283959738},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"3895f24a1ba9ef5d4a024b1f45a5f30bff9f9c7c","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1693144166190},{"_id":"themes/ayer/source/dist/main.js","hash":"158d69f927d1cee076a485e894f307fadbe9656c","modified":1693283423888},{"_id":"themes/ayer/source/images/SETSUNAYANG.JPG","hash":"b7612fc376c8afaccc1f6733a50bc35e8e897500","modified":1693283423889},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1693283423889},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1693283423891},{"_id":"themes/ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1693283423891},{"_id":"themes/ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1693283423891},{"_id":"themes/ayer/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1693283423891},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1693283423906},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1693283423906},{"_id":"themes/ayer/source/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1693283423906},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1693283423906},{"_id":"themes/ayer/source/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1693283423906},{"_id":"themes/ayer/source/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1693283423906},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1693283423911},{"_id":"themes/ayer/source/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1693283423911},{"_id":"themes/ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1693283423908},{"_id":"themes/ayer/source/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1693283423911},{"_id":"themes/ayer/source/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1693283423912},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1693283423912},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1693283423911},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1693283423912},{"_id":"themes/ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1693283423911},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"219753a5cf40cfbd557fbde01a71f589e6de4327","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"8dedef428b6ac7d629e1d1f6039b0f60dacc4c5e","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"630e719b9e805a26182a37152435d4787c0f1734","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"910dd0682971a616e1610daec23e7ff5a556df98","modified":1693144166207},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"ce395318edf69766fe11161c4587a97f84521d85","modified":1693144166207},{"_id":"themes/ayer/source-src/js/share.js","hash":"7edce2efe23e75e29765201dc8b00fd2a5b5c9d2","modified":1693144166209},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"66dc025b7f87fed31fabdba62a405f85ae443788","modified":1693145314905},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"cfb16c9dda7a609776a28702e0c3854a52e422a7","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/author.ejs","hash":"57738b222e00bbd110be65d300d8bed34d73b3ea","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4647234e5c4529d754c9d0fc53ca9e9205f21443","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"85f0ebeceee1c32623bfa1e4170dbe1e34442fea","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"9f86e3d222555181a3e631a09bcdabdd44507cb8","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"5f8487fe7bed9a09001c6655244ff35f583cf1eb","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"4a21fd3d7335ffcd0661036fee81a927c125e2e2","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"e59198918e92ef92156aeefbf6023584ac1cae64","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"0a364766931f48df60b7c92fec8fde1067a93e00","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"3b076a65b9847cd6e0d424f5c2874046ef51d4d9","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/twikoo.ejs","hash":"63bc5c056b2db2aca479705fc94eaa7fd26a7976","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"369396d0c5b669df7a26df95f7a1b8a52f4eea65","modified":1693144166194},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"bc540478d35780e142b069ba2adafd5d5ce8a7b0","modified":1693144166192},{"_id":"themes/ayer/scripts/events/lib/hello.js","hash":"96213218d7ce78eccf087d01038245be5169fee0","modified":1693145314889},{"_id":"themes/ayer/scripts/events/lib/merge-configs.js","hash":"54836a1b41ebb32acc41839f53e1892779f66bb2","modified":1693144166199},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1693144166200},{"_id":"themes/ayer/source-src/css/style.styl","hash":"3941939bdb95297488d19e3e3716d5925b6eed44","modified":1693144166208},{"_id":"themes/ayer/source-src/css/_partial/ads.styl","hash":"d4be39f60a81dd0e5bdd49671e7308deddc572de","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"3044bf059522e79a726265c9a2f603ec8dc4222d","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"39a0bc6c5cf85f0527d6ee81f6feebce8550c1dd","modified":1693144166202},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"712cb4d8f3cef18dc33281bd8e9b6879efdb1687","modified":1693144166202},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"3b11d0c6c4439b0856ba81c50bd8867d5bb081da","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/friends.styl","hash":"9dd116846c92daee1c8f80b79cab231613b164b2","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"1a4576c38ef19834a4d0a8ac887e7b55d21f2f13","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"e894b3a1aff76e84137e1e6db59a75afd0a53f52","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"f2f43ae9831c3df017b35c68caa94f5eb911f697","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"b81d13334cf39941792dff0e3af393fb7b8cc214","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"94342884feac98e5ef58c9bd2781fc8f35220c1c","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"da34b6125de01938d11de6ad3c0fed2c75faf40a","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"da8a82a48852411c10e279dfee43038d46f4f273","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bde7bf3577c66a3ac829410d52fa2144212282ef","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a8a069ea34a0fd043832890db5341405e9f462cd","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"9ce2dd3ffdc4e170dfcb975a7158f913bc40b8d8","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"87df748185edfba222c3f9a4b9ef8eee0e8e5ad3","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"007bca390ec685349add74e033ff2cb90a1701bc","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"9e9d8dc167ed2c332e4520cbf41244c34c1ebf64","modified":1693144166206},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"9898b0dd9237e21908ba40292a8a9f947bed44d2","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"4b8e8455709debd73fba6bf3aad63378c4156dc1","modified":1693144166194},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"fea793e132f627a8148059a9aee8bc33550506d1","modified":1693144166193},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1693283423896},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"e3b411aef6e5f25f6c5c66b93d653ef70da8d4af","modified":1693144166194},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1693283423912},{"_id":"themes/ayer/source/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1693283423880},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1693283423887},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1693283423888},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"f81076fc6d4a83be3371bcb79ab54d88e2605714","modified":1693144166205},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1693283423906},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1693144166199},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1693283423893},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1693283423898},{"_id":"themes/ayer/source/images/alipay.jpg","hash":"74e90e8757a66b03304fd6e2abb086e85dd72edf","modified":1693283423891},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1693283423882},{"_id":"themes/ayer/source/images/wechat.jpg","hash":"d560cecf759485dfd385af9bad8f4f200aff21e5","modified":1693283423910},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1693283423887},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1693283423901},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1693283423905},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","hash":"94144debfb5761d37d79336a10ef674f82baec1b","modified":1693283423885},{"_id":"public/search.xml","hash":"2373b48086f2dd21a5d3ec397aca998a05bc0521","modified":1693627168437},{"_id":"public/tags/index.html","hash":"3b2fde7dec86b2e4d7e453545e9b7198452f5216","modified":1693627168437},{"_id":"public/archives/2023/09/index.html","hash":"2fada7183f33642c9c8d1e7b95393271bd47bdd5","modified":1693627168437},{"_id":"public/categories/基本功/计算机网络/index.html","hash":"2e3bdc089c887dcaeb54f935c505f5bbe29ecd04","modified":1693627168437},{"_id":"public/categories/基本功/操作系统/index.html","hash":"f4febf700db2f0c16d49a39e355ee4c7a5609bbf","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/C/index.html","hash":"fb944bbceeaa0e635be554898a14fa157c4222e2","modified":1693627168437},{"_id":"public/categories/思考/index.html","hash":"a9a4de18fa388d8f5d7aa48d37c176817c6aca5a","modified":1693627168437},{"_id":"public/categories/其他/index.html","hash":"00c8457dfd5d00b01a38ba31b21c099f2f2ad311","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/Java/index.html","hash":"cc09c3547366bbc972e21a717fd65f37d2cb97dd","modified":1693627168437},{"_id":"public/categories/工程/云计算/index.html","hash":"dd34d1cf57b06ad192374da2c48cdbf49c1ab287","modified":1693627168437},{"_id":"public/categories/工程/服务端/index.html","hash":"bccdce0c09fd4e6bf6a008db7bed2bee88150683","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/编程理论/index.html","hash":"0d95439be2cfaec2854e7c696eb3874feede48c0","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/Go/index.html","hash":"f12fffda9dd45beb8f7e67f9e2cd078cb26ae1ac","modified":1693627168437},{"_id":"public/categories/工程/Qt/index.html","hash":"e573f46e75bff6c24b1e61f1ddc2436f1066755b","modified":1693627168437},{"_id":"public/categories/思考/读书笔记/index.html","hash":"f91c8b77191d4fdde7afce179ff66da8bb9c78ea","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/Java/JVM/index.html","hash":"8fde9b8ff8c1407d6823eb472fdef9299a413cea","modified":1693627168437},{"_id":"public/categories/工程/问题记录与事故复盘/index.html","hash":"0867ac73a201ec87cefdb7cb6df38016438c2156","modified":1693627168437},{"_id":"public/categories/工程/云计算/Docker/index.html","hash":"d0e05d2bd5c2f2c430fe41eb67916d875708cc9c","modified":1693627168437},{"_id":"public/categories/工程/服务端/MySQL/index.html","hash":"7973704935d4328ddfb8036296d008d911f5e987","modified":1693627168437},{"_id":"public/categories/工程/云计算/K8S/index.html","hash":"5b0a260ed270bbb8e522c934d19c79f336ec8946","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/Go/GPM/index.html","hash":"8072e27a4873265cb446f6db50d6a493cfd0bf4e","modified":1693627168437},{"_id":"public/categories/工程/服务端/Tomcat/index.html","hash":"52bcf40ebf59462e4f863eb68e78bf72c6250269","modified":1693627168437},{"_id":"public/categories/工程/服务端/Spring/index.html","hash":"adca2104f9e414eb2477937f9089e84692ec762b","modified":1693627168437},{"_id":"public/tags/C/index.html","hash":"4a2a6c3281eb2753124f668b40d165f058d1bada","modified":1693627168437},{"_id":"public/tags/JVM/index.html","hash":"771ba04d28d2129b7f39596acfb1b9cb7c64f607","modified":1693627168437},{"_id":"public/tags/基础知识/index.html","hash":"03078dbd1f4f39b9ec0264b8b39031cc40240ffb","modified":1693627168437},{"_id":"public/tags/Go/index.html","hash":"e65918cbcd745b1e907aa41ff508fdc84e7a17a8","modified":1693627168437},{"_id":"public/tags/GPM/index.html","hash":"d620542c087664acb9d34aa2b21ab85f6a1d6563","modified":1693627168437},{"_id":"public/tags/计算机网络/index.html","hash":"598e08aaf95ae3577c303cb63f197eeae9ecc136","modified":1693627168437},{"_id":"public/tags/IP数据报/index.html","hash":"2ec5ddc8ab504525b3c8de8b6d970b567286a268","modified":1693627168437},{"_id":"public/tags/数据库/index.html","hash":"a0d3e8070656347d74cb30fcb076fc0afca16059","modified":1693627168437},{"_id":"public/tags/云计算领域/index.html","hash":"e720433279292f79c0d3a6af9210edaf9b4b4fa3","modified":1693627168437},{"_id":"public/tags/K8S/index.html","hash":"2b8a4527bbae0d70bd456268fc0535d49cfebb69","modified":1693627168437},{"_id":"public/tags/Qt/index.html","hash":"f9b54518c6dc799237b711a3394528ac1af69e30","modified":1693627168437},{"_id":"public/tags/桌面开发/index.html","hash":"41d037ef0ebd16f9f8c237067e1989a874a3d1bd","modified":1693627168437},{"_id":"public/tags/Tomcat/index.html","hash":"52fcb9fde04bfc2d0db7d5d995669fab4e2aef82","modified":1693627168437},{"_id":"public/tags/Java-Web/index.html","hash":"3baee75d364afa8f84e22ab17718192a3da8c0cc","modified":1693627168437},{"_id":"public/tags/Servlet/index.html","hash":"0be67ff2838bba70aa36625ae555644081d4f315","modified":1693627168437},{"_id":"public/tags/Java-EE/index.html","hash":"4d2e98c1b85365666964e40a82c7c4b549f7dde3","modified":1693627168437},{"_id":"public/tags/Spring/index.html","hash":"ce0747039eed43f2804d6d983a89874b6f82f6fb","modified":1693627168437},{"_id":"public/tags/操作系统/index.html","hash":"0a8bc22147dd127b2be789e683b26e36cc2b023a","modified":1693627168437},{"_id":"public/tags/回调/index.html","hash":"b0c26691859b437dd8e89930b2f37b14fb810627","modified":1693627168437},{"_id":"public/tags/工具类/index.html","hash":"da95f7f4a0c23b0686c7940fd3d364b9db423134","modified":1693627168437},{"_id":"public/tags/工作/index.html","hash":"af6665cdd62717470ccf76ae3a7fde74f4affe60","modified":1693627168437},{"_id":"public/tags/问题记录/index.html","hash":"67c381b2682ddae87dcac9cdde2b63178eed2130","modified":1693627168437},{"_id":"public/tags/线上事故/index.html","hash":"d4a9e9a8667d05c8d1b9bce9e60aa07d5d4ad78b","modified":1693627168437},{"_id":"public/tags/MyBatis/index.html","hash":"1f4569bcbc91fc35e6b9b9a85aeaa6de8e05e86f","modified":1693627168437},{"_id":"public/tags/Docker/index.html","hash":"3d099186e79e7f7fd8c9b92c1e3c976e027e70c6","modified":1693627168437},{"_id":"public/categories/index.html","hash":"bbc251330980585a57761f0628ad81ae33163a97","modified":1693627168437},{"_id":"public/2023/09/02/C-基础教程/index.html","hash":"fc2a0df997f6101ad94c3eb558584cb57d75aa9d","modified":1693627168437},{"_id":"public/2023/08/31/OSI-ISO七层网络/index.html","hash":"ce606bf5db149016da66d9da338d6598f13104f3","modified":1693627168437},{"_id":"public/2023/08/31/一次Mybatis升级引发的线上事故/index.html","hash":"b2853f053074ebb4780fc96ef58296a671b0a0b2","modified":1693627168437},{"_id":"public/2023/08/29/GPM模型/index.html","hash":"351ddaff9e6f895e11f238155237f7ae444fd691","modified":1693627168437},{"_id":"public/2023/08/29/GC—全过程/index.html","hash":"c064aeeb1f4c2044609c55df48da6d4d9dc6be93","modified":1693627168437},{"_id":"public/2023/08/29/K8S架构图/index.html","hash":"b8216aa623f52c0cab7e8b20bd1e6d7057f8e3aa","modified":1693627168437},{"_id":"public/2023/08/29/本地调试Docker源码/index.html","hash":"efdf6483b74b4cd2214e112f1cc3e42b65e18011","modified":1693627168437},{"_id":"public/2023/08/29/Qt简介/index.html","hash":"36f314bb329d3b350b2eb1fb0399b6b3ec3cdd48","modified":1693627168437},{"_id":"public/2023/08/29/IP数据报/index.html","hash":"0b955ef07df044adaa91d40bf90037199ef31de2","modified":1693627168437},{"_id":"public/2023/08/29/Innodb中的事务隔离级别和锁实现/index.html","hash":"d7c1b571226538db9546c2f9df359e9fe5993551","modified":1693627168437},{"_id":"public/2023/08/29/Spring全景/index.html","hash":"d7e29e48bb2b12df55edbeb23a77d8e1457e38d6","modified":1693627168437},{"_id":"public/2023/08/29/保持敬畏之心/index.html","hash":"7fbba8cc2ffa676e75197a3a29993ac1d713407e","modified":1693627168437},{"_id":"public/2023/08/29/命令行常用指令/index.html","hash":"c32fdeffe2344771fd3de2a2b34026426f3ae745","modified":1693627168437},{"_id":"public/2023/08/29/Tomcat启动流程/index.html","hash":"56f96e5c2f3e1881aa3dafff4481185bf22340ef","modified":1693627168437},{"_id":"public/2023/08/29/C-程序内存分区/index.html","hash":"dfcad0b7f0f0afab4ab5289e8ef8cdaa38766ade","modified":1693627168437},{"_id":"public/2023/08/29/回调机制/index.html","hash":"26444e3c46f496032e808a9fdbe13d9b0c6595d2","modified":1693627168437},{"_id":"public/2023/08/28/GC—基础知识/index.html","hash":"520eb3e648422797acd3f9591418fa96da837d4f","modified":1693627168437},{"_id":"public/2023/08/28/内核页表设计/index.html","hash":"5368ad139594f4c09f85c0c9ae28400411997be3","modified":1693627168437},{"_id":"public/archives/index.html","hash":"dda44515508fd85a6511ff6b2b7c29df33fc367b","modified":1693627168437},{"_id":"public/archives/page/2/index.html","hash":"afb44d615b084856628908cf098ff4db1d2d7ccd","modified":1693627168437},{"_id":"public/archives/2023/index.html","hash":"d3d6c027cc3a55e35257a8c2af4fb6cfd5bb8757","modified":1693627168437},{"_id":"public/archives/2023/page/2/index.html","hash":"356ed2025b159a7a94fc04bd69757cde50a2d5ff","modified":1693627168437},{"_id":"public/archives/2023/08/index.html","hash":"d2e90282a498b46fea3b98ab9bdafc782c090c08","modified":1693627168437},{"_id":"public/archives/2023/08/page/2/index.html","hash":"8b04b67c7b93cc4c7cdb8c3c74ef79fc5c6edb48","modified":1693627168437},{"_id":"public/categories/基本功/index.html","hash":"fec6739c890588762958592fbf2afbac4f5fe11a","modified":1693627168437},{"_id":"public/categories/基本功/编程基础/index.html","hash":"9cb8186b3e84829f08d4697fbfa8977a2bfa7f8a","modified":1693627168437},{"_id":"public/categories/工程/index.html","hash":"60dd4a9c5296d0952d2210687c2cb50abcd58ece","modified":1693627168437},{"_id":"public/index.html","hash":"47a6e2be2c70c23e52d099f04cd4dd91de1650da","modified":1693627168437},{"_id":"public/page/2/index.html","hash":"0ea092bb71f05be49d58c1cb66f10dd3e5819fc2","modified":1693627168437},{"_id":"public/tags/Java/index.html","hash":"4dd85ce461008da02c22e657d5ec40e11547d69d","modified":1693627168437},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1693627168437},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1693627168437},{"_id":"public/images/SETSUNAYANG.JPG","hash":"b7612fc376c8afaccc1f6733a50bc35e8e897500","modified":1693627168437},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1693627168437},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1693627168437},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1693627168437},{"_id":"public/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1693627168437},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1693627168437},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1693627168437},{"_id":"public/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1693627168437},{"_id":"public/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1693627168437},{"_id":"public/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1693627168437},{"_id":"public/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1693627168437},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1693627168437},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1693627168437},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1693627168437},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1693627168437},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1693627168437},{"_id":"public/css/hbe.style.css","hash":"72959894400fd5c350106cb558c39fa51f722cbd","modified":1693627168437},{"_id":"public/lib/hbe.js","hash":"fb05fcd82bb28d3b2887d388cabea7f9b1a318eb","modified":1693627168437},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1693627168437},{"_id":"public/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1693627168437},{"_id":"public/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1693627168437},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1693627168437},{"_id":"public/404.html","hash":"6e6ebc1161643ffa524c9ecf38af7cd8cf1c9ecc","modified":1693627168437},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1693627168437},{"_id":"public/css/custom.css","hash":"58950a4f4cd82465f85428ec17b3bc05f8153b56","modified":1693627168437},{"_id":"public/dist/main.js","hash":"158d69f927d1cee076a485e894f307fadbe9656c","modified":1693627168437},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1693627168437},{"_id":"public/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1693627168437},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1693627168437},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1693627168437},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1693627168437},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1693627168437},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1693627168437},{"_id":"public/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1693627168437},{"_id":"public/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1693627168437},{"_id":"public/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1693627168437},{"_id":"public/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1693627168437},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1693627168437},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1693627168437},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1693627168437},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1693627168437},{"_id":"public/images/alipay.jpg","hash":"74e90e8757a66b03304fd6e2abb086e85dd72edf","modified":1693627168437},{"_id":"public/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1693627168437},{"_id":"public/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1693627168437},{"_id":"public/assets/js/DPlayer.min.js","hash":"290283e41ac69bfd570c90800680097f998e4e0c","modified":1693627168437},{"_id":"public/images/wechat.jpg","hash":"d560cecf759485dfd385af9bad8f4f200aff21e5","modified":1693627168437},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1693627168437},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1693627168437},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1693627168437},{"_id":"public/css/fonts/remixicon.svg","hash":"94144debfb5761d37d79336a10ef674f82baec1b","modified":1693627168437}],"Category":[{"name":"基本功","_id":"clm1hvz630004uywx7ft82n6c"},{"name":"计算机网络","parent":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6d000iuywxda9u3vnp"},{"name":"编程基础","parent":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6g000nuywx0p5qdgzo"},{"name":"工程","_id":"clm1hvz6j000yuywx1m807tnp"},{"name":"操作系统","parent":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6p001tuywx46v86zk9"},{"name":"C++","parent":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6q001xuywx4700bul7"},{"name":"思考","_id":"clm1hvz6r0021uywxhrug7owt"},{"name":"其他","_id":"clm1hvz6s0026uywxcogm0xye"},{"name":"Java","parent":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6s002buywxbsn5grri"},{"name":"云计算","parent":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6t002iuywx0n1veyxm"},{"name":"服务端","parent":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6t002luywxcyf052il"},{"name":"编程理论","parent":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6u002quywx6eqqc3fm"},{"name":"Go","parent":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6v0033uywxh6f736jc"},{"name":"Qt","parent":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6v0038uywxdcmu08yi"},{"name":"读书笔记","parent":"clm1hvz6r0021uywxhrug7owt","_id":"clm1hvz6w003luywx7g8d6x9t"},{"name":"JVM","parent":"clm1hvz6s002buywxbsn5grri","_id":"clm1hvz6w003puywxeg6lf74w"},{"name":"问题记录与事故复盘","parent":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6w003suywxg9nkbgfs"},{"name":"Docker","parent":"clm1hvz6t002iuywx0n1veyxm","_id":"clm1hvz6x003wuywx9pzv5umj"},{"name":"MySQL","parent":"clm1hvz6t002luywxcyf052il","_id":"clm1hvz6x0040uywxfkcubim2"},{"name":"K8S","parent":"clm1hvz6t002iuywx0n1veyxm","_id":"clm1hvz6y004cuywxc1jf0yl2"},{"name":"GPM","parent":"clm1hvz6v0033uywxh6f736jc","_id":"clm1hvz6z004huywx0may706u"},{"name":"Tomcat","parent":"clm1hvz6t002luywxcyf052il","_id":"clm1hvz6z004nuywx921pd8kg"},{"name":"Spring","parent":"clm1hvz6t002luywxcyf052il","_id":"clm1hvz6z004ruywxberq4s44"}],"Data":[],"Page":[{"title":"categories","date":"2023-08-28T15:21:32.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-08-28 23:21:32\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2023-08-28T15:44:07.813Z","path":"categories/index.html","comments":1,"_id":"clm1hvz5r0000uywx0zfp3bzb","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2023-08-28T15:23:28.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-08-28 23:23:28\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2023-08-28T15:50:37.078Z","path":"tags/index.html","comments":1,"_id":"clm1hvz600002uywxdgaq96il","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++程序内存分区","date":"2023-08-28T17:14:22.000Z","_content":"\n__代码区：__ 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。\n\n__静态区：__ 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！\n\n__堆：__ 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。\n\n__栈：__ 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。\n\n__常量区：__ 常量字符串就是放在这⾥的。 程序结束后由系统释放。\n\n__BSS段：__ 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：\n\n```C++\n\nint a = 0; //全局初始化区（静态区）\nchar *p1; //全局未初始化区 （BSS段）\nint main() {\n    int b; //栈 6 char s[] = \"abc\"; //栈 7 char *p2; //栈 8 char *p3 = \"123456\"; //123456/0在常量区，p3在栈上。\n    static int c = 0; //全局（静态）初始化区 （静态区）\n    p1 = (char *) malloc(10); //分配得10和20字节的区域就在堆区。\n    // p2 = (char *) malloc(20);\n    strcpy(p1, \"123456\");\n    //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成⼀块。\n    return 0;\n}\n```\n\n","source":"_posts/C-程序内存分区.md","raw":"---\ntitle: C++程序内存分区\ndate: 2023-08-29 01:14:22\ncategories: \n- 基本功\n- 编程基础\n- C++\ntags:\n- C++\n- Java\n---\n\n__代码区：__ 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。\n\n__静态区：__ 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！\n\n__堆：__ 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。\n\n__栈：__ 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。\n\n__常量区：__ 常量字符串就是放在这⾥的。 程序结束后由系统释放。\n\n__BSS段：__ 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：\n\n```C++\n\nint a = 0; //全局初始化区（静态区）\nchar *p1; //全局未初始化区 （BSS段）\nint main() {\n    int b; //栈 6 char s[] = \"abc\"; //栈 7 char *p2; //栈 8 char *p3 = \"123456\"; //123456/0在常量区，p3在栈上。\n    static int c = 0; //全局（静态）初始化区 （静态区）\n    p1 = (char *) malloc(10); //分配得10和20字节的区域就在堆区。\n    // p2 = (char *) malloc(20);\n    strcpy(p1, \"123456\");\n    //123456/0放在常量区，编译器可能会将它与p3所指向的\"123456\"优化成⼀块。\n    return 0;\n}\n```\n\n","slug":"C-程序内存分区","published":1,"updated":"2023-08-29T10:00:27.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz5x0001uywxakhleuix","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>代码区：</strong> 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。</p>\n<p><strong>静态区：</strong> 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！</p>\n<p><strong>堆：</strong> 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。</p>\n<p><strong>栈：</strong> 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。</p>\n<p><strong>常量区：</strong> 常量字符串就是放在这⾥的。 程序结束后由系统释放。</p>\n<p><strong>BSS段：</strong> 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>; <span class=\"comment\">//全局初始化区（静态区）</span></span><br><span class=\"line\"><span class=\"type\">char</span> *p1; <span class=\"comment\">//全局未初始化区 （BSS段）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> b; <span class=\"comment\">//栈 6 char s[] = &quot;abc&quot;; //栈 7 char *p2; //栈 8 char *p3 = &quot;123456&quot;; //123456/0在常量区，p3在栈上。</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> c = <span class=\"number\">0</span>; <span class=\"comment\">//全局（静态）初始化区 （静态区）</span></span><br><span class=\"line\">    p1 = (<span class=\"type\">char</span> *) <span class=\"built_in\">malloc</span>(<span class=\"number\">10</span>); <span class=\"comment\">//分配得10和20字节的区域就在堆区。</span></span><br><span class=\"line\">    <span class=\"comment\">// p2 = (char *) malloc(20);</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(p1, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成⼀块。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>代码区：</strong> 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。</p>\n<p><strong>静态区：</strong> 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！</p>\n<p><strong>堆：</strong> 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。</p>\n<p><strong>栈：</strong> 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。</p>\n<p><strong>常量区：</strong> 常量字符串就是放在这⾥的。 程序结束后由系统释放。</p>\n<p><strong>BSS段：</strong> 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>; <span class=\"comment\">//全局初始化区（静态区）</span></span><br><span class=\"line\"><span class=\"type\">char</span> *p1; <span class=\"comment\">//全局未初始化区 （BSS段）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> b; <span class=\"comment\">//栈 6 char s[] = &quot;abc&quot;; //栈 7 char *p2; //栈 8 char *p3 = &quot;123456&quot;; //123456/0在常量区，p3在栈上。</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> c = <span class=\"number\">0</span>; <span class=\"comment\">//全局（静态）初始化区 （静态区）</span></span><br><span class=\"line\">    p1 = (<span class=\"type\">char</span> *) <span class=\"built_in\">malloc</span>(<span class=\"number\">10</span>); <span class=\"comment\">//分配得10和20字节的区域就在堆区。</span></span><br><span class=\"line\">    <span class=\"comment\">// p2 = (char *) malloc(20);</span></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(p1, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成⼀块。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"GC-全流程","date":"2023-08-29T07:46:59.000Z","_content":"\n\n#### __1、minorGC 和 Full GC 区别__\n&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n\n&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n#### __2、minorGC 过程详解__\n&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-\nXX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n#### __3、整体描述__\n&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -> Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。\n\n#### __4、GC 触发条件__\n&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：\n* 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；\n* 老年代空间不足；\n* 方法去空间不足；\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存；\n* 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n#### __5、对象进入老年代的四种情况__\n&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没\"熬过\"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。\n\n&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true)\n\n#### __6、空间分配担保__\n&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。\n\n&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。\n\n&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。\n\n\n\n\n\n\n\n","source":"_posts/GC—全过程.md","raw":"---\ntitle: GC-全流程\ndate: 2023-08-29 15:46:59\ncategories:\n- 基本功\n- 编程基础\n- Java\n- JVM\ntags:\n- Java\n- JVM\n- 基础知识\n---\n\n\n#### __1、minorGC 和 Full GC 区别__\n&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n\n&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n#### __2、minorGC 过程详解__\n&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-\nXX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n#### __3、整体描述__\n&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -> Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。\n\n#### __4、GC 触发条件__\n&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：\n* 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；\n* 老年代空间不足；\n* 方法去空间不足；\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存；\n* 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n#### __5、对象进入老年代的四种情况__\n&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没\"熬过\"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。\n\n&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true)\n\n#### __6、空间分配担保__\n&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。\n\n&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。\n\n&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。\n\n\n\n\n\n\n\n","slug":"GC—全过程","published":1,"updated":"2023-08-29T08:46:46.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz610003uywxepe7gi93","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"1、minorGC-和-Full-GC-区别\"><a href=\"#1、minorGC-和-Full-GC-区别\" class=\"headerlink\" title=\"1、minorGC 和 Full GC 区别\"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>\n<h4 id=\"2、minorGC-过程详解\"><a href=\"#2、minorGC-过程详解\" class=\"headerlink\" title=\"2、minorGC 过程详解\"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<h4 id=\"3、整体描述\"><a href=\"#3、整体描述\" class=\"headerlink\" title=\"3、整体描述\"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>\n<h4 id=\"4、GC-触发条件\"><a href=\"#4、GC-触发条件\" class=\"headerlink\" title=\"4、GC 触发条件\"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>\n<ul>\n<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>\n<li>老年代空间不足；</li>\n<li>方法去空间不足；</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>\n<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>\n</ul>\n<h4 id=\"5、对象进入老年代的四种情况\"><a href=\"#5、对象进入老年代的四种情况\" class=\"headerlink\" title=\"5、对象进入老年代的四种情况\"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true\"></p>\n<h4 id=\"6、空间分配担保\"><a href=\"#6、空间分配担保\" class=\"headerlink\" title=\"6、空间分配担保\"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、minorGC-和-Full-GC-区别\"><a href=\"#1、minorGC-和-Full-GC-区别\" class=\"headerlink\" title=\"1、minorGC 和 Full GC 区别\"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>\n<h4 id=\"2、minorGC-过程详解\"><a href=\"#2、minorGC-过程详解\" class=\"headerlink\" title=\"2、minorGC 过程详解\"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<h4 id=\"3、整体描述\"><a href=\"#3、整体描述\" class=\"headerlink\" title=\"3、整体描述\"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>\n<h4 id=\"4、GC-触发条件\"><a href=\"#4、GC-触发条件\" class=\"headerlink\" title=\"4、GC 触发条件\"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>\n<ul>\n<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>\n<li>老年代空间不足；</li>\n<li>方法去空间不足；</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>\n<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>\n</ul>\n<h4 id=\"5、对象进入老年代的四种情况\"><a href=\"#5、对象进入老年代的四种情况\" class=\"headerlink\" title=\"5、对象进入老年代的四种情况\"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true\"></p>\n<h4 id=\"6、空间分配担保\"><a href=\"#6、空间分配担保\" class=\"headerlink\" title=\"6、空间分配担保\"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>\n"},{"title":"GPM模型","date":"2023-08-29T08:54:42.000Z","_content":"","source":"_posts/GPM模型.md","raw":"---\ntitle: GPM模型\ndate: 2023-08-29 16:54:42\ncategories: \n- 基本功\n- 编程基础\n- Go\n- GPM\ntags:\n- Go\n- GPM\n- 基础知识\n---\n","slug":"GPM模型","published":1,"updated":"2023-08-29T08:55:42.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz640006uywx64ct1u5u","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"IP数据报","date":"2023-08-28T17:29:54.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。\n\n\n![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### __1、固定部分__\n\n* 版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。\n* 首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。\n* 区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。\n* 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。\n* 标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。\n* 标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF=0 时才允许分片。\n* 片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。\n* 生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。\n* 协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。\n* 首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。\n* 源地址和目的地址：32位，IPV4 地址。\n\n#### __2、可变部分__\n\n&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：\n* 安全和处理限制（用于军事领域）。\n* 记录路径（让每个路由器都记下它的IP地址）。\n* 时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。\n* 宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。\n* 严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。\n\n&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。\n","source":"_posts/IP数据报.md","raw":"---\ntitle: IP数据报\ndate: 2023-08-29 01:29:54\ncategories: \n- 基本功\n- 计算机网络\ntags:\n- 计算机网络\n- IP数据报\n---\n\n&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。\n\n\n![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### __1、固定部分__\n\n* 版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。\n* 首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。\n* 区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。\n* 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。\n* 标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。\n* 标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF=0 时才允许分片。\n* 片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。\n* 生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。\n* 协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。\n* 首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。\n* 源地址和目的地址：32位，IPV4 地址。\n\n#### __2、可变部分__\n\n&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：\n* 安全和处理限制（用于军事领域）。\n* 记录路径（让每个路由器都记下它的IP地址）。\n* 时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。\n* 宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。\n* 严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。\n\n&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。\n","slug":"IP数据报","published":1,"updated":"2023-08-31T06:44:33.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz660007uywxghhuhy1c","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"IP报文结构\"></p>\n<h4 id=\"1、固定部分\"><a href=\"#1、固定部分\" class=\"headerlink\" title=\"1、固定部分\"></a><strong>1、固定部分</strong></h4><ul>\n<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>\n<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>\n<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>\n<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>\n<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>\n<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>\n<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>\n<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>\n<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>\n<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址和目的地址：32位，IPV4 地址。</li>\n</ul>\n<h4 id=\"2、可变部分\"><a href=\"#2、可变部分\" class=\"headerlink\" title=\"2、可变部分\"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>\n<ul>\n<li>安全和处理限制（用于军事领域）。</li>\n<li>记录路径（让每个路由器都记下它的IP地址）。</li>\n<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>\n<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>\n<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"IP报文结构\"></p>\n<h4 id=\"1、固定部分\"><a href=\"#1、固定部分\" class=\"headerlink\" title=\"1、固定部分\"></a><strong>1、固定部分</strong></h4><ul>\n<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>\n<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>\n<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>\n<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>\n<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>\n<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>\n<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>\n<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>\n<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>\n<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址和目的地址：32位，IPV4 地址。</li>\n</ul>\n<h4 id=\"2、可变部分\"><a href=\"#2、可变部分\" class=\"headerlink\" title=\"2、可变部分\"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>\n<ul>\n<li>安全和处理限制（用于军事领域）。</li>\n<li>记录路径（让每个路由器都记下它的IP地址）。</li>\n<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>\n<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>\n<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</p>\n"},{"title":"GC—基础知识","date":"2023-08-28T15:31:37.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样\n的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？\n\n#### __1、可达性分析算法（GC Roots）__\n\n&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现\n方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之\n间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标\n记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下\n几种：\n* 虚拟机栈（本地变量表）中引用的对象\n* 方法区中类静态属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中引用的对象\n\n#### __2、JVM中的堆结构__\n&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：\n![JVM 分代比例](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to\n区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：\n![JVM 内存模型全景](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)\n\n#### __2.1、为何新生代要分为三个区__\n&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小\n相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。\n\n&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。\n\n&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。\n\n&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。\n\n#### __2.2、新生代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；\n\n&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；\n\n&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：\nfrom 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）\n\n#### __2.3、老年代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经\n过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-\nXX:PretenureSizeThreshold=30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。\n\n&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和\n大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己\n的晋升年龄。\n\n#### __3、JVM完整的GC流程__\n&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。\n\n&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重\n影响性能。\n\n&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。\n处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾\n回收器等。","source":"_posts/GC—基础知识.md","raw":"---\ntitle: GC—基础知识\ndate: 2023-08-28 23:31:37\ncategories: \n- 基本功\n- 编程基础\n- Java\n- JVM\ntags:\n- Java\n- JVM\n- 基础知识\n---\n\n&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样\n的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？\n\n#### __1、可达性分析算法（GC Roots）__\n\n&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现\n方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之\n间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标\n记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下\n几种：\n* 虚拟机栈（本地变量表）中引用的对象\n* 方法区中类静态属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中引用的对象\n\n#### __2、JVM中的堆结构__\n&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：\n![JVM 分代比例](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to\n区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：\n![JVM 内存模型全景](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)\n\n#### __2.1、为何新生代要分为三个区__\n&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小\n相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。\n\n&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。\n\n&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。\n\n&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。\n\n#### __2.2、新生代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；\n\n&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；\n\n&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：\nfrom 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）\n\n#### __2.3、老年代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经\n过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-\nXX:PretenureSizeThreshold=30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。\n\n&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和\n大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己\n的晋升年龄。\n\n#### __3、JVM完整的GC流程__\n&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。\n\n&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重\n影响性能。\n\n&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。\n处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾\n回收器等。","slug":"GC—基础知识","published":1,"updated":"2023-08-29T08:31:32.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz670008uywxb8frep5i","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>\n<h4 id=\"1、可达性分析算法（GC-Roots）\"><a href=\"#1、可达性分析算法（GC-Roots）\" class=\"headerlink\" title=\"1、可达性分析算法（GC Roots）\"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>\n<ul>\n<li>虚拟机栈（本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n</ul>\n<h4 id=\"2、JVM中的堆结构\"><a href=\"#2、JVM中的堆结构\" class=\"headerlink\" title=\"2、JVM中的堆结构\"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true\" alt=\"JVM 分代比例\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"JVM 内存模型全景\"></p>\n<h4 id=\"2-1、为何新生代要分为三个区\"><a href=\"#2-1、为何新生代要分为三个区\" class=\"headerlink\" title=\"2.1、为何新生代要分为三个区\"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>\n<h4 id=\"2-2、新生代对象的分配和回收\"><a href=\"#2-2、新生代对象的分配和回收\" class=\"headerlink\" title=\"2.2、新生代对象的分配和回收\"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>\n<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>\n<h4 id=\"2-3、老年代对象的分配和回收\"><a href=\"#2-3、老年代对象的分配和回收\" class=\"headerlink\" title=\"2.3、老年代对象的分配和回收\"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>\n<h4 id=\"3、JVM完整的GC流程\"><a href=\"#3、JVM完整的GC流程\" class=\"headerlink\" title=\"3、JVM完整的GC流程\"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>\n<h4 id=\"1、可达性分析算法（GC-Roots）\"><a href=\"#1、可达性分析算法（GC-Roots）\" class=\"headerlink\" title=\"1、可达性分析算法（GC Roots）\"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>\n<ul>\n<li>虚拟机栈（本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n</ul>\n<h4 id=\"2、JVM中的堆结构\"><a href=\"#2、JVM中的堆结构\" class=\"headerlink\" title=\"2、JVM中的堆结构\"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true\" alt=\"JVM 分代比例\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"JVM 内存模型全景\"></p>\n<h4 id=\"2-1、为何新生代要分为三个区\"><a href=\"#2-1、为何新生代要分为三个区\" class=\"headerlink\" title=\"2.1、为何新生代要分为三个区\"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>\n<h4 id=\"2-2、新生代对象的分配和回收\"><a href=\"#2-2、新生代对象的分配和回收\" class=\"headerlink\" title=\"2.2、新生代对象的分配和回收\"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>\n<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>\n<h4 id=\"2-3、老年代对象的分配和回收\"><a href=\"#2-3、老年代对象的分配和回收\" class=\"headerlink\" title=\"2.3、老年代对象的分配和回收\"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>\n<h4 id=\"3、JVM完整的GC流程\"><a href=\"#3、JVM完整的GC流程\" class=\"headerlink\" title=\"3、JVM完整的GC流程\"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>\n"},{"title":"Innodb中的事务隔离级别和锁实现","date":"2023-08-28T17:28:46.000Z","_content":"","source":"_posts/Innodb中的事务隔离级别和锁实现.md","raw":"---\ntitle: Innodb中的事务隔离级别和锁实现\ndate: 2023-08-29 01:28:46\ncategories: \n- 工程\n- 服务端\n- MySQL\ntags:\n- 数据库\n---\n","slug":"Innodb中的事务隔离级别和锁实现","published":1,"updated":"2023-08-29T00:52:19.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6a000buywx0rfk0xtn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"OSI/ISO七层网络","date":"2023-08-31T06:42:29.000Z","_content":"\n\n&ensp;&ensp; 七层网络的常见设备，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true)\n\n&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true)\n\n\n","source":"_posts/OSI-ISO七层网络.md","raw":"---\ntitle: OSI/ISO七层网络\ndate: 2023-08-31 14:42:29\ncategories: \n- 基本功\n- 计算机网络\ntags:\n- 计算机网络\n- IP数据报\n---\n\n\n&ensp;&ensp; 七层网络的常见设备，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true)\n\n&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true)\n\n\n","slug":"OSI-ISO七层网络","published":1,"updated":"2023-08-31T07:05:20.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6b000cuywx14zvdru7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp; 七层网络的常见设备，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true\"></p>\n<p>&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp; 七层网络的常见设备，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true\"></p>\n<p>&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true\"></p>\n"},{"title":"K8S架构图","date":"2023-08-29T02:33:27.000Z","_content":"\n\n![K8S架构图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)","source":"_posts/K8S架构图.md","raw":"---\ntitle: K8S架构图\ndate: 2023-08-29 10:33:27\ncategories: \n- 工程\n- 云计算\n- K8S\ntags:\n- 云计算领域\n- K8S\n---\n\n\n![K8S架构图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)","slug":"K8S架构图","published":1,"updated":"2023-08-29T08:32:26.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6c000fuywxhbuzgtqj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"K8S架构图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"K8S架构图\"></p>\n"},{"title":"Qt简介","date":"2023-08-29T00:49:39.000Z","_content":"","source":"_posts/Qt简介.md","raw":"---\ntitle: Qt简介\ndate: 2023-08-29 08:49:39\ncategories: \n- 工程\n- Qt\ntags:\n- Qt\n- 桌面开发\n---\n","slug":"Qt简介","published":1,"updated":"2023-08-29T00:51:11.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6c000huywx2p27aj6b","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"Tomcat启动流程","date":"2023-08-28T17:16:02.000Z","_content":"","source":"_posts/Tomcat启动流程.md","raw":"---\ntitle: Tomcat启动流程\ndate: 2023-08-29 01:16:02\ncategories: \n- 工程\n- 服务端\n- Tomcat\ntags:\n- Tomcat\n- Java Web\n- Servlet\n- Java EE\n---\n","slug":"Tomcat启动流程","published":1,"updated":"2023-08-29T00:52:02.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6e000luywxd06j9n1u","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"Spring全景","date":"2023-08-28T17:20:39.000Z","_content":"\n\n![Spring 全景图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true)","source":"_posts/Spring全景.md","raw":"---\ntitle: Spring全景\ndate: 2023-08-29 01:20:39\ncategories: \n- 工程\n- 服务端\n- Spring\ntags:\n- Spring\n- Java EE\n---\n\n\n![Spring 全景图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true)","slug":"Spring全景","published":1,"updated":"2023-08-29T08:32:47.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6e000muywx2ufig5ia","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true\" alt=\"Spring 全景图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true\" alt=\"Spring 全景图\"></p>\n"},{"title":"内核页表设计","date":"2023-08-28T15:31:37.000Z","_content":"\n![内核页表设计](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true)\n","source":"_posts/内核页表设计.md","raw":"---\ntitle: 内核页表设计\ndate: 2023-08-28 23:31:37\ncategories: \n- 基本功\n- 操作系统\ntags:\n- 操作系统\n---\n\n![内核页表设计](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true)\n","slug":"内核页表设计","published":1,"updated":"2023-08-29T08:30:36.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6g000puywx6y4w92v5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true\" alt=\"内核页表设计\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true\" alt=\"内核页表设计\"></p>\n"},{"title":"保持敬畏之心","date":"2023-08-28T17:19:15.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。\n","source":"_posts/保持敬畏之心.md","raw":"---\ntitle: 保持敬畏之心\ndate: 2023-08-29 01:19:15\ncategories: \n- 思考\n- 读书笔记\ntags:\n- C++\n- Java\n- 回调\n---\n\n&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。\n","slug":"保持敬畏之心","published":1,"updated":"2023-08-29T11:49:21.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6h000quywx4odo3ta3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。</p>\n"},{"title":"命令行常用指令","date":"2023-08-28T17:17:53.000Z","_content":"\n\n&ensp;&ensp; MySQL 创建数据库并指定字符集：\n```xshell\ndrop schema if exists `test`;\nCREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\n```\n\n&ensp;&ensp; Brew 相关的\n\n```shell\n// 先卸载Homebrew\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n// 然后在安装\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n// 搜索包\nbrew search mysql\n// 安装包\nbrew install mysql\n// 查看包信息，比如目前的版本，依赖，安装后注意事项等\nbrew info mysql\n// 卸载包\nbrew uninstall wget\n// 显示已安装的包\nbrew list\n// 查看brew的帮助\nbrew –help\n// 更新， 这会更新 Homebrew 自己\nbrew update\n// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated mysql\n// 升级所有可以升级的软件们\nbrew upgrade\nbrew upgrade mysql\n// 清理不需要的版本极其安装包缓存\nbrew cleanup\nbrew cleanup mysql\n```\n&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)\n```shell\n-DCMAKE_BUILD_TYPE=Debug\n-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0\n-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build\n-DWITH_SSL=system\n\n./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\\n--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\\n--initialize-insecure --user=mysql\n```\n\n&ensp;&ensp; Git重新关联远程仓库\n```shell \ngit remote rm origin \ngit remote add origin [url]\ngit config --global user.name \"杨海波\"\ngit config --global user.email “3546514206@QQ.COM\"\n```\n\n&ensp;&ensp; 设置主机名称\n```shell\nsudo scutil --set HostName SetsunaYang\n```\n\n\n\n\n","source":"_posts/命令行常用指令.md","raw":"---\ntitle: 命令行常用指令\ndate: 2023-08-29 01:17:53\ncategories: \n- 其他\ntags:\n- 工具类\n---\n\n\n&ensp;&ensp; MySQL 创建数据库并指定字符集：\n```xshell\ndrop schema if exists `test`;\nCREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;\n```\n\n&ensp;&ensp; Brew 相关的\n\n```shell\n// 先卸载Homebrew\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n// 然后在安装\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n// 搜索包\nbrew search mysql\n// 安装包\nbrew install mysql\n// 查看包信息，比如目前的版本，依赖，安装后注意事项等\nbrew info mysql\n// 卸载包\nbrew uninstall wget\n// 显示已安装的包\nbrew list\n// 查看brew的帮助\nbrew –help\n// 更新， 这会更新 Homebrew 自己\nbrew update\n// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级\nbrew outdated\nbrew outdated mysql\n// 升级所有可以升级的软件们\nbrew upgrade\nbrew upgrade mysql\n// 清理不需要的版本极其安装包缓存\nbrew cleanup\nbrew cleanup mysql\n```\n&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)\n```shell\n-DCMAKE_BUILD_TYPE=Debug\n-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0\n-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build\n-DWITH_SSL=system\n\n./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\\n--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\\n--initialize-insecure --user=mysql\n```\n\n&ensp;&ensp; Git重新关联远程仓库\n```shell \ngit remote rm origin \ngit remote add origin [url]\ngit config --global user.name \"杨海波\"\ngit config --global user.email “3546514206@QQ.COM\"\n```\n\n&ensp;&ensp; 设置主机名称\n```shell\nsudo scutil --set HostName SetsunaYang\n```\n\n\n\n\n","slug":"命令行常用指令","published":1,"updated":"2023-08-31T00:47:34.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6j000uuywxfwpmgjl8","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp; MySQL 创建数据库并指定字符集：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop schema if exists `test`;</span><br><span class=\"line\">CREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Brew 相关的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先卸载Homebrew</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class=\"line\">// 然后在安装</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class=\"line\">// 搜索包</span><br><span class=\"line\">brew search mysql</span><br><span class=\"line\">// 安装包</span><br><span class=\"line\">brew install mysql</span><br><span class=\"line\">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span><br><span class=\"line\">brew info mysql</span><br><span class=\"line\">// 卸载包</span><br><span class=\"line\">brew uninstall wget</span><br><span class=\"line\">// 显示已安装的包</span><br><span class=\"line\">brew list</span><br><span class=\"line\">// 查看brew的帮助</span><br><span class=\"line\">brew –help</span><br><span class=\"line\">// 更新， 这会更新 Homebrew 自己</span><br><span class=\"line\">brew update</span><br><span class=\"line\">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class=\"line\">brew outdated</span><br><span class=\"line\">brew outdated mysql</span><br><span class=\"line\">// 升级所有可以升级的软件们</span><br><span class=\"line\">brew upgrade</span><br><span class=\"line\">brew upgrade mysql</span><br><span class=\"line\">// 清理不需要的版本极其安装包缓存</span><br><span class=\"line\">brew cleanup</span><br><span class=\"line\">brew cleanup mysql</span><br></pre></td></tr></table></figure>\n<p>&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-DCMAKE_BUILD_TYPE=Debug</span><br><span class=\"line\">-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0</span><br><span class=\"line\">-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build</span><br><span class=\"line\">-DWITH_SSL=system</span><br><span class=\"line\"></span><br><span class=\"line\">./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\</span><br><span class=\"line\">--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\</span><br><span class=\"line\">--initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Git重新关联远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin </span><br><span class=\"line\">git remote add origin [url]</span><br><span class=\"line\">git config --global user.name &quot;杨海波&quot;</span><br><span class=\"line\">git config --global user.email “3546514206@QQ.COM&quot;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; 设置主机名称</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo scutil --set HostName SetsunaYang</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp; MySQL 创建数据库并指定字符集：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop schema if exists `test`;</span><br><span class=\"line\">CREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Brew 相关的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 先卸载Homebrew</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class=\"line\">// 然后在安装</span><br><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class=\"line\">// 搜索包</span><br><span class=\"line\">brew search mysql</span><br><span class=\"line\">// 安装包</span><br><span class=\"line\">brew install mysql</span><br><span class=\"line\">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span><br><span class=\"line\">brew info mysql</span><br><span class=\"line\">// 卸载包</span><br><span class=\"line\">brew uninstall wget</span><br><span class=\"line\">// 显示已安装的包</span><br><span class=\"line\">brew list</span><br><span class=\"line\">// 查看brew的帮助</span><br><span class=\"line\">brew –help</span><br><span class=\"line\">// 更新， 这会更新 Homebrew 自己</span><br><span class=\"line\">brew update</span><br><span class=\"line\">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class=\"line\">brew outdated</span><br><span class=\"line\">brew outdated mysql</span><br><span class=\"line\">// 升级所有可以升级的软件们</span><br><span class=\"line\">brew upgrade</span><br><span class=\"line\">brew upgrade mysql</span><br><span class=\"line\">// 清理不需要的版本极其安装包缓存</span><br><span class=\"line\">brew cleanup</span><br><span class=\"line\">brew cleanup mysql</span><br></pre></td></tr></table></figure>\n<p>&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-DCMAKE_BUILD_TYPE=Debug</span><br><span class=\"line\">-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0</span><br><span class=\"line\">-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build</span><br><span class=\"line\">-DWITH_SSL=system</span><br><span class=\"line\"></span><br><span class=\"line\">./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \\</span><br><span class=\"line\">--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \\</span><br><span class=\"line\">--initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; Git重新关联远程仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin </span><br><span class=\"line\">git remote add origin [url]</span><br><span class=\"line\">git config --global user.name &quot;杨海波&quot;</span><br><span class=\"line\">git config --global user.email “3546514206@QQ.COM&quot;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp; 设置主机名称</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo scutil --set HostName SetsunaYang</span><br></pre></td></tr></table></figure>\n\n\n\n\n"},{"title":"深入 OGNL 与  Mybatis 源代码分析一次 Mybatis 升级引发的线上事故","date":"2023-08-31T02:16:04.000Z","_content":"\n\n&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -> 3.4.4：\n\n![mybatis前后版本升级](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：\n\n![报错信息](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。\n\n&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:\n\n![分别引入两个版本的依赖](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:\n\n![数据库脚本](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：\n\n![dao层方法调用](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:\n\n```shell\ninvalid comparision:  java.util.HashMap and java.lang.String\n```\n\n&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!='' 将_parameter 与 '' 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 '' 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。\n\n&ensp;&ensp;&ensp;&ensp; 但是问题又来了，__为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？__ 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：\n\n![ifnode](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 ... && _parameter!='' 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：\n\n```shell\nmybatis-3.2.5  ->  ognl-2.6.9\nmybatis-3.4.4  ->  ognl-3.1.14\n```\n\n&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：\n\n![高版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：\n\n![低版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：\n\n![类型标记](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!='' 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ''）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：\n\n![调试信息如下](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 解释一下：t1 = t2 = 10，表示 _parameter 与 '' 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 = ''。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。\n\n&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：\n\n&ensp;&ensp;&ensp;&ensp; __如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -> String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务__\n\n&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：\n\n&ensp;&ensp;&ensp;&ensp; __如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本。接下来我们看方法外面这个 equals 的来源：__\n\n![equals](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。\n\n&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： __低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 _parameter!='' 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。__\n\n&ensp;&ensp;&ensp;&ensp; __反思：__\n* __日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。__\n* __组件升级要慎之又慎，测试要充分。__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/一次Mybatis升级引发的线上事故.md","raw":"---\ntitle: 深入 OGNL 与  Mybatis 源代码分析一次 Mybatis 升级引发的线上事故\ndate: 2023-08-31 10:16:04\ncategories:\n- 工程\n- 问题记录与事故复盘\ntags:\n- 工作\n- 问题记录\n- 线上事故\n- MyBatis\n---\n\n\n&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -> 3.4.4：\n\n![mybatis前后版本升级](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：\n\n![报错信息](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。\n\n&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:\n\n![分别引入两个版本的依赖](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:\n\n![数据库脚本](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：\n\n![dao层方法调用](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:\n\n```shell\ninvalid comparision:  java.util.HashMap and java.lang.String\n```\n\n&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!='' 将_parameter 与 '' 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 '' 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。\n\n&ensp;&ensp;&ensp;&ensp; 但是问题又来了，__为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？__ 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：\n\n![ifnode](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 ... && _parameter!='' 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：\n\n```shell\nmybatis-3.2.5  ->  ognl-2.6.9\nmybatis-3.4.4  ->  ognl-3.1.14\n```\n\n&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：\n\n![高版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：\n\n![低版本 OGNL 代码](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：\n\n![类型标记](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!='' 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ''）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：\n\n![调试信息如下](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 解释一下：t1 = t2 = 10，表示 _parameter 与 '' 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 = ''。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。\n\n&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：\n\n&ensp;&ensp;&ensp;&ensp; __如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -> String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务__\n\n&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：\n\n&ensp;&ensp;&ensp;&ensp; __如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本。接下来我们看方法外面这个 equals 的来源：__\n\n![equals](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。\n\n&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： __低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 _parameter!='' 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。__\n\n&ensp;&ensp;&ensp;&ensp; __反思：__\n* __日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。__\n* __组件升级要慎之又慎，测试要充分。__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"一次Mybatis升级引发的线上事故","published":1,"updated":"2023-09-01T14:32:34.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6j000xuywxb1sj5ppn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -&gt; 3.4.4：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true\" alt=\"mybatis前后版本升级\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true\" alt=\"报错信息\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true\" alt=\"分别引入两个版本的依赖\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true\" alt=\"数据库脚本\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true\" alt=\"dao层方法调用\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invalid comparision:  java.util.HashMap and java.lang.String</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!&#x3D;’’ 将_parameter 与 ‘’ 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 ‘’ 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 但是问题又来了，<strong>为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？</strong> 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true\" alt=\"ifnode\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 … &amp;&amp; _parameter!&#x3D;’’ 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis-3.2.5  -&gt;  ognl-2.6.9</span><br><span class=\"line\">mybatis-3.4.4  -&gt;  ognl-3.1.14</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"高版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"低版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true\" alt=\"类型标记\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!&#x3D;’’ 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ‘’）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true\" alt=\"调试信息如下\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 解释一下：t1 &#x3D; t2 &#x3D; 10，表示 _parameter 与 ‘’ 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 &#x3D; ‘’。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：</p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -&gt; String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务</strong></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：</p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本。接下来我们看方法外面这个 equals 的来源：</strong></p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true\" alt=\"equals\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： _<em>低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 <em>parameter!&#x3D;’’ 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。</em></em></p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>反思：</strong></p>\n<ul>\n<li><strong>日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。</strong></li>\n<li><strong>组件升级要慎之又慎，测试要充分。</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -&gt; 3.4.4：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true\" alt=\"mybatis前后版本升级\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true\" alt=\"报错信息\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true\" alt=\"分别引入两个版本的依赖\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true\" alt=\"数据库脚本\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true\" alt=\"dao层方法调用\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">invalid comparision:  java.util.HashMap and java.lang.String</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!&#x3D;’’ 将_parameter 与 ‘’ 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 ‘’ 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 但是问题又来了，<strong>为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？</strong> 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true\" alt=\"ifnode\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 … &amp;&amp; _parameter!&#x3D;’’ 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mybatis-3.2.5  -&gt;  ognl-2.6.9</span><br><span class=\"line\">mybatis-3.4.4  -&gt;  ognl-3.1.14</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"高版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true\" alt=\"低版本 OGNL 代码\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true\" alt=\"类型标记\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!&#x3D;’’ 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ‘’）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true\" alt=\"调试信息如下\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 解释一下：t1 &#x3D; t2 &#x3D; 10，表示 _parameter 与 ‘’ 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 &#x3D; ‘’。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：</p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -&gt; String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务</strong></p>\n<p>&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：</p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本。接下来我们看方法外面这个 equals 的来源：</strong></p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true\" alt=\"equals\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： _<em>低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 <em>parameter!&#x3D;’’ 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。</em></em></p>\n<p>&ensp;&ensp;&ensp;&ensp; <strong>反思：</strong></p>\n<ul>\n<li><strong>日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。</strong></li>\n<li><strong>组件升级要慎之又慎，测试要充分。</strong></li>\n</ul>\n"},{"title":"本地调试Docker源码","date":"2023-08-29T00:50:52.000Z","_content":"","source":"_posts/本地调试Docker源码.md","raw":"---\ntitle: 本地调试Docker源码\ndate: 2023-08-29 08:50:52\ncategories: \n- 工程\n- 云计算\n- Docker\ntags:\n- 云计算领域\n- Docker\n---\n","slug":"本地调试Docker源码","published":1,"updated":"2023-08-29T02:22:56.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6k0010uywxgoa7exrh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"C++基础教程","date":"2023-09-02T03:55:33.000Z","_content":"\n__原文来自：https://github.com/GrindGold/CppGuide__\n\n# C++ 教程\n\n![](https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png)\n\nC++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。\n\n本教程通过通俗易懂的语言来讲解 C++ 编程语言。\n\n**现在开始学习 C++ 编程！**\n\n \n\n## 谁适合阅读本教程？\n\n本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。\n\n## 阅读本教程前，您需要了解的知识：\n\n在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。\n\n## 编译/执行 C++ 程序\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std;int main(){\n    cout << \"Hello, world!\" << endl;    return 0;\n}\n```\n\n运行结果：\n\n```cpp\nHello, world!\n```\n\n你可以用 \"\\n\" 代替以上代码里的 \"endl\"。\n\n# C++ 简介\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\n\nC++ 被认为是一种**中级**语言，它综合了高级语言和低级语言的特点。\n\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。\n\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n\n**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。\n\n## 面向对象程序设计\n\nC++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：\n\n- 封装\n- 抽象\n- 继承\n- 多态\n\n## 标准库\n\n标准的 C++ 由三个重要部分组成：\n\n- 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。\n- C++ 标准库，提供了大量的函数，用于操作文件、字符串等。\n- 标准模板库（STL），提供了大量的方法，用于操作数据结构等。\n\n## ANSI 标准\n\nANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。\n\n由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。\n\n## 学习 C++\n\n学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。\n\n学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。\n\nC++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。\n\n## C++ 的使用\n\n基本上每个应用程序领域的程序员都有使用 C++。\n\nC++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。\n\nC++ 广泛用于教学和研究。\n\n任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。\n\n------\n\n## 标准化\n\n| 发布时间 | 文档                  | 通称   | 备注                |      |\n| :------- | :-------------------- | :----- | :------------------ | :--- |\n| 2015     | ISO/IEC TS 19570:2015 | -      | 用于并行计算的扩展  |      |\n| 2015     | ISO/IEC TS 18822:2015 | -      | 文件系统            |      |\n| 2014     | ISO/IEC 14882:2014    | C++14  | 第四个C++标准       |      |\n| 2011     | ISO/IEC TR 24733:2011 | -      | 十进制浮点数扩展    |      |\n| 2011     | ISO/IEC 14882:2011    | C++11  | 第三个C++标准       |      |\n| 2010     | ISO/IEC TR 29124:2010 | -      | 数学函数扩展        |      |\n| 2007     | ISO/IEC TR 19768:2007 | C++TR1 | C++技术报告：库扩展 |      |\n| 2006     | ISO/IEC TR 18015:2006 | -      | C++性能技术报告     |      |\n| 2003     | ISO/IEC 14882:2003    | C++03  | 第二个C++标准       |      |\n| 1998     | ISO/IEC 14882:1998    | C++98  | 第一个C++标准       |      |\n\n# C++ 环境设置\n\n## 本地环境设置\n\n如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。\n\n## 文本编辑器\n\n这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。\n\n文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。\n\n通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。\n\n在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。\n\n## C++ 编译器\n\n写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。\n\nC++ 编译器用于把源代码编译成最终的可执行程序。\n\n大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。\n\n最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。\n\n以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。\n\n## 安装 GNU 的 C/C++ 编译器\n\n### UNIX/Linux 上的安装\n\n如果您使用的是 **Linux 或 UNIX**，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：\n\n```cpp\n$ g++ -v\n```\n\n如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：\n\n```cpp\nUsing built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix\ngcc version 4.1.2 20080704 (Red Hat 4.1.2-46)\n```\n\n如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。\n\n### Mac OS X 上的安装\n\n如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。\n\nXcode 目前可从 developer.apple.com/technologies/tools/ 上下载。\n\n### Windows 上的安装\n\n为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 www.mingw.org，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。\n\n当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。\n\n添加您安装的 MinGW 的 bin 子目录到您的 **PATH** 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。\n\n当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。\n\n------\n\n## 使用 Visual Studio (Graphical Interface) 编译\n\n1、下载及安装 Visual Studio Community 2015。\n\n2、打开 Visual Studio Community\n\n3、点击 File -> New -> Project\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png)\n\n4、左侧列表选择 Templates -> Visual C++ -> Win32 Console Application，并设置项目名为 MyFirstProgram。\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png)\n\n \n\n5、点击 OK。\n\n6、在以下窗口中点击 Next\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png)\n\n7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：\n\n8、右击文件夹 Source File 并点击 Add --> New Item... :\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png)\n\n9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png)\n\n \n\n10、拷贝以下代码到 main.cpp 中：\n\n```cpp\n#include <iostream>int main(){\n    std::cout << \"Hello World!\\n\";\n    return 0;}\n```\n\n界面如下所示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png)\n\n11、点击菜单上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png)\n\n12、完成以上操作后，你可以看到以下输出：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png)\n\n------\n\n## g++ 应用说明\n\n程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：\n\n```cpp\n$ gcc main.cpp -lstdc++ -o main\n```\n\n下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：\n\n```cpp\n#include <iostream>using namespace std;int main(){\n    cout << \"Hello, world!\" << endl;\n    return 0;}\n```\n\n最简单的编译方式：\n\n```cpp\n$ g++ helloworld.cpp\n```\n\n由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：\n\n```cpp\n$ ./a.outHello, world!\n```\n\n通常我们使用 **-o** 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：\n\n```cpp\n$ g++ helloworld.cpp -o helloworld\n```\n\n执行 helloworld:\n\n```cpp\n$ ./helloworldHello, world!\n```\n\n如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：\n\n```cpp\n$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob\n```\n\n生成一个 runoob 可执行文件。\n\ng++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：\n\n```cpp\ng++ -g -Wall -std=c++11 main.cpp\n```\n\n### g++ 常用命令选项\n\n| 选项         | 解释                                                         |\n| :----------- | :----------------------------------------------------------- |\n| -ansi        | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |\n| -c           | 只编译并生成目标文件。                                       |\n| -DMACRO      | 以字符串\"1\"定义 MACRO 宏。                                   |\n| -DMACRO=DEFN | 以字符串\"DEFN\"定义 MACRO 宏。                                |\n| -E           | 只运行 C 预编译器。                                          |\n| -g           | 生成调试信息。GNU 调试器可利用该信息。                       |\n| -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |\n| -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |\n| -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |\n| -m486        | 针对 486 进行代码优化。                                      |\n| -o           | FILE 生成指定的输出文件。用在生成可执行文件时。              |\n| -O0          | 不进行优化处理。                                             |\n| -O           | 或 -O1 优化生成代码。                                        |\n| -O2          | 进一步优化。                                                 |\n| -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |\n| -shared      | 生成共享目标文件。通常用在建立共享库时。                     |\n| -static      | 禁止使用共享连接。                                           |\n| -UMACRO      | 取消对 MACRO 宏的定义。                                      |\n| -w           | 不生成任何警告信息。                                         |\n| -Wall        | 生成所有警告信息。                                           |\n\n# C++ 基本语法\n\nC++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。\n\n- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。\n- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。\n- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。\n- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。\n\n## C++ 程序结构\n\n让我们看一段简单的代码，可以输出单词 *Hello World*。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; // main() 是程序开始执行的地方 \n\tint main(){   \n\tcout << \"Hello World\"; // 输出 Hello World   return 0;\n\t}\n```\n\n接下来我们讲解一下上面这段程序：\n\n- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。\n- 行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。\n- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。\n- 下一行 **int main()** 是主函数，程序从这里开始执行。\n- 下一行 **cout << \"Hello World\";** 会在屏幕上显示消息 \"Hello World\"。\n- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。\n\n## 编译 & 执行 C++ 程序\n\n接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：\n\n- 打开一个文本编辑器，添加上述代码。\n- 保存文件为 hello.cpp。\n- 打开命令提示符，进入到保存文件所在的目录。\n- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。\n- 现在，键入 ' a.out' 来运行程序。\n- 您可以看到屏幕上显示 ' Hello World '。\n\n```cpp\n$ g++ hello.cpp$ ./a.outHello World\n```\n\n请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。\n\n您也可以使用 makefile 来编译 C/C++ 程序。\n\n## C++ 中的分号 & 块\n\n在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。\n\n例如，下面是三个不同的语句：\n\n```cpp\nx = y;y = y+1;add(x, y);\n```\n\n块是一组使用大括号括起来的按逻辑连接的语句。例如：\n\n```cpp\n{   cout << \"Hello World\"; // 输出 Hello World   return 0;}\n```\n\nC++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：\n\n```cpp\nx = y;y = y+1;add(x, y);\n```\n\n等同于\n\n```cpp\nx = y; y = y+1; add(x, y);\n```\n\n## C++ 标识符\n\nC++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。\n\nC++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。\n\n下面列出几个有效的标识符：\n\n```cpp\nmohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal\n```\n\n## C++ 关键字\n\n下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。\n\n| asm          | else      | new              | this     |\n| ------------ | --------- | ---------------- | -------- |\n| auto         | enum      | operator         | throw    |\n| bool         | explicit  | private          | true     |\n| break        | export    | protected        | try      |\n| case         | extern    | public           | typedef  |\n| catch        | false     | register         | typeid   |\n| char         | float     | reinterpret_cast | typename |\n| class        | for       | return           | union    |\n| const        | friend    | short            | unsigned |\n| const_cast   | goto      | signed           | using    |\n| continue     | if        | sizeof           | virtual  |\n| default      | inline    | static           | void     |\n| delete       | int       | static_cast      | volatile |\n| do           | long      | struct           | wchar_t  |\n| double       | mutable   | switch           | while    |\n| dynamic_cast | namespace | template         |          |\n\n \n\n## 三字符组\n\n三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。\n\n三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。\n\n三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。\n\n下面列出了最常用的三字符序列：\n\n| 三字符组 | 替换 |\n| :------- | :--- |\n| ??=      | #    |\n| ??/      | \\    |\n| ??'      | ^    |\n| ??(      | [    |\n| ??)      | ]    |\n| ??!      | \\|   |\n| ??<      | {    |\n| ??>      | }    |\n| ??-      | ~    |\n\n如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\"...?\"\"?...\"或者转义序列：\"...?\\?...\"。\n\n从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs\n\ng++仍默认支持三字符组，但会给出编译警告。\n\n## C++ 中的空格\n\n只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。\n\n在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：\n\n```cpp\nint age;\n```\n\n在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：\n\n```cpp\nfruit = apples + oranges;   // 获取水果的总数\n```\n\nfruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。\n\n# C++ 注释\n\n程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。\n\nC++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。\n\nC++ 注释以 /* 开始，以 */ 终止。例如：\n\n```cpp\n/* 这是注释 *//* C++ 注释也可以\n * 跨行\n */\n```\n\n注释也能以 // 开始，直到行末为止。例如：\n\n```cpp\n#include <iostream>using namespace std;main(){\n   cout << \"Hello World\"; // 输出 Hello World\n\n   return 0;}\n```\n\n当上面的代码被编译时，编译器会忽略 **// 输出 Hello World**，最后会产生以下结果：\n\n```cpp\nHello World\n```\n\n在 /* 和 */ 注释内部，// 字符没有特殊的含义。在 // 注释内，/* 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：\n\n```\n \n/* 用于输出 Hello World 的注释\n\ncout << \"Hello World\"; // 输出 Hello World\n\n*/\n```\n\n# C++ 数据类型\n\n使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。\n\n您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。\n\n## 基本的内置类型\n\nC++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：\n\n| 类型     | 关键字  |\n| :------- | :------ |\n| 布尔型   | bool    |\n| 字符型   | char    |\n| 整型     | int     |\n| 浮点型   | float   |\n| 双浮点型 | double  |\n| 无类型   | void    |\n| 宽字符型 | wchar_t |\n\n一些基本类型可以使用一个或多个类型修饰符进行修饰：\n\n- signed\n- unsigned\n- short\n- long\n\n下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。\n\n| 类型               | 位            | 范围                                                    |\n| :----------------- | :------------ | :------------------------------------------------------ |\n| char               | 1 个字节      | -128 到 127 或者 0 到 255                               |\n| unsigned char      | 1 个字节      | 0 到 255                                                |\n| signed char        | 1 个字节      | -128 到 127                                             |\n| int                | 4 个字节      | -2147483648 到 2147483647                               |\n| unsigned int       | 4 个字节      | 0 到 4294967295                                         |\n| signed int         | 4 个字节      | -2147483648 到 2147483647                               |\n| short int          | 2 个字节      | -32768 到 32767                                         |\n| unsigned short int | 2 个字节      | 0 到 65,535                                             |\n| signed short int   | 2 个字节      | -32768 到 32767                                         |\n| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |\n| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |\n| unsigned long int  | 8 个字节      | 0 to 18,446,744,073,709,551,615                         |\n| float              | 4 个字节      | +/- 3.4e +/- 38 (~7 个数字)                             |\n| double             | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |\n| long double        | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |\n| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                              |\n\n从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。\n\n下面实例会输出您电脑上各种数据类型的大小。\n\n```cpp\n#include <iostream>using namespace std;int main(){   \n\tcout << \"Size of char : \" << sizeof(char) << endl;   \n\tcout << \"Size of int : \" << sizeof(int) << endl;  \n\tcout << \"Size of short int : \" << sizeof(short int) << endl;  \n\tcout << \"Size of long int : \" << sizeof(long int) << endl;   \n\tcout << \"Size of float : \" << sizeof(float) << endl;   \n\tcout << \"Size of double : \" << sizeof(double) << endl;  \n\tcout << \"Size of wchar_t : \" << sizeof(wchar_t) << endl;   return 0;\n}\n```\n\n本实例使用了 **endl**，这将在每一行后插入一个换行符，<< 运算符用于向屏幕传多个值。我们也使用 **sizeof()** 函数来获取各种数据类型的大小。\n\n当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：\n\n```cpp\nSize of char : 1Size of int : 4Size of short int : 2Size of long int : 8Size of float : 4Size of double : 8Size of wchar_t : 4\n```\n\n## typedef 声明\n\n您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\n\n```cpp\ntypedef type newname;\n```\n\n例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\n\n```cpp\ntypedef int feet;\n```\n\n现在，下面的声明是完全合法的，它创建了一个整型变量 distance：\n\n```cpp\nfeet distance;\n```\n\n## 枚举类型\n\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n\n```cpp\nenum enum-name { list of names } var-list;\n```\n\n在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。\n\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。\n\n```cpp\nenum color { red, green, blue } c;c = blue;\n```\n\n默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5。\n\n```cpp\nenum color { red, green=5, blue };\n```\n\n在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。\n\n# C++ 变量类型\n\n变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。\n\n变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。\n\n基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：\n\n| 类型    | 描述                                               |\n| :------ | :------------------------------------------------- |\n| bool    | 存储值 true 或 false。                             |\n| char    | 通常是一个八位字节（一个字节）。这是一个整数类型。 |\n| int     | 对机器而言，整数的最自然的大小。                   |\n| float   | 单精度浮点值。                                     |\n| double  | 双精度浮点值。                                     |\n| void    | 表示类型的缺失。                                   |\n| wchar_t | 宽字符类型。                                       |\n\nC++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等，这将会在后续的章节中进行讲解。\n\n下面我们将讲解如何定义、声明和使用各种类型的变量。\n\n## C++ 中的变量定义\n\n变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：\n\n```cpp\ntype variable_list;\n```\n\n在这里，**type** 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：\n\n```cpp\nint    i, j, k;char   c, ch;float  f, salary;double d;\n```\n\n行 **int i, j, k;** 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。\n\n变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：\n\n```cpp\ntype variable_name = value;\n```\n\n下面列举几个实例：\n\n```cpp\nextern int d = 3, f = 5;   \n\t// d 和 f 的声明 int d = 3, f = 5;          \n\t// 定义并初始化 d 和 fbyte z = 22;               \n\t// 定义并初始化 zchar x = 'x';              \n\t// 变量 x 的值为 'x'\n```\n\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\n\n## C++ 中的变量声明\n\n变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n\n当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。\n\n## 实例\n\n尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：\n\n```cpp\n#include <iostream>using namespace std;// 变量声明extern int a, b;extern int c;extern float f;\n  int main (){\n  // 变量定义\n  int a, b;\n  int c;\n  float f;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n \n  cout << c << endl ;\n\n  f = 70.0/3.0;\n  cout << f << endl ;\n \n  return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n3023.3333\n```\n\n同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：\n\n```cpp\n// 函数声明int func();int main(){\n    // 函数调用\n    int i = func();}// 函数定义int func(){\n    return 0;}\n```\n\n## C++ 中的左值（Lvalues）和右值（Rvalues）\n\nC++ 中有两种类型的表达式：\n\n- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\n\n```cpp\nint g = 20;\n```\n\n但是下面这个就不是一个有效的语句，会生成编译时错误：\n\n```cpp\n10 = 20;\n```\n\n# C++ 变量作用域\n\n作用域是程序的一个区域，一般来说有三个地方可以声明变量：\n\n- 在函数或一个代码块内部声明的变量，称为局部变量。\n- 在函数参数的定义中声明的变量，称为形式参数。\n- 在所有函数外部声明的变量，称为全局变量。\n\n我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。\n\n## 局部变量\n\n在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n  // 局部变量声明\n  int a, b;\n  int c;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n \n  cout << c;\n \n  return 0;}\n```\n\n## 全局变量\n\n在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n```cpp\n#include <iostream>using namespace std;\n // 全局变量声明int g;\n int main (){\n  // 局部变量声明\n  int a, b;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  g = a + b;\n \n  cout << g;\n \n  return 0;}\n```\n\n在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：\n\n```cpp\n#include <iostream>using namespace std;\n // 全局变量声明int g = 20;\n int main (){\n  // 局部变量声明\n  int g = 10;\n \n  cout << g;\n \n  return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n10\n```\n\n## 初始化局部变量和全局变量\n\n当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：\n\n| 数据类型 | 初始化默认值 |\n| :------- | :----------- |\n| int      | 0            |\n| char     | '\\0'         |\n| float    | 0            |\n| double   | 0            |\n| pointer  | NULL         |\n\n正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。\n\n# C++ 常量\n\n常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。\n\n常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。\n\n常量就像是常规的变量，只不过常量的值在定义后不能进行修改。\n\n## 整数常量\n\n整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n\n下面列举几个整数常量的实例：\n\n```cpp\n212         // 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀\n```\n\n以下是各种类型的整数常量的实例：\n\n```cpp\n85         // 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数\n```\n\n## 浮点常量\n\n浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n\n下面列举几个浮点常量的实例：\n\n```cpp\n3.14159       // 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数\n```\n\n## 布尔常量\n\n布尔常量共有两个，它们都是标准的 C++ 关键字：\n\n- **true** 值代表真。\n- **false** 值代表假。\n\n我们不应把 true 的值看成 1，把 false 的值看成 0。\n\n## 字符常量\n\n字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。\n\n字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\\t'），或一个通用的字符（例如 '\\u02C0'）。\n\n在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：\n\n| 转义序列   | 含义                       |\n| :--------- | :------------------------- |\n| \\\\         | \\ 字符                     |\n| \\'         | ' 字符                     |\n| \\\"         | \" 字符                     |\n| \\?         | ? 字符                     |\n| \\a         | 警报铃声                   |\n| \\b         | 退格键                     |\n| \\f         | 换页符                     |\n| \\n         | 换行符                     |\n| \\r         | 回车                       |\n| \\t         | 水平制表符                 |\n| \\v         | 垂直制表符                 |\n| \\ooo       | 一到三位的八进制数         |\n| \\xhh . . . | 一个或多个数字的十六进制数 |\n\n下面的实例显示了一些转义序列字符：\n\n```cpp\n#include <iostream>using namespace std;int main(){   cout << \"Hello\\tWorld\\n\\n\";   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nHello   World\n```\n\n## 字符串常量\n\n字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n\n您可以使用空格做分隔符，把一个很长的字符串常量进行分行。\n\n下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。\n\n```cpp\n\"quot;hello, dear\"\"hello, \\dear\"\"hello, \" \"d\" \"ear\"\n```\n\n## 定义常量\n\n在 C++ 中，有两种简单的定义常量的方式：\n\n- 使用 **#define** 预处理器。\n- 使用 **const** 关键字。\n\n## #define 预处理器\n\n下面是使用 #define 预处理器定义常量的形式：\n\n```cpp\n#define identifier value\n```\n\n具体请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;#define LENGTH 10   #define WIDTH  5#define NEWLINE '\\n'int main(){\n\n   int area;  \n   \n   area = LENGTH * WIDTH;\n   cout << area;\n   cout << NEWLINE;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n50\n```\n\n## const 关键字\n\n您可以使用 **const** 前缀声明指定类型的常量，如下所示：\n\n```cpp\nconst type variable = value;\n```\n\n具体请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;int main(){\n   const int  LENGTH = 10;\n   const int  WIDTH  = 5;\n   const char NEWLINE = '\\n';\n   int area;  \n   \n   area = LENGTH * WIDTH;\n   cout << area;\n   cout << NEWLINE;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n50\n```\n\n请注意，把常量定义为大写字母形式，是一个很好的编程实践。\n\n# C++ 修饰符类型\n\nC++ 允许在 **char、int 和 double** 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。\n\n下面列出了数据类型修饰符：\n\n- signed\n- unsigned\n- long\n- short\n\n修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。\n\n修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。\n\nC++ 允许使用速记符号来声明**无符号短整数**或**无符号长整数**。您可以不写 int，只写单词 **unsigned、short** 或 **unsigned、long**，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。\n\n```cpp\nunsigned x;\nunsigned int y;\n```\n\n为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：\n\n```cpp\n#include <iostream>\nusing namespace std;\n \n/* \n * 这个程序演示了有符号整数和无符号整数之间的差别\n*/\nint main()\n{\n   short int i;           // 有符号短整数\n   short unsigned int j;  // 无符号短整数\n\n   j = 50000;\n\n   i = j;\n   cout << i << \" \" << j;\n\n   return 0;\n}\n```\n\n当上面的程序运行时，会输出下列结果：\n\n```cpp\n-15536 50000\n```\n\n上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。\n\n## C++ 中的类型限定符\n\n类型限定符提供了变量的额外信息。\n\n| 限定符   | 含义                                                         |\n| :------- | :----------------------------------------------------------- |\n| const    | **const** 类型的对象在程序执行期间不能被修改改变。           |\n| volatile | 修饰符 **volatile** 告诉编译器，变量的值可能以程序未明确指定的方式被改变。 |\n| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |\n\n# C++ 存储类\n\n存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：\n\n- auto\n- register\n- static\n- extern\n- mutable\n- thread_local (C++11)\n\n从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。\n\n## auto 存储类\n\n自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\n\nC++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。\n\n根据初始化表达式自动推断被声明的变量的类型，如：\n\nauto f=3.14;    //doubleauto s(\"hello\");  //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n\n## register 存储类\n\n**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。\n\n{  register int miles;}\n\n寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。\n\n## static 存储类\n\n**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\n\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n\n在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。\n\n## 实例\n\n```cpp\n#include <iostream>\n // 函数声明 void func(void); \nstatic int count = 10; /* 全局变量 */\n int main(){\n    while(count--)\n    {\n       func();    }\n    return 0;}// 函数定义void func( void ){\n    static int i = 5; // 局部静态变量\n    i++;    std::cout << \"变量 i 为 \" << i ;    std::cout << \" , 变量 count 为 \" << count << std::endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n变量 i 为 6 , 变量 count 为 9变量 i 为 7 , 变量 count 为 8变量 i 为 8 , 变量 count 为 7变量 i 为 9 , 变量 count 为 6变量 i 为 10 , 变量 count 为 5变量 i 为 11 , 变量 count 为 4变量 i 为 12 , 变量 count 为 3变量 i 为 13 , 变量 count 为 2变量 i 为 14 , 变量 count 为 1变量 i 为 15 , 变量 count 为 0\n```\n\n## extern 存储类\n\n**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。\n\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n\n第一个文件：main.cpp\n\n## 实例\n\n```cpp\n#include <iostream>\n int count ;extern void write_extern(); \nint main(){\n   count = 5;   write_extern();}\n```\n\n第二个文件：support.cpp\n\n## 实例\n\n```cpp\n#include <iostream>\n extern int count; \nvoid write_extern(void){\n   std::cout << \"Count is \" << count << std::endl;}\n```\n\n在这里，第二个文件中的 *extern* 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：\n\n```cpp\n$ g++ main.cpp support.cpp -o write\n```\n\n这会产生 **write** 可执行程序，尝试执行 **write**，它会产生下列结果：\n\n```cpp\n$ ./writeCount is 5\n```\n\n## mutable 存储类\n\n**mutable** 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。\n\n## thread_local 存储类\n\n使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\n\nthread_local 说明符可以与 static 或 extern 合并。\n\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n\n以下演示了可以被声明为 thread_local 的变量：\n\n```cpp\nthread_local int x;  // 命名空间下的全局变量class X{\n    static thread_local std::string s; // 类的static成员变量};static thread_local std::string X::s;  // X::s 是需要定义的\n void foo(){\n    thread_local std::vector<int> v;  // 本地变量}\n```\n\n# C++ 运算符\n\n运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：\n\n- 算术运算符\n- 关系运算符\n- 逻辑运算符\n- 位运算符\n- 赋值运算符\n- 杂项运算符\n\n本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。\n\n## 算术运算符\n\n下表显示了 C++ 支持的算术运算符。\n\n假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n| 运算符 | 描述                                                         | 实例             |\n| :----- | :----------------------------------------------------------- | :--------------- |\n| +      | 把两个操作数相加                                             | A + B 将得到 30  |\n| -      | 从第一个操作数中减去第二个操作数                             | A - B 将得到 -10 |\n| *      | 把两个操作数相乘                                             | A * B 将得到 200 |\n| /      | 分子除以分母                                                 | B / A 将得到 2   |\n| %      | 取模运算符，整除后的余数                                     | B % A 将得到 0   |\n| ++     | [自增运算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 | A++ 将得到 11    |\n| --     | [自减运算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 | A-- 将得到 9     |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的算术运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int b = 10;   int c ; \n   c = a + b;   cout << \"Line 1 - c 的值是 \" << c << endl ;   c = a - b;   cout << \"Line 2 - c 的值是 \" << c << endl ;   c = a * b;   cout << \"Line 3 - c 的值是 \" << c << endl ;   c = a / b;   cout << \"Line 4 - c 的值是 \" << c << endl ;   c = a % b;   cout << \"Line 5 - c 的值是 \" << c << endl ; \n   int d = 10;   //  测试自增、自减\n   c = d++;   cout << \"Line 6 - c 的值是 \" << c << endl ; \n   d = 10;    // 重新赋值\n   c = d--;   cout << \"Line 7 - c 的值是 \" << c << endl ;   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - c 的值是 31Line 2 - c 的值是 11Line 3 - c 的值是 210Line 4 - c 的值是 2Line 5 - c 的值是 1Line 6 - c 的值是 10Line 7 - c 的值是 10\n```\n\n## 关系运算符\n\n下表显示了 C++ 支持的关系运算符。\n\n假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |\n| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |\n| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |\n| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |\n| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |\n| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的关系运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int b = 10;   int c ; \n   if( a == b )\n   {\n      cout << \"Line 1 - a 等于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 1 - a 不等于 b\" << endl ;   }\n   if ( a < b )\n   {\n      cout << \"Line 2 - a 小于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 2 - a 不小于 b\" << endl ;   }\n   if ( a > b )\n   {\n      cout << \"Line 3 - a 大于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 3 - a 不大于 b\" << endl ;   }\n   /* 改变 a 和 b 的值 */\n   a = 5;   b = 20;   if ( a <= b )\n   {\n      cout << \"Line 4 - a 小于或等于 b\" << endl ;   }\n   if ( b >= a )\n   {\n      cout << \"Line 5 - b 大于或等于 a\" << endl ;   }\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - a 不等于 bLine 2 - a 不小于 bLine 3 - a 大于 bLine 4 - a 小于或等于 bLine 5 - b 大于或等于 a\n```\n\n## 逻辑运算符\n\n下表显示了 C++ 支持的关系逻辑运算符。\n\n假设变量 A 的值为 1，变量 B 的值为 0，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |\n| \\|\\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \\|\\| B) 为真。 |\n| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的逻辑运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 5;   int b = 20;   int c ; \n   if ( a && b )\n   {\n      cout << \"Line 1 - 条件为真\"<< endl ;   }\n   if ( a || b )\n   {\n      cout << \"Line 2 - 条件为真\"<< endl ;   }\n   /* 改变 a 和 b 的值 */\n   a = 0;   b = 10;   if ( a && b )\n   {\n      cout << \"Line 3 - 条件为真\"<< endl ;   }\n   else\n   {\n      cout << \"Line 4 - 条件不为真\"<< endl ;   }\n   if ( !(a && b) )\n   {\n      cout << \"Line 5 - 条件为真\"<< endl ;   }\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - 条件为真Line 2 - 条件为真Line 4 - 条件不为真Line 5 - 条件为真\n```\n\n## 位运算符\n\n位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：\n\n| p    | q    | p & q | p \\| q | p ^ q |\n| :--- | :--- | :---- | :----- | :---- |\n| 0    | 0    | 0     | 0      | 0     |\n| 0    | 1    | 0     | 1      | 1     |\n| 1    | 1    | 1     | 1      | 0     |\n| 1    | 0    | 0     | 1      | 1     |\n\n假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：\n\nA = 0011 1100\n\nB = 0000 1101\n\n\\-----------------\n\nA&B = 0000 1100\n\nA|B = 0011 1101\n\nA^B = 0011 0001\n\n~A = 1100 0011\n\n下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n\n| 运算符 | 描述                                                         | 实例                                                         |\n| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100                            |\n| \\|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。   | (A \\| B) 将得到 61，即为 0011 1101                           |\n| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001                            |\n| ~      | 二进制补码运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |\n| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。   | A << 2 将得到 240，即为 1111 0000                            |\n| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。   | A >> 2 将得到 15，即为 0000 1111                             |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的位运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   unsigned int a = 60;      // 60 = 0011 1100  \n   unsigned int b = 13;      // 13 = 0000 1101\n   int c = 0;           \n \n   c = a & b;             // 12 = 0000 1100\n   cout << \"Line 1 - c 的值是 \" << c << endl ; \n   c = a | b;             // 61 = 0011 1101\n   cout << \"Line 2 - c 的值是 \" << c << endl ; \n   c = a ^ b;             // 49 = 0011 0001\n   cout << \"Line 3 - c 的值是 \" << c << endl ; \n   c = ~a;                // -61 = 1100 0011\n   cout << \"Line 4 - c 的值是 \" << c << endl ; \n   c = a << 2;            // 240 = 1111 0000\n   cout << \"Line 5 - c 的值是 \" << c << endl ; \n   c = a >> 2;            // 15 = 0000 1111\n   cout << \"Line 6 - c 的值是 \" << c << endl ; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```\n \nLine 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15\n```\n\n## 赋值运算符\n\n下表列出了 C++ 支持的赋值运算符：\n\n| 运算符 | 描述                                                         | 实例                            |\n| :----- | :----------------------------------------------------------- | :------------------------------ |\n| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |\n| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |\n| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |\n| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |\n| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |\n| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |\n| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |\n| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |\n| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |\n| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |\n| \\|=    | 按位或且赋值运算符                                           | C \\|= 2 等同于 C = C \\| 2       |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的赋值运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int c ; \n   c =  a;   cout << \"Line 1 - =  运算符实例，c 的值 = : \" <<c<< endl ; \n   c +=  a;   cout << \"Line 2 - += 运算符实例，c 的值 = : \" <<c<< endl ; \n   c -=  a;   cout << \"Line 3 - -= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c *=  a;   cout << \"Line 4 - *= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c /=  a;   cout << \"Line 5 - /= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c  = 200;   c %=  a;   cout << \"Line 6 - %= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c <<=  2;   cout << \"Line 7 - <<= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c >>=  2;   cout << \"Line 8 - >>= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c &=  2;   cout << \"Line 9 - &= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c ^=  2;   cout << \"Line 10 - ^= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c |=  2;   cout << \"Line 11 - |= 运算符实例，c 的值 = : \" <<c<< endl ; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - =  运算符实例，c 的值 = 21Line 2 - += 运算符实例，c 的值 = 42Line 3 - -= 运算符实例，c 的值 = 21Line 4 - *= 运算符实例，c 的值 = 441Line 5 - /= 运算符实例，c 的值 = 21Line 6 - %= 运算符实例，c 的值 = 11Line 7 - <<= 运算符实例，c 的值 = 44Line 8 - >>= 运算符实例，c 的值 = 11Line 9 - &= 运算符实例，c 的值 = 2Line 10 - ^= 运算符实例，c 的值 = 0Line 11 - |= 运算符实例，c 的值 = 2\n```\n\n## 杂项运算符\n\n下表列出了 C++ 支持的其他一些重要的运算符。\n\n| 运算符               | 描述                                                         |\n| :------------------- | :----------------------------------------------------------- |\n| sizeof               | [sizeof 运算符](https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |\n| Condition ? X : Y    | [条件运算符](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |\n| ,                    | [逗号运算符](https://edu.aliyun.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |\n| .（点）和 ->（箭头） | [成员运算符](https://edu.aliyun.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |\n| Cast                 | [强制转换运算符](https://edu.aliyun.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |\n| &                    | [指针运算符 &](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |\n| *                    | [指针运算符 *](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |\n\n## C++ 中的运算符优先级\n\n运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。\n\n例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。\n\n下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n\n| 类别       | 运算符                            | 结合性   |\n| :--------- | :-------------------------------- | :------- |\n| 后缀       | () [] -> . ++ - -                 | 从左到右 |\n| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |\n| 乘除       | * / %                             | 从左到右 |\n| 加减       | + -                               | 从左到右 |\n| 移位       | << >>                             | 从左到右 |\n| 关系       | < <= > >=                         | 从左到右 |\n| 相等       | == !=                             | 从左到右 |\n| 位与 AND   | &                                 | 从左到右 |\n| 位异或 XOR | ^                                 | 从左到右 |\n| 位或 OR    | \\|                                | 从左到右 |\n| 逻辑与 AND | &&                                | 从左到右 |\n| 逻辑或 OR  | \\|\\|                              | 从左到右 |\n| 条件       | ?:                                | 从右到左 |\n| 赋值       | = += -= *= /= %=>>= <<= &= ^= \\|= | 从右到左 |\n| 逗号       | ,                                 | 从左到右 |\n\n### 实例\n\n请看下面的实例，了解 C++ 中运算符的优先级。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 20;   int b = 10;   int c = 15;   int d = 5;   int e; \n   e = (a + b) * c / d;      // ( 30 * 15 ) / 5\n   cout << \"(a + b) * c / d 的值是 \" << e << endl ; \n   e = ((a + b) * c) / d;    // (30 * 15 ) / 5\n   cout << \"((a + b) * c) / d 的值是 \" << e << endl ; \n   e = (a + b) * (c / d);   // (30) * (15/5)\n   cout << \"(a + b) * (c / d) 的值是 \" << e << endl ; \n   e = a + (b * c) / d;     //  20 + (150/5)\n   cout << \"a + (b * c) / d 的值是 \" << e << endl ;  \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\n(a + b) * c / d 的值是 90((a + b) * c) / d 的值是 90(a + b) * (c / d) 的值是 90a + (b * c) / d 的值是 50\n```\n\n# C++ 循环\n\n有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。\n\n编程语言提供了允许更为复杂的执行路径的多种控制结构。\n\n循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png)\n\n## 循环类型\n\nC++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。\n\n| 循环类型        | 描述                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| while 循环      | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |\n| for 循环        | 多次执行一个语句序列，简化管理循环变量的代码。               |\n| do...while 循环 | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |\n| 嵌套循环        | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |\n\n \n\n## 循环控制语句\n\n循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。\n\nC++ 提供了下列的控制语句。点击链接查看每个语句的细节。\n\n| 控制语句      | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| break 语句    | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |\n| continue 语句 | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |\n| goto 语句     | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 |\n\n \n\n## 无限循环\n\n如果条件永远不为假，则循环将变成无限循环。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n\n   for( ; ; )\n   {\n      printf(\"This loop will run forever.\\n\");\n   }\n\n   return 0;}\n```\n\n当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。\n\n**注意：**您可以按 Ctrl + C 键终止一个无限循环。\n\n# C++ 判断\n\n判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。\n\n下面是大多数编程语言中典型的判断结构的一般形式：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png)\n\n## 判断语句\n\nC++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。\n\n| 语句             | 描述                                                         |\n| :--------------- | :----------------------------------------------------------- |\n| if 语句          | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |\n| if...else 语句   | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |\n| 嵌套 if 语句     | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |\n| switch 语句      | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |\n| 嵌套 switch 语句 | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |\n\n \n\n## ? : 运算符\n\n我们已经在前面的章节中讲解了 [**条件运算符 ? :**](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)，可以用来替代 **if...else** 语句。它的一般形式如下：\n\n```cpp\nExp1 ? Exp2 : Exp3;\n```\n\n其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。\n\n? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。\n\n# C++ 函数\n\n函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。\n\n您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。\n\n函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。\n\nC++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。\n\n函数还有很多叫法，比如方法、子例程或程序，等等。\n\n## 定义函数\n\nC++ 中的函数定义的一般形式如下：\n\n```cpp\nreturn_type function_name( parameter list ){   body of the function}\n```\n\n在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：\n\n- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。\n- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数主体：**函数主体包含一组定义函数执行任务的语句。\n\n## 实例\n\n以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：\n\n```cpp\n// 函数返回两个数中较大的那个数 int max(int num1, int num2) {   // 局部变量声明   int result;    if (num1 > num2)      result = num1;   else      result = num2;    return result; }\n```\n\n## 函数声明\n\n函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n\n函数声明包括以下几个部分：\n\n```cpp\nreturn_type function_name( parameter list );\n```\n\n针对上面定义的函数 max()，以下是函数声明：\n\n```cpp\nint max(int num1, int num2);\n```\n\n在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：\n\n```cpp\nint max(int, int);\n```\n\n当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。\n\n## 调用函数\n\n创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。\n\n当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。\n\n调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：\n\n```cpp\n#include <iostream>using namespace std;\n // 函数声明int max(int num1, int num2);\n int main (){\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int ret;\n \n   // 调用函数来获取最大值\n   ret = max(a, b);\n \n   cout << \"Max value is : \" << ret << endl;\n \n   return 0;}\n // 函数返回两个数中较大的那个数int max(int num1, int num2) {\n   // 局部变量声明\n   int result;\n \n   if (num1 > num2)\n      result = num1;\n   else\n      result = num2;\n \n   return result; }\n```\n\n把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：\n\n```cpp\nMax value is : 200\n```\n\n## 函数参数\n\n如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。\n\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n当调用函数时，有两种向函数传递参数的方式：\n\n| 调用类型                                                     | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [传值调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |\n| [指针调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n| [引用调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n\n默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。\n\n## 参数的默认值\n\n当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。\n\n这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;\n int sum(int a, int b=20){\n  int result;\n\n  result = a + b;\n  \n  return (result);}int main (){\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int result;\n \n   // 调用函数来添加值\n   result = sum(a, b);\n   cout << \"Total value is :\" << result << endl;\n\n   // 再次调用函数\n   result = sum(a);\n   cout << \"Total value is :\" << result << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal value is :300Total value is :120\n```\n\n------\n\n## Lambda 函数与表达式\n\nC++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。\n\nLambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\n\nLambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:\n\n```cpp\n[capture](parameters)->return-type{body}\n```\n\n例如：\n\n```\n \n[](int x, int y){ return x < y ; }\n```\n\n如果没有参数可以表示为：\n\n```cpp\n[capture](parameters){body}\n```\n\n例如：\n\n```cpp\n[]{ ++global_x; }\n```\n\n在一个更为复杂的例子中，返回类型可以被明确的指定如下：\n\n```cpp\n[](int x, int y) -> int { int z = x + y; return z + x; }\n```\n\n本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。\n\n如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。\n\n在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：\n\n```cpp\n[]      // 沒有定义任何变量。使用未定义变量会引发错误。[x, &y] // x以传值方式传入（默认），y以引用方式传入。[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n```\n\n另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：\n\n```cpp\n[this]() { this->someFunc(); }();\n```\n\n# C++ 数字\n\n通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。\n\n## C++ 定义数字\n\n我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n   // 数字定义\n   short  s;\n   int    i;\n   long   l;\n   float  f;\n   double d;\n   \n   // 数字赋值\n   s = 10;      \n   i = 1000;    \n   l = 1000000; \n   f = 230.47;  \n   d = 30949.374;\n   \n   // 数字输出\n   cout << \"short  s :\" << s << endl;\n   cout << \"int    i :\" << i << endl;\n   cout << \"long   l :\" << l << endl;\n   cout << \"float  f :\" << f << endl;\n   cout << \"double d :\" << d << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nshort  s :10int    i :1000long   l :1000000float  f :230.47double d :30949.4\n```\n\n## C++ 数学运算\n\n在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做**内置**函数。您可以在程序中引用这些函数。\n\nC++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。\n\n为了利用这些函数，您需要引用数学头文件 **<cmath>**。\n\n| 序号 | 函数 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **double cos(double);** 该函数返回弧度角（double 型）的余弦。 |\n| 2    | **double sin(double);** 该函数返回弧度角（double 型）的正弦。 |\n| 3    | **double tan(double);** 该函数返回弧度角（double 型）的正切。 |\n| 4    | **double log(double);** 该函数返回参数的自然对数。           |\n| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |\n| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |\n| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |\n| 8    | **int abs(int);** 该函数返回整数的绝对值。                   |\n| 9    | **double fabs(double);** 该函数返回任意一个十进制数的绝对值。 |\n| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。 |\n\n下面是一个关于数学运算的简单实例：\n\n```cpp\n#include <iostream>#include <cmath>using namespace std;\n int main (){\n   // 数字定义\n   short  s = 10;\n   int    i = -1000;\n   long   l = 100000;\n   float  f = 230.47;\n   double d = 200.374;\n\n   // 数学运算\n   cout << \"sin(d) :\" << sin(d) << endl;\n   cout << \"abs(i)  :\" << abs(i) << endl;\n   cout << \"floor(d) :\" << floor(d) << endl;\n   cout << \"sqrt(f) :\" << sqrt(f) << endl;\n   cout << \"pow( d, 2) :\" << pow(d, 2) << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nsign(d) :-0.634939abs(i)  :1000floor(d) :200sqrt(f) :15.1812pow( d, 2 ) :40149.7\n```\n\n## C++ 随机数\n\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。\n\n下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：\n\n```cpp\n#include <iostream>#include <ctime>#include <cstdlib>using namespace std;\n int main (){\n   int i,j;\n \n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n随机数： 1748144778随机数： 630873888随机数： 2134540646随机数： 219404170随机数： 902129458随机数： 920445370随机数： 1319072661随机数： 257938873随机数： 1256201101随机数： 580322989\n```\n\n# C++ 数组\n\nC++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。\n\n数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。\n\n所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。\n\n## 声明数组\n\n在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：\n\n```cpp\ntype arrayName [ arraySize ];\n```\n\n这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：\n\n```cpp\ndouble balance[10];\n```\n\n现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。\n\n## 初始化数组\n\n在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：\n\n```cpp\ndouble balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};\n```\n\n大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。\n\n如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：\n\n```cpp\ndouble balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};\n```\n\n您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：\n\n```cpp\nbalance[4] = 50.0;\n```\n\n上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：\n\n![数组表示](https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg)\n\n## 访问数组元素\n\n数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：\n\n```cpp\ndouble salary = balance[9];\n```\n\n上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：\n\n```cpp\n#include <iostream>using namespace std;\n #include <iomanip>using std::setw;\n int main (){\n   int n[ 10 ]; // n 是一个包含 10 个整数的数组\n \n   // 初始化数组元素          \n   for ( int i = 0; i < 10; i++ )\n   {\n      n[ i ] = i + 100; // 设置元素 i 为 i + 100\n   }\n   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n \n   // 输出数组中每个元素的值                     \n   for ( int j = 0; j < 10; j++ )\n   {\n      cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;\n   }\n \n   return 0;}\n```\n\n上面的程序使用了 **setw()** 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nElement        Value\n      0          100\n      1          101\n      2          102\n      3          103\n      4          104\n      5          105\n      6          106\n      7          107\n      8          108\n      9          109\n```\n\n## C++ 中数组详解\n\n在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：\n\n| 概念           | 描述                                                         |\n| :------------- | :----------------------------------------------------------- |\n| 多维数组       | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |\n| 指向数组的指针 | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |\n| 传递数组给函数 | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |\n| 从函数返回数组 | C++ 允许从函数返回数组。                                     |\n\n# C++ 字符串\n\nC++ 提供了以下两种类型的字符串表示形式：\n\n- C 风格字符串\n- C++ 引入的 string 类类型\n\n## C 风格字符串\n\nC 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 **null** 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n\n下面的声明和初始化创建了一个 \"Hello\" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 \"Hello\" 的字符数多一个。\n\n```cpp\nchar greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n```\n\n依据数组初始化规则，您可以把上面的语句写成以下语句：\n\n```cpp\nchar greeting[] = \"Hello\";\n```\n\n以下是 C/C++ 中定义的字符串的内存表示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg)\n\n其实，您不需要把 *null* 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\\0' 放在字符串的末尾。让我们尝试输出上面的字符串：\n\n## 实例\n\n```cpp\n#include <iostream>\n using namespace std; \nint main (){\n   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; \n   cout << \"Greeting message: \";   cout << greeting << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nGreeting message: Hello\n```\n\nC++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:\n\n| 序号 | 函数 & 目的                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |\n| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |\n| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |\n| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |\n| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n下面的实例使用了上述的一些函数：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std; \nint main (){\n   char str1[11] = \"Hello\";   char str2[11] = \"World\";   char str3[11];   int  len ; \n   // 复制 str1 到 str3\n   strcpy( str3, str1);   cout << \"strcpy( str3, str1) : \" << str3 << endl; \n   // 连接 str1 和 str2\n   strcat( str1, str2);   cout << \"strcat( str1, str2): \" << str1 << endl; \n   // 连接后，str1 的总长度\n   len = strlen(str1);   cout << \"strlen(str1) : \" << len << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstrcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10\n```\n\n## C++ 中的 String 类\n\nC++ 标准库提供了 **string** 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：\n\n现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。\n\n## 实例\n\n```cpp\n#include <iostream>#include <string>\n using namespace std; \nint main (){\n   string str1 = \"Hello\";   string str2 = \"World\";   string str3;   int  len ; \n   // 复制 str1 到 str3\n   str3 = str1;   cout << \"str3 : \" << str3 << endl; \n   // 连接 str1 和 str2\n   str3 = str1 + str2;   cout << \"str1 + str2 : \" << str3 << endl; \n   // 连接后，str3 的总长度\n   len = str3.size();   cout << \"str3.size() :  \" << len << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstr3 : Hellostr1 + str2 : HelloWorldstr3.size() :  10\n```\n\n# C++ 指针\n\n学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。\n\n正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   int  var1;\n   char var2[10];\n\n   cout << \"var1 变量的地址： \";\n   cout << &var1 << endl;\n\n   cout << \"var2 变量的地址： \";\n   cout << &var2 << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nvar1 变量的地址： 0xbfebd5c0var2 变量的地址： 0xbfebd5b6\n```\n\n通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。\n\n## 什么是指针？\n\n**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：\n\n```cpp\ntype *var-name;\n```\n\n在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：\n\n```cpp\nint    *ip;    /* 一个整型的指针 */double *dp;    /* 一个 double 型的指针 */float  *fp;    /* 一个浮点型的指针 */char   *ch;    /* 一个字符型的指针 */\n```\n\n所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n\n## C++ 中使用指针\n\n使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   int  var = 20;   // 实际变量的声明\n   int  *ip;        // 指针变量的声明\n\n   ip = &var;       // 在指针变量中存储 var 的地址\n\n   cout << \"Value of var variable: \";\n   cout << var << endl;\n\n   // 输出在指针变量中存储的地址\n   cout << \"Address stored in ip variable: \";\n   cout << ip << endl;\n\n   // 访问指针中地址的值\n   cout << \"Value of *ip variable: \";\n   cout << *ip << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of var variable: 20Address stored in ip variable: 0xbfc601acValue of *ip variable: 20\n```\n\n## C++ 指针详解\n\n在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：\n\n| 概念               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| C++ Null 指针      | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |\n| C++ 指针的算术运算 | 可以对指针进行四种算术运算：++、--、+、-                     |\n| C++ 指针 vs 数组   | 指针和数组之间有着密切的关系。                               |\n| C++ 指针数组       | 可以定义用来存储指针的数组。                                 |\n| C++ 指向指针的指针 | C++ 允许指向指针的指针。                                     |\n| C++ 传递指针给函数 | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |\n| C++ 从函数返回指针 | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |\n\n# C++ 引用\n\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n\n## C++ 引用 vs 指针\n\n引用很容易与指针混淆，它们之间有三个主要的不同：\n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n## C++ 中创建引用\n\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：\n\n```cpp\nint i = 17;\n```\n\n我们可以为 i 声明引用变量，如下所示：\n\n```cpp\nint&    r = i;\n```\n\n在这些声明中，& 读作**引用**。因此，第一个声明可以读作 \"r 是一个初始化为 i 的整型引用\"，第二个声明可以读作 \"s 是一个初始化为 d 的 double 型引用\"。下面的实例使用了 int 和 double 引用：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main (){\n   // 声明简单的变量\n   int    i;\n   double d;\n \n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n   \n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n \n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7\n```\n\n引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：\n\n| 概念             | 描述                                                     |\n| :--------------- | :------------------------------------------------------- |\n| 把引用作为参数   | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 |\n| 把引用作为返回值 | 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。    |\n\n# C++ 日期 & 时间\n\nC++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。\n\n有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。\n\n结构类型 **tm** 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：\n\n```cpp\nstruct tm {\n  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61\n  int tm_min;   // 分，范围从 0 到 59\n  int tm_hour;  // 小时，范围从 0 到 23\n  int tm_mday;  // 一月中的第几天，范围从 1 到 31\n  int tm_mon;   // 月，范围从 0 到 11\n  int tm_year;  // 自 1900 年起的年数\n  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起\n  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起\n  int tm_isdst; // 夏令时}\n```\n\n下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。\n\n| 序号 | 函数 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **time_t time(time_t \\*time);** 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 |\n| 2    | **char \\*ctime(const time_t \\*time);** 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\\n\\0*。 |\n| 3    | **struct tm \\*localtime(const time_t \\*time);** 该函数返回一个指向表示本地时间的 **tm** 结构的指针。 |\n| 4    | **clock_t clock(void);** 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 |\n| 5    | **char \\* asctime ( const struct tm \\* time );** 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 |\n| 6    | **struct tm \\*gmtime(const time_t \\*time);** 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |\n| 7    | **time_t mktime(struct tm \\*time);** 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 |\n| 8    | **double difftime ( time_t time2, time_t time1 );** 该函数返回 time1 和 time2 之间相差的秒数。 |\n| 9    | **size_t strftime();** 该函数可用于格式化日期和时间为指定的格式。 |\n\n## 当前日期和时间\n\n下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。\n\n```cpp\n#include <iostream>#include <ctime>using namespace std;int main( ){\n   // 基于当前系统的当前日期/时间\n   time_t now = time(0);\n   \n   // 把 now 转换为字符串形式\n   char* dt = ctime(&now);\n\n   cout << \"本地日期和时间：\" << dt << endl;\n\n   // 把 now 转换为 tm 结构\n   tm *gmtm = gmtime(&now);\n   dt = asctime(gmtm);\n   cout << \"UTC 日期和时间：\"<< dt << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n本地日期和时间：Sat Jan  8 20:07:41 2011UTC 日期和时间：Sun Jan  9 03:07:41 2011\n```\n\n## 使用结构 tm 格式化时间\n\n**tm** 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。\n\n在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -> 运算符来访问结构成员。\n\n```cpp\n#include <iostream>#include <ctime>using namespace std;int main( ){\n   // 基于当前系统的当前日期/时间\n   time_t now = time(0);\n\n   cout << \"Number of sec since January 1,1970:\" << now << endl;\n\n   tm *ltm = localtime(&now);\n\n   // 输出 tm 结构的各个组成部分\n   cout << \"Year: \"<< 1900 + ltm->tm_year << endl;\n   cout << \"Month: \"<< 1 + ltm->tm_mon<< endl;\n   cout << \"Day: \"<<  ltm->tm_mday << endl;\n   cout << \"Time: \"<< 1 + ltm->tm_hour << \":\";\n   cout << 1 + ltm->tm_min << \":\";\n   cout << 1 + ltm->tm_sec << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nNumber of sec since January 1, 1970:1294548238Year: 2011Month: 1Day: 8Time: 22: 44:59\n```\n\n# C++ 基本的输入输出\n\nC++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。\n\nC++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作**。\n\n## I/O 库头文件\n\n下列的头文件在 C++ 编程中很重要。\n\n| 头文件     | 函数和描述                                                   |\n| :--------- | :----------------------------------------------------------- |\n| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |\n| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |\n| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |\n\n## 标准输出流（cout）\n\n预定义的对象 **cout** 是 **ostream** 类的一个实例。cout 对象\"连接\"到标准输出设备，通常是显示屏。**cout** 是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream> using namespace std; int main( ){   char str[] = \"Hello C++\";    cout << \"Value of str is : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of str is : Hello C++\n```\n\nC++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<< 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。\n\n流插入运算符 << 在一个语句中可以多次使用，如上面实例中所示，**endl** 用于在行末添加一个换行符。\n\n## 标准输入流（cin）\n\n预定义的对象 **cin** 是 **istream** 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。**cin** 是与流提取运算符 >> 结合使用的，如下所示：\n\n```cpp\n#include <iostream> using namespace std; int main( ){  \n\tchar name[50];    cout << \"请输入您的名称： \";   \n\tcin >> name;   cout << \"您的名称是： \" << name << endl; }\n```\n\n当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：\n\n```cpp\n请输入您的名称： cplusplus您的名称是： cplusplus\n```\n\nC++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。\n\n流提取运算符 >> 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：\n\n```cpp\ncin >> name >> age;\n```\n\n这相当于下面两个语句：\n\n```cpp\ncin >> name;cin >> age;\n```\n\n## 标准错误流（cerr）\n\n预定义的对象 **cerr** 是 **ostream** 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。\n\n**cerr** 也是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main( ){\n   char str[] = \"Unable to read....\";\n \n   cerr << \"Error message : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nError message : Unable to read....\n```\n\n## 标准日志流（clog）\n\n预定义的对象 **clog** 是 **ostream** 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。\n\n**clog** 也是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main( ){\n   char str[] = \"Unable to read....\";\n \n   clog << \"Error message : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nError message : Unable to read....\n```\n\n通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。\n\n# C++ 数据结构\n\nC/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。\n\n结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：\n\n- Title ：标题\n- Author ：作者\n- Subject ：类目\n- Book ID ：书的 ID\n\n## 定义结构\n\n为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：\n\n \n\n```cpp\nstruct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..} object_names;\n```\n\n**type_name** 是结构体类型的名称，**member_type1 member_name1** 是标准的变量定义，比如 **int i;** 或者 **float f;** 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 **Books**，变量为 **book**：\n\n```cpp\nstruct Books{   char  title[50];   char  author[50];   char  subject[100];      int   book_id;} book;\n```\n\n## 访问结构成员\n\n为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。\n\n下面的实例演示了结构的用法：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std; \n// 声明一个结构体类型 Books struct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n   // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 输出 Book1 信息\n   cout << \"第一本书标题 : \" << Book1.title <<endl;   cout << \"第一本书作者 : \" << Book1.author <<endl;   cout << \"第一本书类目 : \" << Book1.subject <<endl;   cout << \"第一本书 ID : \" << Book1.book_id <<endl; \n   // 输出 Book2 信息\n   cout << \"第二本书标题 : \" << Book2.title <<endl;   cout << \"第二本书作者 : \" << Book2.author <<endl;   cout << \"第二本书类目 : \" << Book2.subject <<endl;   cout << \"第二本书 ID : \" << Book2.book_id <<endl; \n   return 0;}\n```\n\n实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : 12345第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : 12346\n```\n\n## 结构作为函数参数\n\n您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std;void printBook( struct Books book ); \n// 声明一个结构体类型 Books struct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n    // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   \n   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 输出 Book1 信息\n   printBook( Book1 ); \n   // 输出 Book2 信息\n   printBook( Book2 ); \n   return 0;}void printBook( struct Books book ){\n   cout << \"书标题 : \" << book.title <<endl;   cout << \"书作者 : \" \n   << book.author <<endl;   cout << \"书类目 : \" << book.subject <<endl;   \n   cout << \"书 ID : \" << book.book_id <<endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : 12346\n```\n\n## 指向结构的指针\n\n您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：\n\n```cpp\nstruct Books *struct_pointer;\n```\n\n现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：\n\n```cpp\nstruct_pointer = &Book1;\n```\n\n为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：\n\n```cpp\nstruct_pointer->title;\n```\n\n让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std;void printBook( struct Books *book ); \nstruct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n    // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   \n   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 通过传 Book1 的地址来输出 Book1 信息\n   printBook( &Book1 ); \n   // 通过传 Book2 的地址来输出 Book2 信息\n   printBook( &Book2 ); \n   return 0;}// 该函数以结构指针作为参数void printBook( struct Books *book ){\n   cout << \"书标题  : \" << book->title <<endl;   cout << \"书作者 : \" \n   << book->author <<endl;   cout << \"书类目 : \" << book->subject <<endl;   \n   cout << \"书 ID : \" << book->book_id <<endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : 12346\n```\n\n## typedef 关键字\n\n下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如：\n\n```cpp\ntypedef struct{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;}Books;\n```\n\n现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。下面是实例：\n\n```cpp\nBooks Book1, Book2;\n```\n\n您可以使用 **typedef** 关键字来定义非结构类型，如下所示：\n\n```cpp\ntypedef long int *pint32;\n pint32 x, y, z;\n```\n\nx, y 和 z 都是指向长整型 long int 的指针。\n\n# C++ 类 & 对象\n\nC++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。\n\n类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。\n\n## C++ 类定义\n\n定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。\n\n类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 **class** 定义 Box 数据类型，如下所示：\n\n```cpp\nclass Box{   public:      double length;   // Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box};\n```\n\n关键字 **public** 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 **private** 或 **protected**，这个我们稍后会进行讲解。\n\n## 定义 C++ 对象\n\n类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：\n\n```cpp\nBox Box1;          // 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box\n```\n\n对象 Box1 和 Box2 都有它们各自的数据成员。\n\n## 访问数据成员\n\n类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度};int main( ){\n   Box Box1;        // 声明 Box1，类型为 Box\n   Box Box2;        // 声明 Box2，类型为 Box\n   double volume = 0.0;     // 用于存储体积\n \n   // box 1 详述\n   Box1.height = 5.0; \n   Box1.length = 6.0; \n   Box1.breadth = 7.0;\n\n   // box 2 详述\n   Box2.height = 10.0;\n   Box2.length = 12.0;\n   Box2.breadth = 13.0;\n\n   // box 1 的体积\n   volume = Box1.height * Box1.length * Box1.breadth;\n   cout << \"Box1 的体积：\" << volume <<endl;\n\n   // box 2 的体积\n   volume = Box2.height * Box2.length * Box2.breadth;\n   cout << \"Box2 的体积：\" << volume <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nBox1 的体积：210Box2 的体积：1560\n```\n\n需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。\n\n# 类 & 对象详解\n\n到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。\n\n| 概念                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 类成员函数          | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |\n| 类访问修饰符        | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |\n| 构造函数 & 析构函数 | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |\n| C++ 拷贝构造函数    | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |\n| C++ 友元函数        | **友元函数**可以访问类的 private 和 protected 成员。         |\n| C++ 内联函数        | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |\n| C++ 中的 this 指针  | 每个对象都有一个特殊的指针 **this**，它指向对象本身。        |\n| C++ 中指向类的指针  | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |\n| C++ 类的静态成员    | 类的数据成员和函数成员都可以被声明为静态的。                 |\n\n# C++ 继承\n\n面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。\n\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。\n\n继承代表了 **is a** 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。\n\n## 基类 & 派生类\n\n一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：\n\n```cpp\nclass derived-class: access-specifier base-class\n```\n\n其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n\n假设有一个基类 **Shape**，**Rectangle** 是它的派生类，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;// 基类class Shape {\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;};// 派生类class Rectangle: public Shape{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }};int main(void){\n   Rectangle Rect;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n Total area: 35\n```\n\n## 访问控制和继承\n\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n| 访问     | public | protected | private |\n| :------- | :----- | :-------- | :------ |\n| 同一个类 | yes    | yes       | yes     |\n| 派生类   | yes    | yes       | no      |\n| 外部的类 | yes    | no        | no      |\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n## 继承类型\n\n当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。\n\n我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。\n- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。\n- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。\n\n## 多继承\n\n多继承即一个子类可以有多个父类，它继承了多个父类的特性。\n\nC++ 类可以从多个类继承成员，语法如下：\n\n```cpp\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…{<派生类类体>};\n```\n\n其中，访问修饰符继承方式是 **public、protected** 或 **private** 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：\n\n```cpp\n#include <iostream>\n using namespace std;// 基类 Shapeclass Shape {\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;};// 基类 PaintCostclass PaintCost {\n   public:\n      int getCost(int area)\n      {\n         return area * 70;\n      }};// 派生类class Rectangle: public Shape, public PaintCost{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }};int main(void){\n   Rectangle Rect;\n   int area;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   area = Rect.getArea();\n   \n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   // 输出总花费\n   cout << \"Total paint cost: $\" << Rect.getCost(area) << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal area: 35Total paint cost: $2450\n```\n\n# C++ 重载运算符和重载函数\n\nC++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。\n\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n\n当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。\n\n## C++ 中的函数重载\n\n在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。\n\n下面的实例中，同名函数 **print()** 被用于输出不同的数据类型：\n\n```cpp\n#include <iostream>using namespace std;\n class printData \n{\n   public:\n      void print(int i) {\n        cout << \"Printing int: \" << i << endl;\n      }\n\n      void print(double  f) {\n        cout << \"Printing float: \" << f << endl;\n      }\n\n      void print(char* c) {\n        cout << \"Printing character: \" << c << endl;\n      }};int main(void){\n   printData pd;\n \n   // Call print to print integer\n   pd.print(5);\n   // Call print to print float\n   pd.print(500.263);\n   // Call print to print character\n   pd.print(\"Hello C++\");\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nPrinting int: 5Printing float: 500.263Printing character: Hello C++\n```\n\n## C++ 中的运算符重载\n\n您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。\n\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n\n```cpp\nBox operator+(const Box&);\n```\n\n声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：\n\n```cpp\nBox operator+(const Box&, const Box&);\n```\n\n下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 **this** 运算符进行访问，如下所示：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n      void setLength( double len )\n      {\n          length = len;\n      }\n\n      void setBreadth( double bre )\n      {\n          breadth = bre;\n      }\n\n      void setHeight( double hei )\n      {\n          height = hei;\n      }\n      // 重载 + 运算符，用于把两个 Box 对象相加\n      Box operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度};// 程序的主函数int main( ){\n   Box Box1;                // 声明 Box1，类型为 Box\n   Box Box2;                // 声明 Box2，类型为 Box\n   Box Box3;                // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 把体积存储在该变量中\n \n   // Box1 详述\n   Box1.setLength(6.0); \n   Box1.setBreadth(7.0); \n   Box1.setHeight(5.0);\n \n   // Box2 详述\n   Box2.setLength(12.0); \n   Box2.setBreadth(13.0); \n   Box2.setHeight(10.0);\n \n   // Box1 的体积\n   volume = Box1.getVolume();\n   cout << \"Volume of Box1 : \" << volume <<endl;\n \n   // Box2 的体积\n   volume = Box2.getVolume();\n   cout << \"Volume of Box2 : \" << volume <<endl;\n\n   // 把两个对象相加，得到 Box3\n   Box3 = Box1 + Box2;\n\n   // Box3 的体积\n   volume = Box3.getVolume();\n   cout << \"Volume of Box3 : \" << volume <<endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nVolume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400\n```\n\n## 可重载运算符/不可重载运算符\n\n下面是可重载的运算符列表：\n\n| +    | -    | *    | /      | %      | ^         |\n| ---- | ---- | ---- | ------ | ------ | --------- |\n| &    | \\|   | ~    | !      | ,      | =         |\n| <    | >    | <=   | >=     | ++     | --        |\n| <<   | >>   | ==   | !=     | &&     | \\|\\|      |\n| +=   | -=   | /=   | %=     | ^=     | &=        |\n| \\|=  | *=   | <<=  | >>=    | []     | ()        |\n| ->   | ->*  | new  | new [] | delete | delete [] |\n\n下面是不可重载的运算符列表：\n\n| ::   | .*   | .    | ?:   |\n| ---- | ---- | ---- | ---- |\n|      |      |      |      |\n\n## 运算符重载实例\n\n下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。\n\n| 序号 | 运算符和实例             |\n| :--- | :----------------------- |\n| 1    | 一元运算符重载           |\n| 2    | 二元运算符重载           |\n| 3    | 关系运算符重载           |\n| 4    | 输入/输出运算符重载      |\n| 5    | ++ 和 -- 运算符重载      |\n| 6    | 赋值运算符重载           |\n| 7    | 函数调用运算符 () 重载   |\n| 8    | 下标运算符 [] 重载       |\n| 9    | 类成员访问运算符 -> 重载 |\n\n# C++ 多态\n\n**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。\n\nC++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。\n\n下面的实例中，基类 Shape 被派生为两个类，如下所示：\n\n```cpp\n#include <iostream> using namespace std;\n class Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      int area()\n      {\n         cout << \"Parent class area :\" <<endl;\n         return 0;\n      }};class Rectangle: public Shape{\n   public:\n      Rectangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout << \"Rectangle class area :\" <<endl;\n         return (width * height); \n      }};class Triangle: public Shape{\n   public:\n      Triangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout << \"Triangle class area :\" <<endl;\n         return (width * height / 2); \n      }};// 程序的主函数int main( ){\n   Shape *shape;\n   Rectangle rec(10,7);\n   Triangle  tri(10,5);\n\n   // 存储矩形的地址\n   shape = &rec;\n   // 调用矩形的求面积函数 area\n   shape->area();\n\n   // 存储三角形的地址\n   shape = &tri;\n   // 调用三角形的求面积函数 area\n   shape->area();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nParent class areaParent class area\n```\n\n导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。\n\n但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 **virtual**，如下所示：\n\n```cpp\nclass Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      virtual int area()\n      {\n         cout << \"Parent class area :\" <<endl;\n         return 0;\n      }};\n```\n\n修改后，当编译和执行前面的实例代码时，它会产生以下结果：\n\n```cpp\nRectangle class areaTriangle class area\n```\n\n此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。\n\n正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是**多态**的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。\n\n## 虚函数\n\n**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。\n\n## 纯虚函数\n\n您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。\n\n我们可以把基类中的虚函数 area() 改写如下：\n\n```cpp\nclass Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      // pure virtual function\n      virtual int area() = 0;};\n```\n\n= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。\n\n# C++ 数据抽象\n\n数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。\n\n数据抽象是一种依赖于接口和实现分离的编程（设计）技术。\n\n让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。\n\n因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。\n\n现在，让我们言归正传，就 C++ 编程而言，C++ 类为**数据抽象**提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。\n\n例如，您的程序可以调用 **sort()** 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。\n\n在 C++ 中，我们使用**类**来定义我们自己的抽象数据类型（ADT）。您可以使用类 **ostream** 的 **cout** 对象来输出数据到标准输出，如下所示：\n\n```cpp\n#include <iostream>using namespace std;int main( ){   cout << \"Hello C++\" <<endl;   return 0;}\n```\n\n在这里，您不需要理解 **cout** 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。\n\n## 访问标签强制抽象\n\n在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：\n\n- 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。\n- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。\n\n访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。\n\n## 数据抽象的好处\n\n数据抽象有两个重要的优势：\n\n- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。\n- 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。\n\n如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。\n\n## 数据抽象的实例\n\nC++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Adder{\n   public:\n      // 构造函数\n      Adder(int i = 0)\n      {\n        total = i;\n      }\n      // 对外的接口\n      void addNum(int number)\n      {\n          total += number;\n      }\n      // 对外的接口\n      int getTotal()\n      {\n          return total;\n      };\n   private:\n      // 对外隐藏的数据\n      int total;};int main( ){\n   Adder a;\n   \n   a.addNum(10);\n   a.addNum(20);\n   a.addNum(30);\n\n   cout << \"Total \" << a.getTotal() <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal 60\n```\n\n上面的类把数字相加，并返回总和。公有成员 **addNum** 和 **getTotal** 是对外的接口，用户需要知道它们以便使用类。私有成员 **total** 是用户不需要了解的，但又是类能正常工作所必需的。\n\n## 设计策略\n\n抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。\n\n在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。\n\n# C++ 数据封装\n\n所有的 C++ 程序都有以下两个基本要素：\n\n- **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。\n- **程序数据：**数据是程序的信息，会受到程序函数的影响。\n\n封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即**数据隐藏**。\n\n**数据封装**是一种把数据和操作数据的函数捆绑在一起的机制，**数据抽象**是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。\n\nC++ 通过创建**类**来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：\n\n```cpp\nclass Box{\n   public:\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n\t};\n```\n\n变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。\n\n为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 **public** 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。\n\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。\n\n## 数据封装的实例\n\nC++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Adder{\n   public:\n      // 构造函数\n      Adder(int i = 0)\n      {\n        total = i;\n      }\n      // 对外的接口\n      void addNum(int number)\n      {\n          total += number;\n      }\n      // 对外的接口\n      int getTotal()\n      {\n          return total;\n      };\n   private:\n      // 对外隐藏的数据\n      int total;};int main( ){\n   Adder a;\n   \n   a.addNum(10);\n   a.addNum(20);\n   a.addNum(30);\n\n   cout << \"Total \" << a.getTotal() <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal 60\n```\n\n上面的类把数字相加，并返回总和。公有成员 **addNum** 和 **getTotal** 是对外的接口，用户需要知道它们以便使用类。私有成员 **total** 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。\n\n## 设计策略\n\n通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的**封装性**。\n\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。\n\n# C++ 接口（抽象类）\n\n接口描述了类的行为和功能，而不需要完成类的特定实现。\n\nC++ 接口是使用**抽象类**来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。\n\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0\" 来指定的，如下所示：\n\n```cpp\nclass Box{\n   public:\n      // 纯虚函数\n      virtual double getVolume() = 0;\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度};\n```\n\n设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n\n可用于实例化对象的类被称为**具体类**。\n\n## 抽象类的实例\n\n请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：\n\n```cpp\n#include <iostream>\n using namespace std;\n // 基类class Shape {public:\n   // 提供接口框架的纯虚函数\n   virtual int getArea() = 0;\n   void setWidth(int w)\n   {\n      width = w;\n   }\n   void setHeight(int h)\n   {\n      height = h;\n   }protected:\n   int width;\n   int height;};\n // 派生类class Rectangle: public Shape{public:\n   int getArea()\n   { \n      return (width * height); \n   }};class Triangle: public Shape{public:\n   int getArea()\n   { \n      return (width * height)/2; \n   }};\n int main(void){\n   Rectangle Rect;\n   Triangle  Tri;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n   // 输出对象的面积\n   cout << \"Total Rectangle area: \" << Rect.getArea() << endl;\n\n   Tri.setWidth(5);\n   Tri.setHeight(7);\n   // 输出对象的面积\n   cout << \"Total Triangle area: \" << Tri.getArea() << endl; \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal Rectangle area: 35Total Triangle area: 17\n```\n\n从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。\n\n## 设计策略\n\n面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。\n\n外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。\n\n这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。\n\n# C++ 文件和流\n\n到目前为止，我们已经使用了 **iostream** 标准库，它提供了 **cin** 和 **cout** 方法分别用于从标准输入读取流和向标准输出写入流。\n\n本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 **fstream**，它定义了三个新的数据类型：\n\n| 数据类型 | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。     |\n| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。               |\n| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |\n\n要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。\n\n## 打开文件\n\n在从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。\n\n下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。\n\n```cpp\nvoid open(const char *filename, ios::openmode mode);\n```\n\n在这里，**open()** 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。\n\n| 模式标志   | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| ios::app   | 追加模式。所有写入都追加到文件末尾。                         |\n| ios::ate   | 文件打开后定位到文件末尾。                                   |\n| ios::in    | 打开文件用于读取。                                           |\n| ios::out   | 打开文件用于写入。                                           |\n| ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |\n\n您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：\n\n```cpp\nofstream outfile;outfile.open(\"file.dat\", ios::out | ios::trunc );\n```\n\n类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：\n\n```cpp\nfstream  afile;afile.open(\"file.dat\", ios::out | ios::in );\n```\n\n## 关闭文件\n\n当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。\n\n下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。\n\n```cpp\nvoid close();\n```\n\n## 写入文件\n\n在 C++ 编程中，我们使用流插入运算符（ << ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 **ofstream** 或 **fstream** 对象，而不是 **cout** 对象。\n\n## 读取文件\n\n在 C++ 编程中，我们使用流提取运算符（ >> ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 **ifstream** 或 **fstream** 对象，而不是 **cin** 对象。\n\n## 读取 & 写入实例\n\n下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：\n\n```cpp\n#include <fstream>#include <iostream>using namespace std;\n int main (){\n    \n   char data[100];\n\n   // 以写模式打开文件\n   ofstream outfile;\n   outfile.open(\"afile.dat\");\n\n   cout << \"Writing to the file\" << endl;\n   cout << \"Enter your name: \"; \n   cin.getline(data, 100);\n\n   // 向文件写入用户输入的数据\n   outfile << data << endl;\n\n   cout << \"Enter your age: \"; \n   cin >> data;\n   cin.ignore();\n   \n   // 再次向文件写入用户输入的数据\n   outfile << data << endl;\n\n   // 关闭打开的文件\n   outfile.close();\n\n   // 以读模式打开文件\n   ifstream infile; \n   infile.open(\"afile.dat\"); \n \n   cout << \"Reading from the file\" << endl; \n   infile >> data; \n\n   // 在屏幕上写入数据\n   cout << data << endl;\n   \n   // 再次从文件读取数据，并显示它\n   infile >> data; \n   cout << data << endl; \n\n   // 关闭打开的文件\n   infile.close();\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列输入和输出：\n\n```cpp\n$./a.outWriting to the fileEnter your name: ZaraEnter your age: 9Reading from the fileZara9\n```\n\n上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。\n\n## 文件位置指针\n\n**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（\"seek get\"）和关于 ostream 的 **seekp**（\"seek put\"）。\n\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。\n\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 \"get\" 文件位置指针的实例：\n\n```cpp\n// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );\n```\n\n# C++ 异常处理\n\n异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。\n\n异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。\n\n- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。\n- **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。\n- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。\n\n如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：\n\n```cpp\ntry{\n   // 保护代码}catch( ExceptionName e1 ){\n   // catch 块}catch( ExceptionName e2 ){\n   // catch 块}catch( ExceptionName eN ){\n   // catch 块}\n```\n\n如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。\n\n## 抛出异常\n\n您可以使用 **throw** 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。\n\n以下是尝试除以零时抛出异常的实例：\n\n```cpp\ndouble division(int a, int b){\n   if( b == 0 )\n   {\n      throw \"Division by zero condition!\";\n   }\n   return (a/b);}\n```\n\n## 捕获异常\n\n**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。\n\n```cpp\ntry{\n   // 保护代码}catch( ExceptionName e ){\n  // 处理 ExceptionName 异常的代码}\n```\n\n上面的代码会捕获一个类型为 **ExceptionName** 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：\n\n```cpp\ntry{\n   // 保护代码}catch(...){\n  // 能处理任何异常的代码}\n```\n\n下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。\n\n```cpp\n#include <iostream>using namespace std;double division(int a, int b){\n   if( b == 0 )\n   {\n      throw \"Division by zero condition!\";\n   }\n   return (a/b);}int main (){\n   int x = 50;\n   int y = 0;\n   double z = 0;\n \n   try {\n     z = division(x, y);\n     cout << z << endl;\n   }catch (const char* msg) {\n     cerr << msg << endl;\n   }\n\n   return 0;}\n```\n\n由于我们抛出了一个类型为 **const char\\*** 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nDivision by zero condition!\n```\n\n## C++ 标准的异常\n\nC++ 提供了一系列标准的异常，定义在 **<exception>** 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg)\n\n下表是对上面层次结构中出现的每个异常的说明：\n\n| 异常                   | 描述                                                         |\n| :--------------------- | :----------------------------------------------------------- |\n| **std::exception**     | 该异常是所有标准 C++ 异常的父类。                            |\n| std::bad_alloc         | 该异常可以通过 **new** 抛出。                                |\n| std::bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |\n| std::bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |\n| std::bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |\n| **std::logic_error**   | 理论上可以通过读取代码来检测到的异常。                       |\n| std::domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |\n| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |\n| std::length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |\n| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 |\n| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常。                     |\n| std::overflow_error    | 当发生数学上溢时，会抛出该异常。                             |\n| std::range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |\n| std::underflow_error   | 当发生数学下溢时，会抛出该异常。                             |\n\n## 定义新的异常\n\n您可以通过继承和重载 **exception** 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：\n\n```cpp\n#include <iostream>#include <exception>using namespace std;struct MyException : public exception{\n  const char * what () const throw ()\n  {\n    return \"C++ Exception\";\n  }};\n int main(){\n  try\n  {\n    throw MyException();\n  }\n  catch(MyException& e)\n  {\n    std::cout << \"MyException caught\" << std::endl;\n    std::cout << e.what() << std::endl;\n  }\n  catch(std::exception& e)\n  {\n    //其他的错误\n  }}\n```\n\n这将产生以下结果：\n\n```cpp\nMyException caught\nC++ Exception\n```\n\n在这里，**what()** 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。\n\n# C++ 动态内存\n\n了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：\n\n- **栈：**在函数内部声明的所有变量都将占用栈内存。\n- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\n很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。\n\n在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。\n\n如果您不需要动态分配内存，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。\n\n## new 和 delete 运算符\n\n下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：\n\n```cpp\nnew data-type;\n```\n\n在这里，**data-type** 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 **new** 运算符来完成这点：\n\n```cpp\ndouble* pvalue  = NULL; // 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存\n```\n\n如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：\n\n```cpp\ndouble* pvalue  = NULL;if( !(pvalue  = new double )){\n   cout << \"Error: out of memory.\" <<endl;\n   exit(1);}\n```\n\n**malloc()** 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。\n\n在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：\n\n```cpp\ndelete pvalue;        // 释放 pvalue 所指向的内存\n```\n\n下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   double* pvalue  = NULL; // 初始化为 null 的指针\n   pvalue  = new double;   // 为变量请求内存\n \n   *pvalue = 29494.99;     // 在分配的地址存储值\n   cout << \"Value of pvalue : \" << *pvalue << endl;\n\n   delete pvalue;         // 释放内存\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of pvalue : 29495\n```\n\n## 数组的动态内存分配\n\n假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：\n\n```cpp\nchar* pvalue  = NULL;   // 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存\n```\n\n要删除我们刚才创建的数组，语句如下：\n\n```cpp\ndelete [] pvalue;        // 删除 pvalue 所指向的数组\n```\n\n下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：\n\n```cpp\nint ROW = 2;int COL = 3;double **pvalue  = new double* [ROW]; // 为行分配内存// 为列分配内存for(int i = 0; i < COL; i++) {\n    pvalue[i] = new double[COL];}\n```\n\n释放多维数组内存：\n\n```cpp\nfor(int i = 0; i < COL; i++) {\n    delete[] pvalue[i];}delete [] pvalue;\n```\n\n## 对象的动态内存分配\n\n对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n      Box() { \n         cout << \"调用构造函数！\" <<endl; \n      }\n      ~Box() { \n         cout << \"调用析构函数！\" <<endl; \n      }};int main( ){\n   Box* myBoxArray = new Box[4];\n\n   delete [] myBoxArray; // Delete array\n\n   return 0;}\n```\n\n如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！\n```\n\n# C++ 命名空间\n\n假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。\n\n同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。\n\n因此，引入了**命名空间**这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。\n\n## 定义命名空间\n\n命名空间的定义使用关键字 **namespace**，后跟命名空间的名称，如下所示：\n\n```cpp\nnamespace namespace_name {   // 代码声明}\n```\n\n为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：\n\n```cpp\nname::code;  // code 可以是变量或函数\n```\n\n让我们来看看命名空间如何为变量或函数等实体定义范围：\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }}// 第二个命名空间namespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }}int main (){\n \n   // 调用第一个命名空间中的函数\n   first_space::func();\n   \n   // 调用第二个命名空间中的函数\n   second_space::func(); \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside first_spaceInside second_space\n```\n\n## using 指令\n\n您可以使用 **using namespace** 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }}// 第二个命名空间namespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }}using namespace first_space;int main (){\n \n   // 调用第一个命名空间中的函数\n   func();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside first_space\n```\n\nusing 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：\n\n```cpp\nusing std::cout;\n```\n\n随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 **std** 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：\n\n```cpp\n#include <iostream>using std::cout;int main (){   \n\tcout << \"std::endl is used with std!\" << std::endl;      \n\treturn 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstd::endl is used with std!\n```\n\n**using** 指令引入的名称遵循正常的范围规则。名称从使用 **using** 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。\n\n## 不连续的命名空间\n\n命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。\n\n所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：\n\n```cpp\nnamespace namespace_name {\n   // 代码声明}\n```\n\n## 嵌套的命名空间\n\n命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：\n\n```cpp\nnamespace namespace_name1 {\n   // 代码声明\n   namespace namespace_name2 {\n      // 代码声明\n   }}\n```\n\n您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：\n\n```cpp\n// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;\n```\n\n在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }\n   // 第二个命名空间\n   namespace second_space{\n      void func(){\n         cout << \"Inside second_space\" << endl;\n      }\n   }}using namespace first_space::second_space;int main (){\n \n   // 调用第二个命名空间中的函数\n   func();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside second_space\n```\n\n# C++ 模板\n\n模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n\n模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。\n\n每个容器都有一个单一的定义，比如 **向量**，我们可以定义许多不同类型的向量，比如 **vector <int>** 或 **vector <string>**。\n\n您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。\n\n## 函数模板\n\n模板函数定义的一般形式如下所示：\n\n```cpp\ntemplate <class type> ret-type func-name(parameter list){   // 函数的主体}\n```\n\n在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。\n\n下面是函数模板的实例，返回两个数种的最大值：\n\n```cpp\n#include <iostream>#include <string>using namespace std;template <typename T>inline T const& Max (T const& a, T const& b) { \n    return a < b ? b:a; } int main (){\n \n    int i = 39;\n    int j = 20;\n    cout << \"Max(i, j): \" << Max(i, j) << endl; \n\n    double f1 = 13.5; \n    double f2 = 20.7; \n    cout << \"Max(f1, f2): \" << Max(f1, f2) << endl; \n\n    string s1 = \"Hello\"; \n    string s2 = \"World\"; \n    cout << \"Max(s1, s2): \" << Max(s1, s2) << endl; \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nMax(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World\n```\n\n## 类模板\n\n正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：\n\n```cpp\ntemplate <class type> class class-name {...}\n```\n\n在这里，**type** 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。\n\n下面的实例定义了类 Stack<>，并实现了泛型方法来对元素进行入栈出栈操作：\n\n```cpp\n#include <iostream>#include <vector>#include <cstdlib>#include <string>#include <stdexcept>using namespace std;template <class T>class Stack { \n  private: \n    vector<T> elems;     // 元素 \n\n  public: \n    void push(T const&);  // 入栈\n    void pop();               // 出栈\n    T top() const;            // 返回栈顶元素\n    bool empty() const{       // 如果为空则返回真。\n        return elems.empty(); \n    } }; template <class T>void Stack<T>::push (T const& elem) { \n    // 追加传入元素的副本\n    elems.push_back(elem);    } template <class T>void Stack<T>::pop () { \n    if (elems.empty()) { \n        throw out_of_range(\"Stack<>::pop(): empty stack\"); \n    }\n\t// 删除最后一个元素\n    elems.pop_back();         } template <class T>T Stack<T>::top () const { \n    if (elems.empty()) { \n        throw out_of_range(\"Stack<>::top(): empty stack\"); \n    }\n\t// 返回最后一个元素的副本 \n    return elems.back();      } int main() { \n    try { \n        Stack<int>         intStack;  // int 类型的栈 \n        Stack<string> stringStack;    // string 类型的栈 \n\n        // 操作 int 类型的栈 \n        intStack.push(7); \n        cout << intStack.top() <<endl; \n\n        // 操作 string 类型的栈 \n        stringStack.push(\"hello\"); \n        cout << stringStack.top() << std::endl; \n        stringStack.pop(); \n        stringStack.pop(); \n    } \n    catch (exception const& ex) { \n        cerr << \"Exception: \" << ex.what() <<endl; \n        return -1;\n    } }\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n7helloException: Stack<>::pop(): empty stack\n```\n\n# C++ 预处理器\n\n预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。\n\n所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。\n\n我们已经看到，之前所有的实例中都有 **#include** 指令。这个宏用于把头文件包含到源文件中。\n\nC++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。\n\n## #define 预处理\n\n\\#define 预处理指令用于创建符号常量。该符号常量通常称为**宏**，指令的一般形式是：\n\n```cpp\n#define macro-name replacement-text\n```\n\n当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：\n\n```cpp\n#include <iostream>using namespace std;#define PI 3.14159int main (){     cout << \"Value of PI :\" << PI << endl;     return 0;}\n```\n\n现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：\n\n```cpp\n$gcc -E test.cpp > test.p...int main (){     cout << \"Value of PI :\" << 3.14159 << endl;     return 0;}\n```\n\n## 函数宏\n\n您可以使用 #define 来定义一个带有参数的宏，如下所示：\n\n```cpp\n#include <iostream>using namespace std;#define MIN(a,b) (a<b ? a : b)int main (){\n   int i, j;\n   i = 100;\n   j = 30;\n   cout <<\"较小的值为：\" << MIN(i, j) << endl;\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n较小的值为：30\n```\n\n## 条件编译\n\n有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。\n\n条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：\n\n```cpp\n#ifndef NULL   #define NULL 0#endif\n```\n\n您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：\n\n```cpp\n#ifdef DEBUG   cerr <<\"Variable x = \" << x << endl;#endif\n```\n\n如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 **cerr** 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：\n\n```cpp\n#if 0   不进行编译的代码#endif\n```\n\n让我们尝试下面的实例：\n\n```cpp\n#include <iostream>using namespace std;#define DEBUG#define MIN(a,b) (((a)<(b)) ? a : b)int main (){\n   int i, j;\n   i = 100;\n   j = 30;#ifdef DEBUG\n   cerr <<\"Trace: Inside main function\" << endl;#endif#if 0\n   /* 这是注释部分 */\n   cout << MKSTR(HELLO C++) << endl;#endif\n\n   cout <<\"The minimum is \" << MIN(i, j) << endl;#ifdef DEBUG\n   cerr <<\"Trace: Coming out of main function\" << endl;#endif\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTrace: Inside main functionThe minimum is 30Trace: Coming out of main function\n```\n\n## # 和 ## 运算符\n\n\\# 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。\n\n请看下面的宏定义：\n\n```cpp\n#include <iostream>using namespace std;#define MKSTR( x ) #xint main (){    cout << MKSTR(HELLO C++) << endl;    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nHELLO C++\n```\n\n让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：\n\n```cpp\ncout << MKSTR(HELLO C++) << endl;\n```\n\n转换成了：\n\n```cpp\ncout << \"HELLO C++\" << endl;\n```\n\n\\## 运算符用于连接两个令牌。下面是一个实例：\n\n```cpp\n#define CONCAT( x, y )  x ## y\n```\n\n当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 \"HELLO C++\"，如下面实例所示。\n\n```cpp\n#include <iostream>using namespace std;#define concat(a, b) a ## bint main(){   int xy = 100;      cout << concat(x, y);   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n100\n```\n\n让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：\n\n```cpp\ncout << concat(x, y);\n```\n\n转换成了：\n\n```cpp\ncout << xy;\n```\n\n## C++ 中的预定义宏\n\nC++ 提供了下表所示的一些预定义宏：\n\n| 宏       | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| __LINE__ | 这会在程序编译时包含当前行号。                               |\n| __FILE__ | 这会在程序编译时包含当前文件名。                             |\n| __DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |\n| __TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |\n\n让我们看看上述这些宏的实例：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n    cout << \"Value of __LINE__ : \" << __LINE__ << endl;\n    cout << \"Value of __FILE__ : \" << __FILE__ << endl;\n    cout << \"Value of __DATE__ : \" << __DATE__ << endl;\n    cout << \"Value of __TIME__ : \" << __TIME__ << endl;\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of __LINE__ : 6Value of __FILE__ : test.cppValue of __DATE__ : Feb 28 2011Value of __TIME__ : 18:52:48\n```\n\n# C++ 信号处理\n\n信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。\n\n有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。\n\n| 信号    | 描述                                         |\n| :------ | :------------------------------------------- |\n| SIGABRT | 程序的异常终止，如调用 **abort**。           |\n| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |\n| SIGILL  | 检测非法指令。                               |\n| SIGINT  | 接收到交互注意信号。                         |\n| SIGSEGV | 非法访问内存。                               |\n| SIGTERM | 发送到程序的终止请求。                       |\n\n## signal() 函数\n\nC++ 信号处理库提供了 **signal** 函数，用来捕获突发事件。以下是 signal() 函数的语法：\n\n```cpp\nvoid (*signal (int sig, void (*func)(int)))(int);\n```\n\n这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。\n\n让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 **signal** 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：\n\n```cpp\n#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n\n    // 清理并关闭\n    // 终止程序  \n\n   exit(signum);  }int main (){\n    // 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n\n    while(1){\n       cout << \"Going to sleep....\" << endl;\n       sleep(1);\n    }\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....\n```\n\n现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.\n```\n\n## raise() 函数\n\n您可以使用函数 **raise()** 生成信号，该函数带有一个整数信号编号作为参数，语法如下：\n\n```cpp\nint raise (signal sig);\n```\n\n在这里，**sig** 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：\n\n```cpp\n#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n\n    // 清理并关闭\n    // 终止程序 \n\n   exit(signum);  }int main (){\n    int i = 0;\n    // 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n\n    while(++i){\n       cout << \"Going to sleep....\" << endl;\n       if( i == 3 ){\n          raise( SIGINT);\n       }\n       sleep(1);\n    }\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.\n```\n\n# C++ 多线程\n\n多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。\n\n- 基于进程的多任务处理是程序的并发执行。\n- 基于线程的多任务处理是同一程序的片段的并发执行。\n\n多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。\n\n本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。\n\n## 创建线程\n\n下面的程序，我们可以用它来创建一个 POSIX 线程：\n\n```cpp\n#include <pthread.h>pthread_create (thread, attr, start_routine, arg)\n```\n\n在这里，**pthread_create** 创建一个新的线程，并让它可执行。下面是关于参数的说明：\n\n| 参数          | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| thread        | 指向线程标识符指针。                                         |\n| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |\n| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |\n| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |\n\n创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。\n\n## 终止线程\n\n使用下面的程序，我们可以用它来终止一个 POSIX 线程：\n\n```cpp\n#include <pthread.h>pthread_exit (status)\n```\n\n在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。\n\n如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。\n\n## 实例\n\n以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\":\n\n```cpp\n#include <iostream>// 必须的头文件是#include <pthread.h>using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args){\n    cout << \"Hello Runoob！\" << endl;}int main(){\n    // 定义线程的 id 变量，多个变量使用数组\n    pthread_t tids[NUM_THREADS];\n    for(int i = 0; i < NUM_THREADS; ++i)\n    {\n        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数\n        int ret = pthread_create(&tids[i], NULL, say_hello, NULL);\n        if (ret != 0)\n        {\n           cout << \"pthread_create error: error_code=\" << ret << endl;\n        }\n    }\n    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；\n    pthread_exit(NULL);}\n```\n\n使用 -lpthread 库编译下面的程序：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o\n```\n\n现在，执行程序，将产生下列结果：\n\n```cpp\n$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！\n```\n\n以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 \"Hello Runoob!\" 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。\n\n```cpp\n//文件名：test.cpp#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid){  \n   // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取\n   int tid = *((int*)threadid);\n   cout << \"Hello Runoob! 线程 ID, \" << tid << endl;\n   pthread_exit(NULL);}int main (){\n   pthread_t threads[NUM_THREADS];\n   int indexes[NUM_THREADS];// 用数组来保存i的值\n   int rc;\n   int i;\n   for( i=0; i < NUM_THREADS; i++ ){      \n      cout << \"main() : 创建线程, \" << i << endl;\n      indexes[i] = i; //先保存i的值\n      // 传入的时候必须强制转换为void* 类型，即无类型指针        \n      rc = pthread_create(&threads[i], NULL, \n                          PrintHello, (void *)&(indexes[i]));\n      if (rc){\n         cout << \"Error:无法创建线程,\" << rc << endl;\n         exit(-1);\n      }\n   }\n   pthread_exit(NULL);}\n```\n\n现在编译并执行程序，将产生下列结果：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o$ ./test.omain() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3main() : 创建线程, 4Hello Runoob! 线程 ID, 4Hello Runoob! 线程 ID, 3Hello Runoob! 线程 ID, 2Hello Runoob! 线程 ID, 1Hello Runoob! 线程 ID, 0\n```\n\n## 向线程传递参数\n\n这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：\n\n```cpp\n#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5struct thread_data{   int  thread_id;   char *message;};void *PrintHello(void *threadarg){   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout << \"Thread ID : \" << my_data->thread_id ;   cout << \" Message : \" << my_data->message << endl;   pthread_exit(NULL);}int main (){   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i < NUM_THREADS; i++ ){      cout <<\"main() : creating thread, \" << i << endl;      td[i].thread_id = i;      td[i].message = \"This is message\";      rc = pthread_create(&threads[i], NULL,                          PrintHello, (void *)&td[i]);      if (rc){         cout << \"Error:unable to create thread,\" << rc << endl;         exit(-1);      }   }   pthread_exit(NULL);}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o\n$ ./test.o\nmain() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3main() : 创建线程, 4Hello Runoob! 线程 ID, 4Hello Runoob! 线程 ID, 3Hello Runoob! 线程 ID, 2Hello Runoob! 线程 ID, 1Hello Runoob! 线程 ID, 0\n```\n\n## 连接和分离线程\n\n我们可以使用以下两个函数来连接或分离线程：\n\n```cpp\npthread_join (threadid, status) pthread_detach (threadid)\n```\n\npthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。\n\n这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。\n\n```cpp\n#include <iostream>#include <cstdlib>#include <pthread.h>#include <unistd.h>using namespace std;#define NUM_THREADS     5void *wait(void *t){\n   int i;\n   long tid;\n\n   tid = (long)t;\n\n   sleep(1);\n   cout << \"Sleeping in thread \" << endl;\n   cout << \"Thread with id : \" << tid << \"  ...exiting \" << endl;\n   pthread_exit(NULL);}int main (){\n   int rc;\n   int i;\n   pthread_t threads[NUM_THREADS];\n   pthread_attr_t attr;\n   void *status;\n\n   // 初始化并设置线程为可连接的（joinable）\n   pthread_attr_init(&attr);\n   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n   for( i=0; i < NUM_THREADS; i++ ){\n      cout << \"main() : creating thread, \" << i << endl;\n      rc = pthread_create(&threads[i], NULL, wait, (void *)&i );\n      if (rc){\n         cout << \"Error:unable to create thread,\" << rc << endl;\n         exit(-1);\n      }\n   }\n\n   // 删除属性，并等待其他线程\n   pthread_attr_destroy(&attr);\n   for( i=0; i < NUM_THREADS; i++ ){\n      rc = pthread_join(threads[i], &status);\n      if (rc){\n         cout << \"Error:unable to join,\" << rc << endl;\n         exit(-1);\n      }\n      cout << \"Main: completed thread id :\" << i ;\n      cout << \"  exiting with status :\" << status << endl;\n   }\n\n   cout << \"Main: program exiting.\" << endl;\n   pthread_exit(NULL);}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nmain() : creating thread, 0main() : creating thread, 1main() : creating thread, 2main() : creating thread, 3main() : creating thread, 4Sleeping in thread \nThread with id : 4  ...exiting \nSleeping in thread \nThread with id : 3  ...exiting \nSleeping in thread \nThread with id : 2  ...exiting \nSleeping in thread \nThread with id : 1  ...exiting \nSleeping in thread \nThread with id : 0  ...exiting \nMain: completed thread id :0  exiting with status :0Main: completed thread id :1  exiting with status :0Main: completed thread id :2  exiting with status :0Main: completed thread id :3  exiting with status :0Main: completed thread id :4  exiting with status :0Main: program exiting.\n```\n\n# C++ Web 编程\n\n## 什么是 CGI？\n\n- 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。\n- CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：\n- 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。\n- 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。\n\n## Web 浏览\n\n为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。\n\n- 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。\n- Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。\n- Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。\n\n然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。\n\n公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。\n\n## CGI 架构图\n\n下图演示了 CGI 的架构：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif)\n\n## Web 服务器配置\n\n在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 **.cgi**。\n\n默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：\n\n```cpp\n<Directory \"/var/www/cgi-bin\">   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all</Directory> <Directory \"/var/www/cgi-bin\">Options All</Directory>\n```\n\n在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。\n\n## 第一个 CGI 程序\n\n请看下面的 C++ 程序：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n    \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>Hello World - 第一个 CGI 程序</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<h2>Hello World! 这是我的第一个 CGI 程序</h2>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 **chmod 755 cplusplus.cgi** UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：\n\n## Hello World! 这是我的第一个 CGI 程序\n\n上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 **Content-type:text/html\\r\\n\\r\\n**。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。\n\n## HTTP 头信息\n\n行 **Content-type:text/html\\r\\n\\r\\n** 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：\n\n```cpp\nHTTP 字段名称: 字段内容 例如Content-type: text/html\\r\\n\\r\\n\n```\n\n还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。\n\n| 头信息              | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| Content-type:       | MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 |\n| Expires: Date       | 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 |\n| Location: URL       | 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 |\n| Last-modified: Date | 资源的最后修改日期。                                         |\n| Content-length: N   | 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 |\n| Set-Cookie: String  | 通过 *string* 设置 cookie。                                  |\n\n## CGI 环境变量\n\n所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。\n\n| 变量名          | 描述                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| CONTENT_TYPE    | 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 |\n| CONTENT_LENGTH  | 查询的信息长度。只对 POST 请求可用。                         |\n| HTTP_COOKIE     | 以键 & 值对的形式返回设置的 cookies。                        |\n| HTTP_USER_AGENT | 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 |\n| PATH_INFO       | CGI 脚本的路径。                                             |\n| QUERY_STRING    | 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 |\n| REMOTE_ADDR     | 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 |\n| REMOTE_HOST     | 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 |\n| REQUEST_METHOD  | 用于发出请求的方法。最常见的方法是 GET 和 POST。             |\n| SCRIPT_FILENAME | CGI 脚本的完整路径。                                         |\n| SCRIPT_NAME     | CGI 脚本的名称。                                             |\n| SERVER_NAME     | 服务器的主机名或 IP 地址。                                   |\n| SERVER_SOFTWARE | 服务器上运行的软件的名称和版本。                             |\n\n下面的 CGI 程序列出了所有的 CGI 变量。\n\n```cpp\n#include <iostream>#include <stdlib.h>using namespace std;const string ENV[ 24 ] = {                 \n        \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\",   \n        \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\",    &nbsnbsp;        \n        \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\",         \n        \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\",            \n        \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\",      \n        \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\",\n        \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\",      \n        \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\",     \n        \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" };   int main (){\n    \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 环境变量</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<table border = \\\"0\\\" cellspacing = \\\"2\\\">\";\n\n   for ( int i = 0; i < 24; i++ )\n   {\n       cout << \"<tr><td>\" << ENV[ i ] << \"</td><td>\";\n       // 尝试检索环境变量的值\n       char *value = getenv( ENV[ i ].c_str() );  \n       if ( value != 0 ){\n         cout << value;                                 \n       }else{\n         cout << \"环境变量不存在。\";\n       }\n       cout << \"</td></tr>\\n\";\n   }\n   cout << \"</table><\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## C++ CGI 库\n\n在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 [ftp://ftp.gnu.org/gnu/cgicc/](ftp://ftp.gnu.org/gnu/cgicc/) 上下载这个 CGI 库，并按照下面的步骤安装库：\n\n```cpp\n$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install\n```\n\n您可以点击 C++ CGI Lib Documentation，查看相关的库文档。\n\n## GET 和 POST 方法\n\n您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。\n\n## 使用 GET 方法传递信息\n\nGET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：\n\n```cpp\nhttp://www.test.com/cgi-bin/cpp.cgi?key1=value1&key2=value2\n```\n\nGET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。\n\n当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。\n\n您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。\n\n## 简单的 URL 实例：Get 方法\n\n下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。\n\n/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI\n\n下面的实例生成 **cpp_get.cgi** CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>  using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n   \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>使用 GET 和 POST 方法</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"first_name\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"名：\" << **fi << endl;  \n   }else{\n      cout << \"No text entered for first name\" << endl;  \n   }\n   cout << \"<br/>\\n\";\n   fi = formData.getElement(\"last_name\");  \n   if( !fi->isEmpty() &&fi != (*formData).end()) {  \n      cout << \"姓：\" << **fi << endl;  \n   }else{\n      cout << \"No text entered for last name\" << endl;  \n   }\n   cout << \"<br/>\\n\";\n\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n现在，编译上面的程序，如下所示：\n\n```cpp\n$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc\n```\n\n生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：\n\n/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI\n\n这会产生以下结果：\n\n```cpp\n名：ZARA 姓：ALI\n```\n\n## 简单的表单实例：GET 方法\n\n下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。\n\n```cpp\n<form action=\"/cgi-bin/cpp_get.cgi\" method=\"get\">名：<input type=\"text\" name=\"first_name\">  <br /> 姓：<input type=\"text\" name=\"last_name\" /><input type=\"submit\" value=\"提交\" /></form>\n```\n\n下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。\n\n## 使用 POST 方法传递信息\n\n一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。\n\n我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：\n\n```cpp\n<form action=\"/cgi-bin/cpp_get.cgi\" method=\"post\">名：<input type=\"text\" name=\"first_name\"><br />姓：<input type=\"text\" name=\"last_name\" /> <input type=\"submit\" value=\"提交\" /></form>\n```\n\n## 向 CGI 程序传递复选框数据\n\n当需要选择多个选项时，我们使用复选框。\n\n下面的 HTML 代码实例是一个带有两个复选框的表单：\n\n```html\n<form action=\"/cgi-bin/cpp_checkbox.cgi\" \n         method=\"POST\" \n         target=\"_blank\"><input type=\"checkbox\" name=\"maths\" value=\"on\" /> 数学<input type=\"checkbox\" name=\"physics\" value=\"on\" /> 物理<input type=\"submit\" value=\"选择学科\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n   bool maths_flag, physics_flag;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递复选框数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   maths_flag = formData.queryCheckbox(\"maths\");\n   if( maths_flag ) {  \n      cout << \"Maths Flag: ON \" << endl;  \n   }else{\n      cout << \"Maths Flag: OFF \" << endl;  \n   }\n   cout << \"<br/>\\n\";\n\n   physics_flag = formData.queryCheckbox(\"physics\");\n   if( physics_flag ) {  \n      cout << \"Physics Flag: ON \" << endl;  \n   }else{\n      cout << \"Physics Flag: OFF \" << endl;  \n   }\n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递单选按钮数据\n\n当只需要选择一个选项时，我们使用单选按钮。\n\n下面的 HTML 代码实例是一个带有两个单选按钮的表单：\n\n```cpp\n<form action=\"/cgi-bin/cpp_radiobutton.cgi\" \n         method=\"post\" \n         target=\"_blank\"><input type=\"radio\" name=\"subject\" value=\"maths\" \n                                    checked=\"checked\"/> 数学 \n<input type=\"radio\" name=\"subject\" value=\"physics\" /> 物理<input type=\"submit\" value=\"选择学科\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递单选按钮数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"subject\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Radio box selected: \" << **fi << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递文本区域数据\n\n当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。\n\n下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：\n\n```\n<form action=\"/cgi-bin/cpp_textarea.cgi\" \n         method=\"post\" \n         target=\"_blank\"><textarea name=\"textcontent\" cols=\"40\" rows=\"4\">请在这里输入文本...</textarea><input type=\"submit\" value=\"提交\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递文本区域数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"textcontent\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Text Content: \" << **fi << endl;  \n   }else{\n      cout << \"No text entered\" << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递下拉框数据\n\n当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。\n\n下面的 HTML 代码实例是一个带有下拉框的表单：\n\n```cpp\n<form action=\"/cgi-bin/cpp_dropdown.cgi\" \n                       method=\"post\" target=\"_blank\"><select name=\"dropdown\"><option value=\"Maths\" selected>数学</option><option value=\"Physics\">物理</option></select><input type=\"submit\" value=\"提交\"/></form>\n```\n\n下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递下拉框数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"dropdown\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Value Selected: \" << **fi << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 在 CGI 中使用 Cookies\n\nHTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。\n\n在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。\n\n### 它是如何工作的\n\n服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。\n\ncookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：\n\n- **Expires :** cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。\n- **Domain :** 网站的域名。\n- **Path :** 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。\n- **Secure :** 如果此字段包含单词 \"secure\"，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。\n- **Name=Value :** cookie 以键值对的形式被设置和获取。\n\n### 设置 Cookies\n\n向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n \n   cout << \"Set-Cookie:UserID=XYZ;\\r\\n\";\n   cout << \"Set-Cookie:Password=XYZ123;\\r\\n\";\n   cout << \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\";\n   cout << \"Set-Cookie:Path=/perl;\\n\";\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的 Cookies</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   cout << \"设置 cookies\" << endl;  \n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n从这个实例中，我们了解了如何设置 cookies。我们使用 **Set-Cookie** HTTP 头来设置 cookies。\n\n在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 **\"Content-type:text/html\\r\\n\\r\\n** 之前被设置的。\n\n编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：\n\n/cgi-bin/setcookies.cgi\n\n### 获取 Cookies\n\n检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：\n\n```cpp\nkey1=value1;key2=value2;key3=value3....\n```\n\n下面的实例演示了如何获取 cookies。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){\n   Cgicc cgi;\n   const_cookie_iterator cci;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的 Cookies</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<table border = \\\"0\\\" cellspacing = \\\"2\\\">\";\n   \n   // 获取环境变量\n   const CgiEnvironment& env = cgi.getEnvironment();\n\n   for( cci = env.getCookieList().begin();\n        cci != env.getCookieList().end(); \n        ++cci )\n   {\n      cout << \"<tr><td>\" << cci->getName() << \"</td><td>\";\n      cout << cci->getValue();                                 \n      cout << \"</td></tr>\\n\";\n   }\n   cout << \"</table><\\n\";\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：\n\n/cgi-bin/getcookies.cgi\n\n这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：\n\n```cpp\nUserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl\n```\n\n## 文件上传实例\n\n为了上传一个文件，HTML 表单必须把 enctype 属性设置为 **multipart/form-data**。带有文件类型的 input 标签会创建一个 \"Browse\" 按钮。\n\n```cpp\n<html><body>\n   <form enctype=\"multipart/form-data\" \n            action=\"/cgi-bin/cpp_uploadfile.cgi\" \n            method=\"post\">\n   <p>文件：<input type=\"file\" name=\"userfile\" /></p>\n   <p><input type=\"submit\" value=\"上传\" /></p>\n   </form></body></html>\n```\n\n这段代码的结果是下面的表单：\n\n文件：\n\n \n\n**注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。\n\n下面是用于处理文件上传的脚本 **cpp_uploadfile.cpp**：\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){\n   Cgicc cgi;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的文件上传</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   // 获取要被上传的文件列表\n   const_file_iterator file = cgi.getFile(\"userfile\");\n   if(file != cgi.getFiles().end()) {\n      // 在 cout 中发送数据类型\n      cout << HTTPContentHeader(file->getDataType());\n      // 在 cout 中写入内容\n      file->writeToStream(cout);\n   }\n   cout << \"<文件上传成功>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n上面的实例是在 **cout** 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。\n\n# C++ STL 教程\n\n在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |\n| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |\n\n这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。\n\n下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：\n\n```cpp\n#include <iostream>#include <vector>using namespace std;\n int main(){\n   // 创建一个向量存储 int\n   vector<int> vec; \n   int i;\n\n   // 显示 vec 的原始大小\n   cout << \"vector size = \" << vec.size() << endl;\n\n   // 推入 5 个值到向量中\n   for(i = 0; i < 5; i++){\n      vec.push_back(i);\n   }\n\n   // 显示 vec 扩展后的大小\n   cout << \"extended vector size = \" << vec.size() << endl;\n\n   // 访问向量中的 5 个值\n   for(i = 0; i < 5; i++){\n      cout << \"value of vec [\" << i << \"] = \" << vec[i] << endl;\n   }\n\n   // 使用迭代器 iterator 访问值\n   vector<int>::iterator v = vec.begin();\n   while( v != vec.end()) {\n      cout << \"value of v = \" << *v << endl;\n      v++;\n   }\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nvector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4\n```\n\n关于上面实例中所使用的各种函数，有几点要注意：\n\n- push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。\n- size( ) 函数显示向量的大小。\n- begin( ) 函数返回一个指向向量开头的迭代器。\n- end( ) 函数返回一个指向向量末尾的迭代器。\n\n# C++ 标准库\n\nC++ 标准库可以分为两部分：\n\n- **标准函数库：** 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。\n- **面向对象类库：** 这个库是类及其相关函数的集合。\n\nC++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。\n\n## 标准函数库\n\n标准函数库分为以下几类：\n\n- 输入/输出 I/O\n- 字符串和字符处理\n- 数学\n- 时间、日期和本地化\n- 动态分配\n- 其他\n- 宽字符函数\n\n## 面向对象类库\n\n标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：\n\n- 标准的 C++ I/O 类\n- String 类\n- 数值类\n- STL 容器类\n- STL 算法\n- STL 函数对象\n- STL 迭代器\n- STL 分配器\n- 本地化库\n- 异常处理类\n- 杂项支持库\n\n\n\n# 参考资料\n\n来源：https://github.com/0voice/cpp_new_features\n\n","source":"_posts/C-基础教程.md","raw":"---\ntitle: C++基础教程\ndate: 2023-09-02 11:55:33\ncategories: \n- 基本功\n- 编程基础\n- C++\ntags:\n- C++\n- Java\n---\n\n__原文来自：https://github.com/GrindGold/CppGuide__\n\n# C++ 教程\n\n![](https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png)\n\nC++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。\n\n本教程通过通俗易懂的语言来讲解 C++ 编程语言。\n\n**现在开始学习 C++ 编程！**\n\n \n\n## 谁适合阅读本教程？\n\n本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。\n\n## 阅读本教程前，您需要了解的知识：\n\n在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。\n\n## 编译/执行 C++ 程序\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std;int main(){\n    cout << \"Hello, world!\" << endl;    return 0;\n}\n```\n\n运行结果：\n\n```cpp\nHello, world!\n```\n\n你可以用 \"\\n\" 代替以上代码里的 \"endl\"。\n\n# C++ 简介\n\nC++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\n\nC++ 被认为是一种**中级**语言，它综合了高级语言和低级语言的特点。\n\nC++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。\n\nC++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。\n\n**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。\n\n## 面向对象程序设计\n\nC++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：\n\n- 封装\n- 抽象\n- 继承\n- 多态\n\n## 标准库\n\n标准的 C++ 由三个重要部分组成：\n\n- 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。\n- C++ 标准库，提供了大量的函数，用于操作文件、字符串等。\n- 标准模板库（STL），提供了大量的方法，用于操作数据结构等。\n\n## ANSI 标准\n\nANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。\n\n由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。\n\n## 学习 C++\n\n学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。\n\n学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。\n\nC++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。\n\n## C++ 的使用\n\n基本上每个应用程序领域的程序员都有使用 C++。\n\nC++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。\n\nC++ 广泛用于教学和研究。\n\n任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。\n\n------\n\n## 标准化\n\n| 发布时间 | 文档                  | 通称   | 备注                |      |\n| :------- | :-------------------- | :----- | :------------------ | :--- |\n| 2015     | ISO/IEC TS 19570:2015 | -      | 用于并行计算的扩展  |      |\n| 2015     | ISO/IEC TS 18822:2015 | -      | 文件系统            |      |\n| 2014     | ISO/IEC 14882:2014    | C++14  | 第四个C++标准       |      |\n| 2011     | ISO/IEC TR 24733:2011 | -      | 十进制浮点数扩展    |      |\n| 2011     | ISO/IEC 14882:2011    | C++11  | 第三个C++标准       |      |\n| 2010     | ISO/IEC TR 29124:2010 | -      | 数学函数扩展        |      |\n| 2007     | ISO/IEC TR 19768:2007 | C++TR1 | C++技术报告：库扩展 |      |\n| 2006     | ISO/IEC TR 18015:2006 | -      | C++性能技术报告     |      |\n| 2003     | ISO/IEC 14882:2003    | C++03  | 第二个C++标准       |      |\n| 1998     | ISO/IEC 14882:1998    | C++98  | 第一个C++标准       |      |\n\n# C++ 环境设置\n\n## 本地环境设置\n\n如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。\n\n## 文本编辑器\n\n这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。\n\n文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。\n\n通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。\n\n在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。\n\n## C++ 编译器\n\n写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。\n\nC++ 编译器用于把源代码编译成最终的可执行程序。\n\n大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。\n\n最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。\n\n以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。\n\n## 安装 GNU 的 C/C++ 编译器\n\n### UNIX/Linux 上的安装\n\n如果您使用的是 **Linux 或 UNIX**，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：\n\n```cpp\n$ g++ -v\n```\n\n如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：\n\n```cpp\nUsing built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix\ngcc version 4.1.2 20080704 (Red Hat 4.1.2-46)\n```\n\n如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。\n\n### Mac OS X 上的安装\n\n如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。\n\nXcode 目前可从 developer.apple.com/technologies/tools/ 上下载。\n\n### Windows 上的安装\n\n为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 www.mingw.org，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。\n\n当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。\n\n添加您安装的 MinGW 的 bin 子目录到您的 **PATH** 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。\n\n当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。\n\n------\n\n## 使用 Visual Studio (Graphical Interface) 编译\n\n1、下载及安装 Visual Studio Community 2015。\n\n2、打开 Visual Studio Community\n\n3、点击 File -> New -> Project\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png)\n\n4、左侧列表选择 Templates -> Visual C++ -> Win32 Console Application，并设置项目名为 MyFirstProgram。\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png)\n\n \n\n5、点击 OK。\n\n6、在以下窗口中点击 Next\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png)\n\n7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：\n\n8、右击文件夹 Source File 并点击 Add --> New Item... :\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png)\n\n9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png)\n\n \n\n10、拷贝以下代码到 main.cpp 中：\n\n```cpp\n#include <iostream>int main(){\n    std::cout << \"Hello World!\\n\";\n    return 0;}\n```\n\n界面如下所示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png)\n\n11、点击菜单上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png)\n\n12、完成以上操作后，你可以看到以下输出：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png)\n\n------\n\n## g++ 应用说明\n\n程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：\n\n```cpp\n$ gcc main.cpp -lstdc++ -o main\n```\n\n下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：\n\n```cpp\n#include <iostream>using namespace std;int main(){\n    cout << \"Hello, world!\" << endl;\n    return 0;}\n```\n\n最简单的编译方式：\n\n```cpp\n$ g++ helloworld.cpp\n```\n\n由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：\n\n```cpp\n$ ./a.outHello, world!\n```\n\n通常我们使用 **-o** 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：\n\n```cpp\n$ g++ helloworld.cpp -o helloworld\n```\n\n执行 helloworld:\n\n```cpp\n$ ./helloworldHello, world!\n```\n\n如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：\n\n```cpp\n$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob\n```\n\n生成一个 runoob 可执行文件。\n\ng++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：\n\n```cpp\ng++ -g -Wall -std=c++11 main.cpp\n```\n\n### g++ 常用命令选项\n\n| 选项         | 解释                                                         |\n| :----------- | :----------------------------------------------------------- |\n| -ansi        | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |\n| -c           | 只编译并生成目标文件。                                       |\n| -DMACRO      | 以字符串\"1\"定义 MACRO 宏。                                   |\n| -DMACRO=DEFN | 以字符串\"DEFN\"定义 MACRO 宏。                                |\n| -E           | 只运行 C 预编译器。                                          |\n| -g           | 生成调试信息。GNU 调试器可利用该信息。                       |\n| -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |\n| -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |\n| -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |\n| -m486        | 针对 486 进行代码优化。                                      |\n| -o           | FILE 生成指定的输出文件。用在生成可执行文件时。              |\n| -O0          | 不进行优化处理。                                             |\n| -O           | 或 -O1 优化生成代码。                                        |\n| -O2          | 进一步优化。                                                 |\n| -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |\n| -shared      | 生成共享目标文件。通常用在建立共享库时。                     |\n| -static      | 禁止使用共享连接。                                           |\n| -UMACRO      | 取消对 MACRO 宏的定义。                                      |\n| -w           | 不生成任何警告信息。                                         |\n| -Wall        | 生成所有警告信息。                                           |\n\n# C++ 基本语法\n\nC++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。\n\n- **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。\n- **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。\n- **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。\n- **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。\n\n## C++ 程序结构\n\n让我们看一段简单的代码，可以输出单词 *Hello World*。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; // main() 是程序开始执行的地方 \n\tint main(){   \n\tcout << \"Hello World\"; // 输出 Hello World   return 0;\n\t}\n```\n\n接下来我们讲解一下上面这段程序：\n\n- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。\n- 行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。\n- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。\n- 下一行 **int main()** 是主函数，程序从这里开始执行。\n- 下一行 **cout << \"Hello World\";** 会在屏幕上显示消息 \"Hello World\"。\n- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。\n\n## 编译 & 执行 C++ 程序\n\n接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：\n\n- 打开一个文本编辑器，添加上述代码。\n- 保存文件为 hello.cpp。\n- 打开命令提示符，进入到保存文件所在的目录。\n- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。\n- 现在，键入 ' a.out' 来运行程序。\n- 您可以看到屏幕上显示 ' Hello World '。\n\n```cpp\n$ g++ hello.cpp$ ./a.outHello World\n```\n\n请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。\n\n您也可以使用 makefile 来编译 C/C++ 程序。\n\n## C++ 中的分号 & 块\n\n在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。\n\n例如，下面是三个不同的语句：\n\n```cpp\nx = y;y = y+1;add(x, y);\n```\n\n块是一组使用大括号括起来的按逻辑连接的语句。例如：\n\n```cpp\n{   cout << \"Hello World\"; // 输出 Hello World   return 0;}\n```\n\nC++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：\n\n```cpp\nx = y;y = y+1;add(x, y);\n```\n\n等同于\n\n```cpp\nx = y; y = y+1; add(x, y);\n```\n\n## C++ 标识符\n\nC++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。\n\nC++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。\n\n下面列出几个有效的标识符：\n\n```cpp\nmohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal\n```\n\n## C++ 关键字\n\n下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。\n\n| asm          | else      | new              | this     |\n| ------------ | --------- | ---------------- | -------- |\n| auto         | enum      | operator         | throw    |\n| bool         | explicit  | private          | true     |\n| break        | export    | protected        | try      |\n| case         | extern    | public           | typedef  |\n| catch        | false     | register         | typeid   |\n| char         | float     | reinterpret_cast | typename |\n| class        | for       | return           | union    |\n| const        | friend    | short            | unsigned |\n| const_cast   | goto      | signed           | using    |\n| continue     | if        | sizeof           | virtual  |\n| default      | inline    | static           | void     |\n| delete       | int       | static_cast      | volatile |\n| do           | long      | struct           | wchar_t  |\n| double       | mutable   | switch           | while    |\n| dynamic_cast | namespace | template         |          |\n\n \n\n## 三字符组\n\n三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。\n\n三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。\n\n三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。\n\n下面列出了最常用的三字符序列：\n\n| 三字符组 | 替换 |\n| :------- | :--- |\n| ??=      | #    |\n| ??/      | \\    |\n| ??'      | ^    |\n| ??(      | [    |\n| ??)      | ]    |\n| ??!      | \\|   |\n| ??<      | {    |\n| ??>      | }    |\n| ??-      | ~    |\n\n如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\"...?\"\"?...\"或者转义序列：\"...?\\?...\"。\n\n从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs\n\ng++仍默认支持三字符组，但会给出编译警告。\n\n## C++ 中的空格\n\n只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。\n\n在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：\n\n```cpp\nint age;\n```\n\n在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：\n\n```cpp\nfruit = apples + oranges;   // 获取水果的总数\n```\n\nfruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。\n\n# C++ 注释\n\n程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。\n\nC++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。\n\nC++ 注释以 /* 开始，以 */ 终止。例如：\n\n```cpp\n/* 这是注释 *//* C++ 注释也可以\n * 跨行\n */\n```\n\n注释也能以 // 开始，直到行末为止。例如：\n\n```cpp\n#include <iostream>using namespace std;main(){\n   cout << \"Hello World\"; // 输出 Hello World\n\n   return 0;}\n```\n\n当上面的代码被编译时，编译器会忽略 **// 输出 Hello World**，最后会产生以下结果：\n\n```cpp\nHello World\n```\n\n在 /* 和 */ 注释内部，// 字符没有特殊的含义。在 // 注释内，/* 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：\n\n```\n \n/* 用于输出 Hello World 的注释\n\ncout << \"Hello World\"; // 输出 Hello World\n\n*/\n```\n\n# C++ 数据类型\n\n使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。\n\n您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。\n\n## 基本的内置类型\n\nC++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：\n\n| 类型     | 关键字  |\n| :------- | :------ |\n| 布尔型   | bool    |\n| 字符型   | char    |\n| 整型     | int     |\n| 浮点型   | float   |\n| 双浮点型 | double  |\n| 无类型   | void    |\n| 宽字符型 | wchar_t |\n\n一些基本类型可以使用一个或多个类型修饰符进行修饰：\n\n- signed\n- unsigned\n- short\n- long\n\n下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。\n\n| 类型               | 位            | 范围                                                    |\n| :----------------- | :------------ | :------------------------------------------------------ |\n| char               | 1 个字节      | -128 到 127 或者 0 到 255                               |\n| unsigned char      | 1 个字节      | 0 到 255                                                |\n| signed char        | 1 个字节      | -128 到 127                                             |\n| int                | 4 个字节      | -2147483648 到 2147483647                               |\n| unsigned int       | 4 个字节      | 0 到 4294967295                                         |\n| signed int         | 4 个字节      | -2147483648 到 2147483647                               |\n| short int          | 2 个字节      | -32768 到 32767                                         |\n| unsigned short int | 2 个字节      | 0 到 65,535                                             |\n| signed short int   | 2 个字节      | -32768 到 32767                                         |\n| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |\n| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |\n| unsigned long int  | 8 个字节      | 0 to 18,446,744,073,709,551,615                         |\n| float              | 4 个字节      | +/- 3.4e +/- 38 (~7 个数字)                             |\n| double             | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |\n| long double        | 8 个字节      | +/- 1.7e +/- 308 (~15 个数字)                           |\n| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                              |\n\n从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。\n\n下面实例会输出您电脑上各种数据类型的大小。\n\n```cpp\n#include <iostream>using namespace std;int main(){   \n\tcout << \"Size of char : \" << sizeof(char) << endl;   \n\tcout << \"Size of int : \" << sizeof(int) << endl;  \n\tcout << \"Size of short int : \" << sizeof(short int) << endl;  \n\tcout << \"Size of long int : \" << sizeof(long int) << endl;   \n\tcout << \"Size of float : \" << sizeof(float) << endl;   \n\tcout << \"Size of double : \" << sizeof(double) << endl;  \n\tcout << \"Size of wchar_t : \" << sizeof(wchar_t) << endl;   return 0;\n}\n```\n\n本实例使用了 **endl**，这将在每一行后插入一个换行符，<< 运算符用于向屏幕传多个值。我们也使用 **sizeof()** 函数来获取各种数据类型的大小。\n\n当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：\n\n```cpp\nSize of char : 1Size of int : 4Size of short int : 2Size of long int : 8Size of float : 4Size of double : 8Size of wchar_t : 4\n```\n\n## typedef 声明\n\n您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\n\n```cpp\ntypedef type newname;\n```\n\n例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\n\n```cpp\ntypedef int feet;\n```\n\n现在，下面的声明是完全合法的，它创建了一个整型变量 distance：\n\n```cpp\nfeet distance;\n```\n\n## 枚举类型\n\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n\n```cpp\nenum enum-name { list of names } var-list;\n```\n\n在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。\n\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。\n\n```cpp\nenum color { red, green, blue } c;c = blue;\n```\n\n默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5。\n\n```cpp\nenum color { red, green=5, blue };\n```\n\n在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。\n\n# C++ 变量类型\n\n变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。\n\n变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。\n\n基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：\n\n| 类型    | 描述                                               |\n| :------ | :------------------------------------------------- |\n| bool    | 存储值 true 或 false。                             |\n| char    | 通常是一个八位字节（一个字节）。这是一个整数类型。 |\n| int     | 对机器而言，整数的最自然的大小。                   |\n| float   | 单精度浮点值。                                     |\n| double  | 双精度浮点值。                                     |\n| void    | 表示类型的缺失。                                   |\n| wchar_t | 宽字符类型。                                       |\n\nC++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等，这将会在后续的章节中进行讲解。\n\n下面我们将讲解如何定义、声明和使用各种类型的变量。\n\n## C++ 中的变量定义\n\n变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：\n\n```cpp\ntype variable_list;\n```\n\n在这里，**type** 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：\n\n```cpp\nint    i, j, k;char   c, ch;float  f, salary;double d;\n```\n\n行 **int i, j, k;** 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。\n\n变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：\n\n```cpp\ntype variable_name = value;\n```\n\n下面列举几个实例：\n\n```cpp\nextern int d = 3, f = 5;   \n\t// d 和 f 的声明 int d = 3, f = 5;          \n\t// 定义并初始化 d 和 fbyte z = 22;               \n\t// 定义并初始化 zchar x = 'x';              \n\t// 变量 x 的值为 'x'\n```\n\n不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。\n\n## C++ 中的变量声明\n\n变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n\n当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。\n\n## 实例\n\n尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：\n\n```cpp\n#include <iostream>using namespace std;// 变量声明extern int a, b;extern int c;extern float f;\n  int main (){\n  // 变量定义\n  int a, b;\n  int c;\n  float f;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n \n  cout << c << endl ;\n\n  f = 70.0/3.0;\n  cout << f << endl ;\n \n  return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n3023.3333\n```\n\n同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：\n\n```cpp\n// 函数声明int func();int main(){\n    // 函数调用\n    int i = func();}// 函数定义int func(){\n    return 0;}\n```\n\n## C++ 中的左值（Lvalues）和右值（Rvalues）\n\nC++ 中有两种类型的表达式：\n\n- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\n\n```cpp\nint g = 20;\n```\n\n但是下面这个就不是一个有效的语句，会生成编译时错误：\n\n```cpp\n10 = 20;\n```\n\n# C++ 变量作用域\n\n作用域是程序的一个区域，一般来说有三个地方可以声明变量：\n\n- 在函数或一个代码块内部声明的变量，称为局部变量。\n- 在函数参数的定义中声明的变量，称为形式参数。\n- 在所有函数外部声明的变量，称为全局变量。\n\n我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。\n\n## 局部变量\n\n在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n  // 局部变量声明\n  int a, b;\n  int c;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n \n  cout << c;\n \n  return 0;}\n```\n\n## 全局变量\n\n在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n```cpp\n#include <iostream>using namespace std;\n // 全局变量声明int g;\n int main (){\n  // 局部变量声明\n  int a, b;\n \n  // 实际初始化\n  a = 10;\n  b = 20;\n  g = a + b;\n \n  cout << g;\n \n  return 0;}\n```\n\n在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：\n\n```cpp\n#include <iostream>using namespace std;\n // 全局变量声明int g = 20;\n int main (){\n  // 局部变量声明\n  int g = 10;\n \n  cout << g;\n \n  return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n10\n```\n\n## 初始化局部变量和全局变量\n\n当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：\n\n| 数据类型 | 初始化默认值 |\n| :------- | :----------- |\n| int      | 0            |\n| char     | '\\0'         |\n| float    | 0            |\n| double   | 0            |\n| pointer  | NULL         |\n\n正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。\n\n# C++ 常量\n\n常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。\n\n常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。\n\n常量就像是常规的变量，只不过常量的值在定义后不能进行修改。\n\n## 整数常量\n\n整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n\n下面列举几个整数常量的实例：\n\n```cpp\n212         // 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀\n```\n\n以下是各种类型的整数常量的实例：\n\n```cpp\n85         // 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数\n```\n\n## 浮点常量\n\n浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n\n下面列举几个浮点常量的实例：\n\n```cpp\n3.14159       // 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数\n```\n\n## 布尔常量\n\n布尔常量共有两个，它们都是标准的 C++ 关键字：\n\n- **true** 值代表真。\n- **false** 值代表假。\n\n我们不应把 true 的值看成 1，把 false 的值看成 0。\n\n## 字符常量\n\n字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。\n\n字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\\t'），或一个通用的字符（例如 '\\u02C0'）。\n\n在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：\n\n| 转义序列   | 含义                       |\n| :--------- | :------------------------- |\n| \\\\         | \\ 字符                     |\n| \\'         | ' 字符                     |\n| \\\"         | \" 字符                     |\n| \\?         | ? 字符                     |\n| \\a         | 警报铃声                   |\n| \\b         | 退格键                     |\n| \\f         | 换页符                     |\n| \\n         | 换行符                     |\n| \\r         | 回车                       |\n| \\t         | 水平制表符                 |\n| \\v         | 垂直制表符                 |\n| \\ooo       | 一到三位的八进制数         |\n| \\xhh . . . | 一个或多个数字的十六进制数 |\n\n下面的实例显示了一些转义序列字符：\n\n```cpp\n#include <iostream>using namespace std;int main(){   cout << \"Hello\\tWorld\\n\\n\";   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nHello   World\n```\n\n## 字符串常量\n\n字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。\n\n您可以使用空格做分隔符，把一个很长的字符串常量进行分行。\n\n下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。\n\n```cpp\n\"quot;hello, dear\"\"hello, \\dear\"\"hello, \" \"d\" \"ear\"\n```\n\n## 定义常量\n\n在 C++ 中，有两种简单的定义常量的方式：\n\n- 使用 **#define** 预处理器。\n- 使用 **const** 关键字。\n\n## #define 预处理器\n\n下面是使用 #define 预处理器定义常量的形式：\n\n```cpp\n#define identifier value\n```\n\n具体请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;#define LENGTH 10   #define WIDTH  5#define NEWLINE '\\n'int main(){\n\n   int area;  \n   \n   area = LENGTH * WIDTH;\n   cout << area;\n   cout << NEWLINE;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n50\n```\n\n## const 关键字\n\n您可以使用 **const** 前缀声明指定类型的常量，如下所示：\n\n```cpp\nconst type variable = value;\n```\n\n具体请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;int main(){\n   const int  LENGTH = 10;\n   const int  WIDTH  = 5;\n   const char NEWLINE = '\\n';\n   int area;  \n   \n   area = LENGTH * WIDTH;\n   cout << area;\n   cout << NEWLINE;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n50\n```\n\n请注意，把常量定义为大写字母形式，是一个很好的编程实践。\n\n# C++ 修饰符类型\n\nC++ 允许在 **char、int 和 double** 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。\n\n下面列出了数据类型修饰符：\n\n- signed\n- unsigned\n- long\n- short\n\n修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。\n\n修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。\n\nC++ 允许使用速记符号来声明**无符号短整数**或**无符号长整数**。您可以不写 int，只写单词 **unsigned、short** 或 **unsigned、long**，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。\n\n```cpp\nunsigned x;\nunsigned int y;\n```\n\n为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：\n\n```cpp\n#include <iostream>\nusing namespace std;\n \n/* \n * 这个程序演示了有符号整数和无符号整数之间的差别\n*/\nint main()\n{\n   short int i;           // 有符号短整数\n   short unsigned int j;  // 无符号短整数\n\n   j = 50000;\n\n   i = j;\n   cout << i << \" \" << j;\n\n   return 0;\n}\n```\n\n当上面的程序运行时，会输出下列结果：\n\n```cpp\n-15536 50000\n```\n\n上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。\n\n## C++ 中的类型限定符\n\n类型限定符提供了变量的额外信息。\n\n| 限定符   | 含义                                                         |\n| :------- | :----------------------------------------------------------- |\n| const    | **const** 类型的对象在程序执行期间不能被修改改变。           |\n| volatile | 修饰符 **volatile** 告诉编译器，变量的值可能以程序未明确指定的方式被改变。 |\n| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |\n\n# C++ 存储类\n\n存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：\n\n- auto\n- register\n- static\n- extern\n- mutable\n- thread_local (C++11)\n\n从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。\n\n## auto 存储类\n\n自 C++ 11 以来，**auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\n\nC++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。\n\n根据初始化表达式自动推断被声明的变量的类型，如：\n\nauto f=3.14;    //doubleauto s(\"hello\");  //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n\n## register 存储类\n\n**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。\n\n{  register int miles;}\n\n寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。\n\n## static 存储类\n\n**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\n\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n\n在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。\n\n## 实例\n\n```cpp\n#include <iostream>\n // 函数声明 void func(void); \nstatic int count = 10; /* 全局变量 */\n int main(){\n    while(count--)\n    {\n       func();    }\n    return 0;}// 函数定义void func( void ){\n    static int i = 5; // 局部静态变量\n    i++;    std::cout << \"变量 i 为 \" << i ;    std::cout << \" , 变量 count 为 \" << count << std::endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n变量 i 为 6 , 变量 count 为 9变量 i 为 7 , 变量 count 为 8变量 i 为 8 , 变量 count 为 7变量 i 为 9 , 变量 count 为 6变量 i 为 10 , 变量 count 为 5变量 i 为 11 , 变量 count 为 4变量 i 为 12 , 变量 count 为 3变量 i 为 13 , 变量 count 为 2变量 i 为 14 , 变量 count 为 1变量 i 为 15 , 变量 count 为 0\n```\n\n## extern 存储类\n\n**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。\n\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：\n\n第一个文件：main.cpp\n\n## 实例\n\n```cpp\n#include <iostream>\n int count ;extern void write_extern(); \nint main(){\n   count = 5;   write_extern();}\n```\n\n第二个文件：support.cpp\n\n## 实例\n\n```cpp\n#include <iostream>\n extern int count; \nvoid write_extern(void){\n   std::cout << \"Count is \" << count << std::endl;}\n```\n\n在这里，第二个文件中的 *extern* 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：\n\n```cpp\n$ g++ main.cpp support.cpp -o write\n```\n\n这会产生 **write** 可执行程序，尝试执行 **write**，它会产生下列结果：\n\n```cpp\n$ ./writeCount is 5\n```\n\n## mutable 存储类\n\n**mutable** 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。\n\n## thread_local 存储类\n\n使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\n\nthread_local 说明符可以与 static 或 extern 合并。\n\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n\n以下演示了可以被声明为 thread_local 的变量：\n\n```cpp\nthread_local int x;  // 命名空间下的全局变量class X{\n    static thread_local std::string s; // 类的static成员变量};static thread_local std::string X::s;  // X::s 是需要定义的\n void foo(){\n    thread_local std::vector<int> v;  // 本地变量}\n```\n\n# C++ 运算符\n\n运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：\n\n- 算术运算符\n- 关系运算符\n- 逻辑运算符\n- 位运算符\n- 赋值运算符\n- 杂项运算符\n\n本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。\n\n## 算术运算符\n\n下表显示了 C++ 支持的算术运算符。\n\n假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n| 运算符 | 描述                                                         | 实例             |\n| :----- | :----------------------------------------------------------- | :--------------- |\n| +      | 把两个操作数相加                                             | A + B 将得到 30  |\n| -      | 从第一个操作数中减去第二个操作数                             | A - B 将得到 -10 |\n| *      | 把两个操作数相乘                                             | A * B 将得到 200 |\n| /      | 分子除以分母                                                 | B / A 将得到 2   |\n| %      | 取模运算符，整除后的余数                                     | B % A 将得到 0   |\n| ++     | [自增运算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整数值增加 1 | A++ 将得到 11    |\n| --     | [自减运算符](https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html)，整数值减少 1 | A-- 将得到 9     |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的算术运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int b = 10;   int c ; \n   c = a + b;   cout << \"Line 1 - c 的值是 \" << c << endl ;   c = a - b;   cout << \"Line 2 - c 的值是 \" << c << endl ;   c = a * b;   cout << \"Line 3 - c 的值是 \" << c << endl ;   c = a / b;   cout << \"Line 4 - c 的值是 \" << c << endl ;   c = a % b;   cout << \"Line 5 - c 的值是 \" << c << endl ; \n   int d = 10;   //  测试自增、自减\n   c = d++;   cout << \"Line 6 - c 的值是 \" << c << endl ; \n   d = 10;    // 重新赋值\n   c = d--;   cout << \"Line 7 - c 的值是 \" << c << endl ;   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - c 的值是 31Line 2 - c 的值是 11Line 3 - c 的值是 210Line 4 - c 的值是 2Line 5 - c 的值是 1Line 6 - c 的值是 10Line 7 - c 的值是 10\n```\n\n## 关系运算符\n\n下表显示了 C++ 支持的关系运算符。\n\n假设变量 A 的值为 10，变量 B 的值为 20，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |\n| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |\n| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |\n| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |\n| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |\n| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的关系运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int b = 10;   int c ; \n   if( a == b )\n   {\n      cout << \"Line 1 - a 等于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 1 - a 不等于 b\" << endl ;   }\n   if ( a < b )\n   {\n      cout << \"Line 2 - a 小于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 2 - a 不小于 b\" << endl ;   }\n   if ( a > b )\n   {\n      cout << \"Line 3 - a 大于 b\" << endl ;   }\n   else\n   {\n      cout << \"Line 3 - a 不大于 b\" << endl ;   }\n   /* 改变 a 和 b 的值 */\n   a = 5;   b = 20;   if ( a <= b )\n   {\n      cout << \"Line 4 - a 小于或等于 b\" << endl ;   }\n   if ( b >= a )\n   {\n      cout << \"Line 5 - b 大于或等于 a\" << endl ;   }\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - a 不等于 bLine 2 - a 不小于 bLine 3 - a 大于 bLine 4 - a 小于或等于 bLine 5 - b 大于或等于 a\n```\n\n## 逻辑运算符\n\n下表显示了 C++ 支持的关系逻辑运算符。\n\n假设变量 A 的值为 1，变量 B 的值为 0，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |\n| \\|\\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \\|\\| B) 为真。 |\n| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的逻辑运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 5;   int b = 20;   int c ; \n   if ( a && b )\n   {\n      cout << \"Line 1 - 条件为真\"<< endl ;   }\n   if ( a || b )\n   {\n      cout << \"Line 2 - 条件为真\"<< endl ;   }\n   /* 改变 a 和 b 的值 */\n   a = 0;   b = 10;   if ( a && b )\n   {\n      cout << \"Line 3 - 条件为真\"<< endl ;   }\n   else\n   {\n      cout << \"Line 4 - 条件不为真\"<< endl ;   }\n   if ( !(a && b) )\n   {\n      cout << \"Line 5 - 条件为真\"<< endl ;   }\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - 条件为真Line 2 - 条件为真Line 4 - 条件不为真Line 5 - 条件为真\n```\n\n## 位运算符\n\n位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：\n\n| p    | q    | p & q | p \\| q | p ^ q |\n| :--- | :--- | :---- | :----- | :---- |\n| 0    | 0    | 0     | 0      | 0     |\n| 0    | 1    | 0     | 1      | 1     |\n| 1    | 1    | 1     | 1      | 0     |\n| 1    | 0    | 0     | 1      | 1     |\n\n假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：\n\nA = 0011 1100\n\nB = 0000 1101\n\n\\-----------------\n\nA&B = 0000 1100\n\nA|B = 0011 1101\n\nA^B = 0011 0001\n\n~A = 1100 0011\n\n下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n\n| 运算符 | 描述                                                         | 实例                                                         |\n| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100                            |\n| \\|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。   | (A \\| B) 将得到 61，即为 0011 1101                           |\n| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001                            |\n| ~      | 二进制补码运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |\n| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。   | A << 2 将得到 240，即为 1111 0000                            |\n| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。   | A >> 2 将得到 15，即为 0000 1111                             |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的位运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   unsigned int a = 60;      // 60 = 0011 1100  \n   unsigned int b = 13;      // 13 = 0000 1101\n   int c = 0;           \n \n   c = a & b;             // 12 = 0000 1100\n   cout << \"Line 1 - c 的值是 \" << c << endl ; \n   c = a | b;             // 61 = 0011 1101\n   cout << \"Line 2 - c 的值是 \" << c << endl ; \n   c = a ^ b;             // 49 = 0011 0001\n   cout << \"Line 3 - c 的值是 \" << c << endl ; \n   c = ~a;                // -61 = 1100 0011\n   cout << \"Line 4 - c 的值是 \" << c << endl ; \n   c = a << 2;            // 240 = 1111 0000\n   cout << \"Line 5 - c 的值是 \" << c << endl ; \n   c = a >> 2;            // 15 = 0000 1111\n   cout << \"Line 6 - c 的值是 \" << c << endl ; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```\n \nLine 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15\n```\n\n## 赋值运算符\n\n下表列出了 C++ 支持的赋值运算符：\n\n| 运算符 | 描述                                                         | 实例                            |\n| :----- | :----------------------------------------------------------- | :------------------------------ |\n| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |\n| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |\n| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |\n| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |\n| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |\n| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |\n| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |\n| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |\n| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |\n| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |\n| \\|=    | 按位或且赋值运算符                                           | C \\|= 2 等同于 C = C \\| 2       |\n\n### 实例\n\n请看下面的实例，了解 C++ 中可用的赋值运算符。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 21;   int c ; \n   c =  a;   cout << \"Line 1 - =  运算符实例，c 的值 = : \" <<c<< endl ; \n   c +=  a;   cout << \"Line 2 - += 运算符实例，c 的值 = : \" <<c<< endl ; \n   c -=  a;   cout << \"Line 3 - -= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c *=  a;   cout << \"Line 4 - *= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c /=  a;   cout << \"Line 5 - /= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c  = 200;   c %=  a;   cout << \"Line 6 - %= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c <<=  2;   cout << \"Line 7 - <<= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c >>=  2;   cout << \"Line 8 - >>= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c &=  2;   cout << \"Line 9 - &= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c ^=  2;   cout << \"Line 10 - ^= 运算符实例，c 的值 = : \" <<c<< endl ; \n   c |=  2;   cout << \"Line 11 - |= 运算符实例，c 的值 = : \" <<c<< endl ; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\nLine 1 - =  运算符实例，c 的值 = 21Line 2 - += 运算符实例，c 的值 = 42Line 3 - -= 运算符实例，c 的值 = 21Line 4 - *= 运算符实例，c 的值 = 441Line 5 - /= 运算符实例，c 的值 = 21Line 6 - %= 运算符实例，c 的值 = 11Line 7 - <<= 运算符实例，c 的值 = 44Line 8 - >>= 运算符实例，c 的值 = 11Line 9 - &= 运算符实例，c 的值 = 2Line 10 - ^= 运算符实例，c 的值 = 0Line 11 - |= 运算符实例，c 的值 = 2\n```\n\n## 杂项运算符\n\n下表列出了 C++ 支持的其他一些重要的运算符。\n\n| 运算符               | 描述                                                         |\n| :------------------- | :----------------------------------------------------------- |\n| sizeof               | [sizeof 运算符](https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html)返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |\n| Condition ? X : Y    | [条件运算符](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 |\n| ,                    | [逗号运算符](https://edu.aliyun.com/cplusplus/cpp-comma-operator.html)会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |\n| .（点）和 ->（箭头） | [成员运算符](https://edu.aliyun.com/cplusplus/cpp-member-operators.html)用于引用类、结构和共用体的成员。 |\n| Cast                 | [强制转换运算符](https://edu.aliyun.com/cplusplus/cpp-casting-operators.html)把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |\n| &                    | [指针运算符 &](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 返回变量的地址。例如 &a; 将给出变量的实际地址。 |\n| *                    | [指针运算符 *](https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html) 指向一个变量。例如，*var; 将指向变量 var。 |\n\n## C++ 中的运算符优先级\n\n运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。\n\n例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。\n\n下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n\n| 类别       | 运算符                            | 结合性   |\n| :--------- | :-------------------------------- | :------- |\n| 后缀       | () [] -> . ++ - -                 | 从左到右 |\n| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |\n| 乘除       | * / %                             | 从左到右 |\n| 加减       | + -                               | 从左到右 |\n| 移位       | << >>                             | 从左到右 |\n| 关系       | < <= > >=                         | 从左到右 |\n| 相等       | == !=                             | 从左到右 |\n| 位与 AND   | &                                 | 从左到右 |\n| 位异或 XOR | ^                                 | 从左到右 |\n| 位或 OR    | \\|                                | 从左到右 |\n| 逻辑与 AND | &&                                | 从左到右 |\n| 逻辑或 OR  | \\|\\|                              | 从左到右 |\n| 条件       | ?:                                | 从右到左 |\n| 赋值       | = += -= *= /= %=>>= <<= &= ^= \\|= | 从右到左 |\n| 逗号       | ,                                 | 从左到右 |\n\n### 实例\n\n请看下面的实例，了解 C++ 中运算符的优先级。\n\n复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。\n\n对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。\n\n## 实例\n\n```cpp\n#include <iostream>using namespace std; \nint main(){\n   int a = 20;   int b = 10;   int c = 15;   int d = 5;   int e; \n   e = (a + b) * c / d;      // ( 30 * 15 ) / 5\n   cout << \"(a + b) * c / d 的值是 \" << e << endl ; \n   e = ((a + b) * c) / d;    // (30 * 15 ) / 5\n   cout << \"((a + b) * c) / d 的值是 \" << e << endl ; \n   e = (a + b) * (c / d);   // (30) * (15/5)\n   cout << \"(a + b) * (c / d) 的值是 \" << e << endl ; \n   e = a + (b * c) / d;     //  20 + (150/5)\n   cout << \"a + (b * c) / d 的值是 \" << e << endl ;  \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生以下结果：\n\n```cpp\n(a + b) * c / d 的值是 90((a + b) * c) / d 的值是 90(a + b) * (c / d) 的值是 90a + (b * c) / d 的值是 50\n```\n\n# C++ 循环\n\n有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。\n\n编程语言提供了允许更为复杂的执行路径的多种控制结构。\n\n循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png)\n\n## 循环类型\n\nC++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。\n\n| 循环类型        | 描述                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| while 循环      | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |\n| for 循环        | 多次执行一个语句序列，简化管理循环变量的代码。               |\n| do...while 循环 | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |\n| 嵌套循环        | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |\n\n \n\n## 循环控制语句\n\n循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。\n\nC++ 提供了下列的控制语句。点击链接查看每个语句的细节。\n\n| 控制语句      | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| break 语句    | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |\n| continue 语句 | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |\n| goto 语句     | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 |\n\n \n\n## 无限循环\n\n如果条件永远不为假，则循环将变成无限循环。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n\n   for( ; ; )\n   {\n      printf(\"This loop will run forever.\\n\");\n   }\n\n   return 0;}\n```\n\n当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。\n\n**注意：**您可以按 Ctrl + C 键终止一个无限循环。\n\n# C++ 判断\n\n判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。\n\n下面是大多数编程语言中典型的判断结构的一般形式：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png)\n\n## 判断语句\n\nC++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。\n\n| 语句             | 描述                                                         |\n| :--------------- | :----------------------------------------------------------- |\n| if 语句          | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |\n| if...else 语句   | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |\n| 嵌套 if 语句     | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |\n| switch 语句      | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |\n| 嵌套 switch 语句 | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |\n\n \n\n## ? : 运算符\n\n我们已经在前面的章节中讲解了 [**条件运算符 ? :**](https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html)，可以用来替代 **if...else** 语句。它的一般形式如下：\n\n```cpp\nExp1 ? Exp2 : Exp3;\n```\n\n其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。\n\n? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。\n\n# C++ 函数\n\n函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。\n\n您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。\n\n函数**声明**告诉编译器函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。\n\nC++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。\n\n函数还有很多叫法，比如方法、子例程或程序，等等。\n\n## 定义函数\n\nC++ 中的函数定义的一般形式如下：\n\n```cpp\nreturn_type function_name( parameter list ){   body of the function}\n```\n\n在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：\n\n- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。\n- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数主体：**函数主体包含一组定义函数执行任务的语句。\n\n## 实例\n\n以下是 **max()** 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：\n\n```cpp\n// 函数返回两个数中较大的那个数 int max(int num1, int num2) {   // 局部变量声明   int result;    if (num1 > num2)      result = num1;   else      result = num2;    return result; }\n```\n\n## 函数声明\n\n函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n\n函数声明包括以下几个部分：\n\n```cpp\nreturn_type function_name( parameter list );\n```\n\n针对上面定义的函数 max()，以下是函数声明：\n\n```cpp\nint max(int num1, int num2);\n```\n\n在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：\n\n```cpp\nint max(int, int);\n```\n\n当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。\n\n## 调用函数\n\n创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。\n\n当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。\n\n调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：\n\n```cpp\n#include <iostream>using namespace std;\n // 函数声明int max(int num1, int num2);\n int main (){\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int ret;\n \n   // 调用函数来获取最大值\n   ret = max(a, b);\n \n   cout << \"Max value is : \" << ret << endl;\n \n   return 0;}\n // 函数返回两个数中较大的那个数int max(int num1, int num2) {\n   // 局部变量声明\n   int result;\n \n   if (num1 > num2)\n      result = num1;\n   else\n      result = num2;\n \n   return result; }\n```\n\n把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：\n\n```cpp\nMax value is : 200\n```\n\n## 函数参数\n\n如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。\n\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n当调用函数时，有两种向函数传递参数的方式：\n\n| 调用类型                                                     | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [传值调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |\n| [指针调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n| [引用调用](https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n\n默认情况下，C++ 使用**传值调用**来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。\n\n## 参数的默认值\n\n当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。\n\n这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;\n int sum(int a, int b=20){\n  int result;\n\n  result = a + b;\n  \n  return (result);}int main (){\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int result;\n \n   // 调用函数来添加值\n   result = sum(a, b);\n   cout << \"Total value is :\" << result << endl;\n\n   // 再次调用函数\n   result = sum(a);\n   cout << \"Total value is :\" << result << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal value is :300Total value is :120\n```\n\n------\n\n## Lambda 函数与表达式\n\nC++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。\n\nLambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。\n\nLambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:\n\n```cpp\n[capture](parameters)->return-type{body}\n```\n\n例如：\n\n```\n \n[](int x, int y){ return x < y ; }\n```\n\n如果没有参数可以表示为：\n\n```cpp\n[capture](parameters){body}\n```\n\n例如：\n\n```cpp\n[]{ ++global_x; }\n```\n\n在一个更为复杂的例子中，返回类型可以被明确的指定如下：\n\n```cpp\n[](int x, int y) -> int { int z = x + y; return z + x; }\n```\n\n本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。\n\n如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。\n\n在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：\n\n```cpp\n[]      // 沒有定义任何变量。使用未定义变量会引发错误。[x, &y] // x以传值方式传入（默认），y以引用方式传入。[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n```\n\n另外有一点需要注意。对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：\n\n```cpp\n[this]() { this->someFunc(); }();\n```\n\n# C++ 数字\n\n通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。\n\n## C++ 定义数字\n\n我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n   // 数字定义\n   short  s;\n   int    i;\n   long   l;\n   float  f;\n   double d;\n   \n   // 数字赋值\n   s = 10;      \n   i = 1000;    \n   l = 1000000; \n   f = 230.47;  \n   d = 30949.374;\n   \n   // 数字输出\n   cout << \"short  s :\" << s << endl;\n   cout << \"int    i :\" << i << endl;\n   cout << \"long   l :\" << l << endl;\n   cout << \"float  f :\" << f << endl;\n   cout << \"double d :\" << d << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nshort  s :10int    i :1000long   l :1000000float  f :230.47double d :30949.4\n```\n\n## C++ 数学运算\n\n在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做**内置**函数。您可以在程序中引用这些函数。\n\nC++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。\n\n为了利用这些函数，您需要引用数学头文件 **<cmath>**。\n\n| 序号 | 函数 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **double cos(double);** 该函数返回弧度角（double 型）的余弦。 |\n| 2    | **double sin(double);** 该函数返回弧度角（double 型）的正弦。 |\n| 3    | **double tan(double);** 该函数返回弧度角（double 型）的正切。 |\n| 4    | **double log(double);** 该函数返回参数的自然对数。           |\n| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |\n| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |\n| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |\n| 8    | **int abs(int);** 该函数返回整数的绝对值。                   |\n| 9    | **double fabs(double);** 该函数返回任意一个十进制数的绝对值。 |\n| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。 |\n\n下面是一个关于数学运算的简单实例：\n\n```cpp\n#include <iostream>#include <cmath>using namespace std;\n int main (){\n   // 数字定义\n   short  s = 10;\n   int    i = -1000;\n   long   l = 100000;\n   float  f = 230.47;\n   double d = 200.374;\n\n   // 数学运算\n   cout << \"sin(d) :\" << sin(d) << endl;\n   cout << \"abs(i)  :\" << abs(i) << endl;\n   cout << \"floor(d) :\" << floor(d) << endl;\n   cout << \"sqrt(f) :\" << sqrt(f) << endl;\n   cout << \"pow( d, 2) :\" << pow(d, 2) << endl;\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nsign(d) :-0.634939abs(i)  :1000floor(d) :200sqrt(f) :15.1812pow( d, 2 ) :40149.7\n```\n\n## C++ 随机数\n\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。\n\n下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：\n\n```cpp\n#include <iostream>#include <ctime>#include <cstdlib>using namespace std;\n int main (){\n   int i,j;\n \n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n随机数： 1748144778随机数： 630873888随机数： 2134540646随机数： 219404170随机数： 902129458随机数： 920445370随机数： 1319072661随机数： 257938873随机数： 1256201101随机数： 580322989\n```\n\n# C++ 数组\n\nC++ 支持**数组**数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。\n\n数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。\n\n所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。\n\n## 声明数组\n\n在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：\n\n```cpp\ntype arrayName [ arraySize ];\n```\n\n这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：\n\n```cpp\ndouble balance[10];\n```\n\n现在 *balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。\n\n## 初始化数组\n\n在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：\n\n```cpp\ndouble balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};\n```\n\n大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。\n\n如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：\n\n```cpp\ndouble balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};\n```\n\n您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：\n\n```cpp\nbalance[4] = 50.0;\n```\n\n上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：\n\n![数组表示](https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg)\n\n## 访问数组元素\n\n数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：\n\n```cpp\ndouble salary = balance[9];\n```\n\n上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：\n\n```cpp\n#include <iostream>using namespace std;\n #include <iomanip>using std::setw;\n int main (){\n   int n[ 10 ]; // n 是一个包含 10 个整数的数组\n \n   // 初始化数组元素          \n   for ( int i = 0; i < 10; i++ )\n   {\n      n[ i ] = i + 100; // 设置元素 i 为 i + 100\n   }\n   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n \n   // 输出数组中每个元素的值                     \n   for ( int j = 0; j < 10; j++ )\n   {\n      cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;\n   }\n \n   return 0;}\n```\n\n上面的程序使用了 **setw()** 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nElement        Value\n      0          100\n      1          101\n      2          102\n      3          103\n      4          104\n      5          105\n      6          106\n      7          107\n      8          108\n      9          109\n```\n\n## C++ 中数组详解\n\n在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：\n\n| 概念           | 描述                                                         |\n| :------------- | :----------------------------------------------------------- |\n| 多维数组       | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |\n| 指向数组的指针 | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |\n| 传递数组给函数 | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |\n| 从函数返回数组 | C++ 允许从函数返回数组。                                     |\n\n# C++ 字符串\n\nC++ 提供了以下两种类型的字符串表示形式：\n\n- C 风格字符串\n- C++ 引入的 string 类类型\n\n## C 风格字符串\n\nC 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 **null** 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n\n下面的声明和初始化创建了一个 \"Hello\" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 \"Hello\" 的字符数多一个。\n\n```cpp\nchar greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n```\n\n依据数组初始化规则，您可以把上面的语句写成以下语句：\n\n```cpp\nchar greeting[] = \"Hello\";\n```\n\n以下是 C/C++ 中定义的字符串的内存表示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg)\n\n其实，您不需要把 *null* 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\\0' 放在字符串的末尾。让我们尝试输出上面的字符串：\n\n## 实例\n\n```cpp\n#include <iostream>\n using namespace std; \nint main (){\n   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; \n   cout << \"Greeting message: \";   cout << greeting << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nGreeting message: Hello\n```\n\nC++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:\n\n| 序号 | 函数 & 目的                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |\n| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |\n| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |\n| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |\n| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n下面的实例使用了上述的一些函数：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std; \nint main (){\n   char str1[11] = \"Hello\";   char str2[11] = \"World\";   char str3[11];   int  len ; \n   // 复制 str1 到 str3\n   strcpy( str3, str1);   cout << \"strcpy( str3, str1) : \" << str3 << endl; \n   // 连接 str1 和 str2\n   strcat( str1, str2);   cout << \"strcat( str1, str2): \" << str1 << endl; \n   // 连接后，str1 的总长度\n   len = strlen(str1);   cout << \"strlen(str1) : \" << len << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstrcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10\n```\n\n## C++ 中的 String 类\n\nC++ 标准库提供了 **string** 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：\n\n现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。\n\n## 实例\n\n```cpp\n#include <iostream>#include <string>\n using namespace std; \nint main (){\n   string str1 = \"Hello\";   string str2 = \"World\";   string str3;   int  len ; \n   // 复制 str1 到 str3\n   str3 = str1;   cout << \"str3 : \" << str3 << endl; \n   // 连接 str1 和 str2\n   str3 = str1 + str2;   cout << \"str1 + str2 : \" << str3 << endl; \n   // 连接后，str3 的总长度\n   len = str3.size();   cout << \"str3.size() :  \" << len << endl; \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstr3 : Hellostr1 + str2 : HelloWorldstr3.size() :  10\n```\n\n# C++ 指针\n\n学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。\n\n正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   int  var1;\n   char var2[10];\n\n   cout << \"var1 变量的地址： \";\n   cout << &var1 << endl;\n\n   cout << \"var2 变量的地址： \";\n   cout << &var2 << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nvar1 变量的地址： 0xbfebd5c0var2 变量的地址： 0xbfebd5b6\n```\n\n通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。\n\n## 什么是指针？\n\n**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：\n\n```cpp\ntype *var-name;\n```\n\n在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：\n\n```cpp\nint    *ip;    /* 一个整型的指针 */double *dp;    /* 一个 double 型的指针 */float  *fp;    /* 一个浮点型的指针 */char   *ch;    /* 一个字符型的指针 */\n```\n\n所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n\n## C++ 中使用指针\n\n使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   int  var = 20;   // 实际变量的声明\n   int  *ip;        // 指针变量的声明\n\n   ip = &var;       // 在指针变量中存储 var 的地址\n\n   cout << \"Value of var variable: \";\n   cout << var << endl;\n\n   // 输出在指针变量中存储的地址\n   cout << \"Address stored in ip variable: \";\n   cout << ip << endl;\n\n   // 访问指针中地址的值\n   cout << \"Value of *ip variable: \";\n   cout << *ip << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of var variable: 20Address stored in ip variable: 0xbfc601acValue of *ip variable: 20\n```\n\n## C++ 指针详解\n\n在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：\n\n| 概念               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| C++ Null 指针      | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |\n| C++ 指针的算术运算 | 可以对指针进行四种算术运算：++、--、+、-                     |\n| C++ 指针 vs 数组   | 指针和数组之间有着密切的关系。                               |\n| C++ 指针数组       | 可以定义用来存储指针的数组。                                 |\n| C++ 指向指针的指针 | C++ 允许指向指针的指针。                                     |\n| C++ 传递指针给函数 | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |\n| C++ 从函数返回指针 | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |\n\n# C++ 引用\n\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n\n## C++ 引用 vs 指针\n\n引用很容易与指针混淆，它们之间有三个主要的不同：\n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n## C++ 中创建引用\n\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：\n\n```cpp\nint i = 17;\n```\n\n我们可以为 i 声明引用变量，如下所示：\n\n```cpp\nint&    r = i;\n```\n\n在这些声明中，& 读作**引用**。因此，第一个声明可以读作 \"r 是一个初始化为 i 的整型引用\"，第二个声明可以读作 \"s 是一个初始化为 d 的 double 型引用\"。下面的实例使用了 int 和 double 引用：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main (){\n   // 声明简单的变量\n   int    i;\n   double d;\n \n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n   \n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n \n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of i : 5Value of i reference : 5Value of d : 11.7Value of d reference : 11.7\n```\n\n引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：\n\n| 概念             | 描述                                                     |\n| :--------------- | :------------------------------------------------------- |\n| 把引用作为参数   | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 |\n| 把引用作为返回值 | 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。    |\n\n# C++ 日期 & 时间\n\nC++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。\n\n有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。\n\n结构类型 **tm** 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：\n\n```cpp\nstruct tm {\n  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61\n  int tm_min;   // 分，范围从 0 到 59\n  int tm_hour;  // 小时，范围从 0 到 23\n  int tm_mday;  // 一月中的第几天，范围从 1 到 31\n  int tm_mon;   // 月，范围从 0 到 11\n  int tm_year;  // 自 1900 年起的年数\n  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起\n  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起\n  int tm_isdst; // 夏令时}\n```\n\n下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。\n\n| 序号 | 函数 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **time_t time(time_t \\*time);** 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 |\n| 2    | **char \\*ctime(const time_t \\*time);** 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\\n\\0*。 |\n| 3    | **struct tm \\*localtime(const time_t \\*time);** 该函数返回一个指向表示本地时间的 **tm** 结构的指针。 |\n| 4    | **clock_t clock(void);** 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 |\n| 5    | **char \\* asctime ( const struct tm \\* time );** 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 |\n| 6    | **struct tm \\*gmtime(const time_t \\*time);** 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |\n| 7    | **time_t mktime(struct tm \\*time);** 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 |\n| 8    | **double difftime ( time_t time2, time_t time1 );** 该函数返回 time1 和 time2 之间相差的秒数。 |\n| 9    | **size_t strftime();** 该函数可用于格式化日期和时间为指定的格式。 |\n\n## 当前日期和时间\n\n下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。\n\n```cpp\n#include <iostream>#include <ctime>using namespace std;int main( ){\n   // 基于当前系统的当前日期/时间\n   time_t now = time(0);\n   \n   // 把 now 转换为字符串形式\n   char* dt = ctime(&now);\n\n   cout << \"本地日期和时间：\" << dt << endl;\n\n   // 把 now 转换为 tm 结构\n   tm *gmtm = gmtime(&now);\n   dt = asctime(gmtm);\n   cout << \"UTC 日期和时间：\"<< dt << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n本地日期和时间：Sat Jan  8 20:07:41 2011UTC 日期和时间：Sun Jan  9 03:07:41 2011\n```\n\n## 使用结构 tm 格式化时间\n\n**tm** 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。\n\n在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -> 运算符来访问结构成员。\n\n```cpp\n#include <iostream>#include <ctime>using namespace std;int main( ){\n   // 基于当前系统的当前日期/时间\n   time_t now = time(0);\n\n   cout << \"Number of sec since January 1,1970:\" << now << endl;\n\n   tm *ltm = localtime(&now);\n\n   // 输出 tm 结构的各个组成部分\n   cout << \"Year: \"<< 1900 + ltm->tm_year << endl;\n   cout << \"Month: \"<< 1 + ltm->tm_mon<< endl;\n   cout << \"Day: \"<<  ltm->tm_mday << endl;\n   cout << \"Time: \"<< 1 + ltm->tm_hour << \":\";\n   cout << 1 + ltm->tm_min << \":\";\n   cout << 1 + ltm->tm_sec << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nNumber of sec since January 1, 1970:1294548238Year: 2011Month: 1Day: 8Time: 22: 44:59\n```\n\n# C++ 基本的输入输出\n\nC++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。\n\nC++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作**。\n\n## I/O 库头文件\n\n下列的头文件在 C++ 编程中很重要。\n\n| 头文件     | 函数和描述                                                   |\n| :--------- | :----------------------------------------------------------- |\n| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |\n| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |\n| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |\n\n## 标准输出流（cout）\n\n预定义的对象 **cout** 是 **ostream** 类的一个实例。cout 对象\"连接\"到标准输出设备，通常是显示屏。**cout** 是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream> using namespace std; int main( ){   char str[] = \"Hello C++\";    cout << \"Value of str is : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of str is : Hello C++\n```\n\nC++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<< 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。\n\n流插入运算符 << 在一个语句中可以多次使用，如上面实例中所示，**endl** 用于在行末添加一个换行符。\n\n## 标准输入流（cin）\n\n预定义的对象 **cin** 是 **istream** 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。**cin** 是与流提取运算符 >> 结合使用的，如下所示：\n\n```cpp\n#include <iostream> using namespace std; int main( ){  \n\tchar name[50];    cout << \"请输入您的名称： \";   \n\tcin >> name;   cout << \"您的名称是： \" << name << endl; }\n```\n\n当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：\n\n```cpp\n请输入您的名称： cplusplus您的名称是： cplusplus\n```\n\nC++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。\n\n流提取运算符 >> 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：\n\n```cpp\ncin >> name >> age;\n```\n\n这相当于下面两个语句：\n\n```cpp\ncin >> name;cin >> age;\n```\n\n## 标准错误流（cerr）\n\n预定义的对象 **cerr** 是 **ostream** 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。\n\n**cerr** 也是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main( ){\n   char str[] = \"Unable to read....\";\n \n   cerr << \"Error message : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nError message : Unable to read....\n```\n\n## 标准日志流（clog）\n\n预定义的对象 **clog** 是 **ostream** 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。\n\n**clog** 也是与流插入运算符 << 结合使用的，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;\n int main( ){\n   char str[] = \"Unable to read....\";\n \n   clog << \"Error message : \" << str << endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nError message : Unable to read....\n```\n\n通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。\n\n# C++ 数据结构\n\nC/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。\n\n结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：\n\n- Title ：标题\n- Author ：作者\n- Subject ：类目\n- Book ID ：书的 ID\n\n## 定义结构\n\n为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：\n\n \n\n```cpp\nstruct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..} object_names;\n```\n\n**type_name** 是结构体类型的名称，**member_type1 member_name1** 是标准的变量定义，比如 **int i;** 或者 **float f;** 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 **Books**，变量为 **book**：\n\n```cpp\nstruct Books{   char  title[50];   char  author[50];   char  subject[100];      int   book_id;} book;\n```\n\n## 访问结构成员\n\n为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。\n\n下面的实例演示了结构的用法：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std; \n// 声明一个结构体类型 Books struct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n   // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 输出 Book1 信息\n   cout << \"第一本书标题 : \" << Book1.title <<endl;   cout << \"第一本书作者 : \" << Book1.author <<endl;   cout << \"第一本书类目 : \" << Book1.subject <<endl;   cout << \"第一本书 ID : \" << Book1.book_id <<endl; \n   // 输出 Book2 信息\n   cout << \"第二本书标题 : \" << Book2.title <<endl;   cout << \"第二本书作者 : \" << Book2.author <<endl;   cout << \"第二本书类目 : \" << Book2.subject <<endl;   cout << \"第二本书 ID : \" << Book2.book_id <<endl; \n   return 0;}\n```\n\n实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : 12345第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : 12346\n```\n\n## 结构作为函数参数\n\n您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std;void printBook( struct Books book ); \n// 声明一个结构体类型 Books struct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n    // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   \n   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 输出 Book1 信息\n   printBook( Book1 ); \n   // 输出 Book2 信息\n   printBook( Book2 ); \n   return 0;}void printBook( struct Books book ){\n   cout << \"书标题 : \" << book.title <<endl;   cout << \"书作者 : \" \n   << book.author <<endl;   cout << \"书类目 : \" << book.subject <<endl;   \n   cout << \"书 ID : \" << book.book_id <<endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : 12346\n```\n\n## 指向结构的指针\n\n您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：\n\n```cpp\nstruct Books *struct_pointer;\n```\n\n现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：\n\n```cpp\nstruct_pointer = &Book1;\n```\n\n为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：\n\n```cpp\nstruct_pointer->title;\n```\n\n让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：\n\n## 实例\n\n```cpp\n#include <iostream>#include <cstring>\n using namespace std;void printBook( struct Books *book ); \nstruct Books{\n   char  title[50];   char  author[50];   char  subject[100];   int   book_id;}; \nint main( ){\n   Books Book1;        // 定义结构体类型 Books 的变量 Book1\n   Books Book2;        // 定义结构体类型 Books 的变量 Book2\n \n    // Book1 详述\n   strcpy( Book1.title, \"C++ 教程\");   strcpy( Book1.author, \"Runoob\"); \n   strcpy( Book1.subject, \"编程语言\");   Book1.book_id = 12345; \n   // Book2 详述\n   strcpy( Book2.title, \"CSS 教程\");   strcpy( Book2.author, \"Runoob\");   \n   strcpy( Book2.subject, \"前端技术\");   Book2.book_id = 12346; \n   // 通过传 Book1 的地址来输出 Book1 信息\n   printBook( &Book1 ); \n   // 通过传 Book2 的地址来输出 Book2 信息\n   printBook( &Book2 ); \n   return 0;}// 该函数以结构指针作为参数void printBook( struct Books *book ){\n   cout << \"书标题  : \" << book->title <<endl;   cout << \"书作者 : \" \n   << book->author <<endl;   cout << \"书类目 : \" << book->subject <<endl;   \n   cout << \"书 ID : \" << book->book_id <<endl;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : 12346\n```\n\n## typedef 关键字\n\n下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如：\n\n```cpp\ntypedef struct{\n   char  title[50];\n   char  author[50];\n   char  subject[100];\n   int   book_id;}Books;\n```\n\n现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。下面是实例：\n\n```cpp\nBooks Book1, Book2;\n```\n\n您可以使用 **typedef** 关键字来定义非结构类型，如下所示：\n\n```cpp\ntypedef long int *pint32;\n pint32 x, y, z;\n```\n\nx, y 和 z 都是指向长整型 long int 的指针。\n\n# C++ 类 & 对象\n\nC++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。\n\n类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。\n\n## C++ 类定义\n\n定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。\n\n类定义是以关键字 **class** 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 **class** 定义 Box 数据类型，如下所示：\n\n```cpp\nclass Box{   public:      double length;   // Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box};\n```\n\n关键字 **public** 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 **private** 或 **protected**，这个我们稍后会进行讲解。\n\n## 定义 C++ 对象\n\n类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：\n\n```cpp\nBox Box1;          // 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box\n```\n\n对象 Box1 和 Box2 都有它们各自的数据成员。\n\n## 访问数据成员\n\n类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度};int main( ){\n   Box Box1;        // 声明 Box1，类型为 Box\n   Box Box2;        // 声明 Box2，类型为 Box\n   double volume = 0.0;     // 用于存储体积\n \n   // box 1 详述\n   Box1.height = 5.0; \n   Box1.length = 6.0; \n   Box1.breadth = 7.0;\n\n   // box 2 详述\n   Box2.height = 10.0;\n   Box2.length = 12.0;\n   Box2.breadth = 13.0;\n\n   // box 1 的体积\n   volume = Box1.height * Box1.length * Box1.breadth;\n   cout << \"Box1 的体积：\" << volume <<endl;\n\n   // box 2 的体积\n   volume = Box2.height * Box2.length * Box2.breadth;\n   cout << \"Box2 的体积：\" << volume <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nBox1 的体积：210Box2 的体积：1560\n```\n\n需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。\n\n# 类 & 对象详解\n\n到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。\n\n| 概念                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 类成员函数          | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |\n| 类访问修饰符        | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |\n| 构造函数 & 析构函数 | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |\n| C++ 拷贝构造函数    | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |\n| C++ 友元函数        | **友元函数**可以访问类的 private 和 protected 成员。         |\n| C++ 内联函数        | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |\n| C++ 中的 this 指针  | 每个对象都有一个特殊的指针 **this**，它指向对象本身。        |\n| C++ 中指向类的指针  | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |\n| C++ 类的静态成员    | 类的数据成员和函数成员都可以被声明为静态的。                 |\n\n# C++ 继承\n\n面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。\n\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。\n\n继承代表了 **is a** 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。\n\n## 基类 & 派生类\n\n一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：\n\n```cpp\nclass derived-class: access-specifier base-class\n```\n\n其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n\n假设有一个基类 **Shape**，**Rectangle** 是它的派生类，如下所示：\n\n```cpp\n#include <iostream>\n using namespace std;// 基类class Shape {\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;};// 派生类class Rectangle: public Shape{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }};int main(void){\n   Rectangle Rect;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n Total area: 35\n```\n\n## 访问控制和继承\n\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n| 访问     | public | protected | private |\n| :------- | :----- | :-------- | :------ |\n| 同一个类 | yes    | yes       | yes     |\n| 派生类   | yes    | yes       | no      |\n| 外部的类 | yes    | no        | no      |\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n## 继承类型\n\n当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。\n\n我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。\n- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。\n- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。\n\n## 多继承\n\n多继承即一个子类可以有多个父类，它继承了多个父类的特性。\n\nC++ 类可以从多个类继承成员，语法如下：\n\n```cpp\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…{<派生类类体>};\n```\n\n其中，访问修饰符继承方式是 **public、protected** 或 **private** 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：\n\n```cpp\n#include <iostream>\n using namespace std;// 基类 Shapeclass Shape {\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;};// 基类 PaintCostclass PaintCost {\n   public:\n      int getCost(int area)\n      {\n         return area * 70;\n      }};// 派生类class Rectangle: public Shape, public PaintCost{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }};int main(void){\n   Rectangle Rect;\n   int area;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   area = Rect.getArea();\n   \n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   // 输出总花费\n   cout << \"Total paint cost: $\" << Rect.getCost(area) << endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal area: 35Total paint cost: $2450\n```\n\n# C++ 重载运算符和重载函数\n\nC++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。\n\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n\n当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。\n\n## C++ 中的函数重载\n\n在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。\n\n下面的实例中，同名函数 **print()** 被用于输出不同的数据类型：\n\n```cpp\n#include <iostream>using namespace std;\n class printData \n{\n   public:\n      void print(int i) {\n        cout << \"Printing int: \" << i << endl;\n      }\n\n      void print(double  f) {\n        cout << \"Printing float: \" << f << endl;\n      }\n\n      void print(char* c) {\n        cout << \"Printing character: \" << c << endl;\n      }};int main(void){\n   printData pd;\n \n   // Call print to print integer\n   pd.print(5);\n   // Call print to print float\n   pd.print(500.263);\n   // Call print to print character\n   pd.print(\"Hello C++\");\n \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nPrinting int: 5Printing float: 500.263Printing character: Hello C++\n```\n\n## C++ 中的运算符重载\n\n您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。\n\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n\n```cpp\nBox operator+(const Box&);\n```\n\n声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：\n\n```cpp\nBox operator+(const Box&, const Box&);\n```\n\n下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 **this** 运算符进行访问，如下所示：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n      void setLength( double len )\n      {\n          length = len;\n      }\n\n      void setBreadth( double bre )\n      {\n          breadth = bre;\n      }\n\n      void setHeight( double hei )\n      {\n          height = hei;\n      }\n      // 重载 + 运算符，用于把两个 Box 对象相加\n      Box operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度};// 程序的主函数int main( ){\n   Box Box1;                // 声明 Box1，类型为 Box\n   Box Box2;                // 声明 Box2，类型为 Box\n   Box Box3;                // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 把体积存储在该变量中\n \n   // Box1 详述\n   Box1.setLength(6.0); \n   Box1.setBreadth(7.0); \n   Box1.setHeight(5.0);\n \n   // Box2 详述\n   Box2.setLength(12.0); \n   Box2.setBreadth(13.0); \n   Box2.setHeight(10.0);\n \n   // Box1 的体积\n   volume = Box1.getVolume();\n   cout << \"Volume of Box1 : \" << volume <<endl;\n \n   // Box2 的体积\n   volume = Box2.getVolume();\n   cout << \"Volume of Box2 : \" << volume <<endl;\n\n   // 把两个对象相加，得到 Box3\n   Box3 = Box1 + Box2;\n\n   // Box3 的体积\n   volume = Box3.getVolume();\n   cout << \"Volume of Box3 : \" << volume <<endl;\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nVolume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400\n```\n\n## 可重载运算符/不可重载运算符\n\n下面是可重载的运算符列表：\n\n| +    | -    | *    | /      | %      | ^         |\n| ---- | ---- | ---- | ------ | ------ | --------- |\n| &    | \\|   | ~    | !      | ,      | =         |\n| <    | >    | <=   | >=     | ++     | --        |\n| <<   | >>   | ==   | !=     | &&     | \\|\\|      |\n| +=   | -=   | /=   | %=     | ^=     | &=        |\n| \\|=  | *=   | <<=  | >>=    | []     | ()        |\n| ->   | ->*  | new  | new [] | delete | delete [] |\n\n下面是不可重载的运算符列表：\n\n| ::   | .*   | .    | ?:   |\n| ---- | ---- | ---- | ---- |\n|      |      |      |      |\n\n## 运算符重载实例\n\n下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。\n\n| 序号 | 运算符和实例             |\n| :--- | :----------------------- |\n| 1    | 一元运算符重载           |\n| 2    | 二元运算符重载           |\n| 3    | 关系运算符重载           |\n| 4    | 输入/输出运算符重载      |\n| 5    | ++ 和 -- 运算符重载      |\n| 6    | 赋值运算符重载           |\n| 7    | 函数调用运算符 () 重载   |\n| 8    | 下标运算符 [] 重载       |\n| 9    | 类成员访问运算符 -> 重载 |\n\n# C++ 多态\n\n**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。\n\nC++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。\n\n下面的实例中，基类 Shape 被派生为两个类，如下所示：\n\n```cpp\n#include <iostream> using namespace std;\n class Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      int area()\n      {\n         cout << \"Parent class area :\" <<endl;\n         return 0;\n      }};class Rectangle: public Shape{\n   public:\n      Rectangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout << \"Rectangle class area :\" <<endl;\n         return (width * height); \n      }};class Triangle: public Shape{\n   public:\n      Triangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout << \"Triangle class area :\" <<endl;\n         return (width * height / 2); \n      }};// 程序的主函数int main( ){\n   Shape *shape;\n   Rectangle rec(10,7);\n   Triangle  tri(10,5);\n\n   // 存储矩形的地址\n   shape = &rec;\n   // 调用矩形的求面积函数 area\n   shape->area();\n\n   // 存储三角形的地址\n   shape = &tri;\n   // 调用三角形的求面积函数 area\n   shape->area();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nParent class areaParent class area\n```\n\n导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。\n\n但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 **virtual**，如下所示：\n\n```cpp\nclass Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      virtual int area()\n      {\n         cout << \"Parent class area :\" <<endl;\n         return 0;\n      }};\n```\n\n修改后，当编译和执行前面的实例代码时，它会产生以下结果：\n\n```cpp\nRectangle class areaTriangle class area\n```\n\n此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。\n\n正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是**多态**的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。\n\n## 虚函数\n\n**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。\n\n## 纯虚函数\n\n您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。\n\n我们可以把基类中的虚函数 area() 改写如下：\n\n```cpp\nclass Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      // pure virtual function\n      virtual int area() = 0;};\n```\n\n= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。\n\n# C++ 数据抽象\n\n数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。\n\n数据抽象是一种依赖于接口和实现分离的编程（设计）技术。\n\n让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。\n\n因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。\n\n现在，让我们言归正传，就 C++ 编程而言，C++ 类为**数据抽象**提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。\n\n例如，您的程序可以调用 **sort()** 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。\n\n在 C++ 中，我们使用**类**来定义我们自己的抽象数据类型（ADT）。您可以使用类 **ostream** 的 **cout** 对象来输出数据到标准输出，如下所示：\n\n```cpp\n#include <iostream>using namespace std;int main( ){   cout << \"Hello C++\" <<endl;   return 0;}\n```\n\n在这里，您不需要理解 **cout** 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。\n\n## 访问标签强制抽象\n\n在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：\n\n- 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。\n- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。\n\n访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。\n\n## 数据抽象的好处\n\n数据抽象有两个重要的优势：\n\n- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。\n- 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。\n\n如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。\n\n## 数据抽象的实例\n\nC++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Adder{\n   public:\n      // 构造函数\n      Adder(int i = 0)\n      {\n        total = i;\n      }\n      // 对外的接口\n      void addNum(int number)\n      {\n          total += number;\n      }\n      // 对外的接口\n      int getTotal()\n      {\n          return total;\n      };\n   private:\n      // 对外隐藏的数据\n      int total;};int main( ){\n   Adder a;\n   \n   a.addNum(10);\n   a.addNum(20);\n   a.addNum(30);\n\n   cout << \"Total \" << a.getTotal() <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal 60\n```\n\n上面的类把数字相加，并返回总和。公有成员 **addNum** 和 **getTotal** 是对外的接口，用户需要知道它们以便使用类。私有成员 **total** 是用户不需要了解的，但又是类能正常工作所必需的。\n\n## 设计策略\n\n抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。\n\n在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。\n\n# C++ 数据封装\n\n所有的 C++ 程序都有以下两个基本要素：\n\n- **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。\n- **程序数据：**数据是程序的信息，会受到程序函数的影响。\n\n封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即**数据隐藏**。\n\n**数据封装**是一种把数据和操作数据的函数捆绑在一起的机制，**数据抽象**是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。\n\nC++ 通过创建**类**来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：\n\n```cpp\nclass Box{\n   public:\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n\t};\n```\n\n变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。\n\n为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 **public** 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。\n\n把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。\n\n## 数据封装的实例\n\nC++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：\n\n```cpp\n#include <iostream>using namespace std;class Adder{\n   public:\n      // 构造函数\n      Adder(int i = 0)\n      {\n        total = i;\n      }\n      // 对外的接口\n      void addNum(int number)\n      {\n          total += number;\n      }\n      // 对外的接口\n      int getTotal()\n      {\n          return total;\n      };\n   private:\n      // 对外隐藏的数据\n      int total;};int main( ){\n   Adder a;\n   \n   a.addNum(10);\n   a.addNum(20);\n   a.addNum(30);\n\n   cout << \"Total \" << a.getTotal() <<endl;\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal 60\n```\n\n上面的类把数字相加，并返回总和。公有成员 **addNum** 和 **getTotal** 是对外的接口，用户需要知道它们以便使用类。私有成员 **total** 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。\n\n## 设计策略\n\n通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的**封装性**。\n\n这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。\n\n# C++ 接口（抽象类）\n\n接口描述了类的行为和功能，而不需要完成类的特定实现。\n\nC++ 接口是使用**抽象类**来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。\n\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0\" 来指定的，如下所示：\n\n```cpp\nclass Box{\n   public:\n      // 纯虚函数\n      virtual double getVolume() = 0;\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度};\n```\n\n设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n\n可用于实例化对象的类被称为**具体类**。\n\n## 抽象类的实例\n\n请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：\n\n```cpp\n#include <iostream>\n using namespace std;\n // 基类class Shape {public:\n   // 提供接口框架的纯虚函数\n   virtual int getArea() = 0;\n   void setWidth(int w)\n   {\n      width = w;\n   }\n   void setHeight(int h)\n   {\n      height = h;\n   }protected:\n   int width;\n   int height;};\n // 派生类class Rectangle: public Shape{public:\n   int getArea()\n   { \n      return (width * height); \n   }};class Triangle: public Shape{public:\n   int getArea()\n   { \n      return (width * height)/2; \n   }};\n int main(void){\n   Rectangle Rect;\n   Triangle  Tri;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n   // 输出对象的面积\n   cout << \"Total Rectangle area: \" << Rect.getArea() << endl;\n\n   Tri.setWidth(5);\n   Tri.setHeight(7);\n   // 输出对象的面积\n   cout << \"Total Triangle area: \" << Tri.getArea() << endl; \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTotal Rectangle area: 35Total Triangle area: 17\n```\n\n从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。\n\n## 设计策略\n\n面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。\n\n外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。\n\n这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。\n\n# C++ 文件和流\n\n到目前为止，我们已经使用了 **iostream** 标准库，它提供了 **cin** 和 **cout** 方法分别用于从标准输入读取流和向标准输出写入流。\n\n本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 **fstream**，它定义了三个新的数据类型：\n\n| 数据类型 | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。     |\n| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。               |\n| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |\n\n要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。\n\n## 打开文件\n\n在从文件读取信息或者向文件写入信息之前，必须先打开文件。**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。\n\n下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。\n\n```cpp\nvoid open(const char *filename, ios::openmode mode);\n```\n\n在这里，**open()** 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。\n\n| 模式标志   | 描述                                                         |\n| :--------- | :----------------------------------------------------------- |\n| ios::app   | 追加模式。所有写入都追加到文件末尾。                         |\n| ios::ate   | 文件打开后定位到文件末尾。                                   |\n| ios::in    | 打开文件用于读取。                                           |\n| ios::out   | 打开文件用于写入。                                           |\n| ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |\n\n您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：\n\n```cpp\nofstream outfile;outfile.open(\"file.dat\", ios::out | ios::trunc );\n```\n\n类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：\n\n```cpp\nfstream  afile;afile.open(\"file.dat\", ios::out | ios::in );\n```\n\n## 关闭文件\n\n当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。\n\n下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。\n\n```cpp\nvoid close();\n```\n\n## 写入文件\n\n在 C++ 编程中，我们使用流插入运算符（ << ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 **ofstream** 或 **fstream** 对象，而不是 **cout** 对象。\n\n## 读取文件\n\n在 C++ 编程中，我们使用流提取运算符（ >> ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 **ifstream** 或 **fstream** 对象，而不是 **cin** 对象。\n\n## 读取 & 写入实例\n\n下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：\n\n```cpp\n#include <fstream>#include <iostream>using namespace std;\n int main (){\n    \n   char data[100];\n\n   // 以写模式打开文件\n   ofstream outfile;\n   outfile.open(\"afile.dat\");\n\n   cout << \"Writing to the file\" << endl;\n   cout << \"Enter your name: \"; \n   cin.getline(data, 100);\n\n   // 向文件写入用户输入的数据\n   outfile << data << endl;\n\n   cout << \"Enter your age: \"; \n   cin >> data;\n   cin.ignore();\n   \n   // 再次向文件写入用户输入的数据\n   outfile << data << endl;\n\n   // 关闭打开的文件\n   outfile.close();\n\n   // 以读模式打开文件\n   ifstream infile; \n   infile.open(\"afile.dat\"); \n \n   cout << \"Reading from the file\" << endl; \n   infile >> data; \n\n   // 在屏幕上写入数据\n   cout << data << endl;\n   \n   // 再次从文件读取数据，并显示它\n   infile >> data; \n   cout << data << endl; \n\n   // 关闭打开的文件\n   infile.close();\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列输入和输出：\n\n```cpp\n$./a.outWriting to the fileEnter your name: ZaraEnter your age: 9Reading from the fileZara9\n```\n\n上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。\n\n## 文件位置指针\n\n**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（\"seek get\"）和关于 ostream 的 **seekp**（\"seek put\"）。\n\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。\n\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 \"get\" 文件位置指针的实例：\n\n```cpp\n// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );\n```\n\n# C++ 异常处理\n\n异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。\n\n异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。\n\n- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。\n- **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。\n- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。\n\n如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：\n\n```cpp\ntry{\n   // 保护代码}catch( ExceptionName e1 ){\n   // catch 块}catch( ExceptionName e2 ){\n   // catch 块}catch( ExceptionName eN ){\n   // catch 块}\n```\n\n如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。\n\n## 抛出异常\n\n您可以使用 **throw** 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。\n\n以下是尝试除以零时抛出异常的实例：\n\n```cpp\ndouble division(int a, int b){\n   if( b == 0 )\n   {\n      throw \"Division by zero condition!\";\n   }\n   return (a/b);}\n```\n\n## 捕获异常\n\n**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。\n\n```cpp\ntry{\n   // 保护代码}catch( ExceptionName e ){\n  // 处理 ExceptionName 异常的代码}\n```\n\n上面的代码会捕获一个类型为 **ExceptionName** 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：\n\n```cpp\ntry{\n   // 保护代码}catch(...){\n  // 能处理任何异常的代码}\n```\n\n下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。\n\n```cpp\n#include <iostream>using namespace std;double division(int a, int b){\n   if( b == 0 )\n   {\n      throw \"Division by zero condition!\";\n   }\n   return (a/b);}int main (){\n   int x = 50;\n   int y = 0;\n   double z = 0;\n \n   try {\n     z = division(x, y);\n     cout << z << endl;\n   }catch (const char* msg) {\n     cerr << msg << endl;\n   }\n\n   return 0;}\n```\n\n由于我们抛出了一个类型为 **const char\\*** 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nDivision by zero condition!\n```\n\n## C++ 标准的异常\n\nC++ 提供了一系列标准的异常，定义在 **<exception>** 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg)\n\n下表是对上面层次结构中出现的每个异常的说明：\n\n| 异常                   | 描述                                                         |\n| :--------------------- | :----------------------------------------------------------- |\n| **std::exception**     | 该异常是所有标准 C++ 异常的父类。                            |\n| std::bad_alloc         | 该异常可以通过 **new** 抛出。                                |\n| std::bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |\n| std::bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |\n| std::bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |\n| **std::logic_error**   | 理论上可以通过读取代码来检测到的异常。                       |\n| std::domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |\n| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |\n| std::length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |\n| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 |\n| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常。                     |\n| std::overflow_error    | 当发生数学上溢时，会抛出该异常。                             |\n| std::range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |\n| std::underflow_error   | 当发生数学下溢时，会抛出该异常。                             |\n\n## 定义新的异常\n\n您可以通过继承和重载 **exception** 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：\n\n```cpp\n#include <iostream>#include <exception>using namespace std;struct MyException : public exception{\n  const char * what () const throw ()\n  {\n    return \"C++ Exception\";\n  }};\n int main(){\n  try\n  {\n    throw MyException();\n  }\n  catch(MyException& e)\n  {\n    std::cout << \"MyException caught\" << std::endl;\n    std::cout << e.what() << std::endl;\n  }\n  catch(std::exception& e)\n  {\n    //其他的错误\n  }}\n```\n\n这将产生以下结果：\n\n```cpp\nMyException caught\nC++ Exception\n```\n\n在这里，**what()** 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。\n\n# C++ 动态内存\n\n了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：\n\n- **栈：**在函数内部声明的所有变量都将占用栈内存。\n- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\n很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。\n\n在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 **new** 运算符。\n\n如果您不需要动态分配内存，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。\n\n## new 和 delete 运算符\n\n下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：\n\n```cpp\nnew data-type;\n```\n\n在这里，**data-type** 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 **new** 运算符来完成这点：\n\n```cpp\ndouble* pvalue  = NULL; // 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存\n```\n\n如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：\n\n```cpp\ndouble* pvalue  = NULL;if( !(pvalue  = new double )){\n   cout << \"Error: out of memory.\" <<endl;\n   exit(1);}\n```\n\n**malloc()** 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。\n\n在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：\n\n```cpp\ndelete pvalue;        // 释放 pvalue 所指向的内存\n```\n\n下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n   double* pvalue  = NULL; // 初始化为 null 的指针\n   pvalue  = new double;   // 为变量请求内存\n \n   *pvalue = 29494.99;     // 在分配的地址存储值\n   cout << \"Value of pvalue : \" << *pvalue << endl;\n\n   delete pvalue;         // 释放内存\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of pvalue : 29495\n```\n\n## 数组的动态内存分配\n\n假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：\n\n```cpp\nchar* pvalue  = NULL;   // 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存\n```\n\n要删除我们刚才创建的数组，语句如下：\n\n```cpp\ndelete [] pvalue;        // 删除 pvalue 所指向的数组\n```\n\n下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：\n\n```cpp\nint ROW = 2;int COL = 3;double **pvalue  = new double* [ROW]; // 为行分配内存// 为列分配内存for(int i = 0; i < COL; i++) {\n    pvalue[i] = new double[COL];}\n```\n\n释放多维数组内存：\n\n```cpp\nfor(int i = 0; i < COL; i++) {\n    delete[] pvalue[i];}delete [] pvalue;\n```\n\n## 对象的动态内存分配\n\n对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：\n\n```cpp\n#include <iostream>using namespace std;class Box{\n   public:\n      Box() { \n         cout << \"调用构造函数！\" <<endl; \n      }\n      ~Box() { \n         cout << \"调用析构函数！\" <<endl; \n      }};int main( ){\n   Box* myBoxArray = new Box[4];\n\n   delete [] myBoxArray; // Delete array\n\n   return 0;}\n```\n\n如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！\n```\n\n# C++ 命名空间\n\n假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。\n\n同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。\n\n因此，引入了**命名空间**这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。\n\n## 定义命名空间\n\n命名空间的定义使用关键字 **namespace**，后跟命名空间的名称，如下所示：\n\n```cpp\nnamespace namespace_name {   // 代码声明}\n```\n\n为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：\n\n```cpp\nname::code;  // code 可以是变量或函数\n```\n\n让我们来看看命名空间如何为变量或函数等实体定义范围：\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }}// 第二个命名空间namespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }}int main (){\n \n   // 调用第一个命名空间中的函数\n   first_space::func();\n   \n   // 调用第二个命名空间中的函数\n   second_space::func(); \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside first_spaceInside second_space\n```\n\n## using 指令\n\n您可以使用 **using namespace** 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }}// 第二个命名空间namespace second_space{\n   void func(){\n      cout << \"Inside second_space\" << endl;\n   }}using namespace first_space;int main (){\n \n   // 调用第一个命名空间中的函数\n   func();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside first_space\n```\n\nusing 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：\n\n```cpp\nusing std::cout;\n```\n\n随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 **std** 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：\n\n```cpp\n#include <iostream>using std::cout;int main (){   \n\tcout << \"std::endl is used with std!\" << std::endl;      \n\treturn 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nstd::endl is used with std!\n```\n\n**using** 指令引入的名称遵循正常的范围规则。名称从使用 **using** 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。\n\n## 不连续的命名空间\n\n命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。\n\n所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：\n\n```cpp\nnamespace namespace_name {\n   // 代码声明}\n```\n\n## 嵌套的命名空间\n\n命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：\n\n```cpp\nnamespace namespace_name1 {\n   // 代码声明\n   namespace namespace_name2 {\n      // 代码声明\n   }}\n```\n\n您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：\n\n```cpp\n// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;\n```\n\n在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：\n\n```cpp\n#include <iostream>using namespace std;// 第一个命名空间namespace first_space{\n   void func(){\n      cout << \"Inside first_space\" << endl;\n   }\n   // 第二个命名空间\n   namespace second_space{\n      void func(){\n         cout << \"Inside second_space\" << endl;\n      }\n   }}using namespace first_space::second_space;int main (){\n \n   // 调用第二个命名空间中的函数\n   func();\n   \n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nInside second_space\n```\n\n# C++ 模板\n\n模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n\n模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。\n\n每个容器都有一个单一的定义，比如 **向量**，我们可以定义许多不同类型的向量，比如 **vector <int>** 或 **vector <string>**。\n\n您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。\n\n## 函数模板\n\n模板函数定义的一般形式如下所示：\n\n```cpp\ntemplate <class type> ret-type func-name(parameter list){   // 函数的主体}\n```\n\n在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。\n\n下面是函数模板的实例，返回两个数种的最大值：\n\n```cpp\n#include <iostream>#include <string>using namespace std;template <typename T>inline T const& Max (T const& a, T const& b) { \n    return a < b ? b:a; } int main (){\n \n    int i = 39;\n    int j = 20;\n    cout << \"Max(i, j): \" << Max(i, j) << endl; \n\n    double f1 = 13.5; \n    double f2 = 20.7; \n    cout << \"Max(f1, f2): \" << Max(f1, f2) << endl; \n\n    string s1 = \"Hello\"; \n    string s2 = \"World\"; \n    cout << \"Max(s1, s2): \" << Max(s1, s2) << endl; \n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nMax(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World\n```\n\n## 类模板\n\n正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：\n\n```cpp\ntemplate <class type> class class-name {...}\n```\n\n在这里，**type** 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。\n\n下面的实例定义了类 Stack<>，并实现了泛型方法来对元素进行入栈出栈操作：\n\n```cpp\n#include <iostream>#include <vector>#include <cstdlib>#include <string>#include <stdexcept>using namespace std;template <class T>class Stack { \n  private: \n    vector<T> elems;     // 元素 \n\n  public: \n    void push(T const&);  // 入栈\n    void pop();               // 出栈\n    T top() const;            // 返回栈顶元素\n    bool empty() const{       // 如果为空则返回真。\n        return elems.empty(); \n    } }; template <class T>void Stack<T>::push (T const& elem) { \n    // 追加传入元素的副本\n    elems.push_back(elem);    } template <class T>void Stack<T>::pop () { \n    if (elems.empty()) { \n        throw out_of_range(\"Stack<>::pop(): empty stack\"); \n    }\n\t// 删除最后一个元素\n    elems.pop_back();         } template <class T>T Stack<T>::top () const { \n    if (elems.empty()) { \n        throw out_of_range(\"Stack<>::top(): empty stack\"); \n    }\n\t// 返回最后一个元素的副本 \n    return elems.back();      } int main() { \n    try { \n        Stack<int>         intStack;  // int 类型的栈 \n        Stack<string> stringStack;    // string 类型的栈 \n\n        // 操作 int 类型的栈 \n        intStack.push(7); \n        cout << intStack.top() <<endl; \n\n        // 操作 string 类型的栈 \n        stringStack.push(\"hello\"); \n        cout << stringStack.top() << std::endl; \n        stringStack.pop(); \n        stringStack.pop(); \n    } \n    catch (exception const& ex) { \n        cerr << \"Exception: \" << ex.what() <<endl; \n        return -1;\n    } }\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n7helloException: Stack<>::pop(): empty stack\n```\n\n# C++ 预处理器\n\n预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。\n\n所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。\n\n我们已经看到，之前所有的实例中都有 **#include** 指令。这个宏用于把头文件包含到源文件中。\n\nC++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。\n\n## #define 预处理\n\n\\#define 预处理指令用于创建符号常量。该符号常量通常称为**宏**，指令的一般形式是：\n\n```cpp\n#define macro-name replacement-text\n```\n\n当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：\n\n```cpp\n#include <iostream>using namespace std;#define PI 3.14159int main (){     cout << \"Value of PI :\" << PI << endl;     return 0;}\n```\n\n现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：\n\n```cpp\n$gcc -E test.cpp > test.p...int main (){     cout << \"Value of PI :\" << 3.14159 << endl;     return 0;}\n```\n\n## 函数宏\n\n您可以使用 #define 来定义一个带有参数的宏，如下所示：\n\n```cpp\n#include <iostream>using namespace std;#define MIN(a,b) (a<b ? a : b)int main (){\n   int i, j;\n   i = 100;\n   j = 30;\n   cout <<\"较小的值为：\" << MIN(i, j) << endl;\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n较小的值为：30\n```\n\n## 条件编译\n\n有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。\n\n条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：\n\n```cpp\n#ifndef NULL   #define NULL 0#endif\n```\n\n您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：\n\n```cpp\n#ifdef DEBUG   cerr <<\"Variable x = \" << x << endl;#endif\n```\n\n如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 **cerr** 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：\n\n```cpp\n#if 0   不进行编译的代码#endif\n```\n\n让我们尝试下面的实例：\n\n```cpp\n#include <iostream>using namespace std;#define DEBUG#define MIN(a,b) (((a)<(b)) ? a : b)int main (){\n   int i, j;\n   i = 100;\n   j = 30;#ifdef DEBUG\n   cerr <<\"Trace: Inside main function\" << endl;#endif#if 0\n   /* 这是注释部分 */\n   cout << MKSTR(HELLO C++) << endl;#endif\n\n   cout <<\"The minimum is \" << MIN(i, j) << endl;#ifdef DEBUG\n   cerr <<\"Trace: Coming out of main function\" << endl;#endif\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nTrace: Inside main functionThe minimum is 30Trace: Coming out of main function\n```\n\n## # 和 ## 运算符\n\n\\# 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。\n\n请看下面的宏定义：\n\n```cpp\n#include <iostream>using namespace std;#define MKSTR( x ) #xint main (){    cout << MKSTR(HELLO C++) << endl;    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nHELLO C++\n```\n\n让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：\n\n```cpp\ncout << MKSTR(HELLO C++) << endl;\n```\n\n转换成了：\n\n```cpp\ncout << \"HELLO C++\" << endl;\n```\n\n\\## 运算符用于连接两个令牌。下面是一个实例：\n\n```cpp\n#define CONCAT( x, y )  x ## y\n```\n\n当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 \"HELLO C++\"，如下面实例所示。\n\n```cpp\n#include <iostream>using namespace std;#define concat(a, b) a ## bint main(){   int xy = 100;      cout << concat(x, y);   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n100\n```\n\n让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：\n\n```cpp\ncout << concat(x, y);\n```\n\n转换成了：\n\n```cpp\ncout << xy;\n```\n\n## C++ 中的预定义宏\n\nC++ 提供了下表所示的一些预定义宏：\n\n| 宏       | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| __LINE__ | 这会在程序编译时包含当前行号。                               |\n| __FILE__ | 这会在程序编译时包含当前文件名。                             |\n| __DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |\n| __TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |\n\n让我们看看上述这些宏的实例：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n    cout << \"Value of __LINE__ : \" << __LINE__ << endl;\n    cout << \"Value of __FILE__ : \" << __FILE__ << endl;\n    cout << \"Value of __DATE__ : \" << __DATE__ << endl;\n    cout << \"Value of __TIME__ : \" << __TIME__ << endl;\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nValue of __LINE__ : 6Value of __FILE__ : test.cppValue of __DATE__ : Feb 28 2011Value of __TIME__ : 18:52:48\n```\n\n# C++ 信号处理\n\n信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。\n\n有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。\n\n| 信号    | 描述                                         |\n| :------ | :------------------------------------------- |\n| SIGABRT | 程序的异常终止，如调用 **abort**。           |\n| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |\n| SIGILL  | 检测非法指令。                               |\n| SIGINT  | 接收到交互注意信号。                         |\n| SIGSEGV | 非法访问内存。                               |\n| SIGTERM | 发送到程序的终止请求。                       |\n\n## signal() 函数\n\nC++ 信号处理库提供了 **signal** 函数，用来捕获突发事件。以下是 signal() 函数的语法：\n\n```cpp\nvoid (*signal (int sig, void (*func)(int)))(int);\n```\n\n这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。\n\n让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 **signal** 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：\n\n```cpp\n#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n\n    // 清理并关闭\n    // 终止程序  \n\n   exit(signum);  }int main (){\n    // 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n\n    while(1){\n       cout << \"Going to sleep....\" << endl;\n       sleep(1);\n    }\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....\n```\n\n现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.\n```\n\n## raise() 函数\n\n您可以使用函数 **raise()** 生成信号，该函数带有一个整数信号编号作为参数，语法如下：\n\n```cpp\nint raise (signal sig);\n```\n\n在这里，**sig** 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：\n\n```cpp\n#include <iostream>#include <csignal>using namespace std;void signalHandler( int signum ){\n    cout << \"Interrupt signal (\" << signum << \") received.\\n\";\n\n    // 清理并关闭\n    // 终止程序 \n\n   exit(signum);  }int main (){\n    int i = 0;\n    // 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n\n    while(++i){\n       cout << \"Going to sleep....\" << endl;\n       if( i == 3 ){\n          raise( SIGINT);\n       }\n       sleep(1);\n    }\n\n    return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：\n\n```cpp\nGoing to sleep....Going to sleep....Going to sleep....Interrupt signal (2) received.\n```\n\n# C++ 多线程\n\n多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。\n\n- 基于进程的多任务处理是程序的并发执行。\n- 基于线程的多任务处理是同一程序的片段的并发执行。\n\n多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。\n\n本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。\n\n## 创建线程\n\n下面的程序，我们可以用它来创建一个 POSIX 线程：\n\n```cpp\n#include <pthread.h>pthread_create (thread, attr, start_routine, arg)\n```\n\n在这里，**pthread_create** 创建一个新的线程，并让它可执行。下面是关于参数的说明：\n\n| 参数          | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| thread        | 指向线程标识符指针。                                         |\n| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |\n| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |\n| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |\n\n创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。\n\n## 终止线程\n\n使用下面的程序，我们可以用它来终止一个 POSIX 线程：\n\n```cpp\n#include <pthread.h>pthread_exit (status)\n```\n\n在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。\n\n如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。\n\n## 实例\n\n以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\":\n\n```cpp\n#include <iostream>// 必须的头文件是#include <pthread.h>using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args){\n    cout << \"Hello Runoob！\" << endl;}int main(){\n    // 定义线程的 id 变量，多个变量使用数组\n    pthread_t tids[NUM_THREADS];\n    for(int i = 0; i < NUM_THREADS; ++i)\n    {\n        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数\n        int ret = pthread_create(&tids[i], NULL, say_hello, NULL);\n        if (ret != 0)\n        {\n           cout << \"pthread_create error: error_code=\" << ret << endl;\n        }\n    }\n    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；\n    pthread_exit(NULL);}\n```\n\n使用 -lpthread 库编译下面的程序：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o\n```\n\n现在，执行程序，将产生下列结果：\n\n```cpp\n$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！\n```\n\n以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 \"Hello Runoob!\" 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。\n\n```cpp\n//文件名：test.cpp#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid){  \n   // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取\n   int tid = *((int*)threadid);\n   cout << \"Hello Runoob! 线程 ID, \" << tid << endl;\n   pthread_exit(NULL);}int main (){\n   pthread_t threads[NUM_THREADS];\n   int indexes[NUM_THREADS];// 用数组来保存i的值\n   int rc;\n   int i;\n   for( i=0; i < NUM_THREADS; i++ ){      \n      cout << \"main() : 创建线程, \" << i << endl;\n      indexes[i] = i; //先保存i的值\n      // 传入的时候必须强制转换为void* 类型，即无类型指针        \n      rc = pthread_create(&threads[i], NULL, \n                          PrintHello, (void *)&(indexes[i]));\n      if (rc){\n         cout << \"Error:无法创建线程,\" << rc << endl;\n         exit(-1);\n      }\n   }\n   pthread_exit(NULL);}\n```\n\n现在编译并执行程序，将产生下列结果：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o$ ./test.omain() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3main() : 创建线程, 4Hello Runoob! 线程 ID, 4Hello Runoob! 线程 ID, 3Hello Runoob! 线程 ID, 2Hello Runoob! 线程 ID, 1Hello Runoob! 线程 ID, 0\n```\n\n## 向线程传递参数\n\n这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：\n\n```cpp\n#include <iostream>#include <cstdlib>#include <pthread.h>using namespace std;#define NUM_THREADS     5struct thread_data{   int  thread_id;   char *message;};void *PrintHello(void *threadarg){   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout << \"Thread ID : \" << my_data->thread_id ;   cout << \" Message : \" << my_data->message << endl;   pthread_exit(NULL);}int main (){   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i < NUM_THREADS; i++ ){      cout <<\"main() : creating thread, \" << i << endl;      td[i].thread_id = i;      td[i].message = \"This is message\";      rc = pthread_create(&threads[i], NULL,                          PrintHello, (void *)&td[i]);      if (rc){         cout << \"Error:unable to create thread,\" << rc << endl;         exit(-1);      }   }   pthread_exit(NULL);}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\n$ g++ test.cpp -lpthread -o test.o\n$ ./test.o\nmain() : 创建线程, 0main() : 创建线程, 1main() : 创建线程, 2main() : 创建线程, 3main() : 创建线程, 4Hello Runoob! 线程 ID, 4Hello Runoob! 线程 ID, 3Hello Runoob! 线程 ID, 2Hello Runoob! 线程 ID, 1Hello Runoob! 线程 ID, 0\n```\n\n## 连接和分离线程\n\n我们可以使用以下两个函数来连接或分离线程：\n\n```cpp\npthread_join (threadid, status) pthread_detach (threadid)\n```\n\npthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。\n\n这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。\n\n```cpp\n#include <iostream>#include <cstdlib>#include <pthread.h>#include <unistd.h>using namespace std;#define NUM_THREADS     5void *wait(void *t){\n   int i;\n   long tid;\n\n   tid = (long)t;\n\n   sleep(1);\n   cout << \"Sleeping in thread \" << endl;\n   cout << \"Thread with id : \" << tid << \"  ...exiting \" << endl;\n   pthread_exit(NULL);}int main (){\n   int rc;\n   int i;\n   pthread_t threads[NUM_THREADS];\n   pthread_attr_t attr;\n   void *status;\n\n   // 初始化并设置线程为可连接的（joinable）\n   pthread_attr_init(&attr);\n   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n   for( i=0; i < NUM_THREADS; i++ ){\n      cout << \"main() : creating thread, \" << i << endl;\n      rc = pthread_create(&threads[i], NULL, wait, (void *)&i );\n      if (rc){\n         cout << \"Error:unable to create thread,\" << rc << endl;\n         exit(-1);\n      }\n   }\n\n   // 删除属性，并等待其他线程\n   pthread_attr_destroy(&attr);\n   for( i=0; i < NUM_THREADS; i++ ){\n      rc = pthread_join(threads[i], &status);\n      if (rc){\n         cout << \"Error:unable to join,\" << rc << endl;\n         exit(-1);\n      }\n      cout << \"Main: completed thread id :\" << i ;\n      cout << \"  exiting with status :\" << status << endl;\n   }\n\n   cout << \"Main: program exiting.\" << endl;\n   pthread_exit(NULL);}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nmain() : creating thread, 0main() : creating thread, 1main() : creating thread, 2main() : creating thread, 3main() : creating thread, 4Sleeping in thread \nThread with id : 4  ...exiting \nSleeping in thread \nThread with id : 3  ...exiting \nSleeping in thread \nThread with id : 2  ...exiting \nSleeping in thread \nThread with id : 1  ...exiting \nSleeping in thread \nThread with id : 0  ...exiting \nMain: completed thread id :0  exiting with status :0Main: completed thread id :1  exiting with status :0Main: completed thread id :2  exiting with status :0Main: completed thread id :3  exiting with status :0Main: completed thread id :4  exiting with status :0Main: program exiting.\n```\n\n# C++ Web 编程\n\n## 什么是 CGI？\n\n- 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。\n- CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：\n- 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。\n- 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。\n\n## Web 浏览\n\n为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。\n\n- 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。\n- Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。\n- Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。\n\n然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。\n\n公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。\n\n## CGI 架构图\n\n下图演示了 CGI 的架构：\n\n![img](https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif)\n\n## Web 服务器配置\n\n在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 **.cgi**。\n\n默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：\n\n```cpp\n<Directory \"/var/www/cgi-bin\">   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all</Directory> <Directory \"/var/www/cgi-bin\">Options All</Directory>\n```\n\n在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。\n\n## 第一个 CGI 程序\n\n请看下面的 C++ 程序：\n\n```cpp\n#include <iostream>using namespace std;\n int main (){\n    \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>Hello World - 第一个 CGI 程序</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<h2>Hello World! 这是我的第一个 CGI 程序</h2>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 **chmod 755 cplusplus.cgi** UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：\n\n## Hello World! 这是我的第一个 CGI 程序\n\n上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 **Content-type:text/html\\r\\n\\r\\n**。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。\n\n## HTTP 头信息\n\n行 **Content-type:text/html\\r\\n\\r\\n** 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：\n\n```cpp\nHTTP 字段名称: 字段内容 例如Content-type: text/html\\r\\n\\r\\n\n```\n\n还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。\n\n| 头信息              | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| Content-type:       | MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 |\n| Expires: Date       | 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 |\n| Location: URL       | 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 |\n| Last-modified: Date | 资源的最后修改日期。                                         |\n| Content-length: N   | 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 |\n| Set-Cookie: String  | 通过 *string* 设置 cookie。                                  |\n\n## CGI 环境变量\n\n所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。\n\n| 变量名          | 描述                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| CONTENT_TYPE    | 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 |\n| CONTENT_LENGTH  | 查询的信息长度。只对 POST 请求可用。                         |\n| HTTP_COOKIE     | 以键 & 值对的形式返回设置的 cookies。                        |\n| HTTP_USER_AGENT | 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 |\n| PATH_INFO       | CGI 脚本的路径。                                             |\n| QUERY_STRING    | 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 |\n| REMOTE_ADDR     | 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 |\n| REMOTE_HOST     | 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 |\n| REQUEST_METHOD  | 用于发出请求的方法。最常见的方法是 GET 和 POST。             |\n| SCRIPT_FILENAME | CGI 脚本的完整路径。                                         |\n| SCRIPT_NAME     | CGI 脚本的名称。                                             |\n| SERVER_NAME     | 服务器的主机名或 IP 地址。                                   |\n| SERVER_SOFTWARE | 服务器上运行的软件的名称和版本。                             |\n\n下面的 CGI 程序列出了所有的 CGI 变量。\n\n```cpp\n#include <iostream>#include <stdlib.h>using namespace std;const string ENV[ 24 ] = {                 \n        \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\",   \n        \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\",    &nbsnbsp;        \n        \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\",         \n        \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\",            \n        \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\",      \n        \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\",\n        \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\",      \n        \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\",     \n        \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" };   int main (){\n    \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 环境变量</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<table border = \\\"0\\\" cellspacing = \\\"2\\\">\";\n\n   for ( int i = 0; i < 24; i++ )\n   {\n       cout << \"<tr><td>\" << ENV[ i ] << \"</td><td>\";\n       // 尝试检索环境变量的值\n       char *value = getenv( ENV[ i ].c_str() );  \n       if ( value != 0 ){\n         cout << value;                                 \n       }else{\n         cout << \"环境变量不存在。\";\n       }\n       cout << \"</td></tr>\\n\";\n   }\n   cout << \"</table><\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## C++ CGI 库\n\n在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 [ftp://ftp.gnu.org/gnu/cgicc/](ftp://ftp.gnu.org/gnu/cgicc/) 上下载这个 CGI 库，并按照下面的步骤安装库：\n\n```cpp\n$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install\n```\n\n您可以点击 C++ CGI Lib Documentation，查看相关的库文档。\n\n## GET 和 POST 方法\n\n您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。\n\n## 使用 GET 方法传递信息\n\nGET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：\n\n```cpp\nhttp://www.test.com/cgi-bin/cpp.cgi?key1=value1&key2=value2\n```\n\nGET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。\n\n当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。\n\n您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。\n\n## 简单的 URL 实例：Get 方法\n\n下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。\n\n/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI\n\n下面的实例生成 **cpp_get.cgi** CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>  using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n   \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>使用 GET 和 POST 方法</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"first_name\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"名：\" << **fi << endl;  \n   }else{\n      cout << \"No text entered for first name\" << endl;  \n   }\n   cout << \"<br/>\\n\";\n   fi = formData.getElement(\"last_name\");  \n   if( !fi->isEmpty() &&fi != (*formData).end()) {  \n      cout << \"姓：\" << **fi << endl;  \n   }else{\n      cout << \"No text entered for last name\" << endl;  \n   }\n   cout << \"<br/>\\n\";\n\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n现在，编译上面的程序，如下所示：\n\n```cpp\n$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc\n```\n\n生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：\n\n/cgi-bin/cpp_get.cgi?first_name=ZARA&last_name=ALI\n\n这会产生以下结果：\n\n```cpp\n名：ZARA 姓：ALI\n```\n\n## 简单的表单实例：GET 方法\n\n下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。\n\n```cpp\n<form action=\"/cgi-bin/cpp_get.cgi\" method=\"get\">名：<input type=\"text\" name=\"first_name\">  <br /> 姓：<input type=\"text\" name=\"last_name\" /><input type=\"submit\" value=\"提交\" /></form>\n```\n\n下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。\n\n## 使用 POST 方法传递信息\n\n一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。\n\n我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：\n\n```cpp\n<form action=\"/cgi-bin/cpp_get.cgi\" method=\"post\">名：<input type=\"text\" name=\"first_name\"><br />姓：<input type=\"text\" name=\"last_name\" /> <input type=\"submit\" value=\"提交\" /></form>\n```\n\n## 向 CGI 程序传递复选框数据\n\n当需要选择多个选项时，我们使用复选框。\n\n下面的 HTML 代码实例是一个带有两个复选框的表单：\n\n```html\n<form action=\"/cgi-bin/cpp_checkbox.cgi\" \n         method=\"POST\" \n         target=\"_blank\"><input type=\"checkbox\" name=\"maths\" value=\"on\" /> 数学<input type=\"checkbox\" name=\"physics\" value=\"on\" /> 物理<input type=\"submit\" value=\"选择学科\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n   bool maths_flag, physics_flag;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递复选框数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   maths_flag = formData.queryCheckbox(\"maths\");\n   if( maths_flag ) {  \n      cout << \"Maths Flag: ON \" << endl;  \n   }else{\n      cout << \"Maths Flag: OFF \" << endl;  \n   }\n   cout << \"<br/>\\n\";\n\n   physics_flag = formData.queryCheckbox(\"physics\");\n   if( physics_flag ) {  \n      cout << \"Physics Flag: ON \" << endl;  \n   }else{\n      cout << \"Physics Flag: OFF \" << endl;  \n   }\n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递单选按钮数据\n\n当只需要选择一个选项时，我们使用单选按钮。\n\n下面的 HTML 代码实例是一个带有两个单选按钮的表单：\n\n```cpp\n<form action=\"/cgi-bin/cpp_radiobutton.cgi\" \n         method=\"post\" \n         target=\"_blank\"><input type=\"radio\" name=\"subject\" value=\"maths\" \n                                    checked=\"checked\"/> 数学 \n<input type=\"radio\" name=\"subject\" value=\"physics\" /> 物理<input type=\"submit\" value=\"选择学科\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递单选按钮数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"subject\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Radio box selected: \" << **fi << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递文本区域数据\n\n当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。\n\n下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：\n\n```\n<form action=\"/cgi-bin/cpp_textarea.cgi\" \n         method=\"post\" \n         target=\"_blank\"><textarea name=\"textcontent\" cols=\"40\" rows=\"4\">请在这里输入文本...</textarea><input type=\"submit\" value=\"提交\" /></form>\n```\n\n下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递文本区域数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"textcontent\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Text Content: \" << **fi << endl;  \n   }else{\n      cout << \"No text entered\" << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 向 CGI 程序传递下拉框数据\n\n当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。\n\n下面的 HTML 代码实例是一个带有下拉框的表单：\n\n```cpp\n<form action=\"/cgi-bin/cpp_dropdown.cgi\" \n                       method=\"post\" target=\"_blank\"><select name=\"dropdown\"><option value=\"Maths\" selected>数学</option><option value=\"Physics\">物理</option></select><input type=\"submit\" value=\"提交\"/></form>\n```\n\n下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h> using namespace std;using namespace cgicc;int main (){\n   Cgicc formData;\n  \n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>向 CGI 程序传递下拉框数据</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   form_iterator fi = formData.getElement(\"dropdown\");  \n   if( !fi->isEmpty() && fi != (*formData).end()) {  \n      cout << \"Value Selected: \" << **fi << endl;  \n   }\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n## 在 CGI 中使用 Cookies\n\nHTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。\n\n在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。\n\n### 它是如何工作的\n\n服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。\n\ncookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：\n\n- **Expires :** cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。\n- **Domain :** 网站的域名。\n- **Path :** 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。\n- **Secure :** 如果此字段包含单词 \"secure\"，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。\n- **Name=Value :** cookie 以键值对的形式被设置和获取。\n\n### 设置 Cookies\n\n向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：\n\n```cpp\n#include <iostream>using namespace std;int main (){\n \n   cout << \"Set-Cookie:UserID=XYZ;\\r\\n\";\n   cout << \"Set-Cookie:Password=XYZ123;\\r\\n\";\n   cout << \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\";\n   cout << \"Set-Cookie:Path=/perl;\\n\";\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的 Cookies</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   cout << \"设置 cookies\" << endl;  \n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n从这个实例中，我们了解了如何设置 cookies。我们使用 **Set-Cookie** HTTP 头来设置 cookies。\n\n在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 **\"Content-type:text/html\\r\\n\\r\\n** 之前被设置的。\n\n编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：\n\n/cgi-bin/setcookies.cgi\n\n### 获取 Cookies\n\n检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：\n\n```cpp\nkey1=value1;key2=value2;key3=value3....\n```\n\n下面的实例演示了如何获取 cookies。\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){\n   Cgicc cgi;\n   const_cookie_iterator cci;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的 Cookies</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n   cout << \"<table border = \\\"0\\\" cellspacing = \\\"2\\\">\";\n   \n   // 获取环境变量\n   const CgiEnvironment& env = cgi.getEnvironment();\n\n   for( cci = env.getCookieList().begin();\n        cci != env.getCookieList().end(); \n        ++cci )\n   {\n      cout << \"<tr><td>\" << cci->getName() << \"</td><td>\";\n      cout << cci->getValue();                                 \n      cout << \"</td></tr>\\n\";\n   }\n   cout << \"</table><\\n\";\n  \n   cout << \"<br/>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：\n\n/cgi-bin/getcookies.cgi\n\n这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：\n\n```cpp\nUserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl\n```\n\n## 文件上传实例\n\n为了上传一个文件，HTML 表单必须把 enctype 属性设置为 **multipart/form-data**。带有文件类型的 input 标签会创建一个 \"Browse\" 按钮。\n\n```cpp\n<html><body>\n   <form enctype=\"multipart/form-data\" \n            action=\"/cgi-bin/cpp_uploadfile.cgi\" \n            method=\"post\">\n   <p>文件：<input type=\"file\" name=\"userfile\" /></p>\n   <p><input type=\"submit\" value=\"上传\" /></p>\n   </form></body></html>\n```\n\n这段代码的结果是下面的表单：\n\n文件：\n\n \n\n**注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。\n\n下面是用于处理文件上传的脚本 **cpp_uploadfile.cpp**：\n\n```cpp\n#include <iostream>#include <vector>  #include <string>  #include <stdio.h>  #include <stdlib.h> #include <cgicc/CgiDefs.h> #include <cgicc/Cgicc.h> #include <cgicc/HTTPHTMLHeader.h> #include <cgicc/HTMLClasses.h>using namespace std;using namespace cgicc;int main (){\n   Cgicc cgi;\n\n   cout << \"Content-type:text/html\\r\\n\\r\\n\";\n   cout << \"<html>\\n\";\n   cout << \"<head>\\n\";\n   cout << \"<title>CGI 中的文件上传</title>\\n\";\n   cout << \"</head>\\n\";\n   cout << \"<body>\\n\";\n\n   // 获取要被上传的文件列表\n   const_file_iterator file = cgi.getFile(\"userfile\");\n   if(file != cgi.getFiles().end()) {\n      // 在 cout 中发送数据类型\n      cout << HTTPContentHeader(file->getDataType());\n      // 在 cout 中写入内容\n      file->writeToStream(cout);\n   }\n   cout << \"<文件上传成功>\\n\";\n   cout << \"</body>\\n\";\n   cout << \"</html>\\n\";\n   \n   return 0;}\n```\n\n上面的实例是在 **cout** 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。\n\n# C++ STL 教程\n\n在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |\n| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |\n\n这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。\n\n下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：\n\n```cpp\n#include <iostream>#include <vector>using namespace std;\n int main(){\n   // 创建一个向量存储 int\n   vector<int> vec; \n   int i;\n\n   // 显示 vec 的原始大小\n   cout << \"vector size = \" << vec.size() << endl;\n\n   // 推入 5 个值到向量中\n   for(i = 0; i < 5; i++){\n      vec.push_back(i);\n   }\n\n   // 显示 vec 扩展后的大小\n   cout << \"extended vector size = \" << vec.size() << endl;\n\n   // 访问向量中的 5 个值\n   for(i = 0; i < 5; i++){\n      cout << \"value of vec [\" << i << \"] = \" << vec[i] << endl;\n   }\n\n   // 使用迭代器 iterator 访问值\n   vector<int>::iterator v = vec.begin();\n   while( v != vec.end()) {\n      cout << \"value of v = \" << *v << endl;\n      v++;\n   }\n\n   return 0;}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```cpp\nvector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4\n```\n\n关于上面实例中所使用的各种函数，有几点要注意：\n\n- push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。\n- size( ) 函数显示向量的大小。\n- begin( ) 函数返回一个指向向量开头的迭代器。\n- end( ) 函数返回一个指向向量末尾的迭代器。\n\n# C++ 标准库\n\nC++ 标准库可以分为两部分：\n\n- **标准函数库：** 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。\n- **面向对象类库：** 这个库是类及其相关函数的集合。\n\nC++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。\n\n## 标准函数库\n\n标准函数库分为以下几类：\n\n- 输入/输出 I/O\n- 字符串和字符处理\n- 数学\n- 时间、日期和本地化\n- 动态分配\n- 其他\n- 宽字符函数\n\n## 面向对象类库\n\n标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：\n\n- 标准的 C++ I/O 类\n- String 类\n- 数值类\n- STL 容器类\n- STL 算法\n- STL 函数对象\n- STL 迭代器\n- STL 分配器\n- 本地化库\n- 异常处理类\n- 杂项支持库\n\n\n\n# 参考资料\n\n来源：https://github.com/0voice/cpp_new_features\n\n","slug":"C-基础教程","published":1,"updated":"2023-09-02T03:59:11.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6m0013uywx90nfb5ix","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><strong>原文来自：<a href=\"https://github.com/GrindGold/CppGuide\">https://github.com/GrindGold/CppGuide</a></strong></p>\n<h1 id=\"C-教程\"><a href=\"#C-教程\" class=\"headerlink\" title=\"C++ 教程\"></a>C++ 教程</h1><p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png\"></p>\n<p>C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。</p>\n<p>本教程通过通俗易懂的语言来讲解 C++ 编程语言。</p>\n<p><strong>现在开始学习 C++ 编程！</strong></p>\n<h2 id=\"谁适合阅读本教程？\"><a href=\"#谁适合阅读本教程？\" class=\"headerlink\" title=\"谁适合阅读本教程？\"></a>谁适合阅读本教程？</h2><p>本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。</p>\n<h2 id=\"阅读本教程前，您需要了解的知识：\"><a href=\"#阅读本教程前，您需要了解的知识：\" class=\"headerlink\" title=\"阅读本教程前，您需要了解的知识：\"></a>阅读本教程前，您需要了解的知识：</h2><p>在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。</p>\n<h2 id=\"编译-执行-C-程序\"><a href=\"#编译-执行-C-程序\" class=\"headerlink\" title=\"编译&#x2F;执行 C++ 程序\"></a>编译&#x2F;执行 C++ 程序</h2><h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span> &lt;&lt; endl;    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n\n<p>你可以用 “\\n” 代替以上代码里的 “endl”。</p>\n<h1 id=\"C-简介\"><a href=\"#C-简介\" class=\"headerlink\" title=\"C++ 简介\"></a>C++ 简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>\n<p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p>\n<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p>\n<p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p>\n<p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>\n<h2 id=\"面向对象程序设计\"><a href=\"#面向对象程序设计\" class=\"headerlink\" title=\"面向对象程序设计\"></a>面向对象程序设计</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p>\n<ul>\n<li>封装</li>\n<li>抽象</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h2 id=\"标准库\"><a href=\"#标准库\" class=\"headerlink\" title=\"标准库\"></a>标准库</h2><p>标准的 C++ 由三个重要部分组成：</p>\n<ul>\n<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>\n<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>\n<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>\n</ul>\n<h2 id=\"ANSI-标准\"><a href=\"#ANSI-标准\" class=\"headerlink\" title=\"ANSI 标准\"></a>ANSI 标准</h2><p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>\n<p>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p>\n<h2 id=\"学习-C\"><a href=\"#学习-C\" class=\"headerlink\" title=\"学习 C++\"></a>学习 C++</h2><p>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</p>\n<p>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</p>\n<p>C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。</p>\n<h2 id=\"C-的使用\"><a href=\"#C-的使用\" class=\"headerlink\" title=\"C++ 的使用\"></a>C++ 的使用</h2><p>基本上每个应用程序领域的程序员都有使用 C++。</p>\n<p>C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。</p>\n<p>C++ 广泛用于教学和研究。</p>\n<p>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</p>\n<hr>\n<h2 id=\"标准化\"><a href=\"#标准化\" class=\"headerlink\" title=\"标准化\"></a>标准化</h2><table>\n<thead>\n<tr>\n<th align=\"left\">发布时间</th>\n<th align=\"left\">文档</th>\n<th align=\"left\">通称</th>\n<th align=\"left\">备注</th>\n<th align=\"left\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2015</td>\n<td align=\"left\">ISO&#x2F;IEC TS 19570:2015</td>\n<td align=\"left\">-</td>\n<td align=\"left\">用于并行计算的扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2015</td>\n<td align=\"left\">ISO&#x2F;IEC TS 18822:2015</td>\n<td align=\"left\">-</td>\n<td align=\"left\">文件系统</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2014</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:2014</td>\n<td align=\"left\">C++14</td>\n<td align=\"left\">第四个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2011</td>\n<td align=\"left\">ISO&#x2F;IEC TR 24733:2011</td>\n<td align=\"left\">-</td>\n<td align=\"left\">十进制浮点数扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2011</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:2011</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">第三个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2010</td>\n<td align=\"left\">ISO&#x2F;IEC TR 29124:2010</td>\n<td align=\"left\">-</td>\n<td align=\"left\">数学函数扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2007</td>\n<td align=\"left\">ISO&#x2F;IEC TR 19768:2007</td>\n<td align=\"left\">C++TR1</td>\n<td align=\"left\">C++技术报告：库扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2006</td>\n<td align=\"left\">ISO&#x2F;IEC TR 18015:2006</td>\n<td align=\"left\">-</td>\n<td align=\"left\">C++性能技术报告</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2003</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:2003</td>\n<td align=\"left\">C++03</td>\n<td align=\"left\">第二个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">1998</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:1998</td>\n<td align=\"left\">C++98</td>\n<td align=\"left\">第一个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"C-环境设置\"><a href=\"#C-环境设置\" class=\"headerlink\" title=\"C++ 环境设置\"></a>C++ 环境设置</h1><h2 id=\"本地环境设置\"><a href=\"#本地环境设置\" class=\"headerlink\" title=\"本地环境设置\"></a>本地环境设置</h2><p>如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。</p>\n<h2 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h2><p>这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim&#x2F;vi。</p>\n<p>文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim&#x2F;vi 可用于 Windows 和 Linux&#x2F;UNIX 操作系统上。</p>\n<p>通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>\n<p>在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。</p>\n<h2 id=\"C-编译器\"><a href=\"#C-编译器\" class=\"headerlink\" title=\"C++ 编译器\"></a>C++ 编译器</h2><p>写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>\n<p>C++ 编译器用于把源代码编译成最终的可执行程序。</p>\n<p>大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>\n<p>最常用的免费可用的编译器是 GNU 的 C&#x2F;C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>\n<p>以下部分将指导您如何在不同的操作系统上安装 GNU 的 C&#x2F;C++ 编译器。这里同时提到 C&#x2F;C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。</p>\n<h2 id=\"安装-GNU-的-C-C-编译器\"><a href=\"#安装-GNU-的-C-C-编译器\" class=\"headerlink\" title=\"安装 GNU 的 C&#x2F;C++ 编译器\"></a>安装 GNU 的 C&#x2F;C++ 编译器</h2><h3 id=\"UNIX-Linux-上的安装\"><a href=\"#UNIX-Linux-上的安装\" class=\"headerlink\" title=\"UNIX&#x2F;Linux 上的安装\"></a>UNIX&#x2F;Linux 上的安装</h3><p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ -v</span><br></pre></td></tr></table></figure>\n\n<p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix</span><br><span class=\"line\">gcc version <span class=\"number\">4.1</span><span class=\"number\">.2</span> <span class=\"number\">20080704</span> (Red Hat <span class=\"number\">4.1</span><span class=\"number\">.2</span><span class=\"number\">-46</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果未安装 GCC，那么请按照 <a href=\"http://gcc.gnu.org/install/\">http://gcc.gnu.org/install/</a> 上的详细说明安装 GCC。</p>\n<h3 id=\"Mac-OS-X-上的安装\"><a href=\"#Mac-OS-X-上的安装\" class=\"headerlink\" title=\"Mac OS X 上的安装\"></a>Mac OS X 上的安装</h3><p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>\n<p>Xcode 目前可从 developer.apple.com&#x2F;technologies&#x2F;tools&#x2F; 上下载。</p>\n<h3 id=\"Windows-上的安装\"><a href=\"#Windows-上的安装\" class=\"headerlink\" title=\"Windows 上的安装\"></a>Windows 上的安装</h3><p>为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 <a href=\"http://www.mingw.org,进入/\">www.mingw.org，进入</a> MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p>\n<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>\n<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>\n<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p>\n<hr>\n<h2 id=\"使用-Visual-Studio-Graphical-Interface-编译\"><a href=\"#使用-Visual-Studio-Graphical-Interface-编译\" class=\"headerlink\" title=\"使用 Visual Studio (Graphical Interface) 编译\"></a>使用 Visual Studio (Graphical Interface) 编译</h2><p>1、下载及安装 Visual Studio Community 2015。</p>\n<p>2、打开 Visual Studio Community</p>\n<p>3、点击 File -&gt; New -&gt; Project</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png\" alt=\"img\"></p>\n<p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png\" alt=\"img\"></p>\n<p>5、点击 OK。</p>\n<p>6、在以下窗口中点击 Next</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png\" alt=\"img\"></p>\n<p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：</p>\n<p>8、右击文件夹 Source File 并点击 Add –&gt; New Item… :</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png\" alt=\"img\"></p>\n<p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png\" alt=\"img\"></p>\n<p>10、拷贝以下代码到 main.cpp 中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>int main()&#123;</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>界面如下所示：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png\" alt=\"img\"></p>\n<p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png\" alt=\"img\"></p>\n<p>12、完成以上操作后，你可以看到以下输出：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png\" alt=\"img\"></p>\n<hr>\n<h2 id=\"g-应用说明\"><a href=\"#g-应用说明\" class=\"headerlink\" title=\"g++ 应用说明\"></a>g++ 应用说明</h2><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc main.cpp -lstdc++ -o main</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最简单的编译方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure>\n\n<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.outHello, world!</span><br></pre></td></tr></table></figure>\n\n<p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>\n\n<p>执行 helloworld:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./helloworldHello, world!</span><br></pre></td></tr></table></figure>\n\n<p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure>\n\n<p>生成一个 runoob 可执行文件。</p>\n<p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -g -Wall -std=c++<span class=\"number\">11</span> main.cpp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g-常用命令选项\"><a href=\"#g-常用命令选项\" class=\"headerlink\" title=\"g++ 常用命令选项\"></a>g++ 常用命令选项</h3><table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-ansi</td>\n<td align=\"left\">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>\n</tr>\n<tr>\n<td align=\"left\">-c</td>\n<td align=\"left\">只编译并生成目标文件。</td>\n</tr>\n<tr>\n<td align=\"left\">-DMACRO</td>\n<td align=\"left\">以字符串”1”定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td align=\"left\">-DMACRO&#x3D;DEFN</td>\n<td align=\"left\">以字符串”DEFN”定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td align=\"left\">-E</td>\n<td align=\"left\">只运行 C 预编译器。</td>\n</tr>\n<tr>\n<td align=\"left\">-g</td>\n<td align=\"left\">生成调试信息。GNU 调试器可利用该信息。</td>\n</tr>\n<tr>\n<td align=\"left\">-IDIRECTORY</td>\n<td align=\"left\">指定额外的头文件搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td align=\"left\">-LDIRECTORY</td>\n<td align=\"left\">指定额外的函数库搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td align=\"left\">-lLIBRARY</td>\n<td align=\"left\">连接时搜索指定的函数库LIBRARY。</td>\n</tr>\n<tr>\n<td align=\"left\">-m486</td>\n<td align=\"left\">针对 486 进行代码优化。</td>\n</tr>\n<tr>\n<td align=\"left\">-o</td>\n<td align=\"left\">FILE 生成指定的输出文件。用在生成可执行文件时。</td>\n</tr>\n<tr>\n<td align=\"left\">-O0</td>\n<td align=\"left\">不进行优化处理。</td>\n</tr>\n<tr>\n<td align=\"left\">-O</td>\n<td align=\"left\">或 -O1 优化生成代码。</td>\n</tr>\n<tr>\n<td align=\"left\">-O2</td>\n<td align=\"left\">进一步优化。</td>\n</tr>\n<tr>\n<td align=\"left\">-O3</td>\n<td align=\"left\">比 -O2 更进一步优化，包括 inline 函数。</td>\n</tr>\n<tr>\n<td align=\"left\">-shared</td>\n<td align=\"left\">生成共享目标文件。通常用在建立共享库时。</td>\n</tr>\n<tr>\n<td align=\"left\">-static</td>\n<td align=\"left\">禁止使用共享连接。</td>\n</tr>\n<tr>\n<td align=\"left\">-UMACRO</td>\n<td align=\"left\">取消对 MACRO 宏的定义。</td>\n</tr>\n<tr>\n<td align=\"left\">-w</td>\n<td align=\"left\">不生成任何警告信息。</td>\n</tr>\n<tr>\n<td align=\"left\">-Wall</td>\n<td align=\"left\">生成所有警告信息。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-基本语法\"><a href=\"#C-基本语法\" class=\"headerlink\" title=\"C++ 基本语法\"></a>C++ 基本语法</h1><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>\n<ul>\n<li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>\n<li><strong>类 -</strong> 类可以定义为描述对象行为&#x2F;状态的模板&#x2F;蓝图。</li>\n<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>\n<li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>\n</ul>\n<h2 id=\"C-程序结构\"><a href=\"#C-程序结构\" class=\"headerlink\" title=\"C++ 程序结构\"></a>C++ 程序结构</h2><p>让我们看一段简单的代码，可以输出单词 <em>Hello World</em>。</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; <span class=\"comment\">// main() 是程序开始执行的地方 </span></span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World   return 0;</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们讲解一下上面这段程序：</p>\n<ul>\n<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。</li>\n<li>行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>\n<li>下一行 <strong>&#x2F;&#x2F; main() 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 &#x2F;&#x2F; 开头，在行末结束。</li>\n<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>\n<li>下一行 <strong>cout &lt;&lt; “Hello World”;</strong> 会在屏幕上显示消息 “Hello World”。</li>\n<li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li>\n</ul>\n<h2 id=\"编译-执行-C-程序-1\"><a href=\"#编译-执行-C-程序-1\" class=\"headerlink\" title=\"编译 &amp; 执行 C++ 程序\"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>\n<ul>\n<li>打开一个文本编辑器，添加上述代码。</li>\n<li>保存文件为 hello.cpp。</li>\n<li>打开命令提示符，进入到保存文件所在的目录。</li>\n<li>键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li>\n<li>现在，键入 ‘ a.out’ 来运行程序。</li>\n<li>您可以看到屏幕上显示 ‘ Hello World ‘。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ hello.cpp$ ./a.outHello World</span><br></pre></td></tr></table></figure>\n\n<p>请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。</p>\n<p>您也可以使用 makefile 来编译 C&#x2F;C++ 程序。</p>\n<h2 id=\"C-中的分号-块\"><a href=\"#C-中的分号-块\" class=\"headerlink\" title=\"C++ 中的分号 &amp; 块\"></a>C++ 中的分号 &amp; 块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>\n<p>例如，下面是三个不同的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y;y = y+<span class=\"number\">1</span>;<span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>块是一组使用大括号括起来的按逻辑连接的语句。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y;y = y+<span class=\"number\">1</span>;<span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y; y = y+<span class=\"number\">1</span>; <span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-标识符\"><a href=\"#C-标识符\" class=\"headerlink\" title=\"C++ 标识符\"></a>C++ 标识符</h2><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>\n<p>C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p>\n<p>下面列出几个有效的标识符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-关键字\"><a href=\"#C-关键字\" class=\"headerlink\" title=\"C++ 关键字\"></a>C++ 关键字</h2><p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>\n<table>\n<thead>\n<tr>\n<th>asm</th>\n<th>else</th>\n<th>new</th>\n<th>this</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed</td>\n<td>using</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch</td>\n<td>while</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"三字符组\"><a href=\"#三字符组\" class=\"headerlink\" title=\"三字符组\"></a>三字符组</h2><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p>\n<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</p>\n<p>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>\n<p>下面列出了最常用的三字符序列：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">三字符组</th>\n<th align=\"left\">替换</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">??&#x3D;</td>\n<td align=\"left\">#</td>\n</tr>\n<tr>\n<td align=\"left\">??&#x2F;</td>\n<td align=\"left\">\\</td>\n</tr>\n<tr>\n<td align=\"left\">??’</td>\n<td align=\"left\">^</td>\n</tr>\n<tr>\n<td align=\"left\">??(</td>\n<td align=\"left\">[</td>\n</tr>\n<tr>\n<td align=\"left\">??)</td>\n<td align=\"left\">]</td>\n</tr>\n<tr>\n<td align=\"left\">??!</td>\n<td align=\"left\">|</td>\n</tr>\n<tr>\n<td align=\"left\">??&lt;</td>\n<td align=\"left\">{</td>\n</tr>\n<tr>\n<td align=\"left\">??&gt;</td>\n<td align=\"left\">}</td>\n</tr>\n<tr>\n<td align=\"left\">??-</td>\n<td align=\"left\">~</td>\n</tr>\n</tbody></table>\n<p>如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：”…?””?…”或者转义序列：”…??…”。</p>\n<p>从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项&#x2F;Zc:trigraphs</p>\n<p>g++仍默认支持三字符组，但会给出编译警告。</p>\n<h2 id=\"C-中的空格\"><a href=\"#C-中的空格\" class=\"headerlink\" title=\"C++ 中的空格\"></a>C++ 中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>\n<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> age;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fruit = apples + oranges;   <span class=\"comment\">// 获取水果的总数</span></span><br></pre></td></tr></table></figure>\n\n<p>fruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>\n<h1 id=\"C-注释\"><a href=\"#C-注释\" class=\"headerlink\" title=\"C++ 注释\"></a>C++ 注释</h1><p>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</p>\n<p>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</p>\n<p>C++ 注释以 &#x2F;* 开始，以 *&#x2F; 终止。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 这是注释 */</span><span class=\"comment\">/* C++ 注释也可以</span></span><br><span class=\"line\"><span class=\"comment\"> * 跨行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>注释也能以 &#x2F;&#x2F; 开始，直到行末为止。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;main()&#123;</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译时，编译器会忽略 <strong>&#x2F;&#x2F; 输出 Hello World</strong>，最后会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<p>在 &#x2F;* 和 <em>&#x2F; 注释内部，&#x2F;&#x2F; 字符没有特殊的含义。在 &#x2F;&#x2F; 注释内，&#x2F;</em> 和 *&#x2F; 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">/* 用于输出 Hello World 的注释</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-数据类型\"><a href=\"#C-数据类型\" class=\"headerlink\" title=\"C++ 数据类型\"></a>C++ 数据类型</h1><p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</p>\n<p>您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。</p>\n<h2 id=\"基本的内置类型\"><a href=\"#基本的内置类型\" class=\"headerlink\" title=\"基本的内置类型\"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">布尔型</td>\n<td align=\"left\">bool</td>\n</tr>\n<tr>\n<td align=\"left\">字符型</td>\n<td align=\"left\">char</td>\n</tr>\n<tr>\n<td align=\"left\">整型</td>\n<td align=\"left\">int</td>\n</tr>\n<tr>\n<td align=\"left\">浮点型</td>\n<td align=\"left\">float</td>\n</tr>\n<tr>\n<td align=\"left\">双浮点型</td>\n<td align=\"left\">double</td>\n</tr>\n<tr>\n<td align=\"left\">无类型</td>\n<td align=\"left\">void</td>\n</tr>\n<tr>\n<td align=\"left\">宽字符型</td>\n<td align=\"left\">wchar_t</td>\n</tr>\n</tbody></table>\n<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>short</li>\n<li>long</li>\n</ul>\n<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">位</th>\n<th align=\"left\">范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127 或者 0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">signed char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">0 到 4294967295</td>\n</tr>\n<tr>\n<td align=\"left\">signed int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">0 到 65,535</td>\n</tr>\n<tr>\n<td align=\"left\">signed short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">signed long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">0 to 18,446,744,073,709,551,615</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">+&#x2F;- 3.4e +&#x2F;- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">long double</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">wchar_t</td>\n<td align=\"left\">2 或 4 个字节</td>\n<td align=\"left\">1 个宽字符</td>\n</tr>\n</tbody></table>\n<p>从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。</p>\n<p>下面实例会输出您电脑上各种数据类型的大小。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;   </span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of char : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">char</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of short int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">short</span> <span class=\"type\">int</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of long int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">int</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of float : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of double : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">double</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of wchar_t : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">wchar_t</span>) &lt;&lt; endl;   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本实例使用了 <strong>endl</strong>，这将在每一行后插入一个换行符，&lt;&lt; 运算符用于向屏幕传多个值。我们也使用 <strong>sizeof()</strong> 函数来获取各种数据类型的大小。</p>\n<p>当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size of <span class=\"type\">char</span> : <span class=\"number\">1</span>Size of <span class=\"type\">int</span> : <span class=\"number\">4</span>Size of <span class=\"type\">short</span> <span class=\"type\">int</span> : <span class=\"number\">2</span>Size of <span class=\"type\">long</span> <span class=\"type\">int</span> : <span class=\"number\">8</span>Size of <span class=\"type\">float</span> : <span class=\"number\">4</span>Size of <span class=\"type\">double</span> : <span class=\"number\">8</span>Size of <span class=\"type\">wchar_t</span> : <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typedef-声明\"><a href=\"#typedef-声明\" class=\"headerlink\" title=\"typedef 声明\"></a>typedef 声明</h2><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> type newname;</span><br></pre></td></tr></table></figure>\n\n<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> feet;</span><br></pre></td></tr></table></figure>\n\n<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feet distance;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">enum</span>-name &#123; list of names &#125; var-list;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。</p>\n<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">color</span> &#123; red, green, blue &#125; c;c = blue;</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">color</span> &#123; red, green=<span class=\"number\">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。</p>\n<h1 id=\"C-变量类型\"><a href=\"#C-变量类型\" class=\"headerlink\" title=\"C++ 变量类型\"></a>C++ 变量类型</h1><p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>\n<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>\n<p>基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">bool</td>\n<td align=\"left\">存储值 true 或 false。</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">通常是一个八位字节（一个字节）。这是一个整数类型。</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">对机器而言，整数的最自然的大小。</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">单精度浮点值。</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">双精度浮点值。</td>\n</tr>\n<tr>\n<td align=\"left\">void</td>\n<td align=\"left\">表示类型的缺失。</td>\n</tr>\n<tr>\n<td align=\"left\">wchar_t</td>\n<td align=\"left\">宽字符类型。</td>\n</tr>\n</tbody></table>\n<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>\n<p>下面我们将讲解如何定义、声明和使用各种类型的变量。</p>\n<h2 id=\"C-中的变量定义\"><a href=\"#C-中的变量定义\" class=\"headerlink\" title=\"C++ 中的变量定义\"></a>C++ 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type variable_list;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>    i, j, k;<span class=\"type\">char</span>   c, ch;<span class=\"type\">float</span>  f, salary;<span class=\"type\">double</span> d;</span><br></pre></td></tr></table></figure>\n\n<p>行 <strong>int i, j, k;</strong> 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。</p>\n<p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type variable_name = value;</span><br></pre></td></tr></table></figure>\n\n<p>下面列举几个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> d = <span class=\"number\">3</span>, f = <span class=\"number\">5</span>;   </span><br><span class=\"line\">\t<span class=\"comment\">// d 和 f 的声明 int d = 3, f = 5;          </span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义并初始化 d 和 fbyte z = 22;               </span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义并初始化 zchar x = &#x27;x&#x27;;              </span></span><br><span class=\"line\">\t<span class=\"comment\">// 变量 x 的值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>\n<h2 id=\"C-中的变量声明\"><a href=\"#C-中的变量声明\" class=\"headerlink\" title=\"C++ 中的变量声明\"></a>C++ 中的变量声明</h2><p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>\n<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>\n<h2 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 变量声明extern int a, b;extern int c;extern float f;</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 变量定义</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"type\">int</span> c;</span><br><span class=\"line\">  <span class=\"type\">float</span> f;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; c &lt;&lt; endl ;</span><br><span class=\"line\"></span><br><span class=\"line\">  f = <span class=\"number\">70.0</span>/<span class=\"number\">3.0</span>;</span><br><span class=\"line\">  cout &lt;&lt; f &lt;&lt; endl ;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3023.3333</span></span><br></pre></td></tr></table></figure>\n\n<p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明int func();int main()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数调用</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"built_in\">func</span>();&#125;<span class=\"comment\">// 函数定义int func()&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的左值（Lvalues）和右值（Rvalues）\"><a href=\"#C-中的左值（Lvalues）和右值（Rvalues）\" class=\"headerlink\" title=\"C++ 中的左值（Lvalues）和右值（Rvalues）\"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>C++ 中有两种类型的表达式：</p>\n<ul>\n<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>\n<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>\n</ul>\n<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> g = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-变量作用域\"><a href=\"#C-变量作用域\" class=\"headerlink\" title=\"C++ 变量作用域\"></a>C++ 变量作用域</h1><p>作用域是程序的一个区域，一般来说有三个地方可以声明变量：</p>\n<ul>\n<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>\n<li>在函数参数的定义中声明的变量，称为形式参数。</li>\n<li>在所有函数外部声明的变量，称为全局变量。</li>\n</ul>\n<p>我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。</p>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"type\">int</span> c;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; c;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 全局变量声明int g;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  g = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 全局变量声明int g = 20;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> g = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化局部变量和全局变量\"><a href=\"#初始化局部变量和全局变量\" class=\"headerlink\" title=\"初始化局部变量和全局变量\"></a>初始化局部变量和全局变量</h2><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">初始化默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">int</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">‘\\0’</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">pointer</td>\n<td align=\"left\">NULL</td>\n</tr>\n</tbody></table>\n<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p>\n<h1 id=\"C-常量\"><a href=\"#C-常量\" class=\"headerlink\" title=\"C++ 常量\"></a>C++ 常量</h1><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>\n<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>\n<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>\n<h2 id=\"整数常量\"><a href=\"#整数常量\" class=\"headerlink\" title=\"整数常量\"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>\n<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>\n<p>下面列举几个整数常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">212</span>         <span class=\"comment\">// 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀</span></span><br></pre></td></tr></table></figure>\n\n<p>以下是各种类型的整数常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">85</span>         <span class=\"comment\">// 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"浮点常量\"><a href=\"#浮点常量\" class=\"headerlink\" title=\"浮点常量\"></a>浮点常量</h2><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>\n<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>\n<p>下面列举几个浮点常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3.14159</span>       <span class=\"comment\">// 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"布尔常量\"><a href=\"#布尔常量\" class=\"headerlink\" title=\"布尔常量\"></a>布尔常量</h2><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>\n<ul>\n<li><strong>true</strong> 值代表真。</li>\n<li><strong>false</strong> 值代表假。</li>\n</ul>\n<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>\n<h2 id=\"字符常量\"><a href=\"#字符常量\" class=\"headerlink\" title=\"字符常量\"></a>字符常量</h2><p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>\n<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。</p>\n<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">转义序列</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">\\</td>\n<td align=\"left\">\\ 字符</td>\n</tr>\n<tr>\n<td align=\"left\">&#39;</td>\n<td align=\"left\">‘ 字符</td>\n</tr>\n<tr>\n<td align=\"left\">&quot;</td>\n<td align=\"left\">“ 字符</td>\n</tr>\n<tr>\n<td align=\"left\">?</td>\n<td align=\"left\">? 字符</td>\n</tr>\n<tr>\n<td align=\"left\">\\a</td>\n<td align=\"left\">警报铃声</td>\n</tr>\n<tr>\n<td align=\"left\">\\b</td>\n<td align=\"left\">退格键</td>\n</tr>\n<tr>\n<td align=\"left\">\\f</td>\n<td align=\"left\">换页符</td>\n</tr>\n<tr>\n<td align=\"left\">\\n</td>\n<td align=\"left\">换行符</td>\n</tr>\n<tr>\n<td align=\"left\">\\r</td>\n<td align=\"left\">回车</td>\n</tr>\n<tr>\n<td align=\"left\">\\t</td>\n<td align=\"left\">水平制表符</td>\n</tr>\n<tr>\n<td align=\"left\">\\v</td>\n<td align=\"left\">垂直制表符</td>\n</tr>\n<tr>\n<td align=\"left\">\\ooo</td>\n<td align=\"left\">一到三位的八进制数</td>\n</tr>\n<tr>\n<td align=\"left\">\\xhh . . .</td>\n<td align=\"left\">一个或多个数字的十六进制数</td>\n</tr>\n</tbody></table>\n<p>下面的实例显示了一些转义序列字符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello\\tWorld\\n\\n&quot;</span>;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello   World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串常量\"><a href=\"#字符串常量\" class=\"headerlink\" title=\"字符串常量\"></a>字符串常量</h2><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>\n<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>\n<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;quot;hello, dear&quot;</span><span class=\"string\">&quot;hello, \\dear&quot;</span><span class=\"string\">&quot;hello, &quot;</span> <span class=\"string\">&quot;d&quot;</span> <span class=\"string\">&quot;ear&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p>在 C++ 中，有两种简单的定义常量的方式：</p>\n<ul>\n<li>使用 <strong>#define</strong> 预处理器。</li>\n<li>使用 <strong>const</strong> 关键字。</li>\n</ul>\n<h2 id=\"define-预处理器\"><a href=\"#define-预处理器\" class=\"headerlink\" title=\"#define 预处理器\"></a>#define 预处理器</h2><p>下面是使用 #define 预处理器定义常量的形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> identifier value</span></span><br></pre></td></tr></table></figure>\n\n<p>具体请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> LENGTH 10   #<span class=\"keyword\">define</span> WIDTH  5#<span class=\"keyword\">define</span> NEWLINE <span class=\"string\">&#x27;\\n&#x27;</span>int main()&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> area;  </span><br><span class=\"line\">   </span><br><span class=\"line\">   area = LENGTH * WIDTH;</span><br><span class=\"line\">   cout &lt;&lt; area;</span><br><span class=\"line\">   cout &lt;&lt; NEWLINE;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h2><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> type variable = value;</span><br></pre></td></tr></table></figure>\n\n<p>具体请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">int</span>  LENGTH = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">int</span>  WIDTH  = <span class=\"number\">5</span>;</span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">char</span> NEWLINE = <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> area;  </span><br><span class=\"line\">   </span><br><span class=\"line\">   area = LENGTH * WIDTH;</span><br><span class=\"line\">   cout &lt;&lt; area;</span><br><span class=\"line\">   cout &lt;&lt; NEWLINE;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，把常量定义为大写字母形式，是一个很好的编程实践。</p>\n<h1 id=\"C-修饰符类型\"><a href=\"#C-修饰符类型\" class=\"headerlink\" title=\"C++ 修饰符类型\"></a>C++ 修饰符类型</h1><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>\n<p>下面列出了数据类型修饰符：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>long</li>\n<li>short</li>\n</ul>\n<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>\n<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>\n<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> x;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> y;</span><br></pre></td></tr></table></figure>\n\n<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 这个程序演示了有符号整数和无符号整数之间的差别</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">short</span> <span class=\"type\">int</span> i;           <span class=\"comment\">// 有符号短整数</span></span><br><span class=\"line\">   <span class=\"type\">short</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> j;  <span class=\"comment\">// 无符号短整数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   j = <span class=\"number\">50000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   i = j;</span><br><span class=\"line\">   cout &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; j;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的程序运行时，会输出下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">-15536</span> <span class=\"number\">50000</span></span><br></pre></td></tr></table></figure>\n\n<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>\n<h2 id=\"C-中的类型限定符\"><a href=\"#C-中的类型限定符\" class=\"headerlink\" title=\"C++ 中的类型限定符\"></a>C++ 中的类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">限定符</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">const</td>\n<td align=\"left\"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>\n</tr>\n<tr>\n<td align=\"left\">volatile</td>\n<td align=\"left\">修饰符 <strong>volatile</strong> 告诉编译器，变量的值可能以程序未明确指定的方式被改变。</td>\n</tr>\n<tr>\n<td align=\"left\">restrict</td>\n<td align=\"left\">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-存储类\"><a href=\"#C-存储类\" class=\"headerlink\" title=\"C++ 存储类\"></a>C++ 存储类</h1><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>\n<ul>\n<li>auto</li>\n<li>register</li>\n<li>static</li>\n<li>extern</li>\n<li>mutable</li>\n<li>thread_local (C++11)</li>\n</ul>\n<p>从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>\n<h2 id=\"auto-存储类\"><a href=\"#auto-存储类\" class=\"headerlink\" title=\"auto 存储类\"></a>auto 存储类</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>\n<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。</p>\n<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>\n<p>auto f&#x3D;3.14;    &#x2F;&#x2F;doubleauto s(“hello”);  &#x2F;&#x2F;const char<em>auto z &#x3D; new auto(9); &#x2F;&#x2F; int</em>auto x1 &#x3D; 5, x2 &#x3D; 5.0, x3&#x3D;’r’;&#x2F;&#x2F;错误，必须是初始化为同一类型</p>\n<h2 id=\"register-存储类\"><a href=\"#register-存储类\" class=\"headerlink\" title=\"register 存储类\"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>\n<p>{  register int miles;}</p>\n<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>\n<h2 id=\"static-存储类\"><a href=\"#static-存储类\" class=\"headerlink\" title=\"static 存储类\"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>\n<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>\n<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>\n<h2 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"comment\">// 函数声明 void func(void); </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">10</span>; <span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"built_in\">func</span>();    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"comment\">// 函数定义void func( void )&#123;</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">5</span>; <span class=\"comment\">// 局部静态变量</span></span><br><span class=\"line\">    i++;    std::cout &lt;&lt; <span class=\"string\">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;    std::cout &lt;&lt; <span class=\"string\">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 i 为 <span class=\"number\">6</span> , 变量 count 为 <span class=\"number\">9</span>变量 i 为 <span class=\"number\">7</span> , 变量 count 为 <span class=\"number\">8</span>变量 i 为 <span class=\"number\">8</span> , 变量 count 为 <span class=\"number\">7</span>变量 i 为 <span class=\"number\">9</span> , 变量 count 为 <span class=\"number\">6</span>变量 i 为 <span class=\"number\">10</span> , 变量 count 为 <span class=\"number\">5</span>变量 i 为 <span class=\"number\">11</span> , 变量 count 为 <span class=\"number\">4</span>变量 i 为 <span class=\"number\">12</span> , 变量 count 为 <span class=\"number\">3</span>变量 i 为 <span class=\"number\">13</span> , 变量 count 为 <span class=\"number\">2</span>变量 i 为 <span class=\"number\">14</span> , 变量 count 为 <span class=\"number\">1</span>变量 i 为 <span class=\"number\">15</span> , 变量 count 为 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"extern-存储类\"><a href=\"#extern-存储类\" class=\"headerlink\" title=\"extern 存储类\"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>\n<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>\n<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>\n<p>第一个文件：main.cpp</p>\n<h2 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> count ;<span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   count = <span class=\"number\">5</span>;   <span class=\"built_in\">write_extern</span>();&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个文件：support.cpp</p>\n<h2 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">extern</span> <span class=\"type\">int</span> count; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   std::cout &lt;&lt; <span class=\"string\">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure>\n\n<p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./writeCount is <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mutable-存储类\"><a href=\"#mutable-存储类\" class=\"headerlink\" title=\"mutable 存储类\"></a>mutable 存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>\n<h2 id=\"thread-local-存储类\"><a href=\"#thread-local-存储类\" class=\"headerlink\" title=\"thread_local 存储类\"></a>thread_local 存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>\n<p>thread_local 说明符可以与 static 或 extern 合并。</p>\n<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>\n<p>以下演示了可以被声明为 thread_local 的变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">thread_local</span> <span class=\"type\">int</span> x;  <span class=\"comment\">// 命名空间下的全局变量class X&#123;</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">thread_local</span> std::string s; <span class=\"comment\">// 类的static成员变量&#125;;static thread_local std::string X::s;  // X::s 是需要定义的</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">thread_local</span> std::vector&lt;<span class=\"type\">int</span>&gt; v;  <span class=\"comment\">// 本地变量&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-运算符\"><a href=\"#C-运算符\" class=\"headerlink\" title=\"C++ 运算符\"></a>C++ 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>\n<ul>\n<li>算术运算符</li>\n<li>关系运算符</li>\n<li>逻辑运算符</li>\n<li>位运算符</li>\n<li>赋值运算符</li>\n<li>杂项运算符</li>\n</ul>\n<p>本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p>下表显示了 C++ 支持的算术运算符。</p>\n<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">+</td>\n<td align=\"left\">把两个操作数相加</td>\n<td align=\"left\">A + B 将得到 30</td>\n</tr>\n<tr>\n<td align=\"left\">-</td>\n<td align=\"left\">从第一个操作数中减去第二个操作数</td>\n<td align=\"left\">A - B 将得到 -10</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td align=\"left\">把两个操作数相乘</td>\n<td align=\"left\">A * B 将得到 200</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;</td>\n<td align=\"left\">分子除以分母</td>\n<td align=\"left\">B &#x2F; A 将得到 2</td>\n</tr>\n<tr>\n<td align=\"left\">%</td>\n<td align=\"left\">取模运算符，整除后的余数</td>\n<td align=\"left\">B % A 将得到 0</td>\n</tr>\n<tr>\n<td align=\"left\">++</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html\">自增运算符</a>，整数值增加 1</td>\n<td align=\"left\">A++ 将得到 11</td>\n</tr>\n<tr>\n<td align=\"left\">–</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html\">自减运算符</a>，整数值减少 1</td>\n<td align=\"left\">A– 将得到 9</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的算术运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   c = a + b;   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a - b;   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a * b;   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a / b;   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a % b;   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"type\">int</span> d = <span class=\"number\">10</span>;   <span class=\"comment\">//  测试自增、自减</span></span><br><span class=\"line\">   c = d++;   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   d = <span class=\"number\">10</span>;    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">   c = d--;   cout &lt;&lt; <span class=\"string\">&quot;Line 7 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - c 的值是 <span class=\"number\">31L</span>ine <span class=\"number\">2</span> - c 的值是 <span class=\"number\">11L</span>ine <span class=\"number\">3</span> - c 的值是 <span class=\"number\">210L</span>ine <span class=\"number\">4</span> - c 的值是 <span class=\"number\">2L</span>ine <span class=\"number\">5</span> - c 的值是 <span class=\"number\">1L</span>ine <span class=\"number\">6</span> - c 的值是 <span class=\"number\">10L</span>ine <span class=\"number\">7</span> - c 的值是 <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>下表显示了 C++ 支持的关系运算符。</p>\n<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&#x3D;&#x3D;</td>\n<td align=\"left\">检查两个操作数的值是否相等，如果相等则条件为真。</td>\n<td align=\"left\">(A &#x3D;&#x3D; B) 不为真。</td>\n</tr>\n<tr>\n<td align=\"left\">!&#x3D;</td>\n<td align=\"left\">检查两个操作数的值是否相等，如果不相等则条件为真。</td>\n<td align=\"left\">(A !&#x3D; B) 为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;</td>\n<td align=\"left\">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &gt; B) 不为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;</td>\n<td align=\"left\">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &lt; B) 为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;&#x3D;</td>\n<td align=\"left\">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &gt;&#x3D; B) 不为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;&#x3D;</td>\n<td align=\"left\">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &lt;&#x3D; B) 为真。</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-8\"><a href=\"#实例-8\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的关系运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-9\"><a href=\"#实例-9\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( a == b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - a 等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - a 不等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &lt; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - a 小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - a 不小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - a 大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - a 不大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"comment\">/* 改变 a 和 b 的值 */</span></span><br><span class=\"line\">   a = <span class=\"number\">5</span>;   b = <span class=\"number\">20</span>;   <span class=\"keyword\">if</span> ( a &lt;= b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 4 - a 小于或等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( b &gt;= a )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 5 - b 大于或等于 a&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - a 不等于 bLine <span class=\"number\">2</span> - a 不小于 bLine <span class=\"number\">3</span> - a 大于 bLine <span class=\"number\">4</span> - a 小于或等于 bLine <span class=\"number\">5</span> - b 大于或等于 a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>下表显示了 C++ 支持的关系逻辑运算符。</p>\n<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&amp;&amp;</td>\n<td align=\"left\">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>\n<td align=\"left\">(A &amp;&amp; B) 为假。</td>\n</tr>\n<tr>\n<td align=\"left\">||</td>\n<td align=\"left\">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>\n<td align=\"left\">(A || B) 为真。</td>\n</tr>\n<tr>\n<td align=\"left\">!</td>\n<td align=\"left\">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>\n<td align=\"left\">!(A &amp;&amp; B) 为真。</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-10\"><a href=\"#实例-10\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的逻辑运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-11\"><a href=\"#实例-11\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">5</span>;   <span class=\"type\">int</span> b = <span class=\"number\">20</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &amp;&amp; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a || b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"comment\">/* 改变 a 和 b 的值 */</span></span><br><span class=\"line\">   a = <span class=\"number\">0</span>;   b = <span class=\"number\">10</span>;   <span class=\"keyword\">if</span> ( a &amp;&amp; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 4 - 条件不为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !(a &amp;&amp; b) )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 5 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - 条件为真Line <span class=\"number\">2</span> - 条件为真Line <span class=\"number\">4</span> - 条件不为真Line <span class=\"number\">5</span> - 条件为真</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">p</th>\n<th align=\"left\">q</th>\n<th align=\"left\">p &amp; q</th>\n<th align=\"left\">p | q</th>\n<th align=\"left\">p ^ q</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p>\n<p>A &#x3D; 0011 1100</p>\n<p>B &#x3D; 0000 1101</p>\n<p>-—————-</p>\n<p>A&amp;B &#x3D; 0000 1100</p>\n<p>A|B &#x3D; 0011 1101</p>\n<p>A^B &#x3D; 0011 0001</p>\n<p>~A &#x3D; 1100 0011</p>\n<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&amp;</td>\n<td align=\"left\">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td align=\"left\">(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td align=\"left\">|</td>\n<td align=\"left\">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td align=\"left\">(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td align=\"left\">^</td>\n<td align=\"left\">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td align=\"left\">(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td align=\"left\">~</td>\n<td align=\"left\">二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td align=\"left\">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;&lt;</td>\n<td align=\"left\">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td align=\"left\">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;&gt;</td>\n<td align=\"left\">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td align=\"left\">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-12\"><a href=\"#实例-12\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的位运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-13\"><a href=\"#实例-13\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">60</span>;      <span class=\"comment\">// 60 = 0011 1100  </span></span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">13</span>;      <span class=\"comment\">// 13 = 0000 1101</span></span><br><span class=\"line\">   <span class=\"type\">int</span> c = <span class=\"number\">0</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\">   c = a &amp; b;             <span class=\"comment\">// 12 = 0000 1100</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a | b;             <span class=\"comment\">// 61 = 0011 1101</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a ^ b;             <span class=\"comment\">// 49 = 0011 0001</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = ~a;                <span class=\"comment\">// -61 = 1100 0011</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a &lt;&lt; <span class=\"number\">2</span>;            <span class=\"comment\">// 240 = 1111 0000</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a &gt;&gt; <span class=\"number\">2</span>;            <span class=\"comment\">// 15 = 0000 1111</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">Line 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>下表列出了 C++ 支持的赋值运算符：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&#x3D;</td>\n<td align=\"left\">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>\n<td align=\"left\">C &#x3D; A + B 将把 A + B 的值赋给 C</td>\n</tr>\n<tr>\n<td align=\"left\">+&#x3D;</td>\n<td align=\"left\">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C +&#x3D; A 相当于 C &#x3D; C + A</td>\n</tr>\n<tr>\n<td align=\"left\">-&#x3D;</td>\n<td align=\"left\">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C -&#x3D; A 相当于 C &#x3D; C - A</td>\n</tr>\n<tr>\n<td align=\"left\">*&#x3D;</td>\n<td align=\"left\">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C *&#x3D; A 相当于 C &#x3D; C * A</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;&#x3D;</td>\n<td align=\"left\">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>\n</tr>\n<tr>\n<td align=\"left\">%&#x3D;</td>\n<td align=\"left\">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>\n<td align=\"left\">C %&#x3D; A 相当于 C &#x3D; C % A</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;&lt;&#x3D;</td>\n<td align=\"left\">左移且赋值运算符</td>\n<td align=\"left\">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;&gt;&#x3D;</td>\n<td align=\"left\">右移且赋值运算符</td>\n<td align=\"left\">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>\n</tr>\n<tr>\n<td align=\"left\">&amp;&#x3D;</td>\n<td align=\"left\">按位与且赋值运算符</td>\n<td align=\"left\">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>\n</tr>\n<tr>\n<td align=\"left\">^&#x3D;</td>\n<td align=\"left\">按位异或且赋值运算符</td>\n<td align=\"left\">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>\n</tr>\n<tr>\n<td align=\"left\">|&#x3D;</td>\n<td align=\"left\">按位或且赋值运算符</td>\n<td align=\"left\">C |&#x3D; 2 等同于 C &#x3D; C | 2</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-14\"><a href=\"#实例-14\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的赋值运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-15\"><a href=\"#实例-15\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   c =  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - =  运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c +=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - += 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c -=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - -= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c *=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - *= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c /=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - /= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c  = <span class=\"number\">200</span>;   c %=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - %= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &lt;&lt;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &gt;&gt;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &amp;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 9 - &amp;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c ^=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 10 - ^= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c |=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 11 - |= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - =  运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">2</span> - += 运算符实例，c 的值 = <span class=\"number\">42L</span>ine <span class=\"number\">3</span> - -= 运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">4</span> - *= 运算符实例，c 的值 = <span class=\"number\">441L</span>ine <span class=\"number\">5</span> - /= 运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">6</span> - %= 运算符实例，c 的值 = <span class=\"number\">11L</span>ine <span class=\"number\">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class=\"number\">44L</span>ine <span class=\"number\">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class=\"number\">11L</span>ine <span class=\"number\">9</span> - &amp;= 运算符实例，c 的值 = <span class=\"number\">2L</span>ine <span class=\"number\">10</span> - ^= 运算符实例，c 的值 = <span class=\"number\">0L</span>ine <span class=\"number\">11</span> - |= 运算符实例，c 的值 = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"杂项运算符\"><a href=\"#杂项运算符\" class=\"headerlink\" title=\"杂项运算符\"></a>杂项运算符</h2><p>下表列出了 C++ 支持的其他一些重要的运算符。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">sizeof</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html\">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td>\n</tr>\n<tr>\n<td align=\"left\">Condition ? X : Y</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html\">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-comma-operator.html\">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>\n</tr>\n<tr>\n<td align=\"left\">.（点）和 -&gt;（箭头）</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-member-operators.html\">成员运算符</a>用于引用类、结构和共用体的成员。</td>\n</tr>\n<tr>\n<td align=\"left\">Cast</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-casting-operators.html\">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td>\n</tr>\n<tr>\n<td align=\"left\">&amp;</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html\">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的实际地址。</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html\">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td>\n</tr>\n</tbody></table>\n<h2 id=\"C-中的运算符优先级\"><a href=\"#C-中的运算符优先级\" class=\"headerlink\" title=\"C++ 中的运算符优先级\"></a>C++ 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>\n<p>例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>\n<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类别</th>\n<th align=\"left\">运算符</th>\n<th align=\"left\">结合性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">后缀</td>\n<td align=\"left\">() [] -&gt; . ++ - -</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">一元</td>\n<td align=\"left\">+ - ! ~ ++ - - (type)* &amp; sizeof</td>\n<td align=\"left\">从右到左</td>\n</tr>\n<tr>\n<td align=\"left\">乘除</td>\n<td align=\"left\">* &#x2F; %</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">加减</td>\n<td align=\"left\">+ -</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">移位</td>\n<td align=\"left\">&lt;&lt; &gt;&gt;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">关系</td>\n<td align=\"left\">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">相等</td>\n<td align=\"left\">&#x3D;&#x3D; !&#x3D;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">位与 AND</td>\n<td align=\"left\">&amp;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">位异或 XOR</td>\n<td align=\"left\">^</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">位或 OR</td>\n<td align=\"left\">|</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">逻辑与 AND</td>\n<td align=\"left\">&amp;&amp;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">逻辑或 OR</td>\n<td align=\"left\">||</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">条件</td>\n<td align=\"left\">?:</td>\n<td align=\"left\">从右到左</td>\n</tr>\n<tr>\n<td align=\"left\">赋值</td>\n<td align=\"left\">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>\n<td align=\"left\">从右到左</td>\n</tr>\n<tr>\n<td align=\"left\">逗号</td>\n<td align=\"left\">,</td>\n<td align=\"left\">从左到右</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-16\"><a href=\"#实例-16\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中运算符的优先级。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<p>对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 &#x2F;、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。</p>\n<h2 id=\"实例-17\"><a href=\"#实例-17\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">20</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c = <span class=\"number\">15</span>;   <span class=\"type\">int</span> d = <span class=\"number\">5</span>;   <span class=\"type\">int</span> e; </span><br><span class=\"line\">   e = (a + b) * c / d;      <span class=\"comment\">// ( 30 * 15 ) / 5</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;(a + b) * c / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = ((a + b) * c) / d;    <span class=\"comment\">// (30 * 15 ) / 5</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;((a + b) * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = (a + b) * (c / d);   <span class=\"comment\">// (30) * (15/5)</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;(a + b) * (c / d) 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = a + (b * c) / d;     <span class=\"comment\">//  20 + (150/5)</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;a + (b * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ;  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a + b) * c / d 的值是 <span class=\"number\">90</span>((a + b) * c) / d 的值是 <span class=\"number\">90</span>(a + b) * (c / d) 的值是 <span class=\"number\">90</span>a + (b * c) / d 的值是 <span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-循环\"><a href=\"#C-循环\" class=\"headerlink\" title=\"C++ 循环\"></a>C++ 循环</h1><p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>\n<p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p>\n<p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png\" alt=\"img\"></p>\n<h2 id=\"循环类型\"><a href=\"#循环类型\" class=\"headerlink\" title=\"循环类型\"></a>循环类型</h2><p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">循环类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">while 循环</td>\n<td align=\"left\">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>\n</tr>\n<tr>\n<td align=\"left\">for 循环</td>\n<td align=\"left\">多次执行一个语句序列，简化管理循环变量的代码。</td>\n</tr>\n<tr>\n<td align=\"left\">do…while 循环</td>\n<td align=\"left\">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>\n</tr>\n<tr>\n<td align=\"left\">嵌套循环</td>\n<td align=\"left\">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>\n</tr>\n</tbody></table>\n<h2 id=\"循环控制语句\"><a href=\"#循环控制语句\" class=\"headerlink\" title=\"循环控制语句\"></a>循环控制语句</h2><p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>\n<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">控制语句</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">break 语句</td>\n<td align=\"left\">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>\n</tr>\n<tr>\n<td align=\"left\">continue 语句</td>\n<td align=\"left\">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>\n</tr>\n<tr>\n<td align=\"left\">goto 语句</td>\n<td align=\"left\">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>\n</tr>\n</tbody></table>\n<h2 id=\"无限循环\"><a href=\"#无限循环\" class=\"headerlink\" title=\"无限循环\"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This loop will run forever.\\n&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>\n<p><strong>注意：</strong>您可以按 Ctrl + C 键终止一个无限循环。</p>\n<h1 id=\"C-判断\"><a href=\"#C-判断\" class=\"headerlink\" title=\"C++ 判断\"></a>C++ 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>\n<p>下面是大多数编程语言中典型的判断结构的一般形式：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png\" alt=\"img\"></p>\n<h2 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h2><p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">语句</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">if 语句</td>\n<td align=\"left\">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>\n</tr>\n<tr>\n<td align=\"left\">if…else 语句</td>\n<td align=\"left\">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>\n</tr>\n<tr>\n<td align=\"left\">嵌套 if 语句</td>\n<td align=\"left\">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>\n</tr>\n<tr>\n<td align=\"left\">switch 语句</td>\n<td align=\"left\">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>\n</tr>\n<tr>\n<td align=\"left\">嵌套 switch 语句</td>\n<td align=\"left\">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>\n</tr>\n</tbody></table>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"? : 运算符\"></a>? : 运算符</h2><p>我们已经在前面的章节中讲解了 <a href=\"https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html\"><strong>条件运算符 ? :</strong></a>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>\n\n<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>\n<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>\n<h1 id=\"C-函数\"><a href=\"#C-函数\" class=\"headerlink\" title=\"C++ 函数\"></a>C++ 函数</h1><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>\n<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>\n<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>\n<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>\n<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>\n<h2 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h2><p>C++ 中的函数定义的一般形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter list )</span></span>&#123;   body of the function&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>\n<ul>\n<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>\n<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>\n<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>\n<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>\n</ul>\n<h2 id=\"实例-18\"><a href=\"#实例-18\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数返回两个数中较大的那个数 int max(int num1, int num2) &#123;   // 局部变量声明   int result;    if (num1 &gt; num2)      result = num1;   else      result = num2;    return result; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>\n<p>函数声明包括以下几个部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>针对上面定义的函数 max()，以下是函数声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> num1, <span class=\"type\">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>\n<h2 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h2><p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>\n<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>\n<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 函数声明int max(int num1, int num2);</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> ret;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来获取最大值</span></span><br><span class=\"line\">   ret = <span class=\"built_in\">max</span>(a, b);</span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Max value is : &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 函数返回两个数中较大的那个数int max(int num1, int num2) &#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">if</span> (num1 &gt; num2)</span><br><span class=\"line\">      result = num1;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">      result = num2;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> result; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Max value is : <span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>\n<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>\n<p>当调用函数时，有两种向函数传递参数的方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">调用类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html\">传值调用</a></td>\n<td align=\"left\">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html\">指针调用</a></td>\n<td align=\"left\">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html\">引用调用</a></td>\n<td align=\"left\">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody></table>\n<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。</p>\n<h2 id=\"参数的默认值\"><a href=\"#参数的默认值\" class=\"headerlink\" title=\"参数的默认值\"></a>参数的默认值</h2><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>\n<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b=<span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = a + b;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (result);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来添加值</span></span><br><span class=\"line\">   result = <span class=\"built_in\">sum</span>(a, b);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 再次调用函数</span></span><br><span class=\"line\">   result = <span class=\"built_in\">sum</span>(a);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total value is :<span class=\"number\">300</span>Total value is :<span class=\"number\">120</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Lambda-函数与表达式\"><a href=\"#Lambda-函数与表达式\" class=\"headerlink\" title=\"Lambda 函数与表达式\"></a>Lambda 函数与表达式</h2><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>\n<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>\n<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)-&gt;<span class=\"keyword\">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有参数可以表示为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]&#123; ++global_x; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) -&gt; <span class=\"type\">int</span> &#123; <span class=\"type\">int</span> z = x + y; <span class=\"keyword\">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p>\n<p>如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。</p>\n<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]      <span class=\"comment\">// 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>\n\n<p>另外有一点需要注意。对于[&#x3D;]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">this</span>]() &#123; <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-数字\"><a href=\"#C-数字\" class=\"headerlink\" title=\"C++ 数字\"></a>C++ 数字</h1><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>\n<h2 id=\"C-定义数字\"><a href=\"#C-定义数字\" class=\"headerlink\" title=\"C++ 定义数字\"></a>C++ 定义数字</h2><p>我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 数字定义</span></span><br><span class=\"line\">   <span class=\"type\">short</span>  s;</span><br><span class=\"line\">   <span class=\"type\">int</span>    i;</span><br><span class=\"line\">   <span class=\"type\">long</span>   l;</span><br><span class=\"line\">   <span class=\"type\">float</span>  f;</span><br><span class=\"line\">   <span class=\"type\">double</span> d;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 数字赋值</span></span><br><span class=\"line\">   s = <span class=\"number\">10</span>;      </span><br><span class=\"line\">   i = <span class=\"number\">1000</span>;    </span><br><span class=\"line\">   l = <span class=\"number\">1000000</span>; </span><br><span class=\"line\">   f = <span class=\"number\">230.47</span>;  </span><br><span class=\"line\">   d = <span class=\"number\">30949.374</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 数字输出</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;short  s :&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;int    i :&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;long   l :&quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;float  f :&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;double d :&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">short</span>  s :<span class=\"number\">10</span><span class=\"type\">int</span>    i :<span class=\"number\">1000l</span>ong   l :<span class=\"number\">1000000f</span>loat  f :<span class=\"number\">230.47</span><span class=\"type\">double</span> d :<span class=\"number\">30949.4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-数学运算\"><a href=\"#C-数学运算\" class=\"headerlink\" title=\"C++ 数学运算\"></a>C++ 数学运算</h2><p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>\n<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>\n<p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><strong>double fabs(double);</strong> 该函数返回任意一个十进制数的绝对值。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td>\n</tr>\n</tbody></table>\n<p>下面是一个关于数学运算的简单实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 数字定义</span></span><br><span class=\"line\">   <span class=\"type\">short</span>  s = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span>    i = <span class=\"number\">-1000</span>;</span><br><span class=\"line\">   <span class=\"type\">long</span>   l = <span class=\"number\">100000</span>;</span><br><span class=\"line\">   <span class=\"type\">float</span>  f = <span class=\"number\">230.47</span>;</span><br><span class=\"line\">   <span class=\"type\">double</span> d = <span class=\"number\">200.374</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 数学运算</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;sin(d) :&quot;</span> &lt;&lt; <span class=\"built_in\">sin</span>(d) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class=\"built_in\">abs</span>(i) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;floor(d) :&quot;</span> &lt;&lt; <span class=\"built_in\">floor</span>(d) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class=\"built_in\">sqrt</span>(f) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class=\"built_in\">pow</span>(d, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sign</span>(d) :<span class=\"number\">-0.634939</span>abs(i)  :<span class=\"number\">1000f</span>loor(d) :<span class=\"number\">200</span>sqrt(f) :<span class=\"number\">15.1812</span>pow( d, <span class=\"number\">2</span> ) :<span class=\"number\">40149.7</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-随机数\"><a href=\"#C-随机数\" class=\"headerlink\" title=\"C++ 随机数\"></a>C++ 随机数</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>\n<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> i,j;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">   <span class=\"built_in\">srand</span>( (<span class=\"type\">unsigned</span>)<span class=\"built_in\">time</span>( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 生成 10 个随机数 */</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成实际的随机数</span></span><br><span class=\"line\">      j= <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">      cout &lt;&lt;<span class=\"string\">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">随机数： <span class=\"number\">1748144778</span>随机数： <span class=\"number\">630873888</span>随机数： <span class=\"number\">2134540646</span>随机数： <span class=\"number\">219404170</span>随机数： <span class=\"number\">902129458</span>随机数： <span class=\"number\">920445370</span>随机数： <span class=\"number\">1319072661</span>随机数： <span class=\"number\">257938873</span>随机数： <span class=\"number\">1256201101</span>随机数： <span class=\"number\">580322989</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-数组\"><a href=\"#C-数组\" class=\"headerlink\" title=\"C++ 数组\"></a>C++ 数组</h1><p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>\n<p>数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。</p>\n<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>\n<h2 id=\"声明数组\"><a href=\"#声明数组\" class=\"headerlink\" title=\"声明数组\"></a>声明数组</h2><p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure>\n\n<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n\n<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>\n<h2 id=\"初始化数组\"><a href=\"#初始化数组\" class=\"headerlink\" title=\"初始化数组\"></a>初始化数组</h2><p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">17.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>\n<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">17.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">balance[<span class=\"number\">4</span>] = <span class=\"number\">50.0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</p>\n<p><img src=\"https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg\" alt=\"数组表示\"></p>\n<h2 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> salary = balance[<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span>using std::setw;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> n[ <span class=\"number\">10</span> ]; <span class=\"comment\">// n 是一个包含 10 个整数的数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 初始化数组元素          </span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      n[ i ] = i + <span class=\"number\">100</span>; <span class=\"comment\">// 设置元素 i 为 i + 100</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Element&quot;</span> &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">13</span> ) &lt;&lt; <span class=\"string\">&quot;Value&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 输出数组中每个元素的值                     </span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">7</span> )&lt;&lt; j &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的程序使用了 <strong>setw()</strong> 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element        Value</span><br><span class=\"line\">      <span class=\"number\">0</span>          <span class=\"number\">100</span></span><br><span class=\"line\">      <span class=\"number\">1</span>          <span class=\"number\">101</span></span><br><span class=\"line\">      <span class=\"number\">2</span>          <span class=\"number\">102</span></span><br><span class=\"line\">      <span class=\"number\">3</span>          <span class=\"number\">103</span></span><br><span class=\"line\">      <span class=\"number\">4</span>          <span class=\"number\">104</span></span><br><span class=\"line\">      <span class=\"number\">5</span>          <span class=\"number\">105</span></span><br><span class=\"line\">      <span class=\"number\">6</span>          <span class=\"number\">106</span></span><br><span class=\"line\">      <span class=\"number\">7</span>          <span class=\"number\">107</span></span><br><span class=\"line\">      <span class=\"number\">8</span>          <span class=\"number\">108</span></span><br><span class=\"line\">      <span class=\"number\">9</span>          <span class=\"number\">109</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中数组详解\"><a href=\"#C-中数组详解\" class=\"headerlink\" title=\"C++ 中数组详解\"></a>C++ 中数组详解</h2><p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">多维数组</td>\n<td align=\"left\">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td>\n</tr>\n<tr>\n<td align=\"left\">指向数组的指针</td>\n<td align=\"left\">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">传递数组给函数</td>\n<td align=\"left\">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">从函数返回数组</td>\n<td align=\"left\">C++ 允许从函数返回数组。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-字符串\"><a href=\"#C-字符串\" class=\"headerlink\" title=\"C++ 字符串\"></a>C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p>\n<ul>\n<li>C 风格字符串</li>\n<li>C++ 引入的 string 类类型</li>\n</ul>\n<h2 id=\"C-风格字符串\"><a href=\"#C-风格字符串\" class=\"headerlink\" title=\"C 风格字符串\"></a>C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>\n<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> greeting[<span class=\"number\">6</span>] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> greeting[] = <span class=\"string\">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>以下是 C&#x2F;C++ 中定义的字符串的内存表示：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg\" alt=\"img\"></p>\n<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。让我们尝试输出上面的字符串：</p>\n<h2 id=\"实例-19\"><a href=\"#实例-19\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> greeting[<span class=\"number\">6</span>] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;; </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Greeting message: &quot;</span>;   cout &lt;&lt; greeting &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Greeting message: Hello</span><br></pre></td></tr></table></figure>\n\n<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 目的</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>\n</tr>\n</tbody></table>\n<p>下面的实例使用了上述的一些函数：</p>\n<h2 id=\"实例-20\"><a href=\"#实例-20\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;Hello&quot;</span>;   <span class=\"type\">char</span> str2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;World&quot;</span>;   <span class=\"type\">char</span> str3[<span class=\"number\">11</span>];   <span class=\"type\">int</span>  len ; </span><br><span class=\"line\">   <span class=\"comment\">// 复制 str1 到 str3</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( str3, str1);   cout &lt;&lt; <span class=\"string\">&quot;strcpy( str3, str1) : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接 str1 和 str2</span></span><br><span class=\"line\">   <span class=\"built_in\">strcat</span>( str1, str2);   cout &lt;&lt; <span class=\"string\">&quot;strcat( str1, str2): &quot;</span> &lt;&lt; str1 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接后，str1 的总长度</span></span><br><span class=\"line\">   len = <span class=\"built_in\">strlen</span>(str1);   cout &lt;&lt; <span class=\"string\">&quot;strlen(str1) : &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcpy</span>( str3, str1) : <span class=\"built_in\">Hellostrcat</span>( str1, str2): <span class=\"built_in\">HelloWorldstrlen</span>(str1) : <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的-String-类\"><a href=\"#C-中的-String-类\" class=\"headerlink\" title=\"C++ 中的 String 类\"></a>C++ 中的 String 类</h2><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>\n<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>\n<h2 id=\"实例-21\"><a href=\"#实例-21\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   string str1 = <span class=\"string\">&quot;Hello&quot;</span>;   string str2 = <span class=\"string\">&quot;World&quot;</span>;   string str3;   <span class=\"type\">int</span>  len ; </span><br><span class=\"line\">   <span class=\"comment\">// 复制 str1 到 str3</span></span><br><span class=\"line\">   str3 = str1;   cout &lt;&lt; <span class=\"string\">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接 str1 和 str2</span></span><br><span class=\"line\">   str3 = str1 + str2;   cout &lt;&lt; <span class=\"string\">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接后，str3 的总长度</span></span><br><span class=\"line\">   len = str3.<span class=\"built_in\">size</span>();   cout &lt;&lt; <span class=\"string\">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str3 : Hellostr1 + str2 : HelloWorldstr3.<span class=\"built_in\">size</span>() :  <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-指针\"><a href=\"#C-指针\" class=\"headerlink\" title=\"C++ 指针\"></a>C++ 指针</h1><p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>\n<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  var1;</span><br><span class=\"line\">   <span class=\"type\">char</span> var2[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;var1 变量的地址： &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;var2 变量的地址： &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var1 变量的地址： <span class=\"number\">0xbfebd5c0</span>var2 变量的地址： <span class=\"number\">0xbfebd5b6</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。</p>\n<h2 id=\"什么是指针？\"><a href=\"#什么是指针？\" class=\"headerlink\" title=\"什么是指针？\"></a>什么是指针？</h2><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type *var-name;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>    *ip;    <span class=\"comment\">/* 一个整型的指针 */</span><span class=\"type\">double</span> *dp;    <span class=\"comment\">/* 一个 double 型的指针 */</span><span class=\"type\">float</span>  *fp;    <span class=\"comment\">/* 一个浮点型的指针 */</span><span class=\"type\">char</span>   *ch;    <span class=\"comment\">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>\n\n<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>\n<h2 id=\"C-中使用指针\"><a href=\"#C-中使用指针\" class=\"headerlink\" title=\"C++ 中使用指针\"></a>C++ 中使用指针</h2><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  var = <span class=\"number\">20</span>;   <span class=\"comment\">// 实际变量的声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  *ip;        <span class=\"comment\">// 指针变量的声明</span></span><br><span class=\"line\"></span><br><span class=\"line\">   ip = &amp;var;       <span class=\"comment\">// 在指针变量中存储 var 的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of var variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; var &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出在指针变量中存储的地址</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Address stored in ip variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 访问指针中地址的值</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of *ip variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; *ip &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of var variable: <span class=\"number\">20</span>Address stored in ip variable: <span class=\"number\">0xbfc601ac</span>Value of *ip variable: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-指针详解\"><a href=\"#C-指针详解\" class=\"headerlink\" title=\"C++ 指针详解\"></a>C++ 指针详解</h2><p>在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C++ Null 指针</td>\n<td align=\"left\">C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指针的算术运算</td>\n<td align=\"left\">可以对指针进行四种算术运算：++、–、+、-</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指针 vs 数组</td>\n<td align=\"left\">指针和数组之间有着密切的关系。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指针数组</td>\n<td align=\"left\">可以定义用来存储指针的数组。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指向指针的指针</td>\n<td align=\"left\">C++ 允许指向指针的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 传递指针给函数</td>\n<td align=\"left\">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 从函数返回指针</td>\n<td align=\"left\">C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-引用\"><a href=\"#C-引用\" class=\"headerlink\" title=\"C++ 引用\"></a>C++ 引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\n<h2 id=\"C-引用-vs-指针\"><a href=\"#C-引用-vs-指针\" class=\"headerlink\" title=\"C++ 引用 vs 指针\"></a>C++ 引用 vs 指针</h2><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n<ul>\n<li>不存在空引用。引用必须连接到一块合法的内存。</li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>\n</ul>\n<h2 id=\"C-中创建引用\"><a href=\"#C-中创建引用\" class=\"headerlink\" title=\"C++ 中创建引用\"></a>C++ 中创建引用</h2><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">17</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以为 i 声明引用变量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;    r = i;</span><br></pre></td></tr></table></figure>\n\n<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 声明简单的变量</span></span><br><span class=\"line\">   <span class=\"type\">int</span>    i;</span><br><span class=\"line\">   <span class=\"type\">double</span> d;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 声明引用变量</span></span><br><span class=\"line\">   <span class=\"type\">int</span>&amp;    r = i;</span><br><span class=\"line\">   <span class=\"type\">double</span>&amp; s = d;</span><br><span class=\"line\">   </span><br><span class=\"line\">   i = <span class=\"number\">5</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   d = <span class=\"number\">11.7</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of i : <span class=\"number\">5</span>Value of i reference : <span class=\"number\">5</span>Value of d : <span class=\"number\">11.7</span>Value of d reference : <span class=\"number\">11.7</span></span><br></pre></td></tr></table></figure>\n\n<p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">把引用作为参数</td>\n<td align=\"left\">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td>\n</tr>\n<tr>\n<td align=\"left\">把引用作为返回值</td>\n<td align=\"left\">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-日期-时间\"><a href=\"#C-日期-时间\" class=\"headerlink\" title=\"C++ 日期 &amp; 时间\"></a>C++ 日期 &amp; 时间</h1><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</p>\n<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>\n<p>结构类型 <strong>tm</strong> 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> tm_sec;   <span class=\"comment\">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_min;   <span class=\"comment\">// 分，范围从 0 到 59</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_hour;  <span class=\"comment\">// 小时，范围从 0 到 23</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_mday;  <span class=\"comment\">// 一月中的第几天，范围从 1 到 31</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_mon;   <span class=\"comment\">// 月，范围从 0 到 11</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_year;  <span class=\"comment\">// 自 1900 年起的年数</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_wday;  <span class=\"comment\">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_yday;  <span class=\"comment\">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_isdst; <span class=\"comment\">// 夏令时&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是 C&#x2F;C++ 中关于日期和时间的重要函数。所有这些函数都是 C&#x2F;C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>time_t time(time_t *time);</strong> 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>char *ctime(const time_t *time);</strong> 该返回一个表示当地时间的字符串指针，字符串形式 <em>day month year hours:minutes:seconds year\\n\\0</em>。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>struct tm *localtime(const time_t *time);</strong> 该函数返回一个指向表示本地时间的 <strong>tm</strong> 结构的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>clock_t clock(void);</strong> 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>char * asctime ( const struct tm * time );</strong> 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>struct tm *gmtime(const time_t *time);</strong> 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><strong>time_t mktime(struct tm *time);</strong> 该函数返回日历时间，相当于 time 所指向结构中存储的时间。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><strong>double difftime ( time_t time2, time_t time1 );</strong> 该函数返回 time1 和 time2 之间相差的秒数。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><strong>size_t strftime();</strong> 该函数可用于格式化日期和时间为指定的格式。</td>\n</tr>\n</tbody></table>\n<h2 id=\"当前日期和时间\"><a href=\"#当前日期和时间\" class=\"headerlink\" title=\"当前日期和时间\"></a>当前日期和时间</h2><p>下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 基于当前系统的当前日期/时间</span></span><br><span class=\"line\">   <span class=\"type\">time_t</span> now = <span class=\"built_in\">time</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 把 now 转换为字符串形式</span></span><br><span class=\"line\">   <span class=\"type\">char</span>* dt = <span class=\"built_in\">ctime</span>(&amp;now);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把 now 转换为 tm 结构</span></span><br><span class=\"line\">   tm *gmtm = <span class=\"built_in\">gmtime</span>(&amp;now);</span><br><span class=\"line\">   dt = <span class=\"built_in\">asctime</span>(gmtm);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地日期和时间：Sat Jan  <span class=\"number\">8</span> <span class=\"number\">20</span>:<span class=\"number\">07</span>:<span class=\"number\">41</span> <span class=\"number\">2011U</span>TC 日期和时间：Sun Jan  <span class=\"number\">9</span> <span class=\"number\">03</span>:<span class=\"number\">07</span>:<span class=\"number\">41</span> <span class=\"number\">2011</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用结构-tm-格式化时间\"><a href=\"#使用结构-tm-格式化时间\" class=\"headerlink\" title=\"使用结构 tm 格式化时间\"></a>使用结构 tm 格式化时间</h2><p><strong>tm</strong> 结构在 C&#x2F;C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>\n<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 基于当前系统的当前日期/时间</span></span><br><span class=\"line\">   <span class=\"type\">time_t</span> now = <span class=\"built_in\">time</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Number of sec since January 1,1970:&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   tm *ltm = <span class=\"built_in\">localtime</span>(&amp;now);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出 tm 结构的各个组成部分</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Year: &quot;</span>&lt;&lt; <span class=\"number\">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Month: &quot;</span>&lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Day: &quot;</span>&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Time: &quot;</span>&lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_hour &lt;&lt; <span class=\"string\">&quot;:&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_min &lt;&lt; <span class=\"string\">&quot;:&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_sec &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number of sec since January <span class=\"number\">1</span>, <span class=\"number\">1970</span>:<span class=\"number\">1294548238</span>Year: <span class=\"number\">2011</span>Month: <span class=\"number\">1</span>Day: <span class=\"number\">8</span>Time: <span class=\"number\">22</span>: <span class=\"number\">44</span>:<span class=\"number\">59</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-基本的输入输出\"><a href=\"#C-基本的输入输出\" class=\"headerlink\" title=\"C++ 基本的输入输出\"></a>C++ 基本的输入输出</h1><p>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</p>\n<p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>\n<h2 id=\"I-O-库头文件\"><a href=\"#I-O-库头文件\" class=\"headerlink\" title=\"I&#x2F;O 库头文件\"></a>I&#x2F;O 库头文件</h2><p>下列的头文件在 C++ 编程中很重要。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">头文件</th>\n<th align=\"left\">函数和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><iostream></td>\n<td align=\"left\">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\"><iomanip></td>\n<td align=\"left\">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td>\n</tr>\n<tr>\n<td align=\"left\"><fstream></td>\n<td align=\"left\">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>\n</tr>\n</tbody></table>\n<h2 id=\"标准输出流（cout）\"><a href=\"#标准输出流（cout）\" class=\"headerlink\" title=\"标准输出流（cout）\"></a>标准输出流（cout）</h2><p>预定义的对象 <strong>cout</strong> 是 <strong>ostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std; int main( )&#123;   char str[] = <span class=\"string\">&quot;Hello C++&quot;</span>;    cout &lt;&lt; <span class=\"string\">&quot;Value of str is : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of str is : Hello C++</span><br></pre></td></tr></table></figure>\n\n<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>\n<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>\n<h2 id=\"标准输入流（cin）\"><a href=\"#标准输入流（cin）\" class=\"headerlink\" title=\"标准输入流（cin）\"></a>标准输入流（cin）</h2><p>预定义的对象 <strong>cin</strong> 是 <strong>istream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std; int main( )&#123;  </span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[<span class=\"number\">50</span>];    cout &lt;&lt; <span class=\"string\">&quot;请输入您的名称： &quot;</span>;   </span><br><span class=\"line\">\tcin &gt;&gt; name;   cout &lt;&lt; <span class=\"string\">&quot;您的名称是： &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入您的名称： cplusplus您的名称是： cplusplus</span><br></pre></td></tr></table></figure>\n\n<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>\n<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure>\n\n<p>这相当于下面两个语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin &gt;&gt; name;cin &gt;&gt; age;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标准错误流（cerr）\"><a href=\"#标准错误流（cerr）\" class=\"headerlink\" title=\"标准错误流（cerr）\"></a>标准错误流（cerr）</h2><p>预定义的对象 <strong>cerr</strong> 是 <strong>ostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>\n<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   cerr &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error message : Unable to read....</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标准日志流（clog）\"><a href=\"#标准日志流（clog）\" class=\"headerlink\" title=\"标准日志流（clog）\"></a>标准日志流（clog）</h2><p>预定义的对象 <strong>clog</strong> 是 <strong>ostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>\n<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   clog &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error message : Unable to read....</span><br></pre></td></tr></table></figure>\n\n<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>\n<h1 id=\"C-数据结构\"><a href=\"#C-数据结构\" class=\"headerlink\" title=\"C++ 数据结构\"></a>C++ 数据结构</h1><p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>\n<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>\n<ul>\n<li>Title ：标题</li>\n<li>Author ：作者</li>\n<li>Subject ：类目</li>\n<li>Book ID ：书的 ID</li>\n</ul>\n<h2 id=\"定义结构\"><a href=\"#定义结构\" class=\"headerlink\" title=\"定义结构\"></a>定义结构</h2><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">type_name</span> &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names;</span><br></pre></td></tr></table></figure>\n\n<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 <strong>Books</strong>，变量为 <strong>book</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span>&#123;   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];      <span class=\"type\">int</span>   book_id;&#125; book;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问结构成员\"><a href=\"#访问结构成员\" class=\"headerlink\" title=\"访问结构成员\"></a>访问结构成员</h2><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>\n<p>下面的实例演示了结构的用法：</p>\n<h2 id=\"实例-22\"><a href=\"#实例-22\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"comment\">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book1 信息</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;第一本书标题 : &quot;</span> &lt;&lt; Book1.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书作者 : &quot;</span> &lt;&lt; Book1.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书类目 : &quot;</span> &lt;&lt; Book1.subject &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书 ID : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt;endl; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book2 信息</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;第二本书标题 : &quot;</span> &lt;&lt; Book2.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书作者 : &quot;</span> &lt;&lt; Book2.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书类目 : &quot;</span> &lt;&lt; Book2.subject &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书 ID : &quot;</span> &lt;&lt; Book2.book_id &lt;&lt;endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : <span class=\"number\">12345</span>第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构作为函数参数\"><a href=\"#结构作为函数参数\" class=\"headerlink\" title=\"结构作为函数参数\"></a>结构作为函数参数</h2><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>\n<h2 id=\"实例-23\"><a href=\"#实例-23\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books book )</span></span>; </span><br><span class=\"line\"><span class=\"comment\">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book1 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( Book1 ); </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book2 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( Book2 ); </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books book )</span></span>&#123;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书作者 : &quot;</span> </span><br><span class=\"line\">   &lt;&lt; book.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class=\"number\">12345</span>书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指向结构的指针\"><a href=\"#指向结构的指针\" class=\"headerlink\" title=\"指向结构的指针\"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span> *struct_pointer;</span><br></pre></td></tr></table></figure>\n\n<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>\n\n<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>\n\n<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>\n<h2 id=\"实例-24\"><a href=\"#实例-24\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books *book )</span></span>; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( &amp;Book1 ); </span><br><span class=\"line\">   <span class=\"comment\">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( &amp;Book2 ); </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"comment\">// 该函数以结构指针作为参数void printBook( struct Books *book )&#123;</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书标题  : &quot;</span> &lt;&lt; book-&gt;title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书作者 : &quot;</span> </span><br><span class=\"line\">   &lt;&lt; book-&gt;author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书类目 : &quot;</span> &lt;&lt; book-&gt;subject &lt;&lt;endl;   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书 ID : &quot;</span> &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class=\"number\">12345</span>书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typedef-关键字\"><a href=\"#typedef-关键字\" class=\"headerlink\" title=\"typedef 关键字\"></a>typedef 关键字</h2><p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];</span><br><span class=\"line\">   <span class=\"type\">int</span>   book_id;&#125;Books;</span><br></pre></td></tr></table></figure>\n\n<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Books Book1, Book2;</span><br></pre></td></tr></table></figure>\n\n<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">int</span> *pint32;</span><br><span class=\"line\"> pint32 x, y, z;</span><br></pre></td></tr></table></figure>\n\n<p>x, y 和 z 都是指向长整型 long int 的指针。</p>\n<h1 id=\"C-类-对象\"><a href=\"#C-类-对象\" class=\"headerlink\" title=\"C++ 类 &amp; 对象\"></a>C++ 类 &amp; 对象</h1><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>\n<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。</p>\n<h2 id=\"C-类定义\"><a href=\"#C-类定义\" class=\"headerlink\" title=\"C++ 类定义\"></a>C++ 类定义</h2><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>\n<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;   <span class=\"keyword\">public</span>:      <span class=\"type\">double</span> length;   <span class=\"comment\">// Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>，这个我们稍后会进行讲解。</p>\n<h2 id=\"定义-C-对象\"><a href=\"#定义-C-对象\" class=\"headerlink\" title=\"定义 C++ 对象\"></a>定义 C++ 对象</h2><p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box Box1;          <span class=\"comment\">// 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>\n\n<p>对象 Box1 和 Box2 都有它们各自的数据成员。</p>\n<h2 id=\"访问数据成员\"><a href=\"#访问数据成员\" class=\"headerlink\" title=\"访问数据成员\"></a>访问数据成员</h2><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;   <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;   <span class=\"comment\">// 高度&#125;;int main( )&#123;</span></span><br><span class=\"line\">   Box Box1;        <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;        <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 用于存储体积</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 1 详述</span></span><br><span class=\"line\">   Box1.height = <span class=\"number\">5.0</span>; </span><br><span class=\"line\">   Box1.length = <span class=\"number\">6.0</span>; </span><br><span class=\"line\">   Box1.breadth = <span class=\"number\">7.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 2 详述</span></span><br><span class=\"line\">   Box2.height = <span class=\"number\">10.0</span>;</span><br><span class=\"line\">   Box2.length = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">   Box2.breadth = <span class=\"number\">13.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 1 的体积</span></span><br><span class=\"line\">   volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 2 的体积</span></span><br><span class=\"line\">   volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box1 的体积：<span class=\"number\">210B</span>ox2 的体积：<span class=\"number\">1560</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>\n<h1 id=\"类-对象详解\"><a href=\"#类-对象详解\" class=\"headerlink\" title=\"类 &amp; 对象详解\"></a>类 &amp; 对象详解</h1><p>到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">类成员函数</td>\n<td align=\"left\">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td>\n</tr>\n<tr>\n<td align=\"left\">类访问修饰符</td>\n<td align=\"left\">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td>\n</tr>\n<tr>\n<td align=\"left\">构造函数 &amp; 析构函数</td>\n<td align=\"left\">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 拷贝构造函数</td>\n<td align=\"left\">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 友元函数</td>\n<td align=\"left\"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 内联函数</td>\n<td align=\"left\">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 中的 this 指针</td>\n<td align=\"left\">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 中指向类的指针</td>\n<td align=\"left\">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 类的静态成员</td>\n<td align=\"left\">类的数据成员和函数成员都可以被声明为静态的。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-继承\"><a href=\"#C-继承\" class=\"headerlink\" title=\"C++ 继承\"></a>C++ 继承</h1><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>\n<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>\n<h2 id=\"基类-派生类\"><a href=\"#基类-派生类\" class=\"headerlink\" title=\"基类 &amp; 派生类\"></a>基类 &amp; 派生类</h2><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">derived</span>-<span class=\"keyword\">class</span>: access-specifier base-<span class=\"keyword\">class</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>\n<p>假设有一个基类 <strong>Shape</strong>，<strong>Rectangle</strong> 是它的派生类，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"comment\">// 基类class Shape &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width;</span><br><span class=\"line\">      <span class=\"type\">int</span> height;&#125;;<span class=\"comment\">// 派生类class Rectangle: public Shape&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: 35</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问控制和继承\"><a href=\"#访问控制和继承\" class=\"headerlink\" title=\"访问控制和继承\"></a>访问控制和继承</h2><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>\n<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">访问</th>\n<th align=\"left\">public</th>\n<th align=\"left\">protected</th>\n<th align=\"left\">private</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">同一个类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">派生类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\">外部的类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">no</td>\n<td align=\"left\">no</td>\n</tr>\n</tbody></table>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<h2 id=\"继承类型\"><a href=\"#继承类型\" class=\"headerlink\" title=\"继承类型\"></a>继承类型</h2><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>\n<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>\n<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>\n</ul>\n<h2 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>\n<p>C++ 类可以从多个类继承成员，语法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> &lt;派生类名&gt;:&lt;继承方式<span class=\"number\">1</span>&gt;&lt;基类名<span class=\"number\">1</span>&gt;,&lt;继承方式<span class=\"number\">2</span>&gt;&lt;基类名<span class=\"number\">2</span>&gt;,…&#123;&lt;派生类类体&gt;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"comment\">// 基类 Shapeclass Shape &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width;</span><br><span class=\"line\">      <span class=\"type\">int</span> height;&#125;;<span class=\"comment\">// 基类 PaintCostclass PaintCost &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"type\">int</span> area)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> area * <span class=\"number\">70</span>;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"comment\">// 派生类class Rectangle: public Shape, public PaintCost&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   <span class=\"type\">int</span> area;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   area = Rect.<span class=\"built_in\">getArea</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出总花费</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getCost</span>(area) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: <span class=\"number\">35</span>Total paint cost: $<span class=\"number\">2450</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-重载运算符和重载函数\"><a href=\"#C-重载运算符和重载函数\" class=\"headerlink\" title=\"C++ 重载运算符和重载函数\"></a>C++ 重载运算符和重载函数</h1><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>\n<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>\n<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>\n<h2 id=\"C-中的函数重载\"><a href=\"#C-中的函数重载\" class=\"headerlink\" title=\"C++ 中的函数重载\"></a>C++ 中的函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>\n<p>下面的实例中，同名函数 <strong>print()</strong> 被用于输出不同的数据类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">printData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span>  f)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">char</span>* c)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing character: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   printData pd;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Call print to print integer</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">// Call print to print float</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">500.263</span>);</span><br><span class=\"line\">   <span class=\"comment\">// Call print to print character</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello C++&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Printing <span class=\"type\">int</span>: <span class=\"number\">5</span>Printing <span class=\"type\">float</span>: <span class=\"number\">500.263</span>Printing character: Hello C++</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的运算符重载\"><a href=\"#C-中的运算符重载\" class=\"headerlink\" title=\"C++ 中的运算符重载\"></a>C++ 中的运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>\n<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>\n\n<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp;, <span class=\"type\">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>\n\n<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 <strong>this</strong> 运算符进行访问，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          length = len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setBreadth</span><span class=\"params\">( <span class=\"type\">double</span> bre )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          breadth = bre;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">( <span class=\"type\">double</span> hei )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          height = hei;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class=\"line\">      Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp; b)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         Box box;</span><br><span class=\"line\">         box.length = <span class=\"keyword\">this</span>-&gt;length + b.length;</span><br><span class=\"line\">         box.breadth = <span class=\"keyword\">this</span>-&gt;breadth + b.breadth;</span><br><span class=\"line\">         box.height = <span class=\"keyword\">this</span>-&gt;height + b.height;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度&#125;;// 程序的主函数int main( )&#123;</span></span><br><span class=\"line\">   Box Box1;                <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;                <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   Box Box3;                <span class=\"comment\">// 声明 Box3，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 把体积存储在该变量中</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box1 详述</span></span><br><span class=\"line\">   Box1.<span class=\"built_in\">setLength</span>(<span class=\"number\">6.0</span>); </span><br><span class=\"line\">   Box1.<span class=\"built_in\">setBreadth</span>(<span class=\"number\">7.0</span>); </span><br><span class=\"line\">   Box1.<span class=\"built_in\">setHeight</span>(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box2 详述</span></span><br><span class=\"line\">   Box2.<span class=\"built_in\">setLength</span>(<span class=\"number\">12.0</span>); </span><br><span class=\"line\">   Box2.<span class=\"built_in\">setBreadth</span>(<span class=\"number\">13.0</span>); </span><br><span class=\"line\">   Box2.<span class=\"built_in\">setHeight</span>(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box1 的体积</span></span><br><span class=\"line\">   volume = Box1.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box2 的体积</span></span><br><span class=\"line\">   volume = Box2.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把两个对象相加，得到 Box3</span></span><br><span class=\"line\">   Box3 = Box1 + Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box3 的体积</span></span><br><span class=\"line\">   volume = Box3.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Volume of Box1 : <span class=\"number\">210</span>Volume of Box2 : <span class=\"number\">1560</span>Volume of Box3 : <span class=\"number\">5400</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可重载运算符-不可重载运算符\"><a href=\"#可重载运算符-不可重载运算符\" class=\"headerlink\" title=\"可重载运算符&#x2F;不可重载运算符\"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p>\n<table>\n<thead>\n<tr>\n<th>+</th>\n<th>-</th>\n<th>*</th>\n<th>&#x2F;</th>\n<th>%</th>\n<th>^</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>|</td>\n<td>~</td>\n<td>!</td>\n<td>,</td>\n<td>&#x3D;</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>&gt;</td>\n<td>&lt;&#x3D;</td>\n<td>&gt;&#x3D;</td>\n<td>++</td>\n<td>–</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>&gt;&gt;</td>\n<td>&#x3D;&#x3D;</td>\n<td>!&#x3D;</td>\n<td>&amp;&amp;</td>\n<td>||</td>\n</tr>\n<tr>\n<td>+&#x3D;</td>\n<td>-&#x3D;</td>\n<td>&#x2F;&#x3D;</td>\n<td>%&#x3D;</td>\n<td>^&#x3D;</td>\n<td>&amp;&#x3D;</td>\n</tr>\n<tr>\n<td>|&#x3D;</td>\n<td>*&#x3D;</td>\n<td>&lt;&lt;&#x3D;</td>\n<td>&gt;&gt;&#x3D;</td>\n<td>[]</td>\n<td>()</td>\n</tr>\n<tr>\n<td>-&gt;</td>\n<td>-&gt;*</td>\n<td>new</td>\n<td>new []</td>\n<td>delete</td>\n<td>delete []</td>\n</tr>\n</tbody></table>\n<p>下面是不可重载的运算符列表：</p>\n<table>\n<thead>\n<tr>\n<th>::</th>\n<th>.*</th>\n<th>.</th>\n<th>?:</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"运算符重载实例\"><a href=\"#运算符重载实例\" class=\"headerlink\" title=\"运算符重载实例\"></a>运算符重载实例</h2><p>下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">运算符和实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">一元运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">二元运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">关系运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">输入&#x2F;输出运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">++ 和 – 运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">赋值运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">函数调用运算符 () 重载</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">下标运算符 [] 重载</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">类成员访问运算符 -&gt; 重载</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-多态\"><a href=\"#C-多态\" class=\"headerlink\" title=\"C++ 多态\"></a>C++ 多态</h1><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>\n<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>\n<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std;</span></span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span>: <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Rectangle</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>):<span class=\"built_in\">Shape</span>(a, b) &#123; &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span>: <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Triangle</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>):<span class=\"built_in\">Shape</span>(a, b) &#123; &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height / <span class=\"number\">2</span>); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"comment\">// 程序的主函数int main( )&#123;</span></span><br><span class=\"line\">   Shape *shape;</span><br><span class=\"line\">   <span class=\"function\">Rectangle <span class=\"title\">rec</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"function\">Triangle  <span class=\"title\">tri</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 存储矩形的地址</span></span><br><span class=\"line\">   shape = &amp;rec;</span><br><span class=\"line\">   <span class=\"comment\">// 调用矩形的求面积函数 area</span></span><br><span class=\"line\">   shape-&gt;<span class=\"built_in\">area</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 存储三角形的地址</span></span><br><span class=\"line\">   shape = &amp;tri;</span><br><span class=\"line\">   <span class=\"comment\">// 调用三角形的求面积函数 area</span></span><br><span class=\"line\">   shape-&gt;<span class=\"built_in\">area</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Parent <span class=\"keyword\">class</span> <span class=\"title class_\">areaParent</span> <span class=\"keyword\">class</span> <span class=\"title class_\">area</span></span><br></pre></td></tr></table></figure>\n\n<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>\n<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rectangle <span class=\"keyword\">class</span> <span class=\"title class_\">areaTriangle</span> <span class=\"keyword\">class</span> <span class=\"title class_\">area</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>\n<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>\n<h2 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h2><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>\n<p>我们可以把基类中的虚函数 area() 改写如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// pure virtual function</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D; 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p>\n<h1 id=\"C-数据抽象\"><a href=\"#C-数据抽象\" class=\"headerlink\" title=\"C++ 数据抽象\"></a>C++ 数据抽象</h1><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>\n<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>\n<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>\n<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>\n<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为<strong>数据抽象</strong>提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>\n<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>\n<p>在 C++ 中，我们使用<strong>类</strong>来定义我们自己的抽象数据类型（ADT）。您可以使用类 <strong>ostream</strong> 的 <strong>cout</strong> 对象来输出数据到标准输出，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main( )&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello C++&quot;</span> &lt;&lt;endl;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，您不需要理解 <strong>cout</strong> 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。</p>\n<h2 id=\"访问标签强制抽象\"><a href=\"#访问标签强制抽象\" class=\"headerlink\" title=\"访问标签强制抽象\"></a>访问标签强制抽象</h2><p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p>\n<ul>\n<li>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。</li>\n<li>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。</li>\n</ul>\n<p>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p>\n<h2 id=\"数据抽象的好处\"><a href=\"#数据抽象的好处\" class=\"headerlink\" title=\"数据抽象的好处\"></a>数据抽象的好处</h2><p>数据抽象有两个重要的优势：</p>\n<ul>\n<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>\n<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>\n</ul>\n<p>如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。</p>\n<h2 id=\"数据抽象的实例\"><a href=\"#数据抽象的实例\" class=\"headerlink\" title=\"数据抽象的实例\"></a>数据抽象的实例</h2><p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      <span class=\"built_in\">Adder</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        total = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> number)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          total += number;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getTotal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 对外隐藏的数据</span></span><br><span class=\"line\">      <span class=\"type\">int</span> total;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Adder a;</span><br><span class=\"line\">   </span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total &quot;</span> &lt;&lt; a.<span class=\"built_in\">getTotal</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是用户不需要了解的，但又是类能正常工作所必需的。</p>\n<h2 id=\"设计策略\"><a href=\"#设计策略\" class=\"headerlink\" title=\"设计策略\"></a>设计策略</h2><p>抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。</p>\n<p>在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。</p>\n<h1 id=\"C-数据封装\"><a href=\"#C-数据封装\" class=\"headerlink\" title=\"C++ 数据封装\"></a>C++ 数据封装</h1><p>所有的 C++ 程序都有以下两个基本要素：</p>\n<ul>\n<li><strong>程序语句（代码）：</strong>这是程序中执行动作的部分，它们被称为函数。</li>\n<li><strong>程序数据：</strong>数据是程序的信息，会受到程序函数的影响。</li>\n</ul>\n<p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即<strong>数据隐藏</strong>。</p>\n<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>\n<p>C++ 通过创建<strong>类</strong>来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度</span></span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。</p>\n<p>为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 <strong>public</strong> 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。</p>\n<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。</p>\n<h2 id=\"数据封装的实例\"><a href=\"#数据封装的实例\" class=\"headerlink\" title=\"数据封装的实例\"></a>数据封装的实例</h2><p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      <span class=\"built_in\">Adder</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        total = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> number)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          total += number;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getTotal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 对外隐藏的数据</span></span><br><span class=\"line\">      <span class=\"type\">int</span> total;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Adder a;</span><br><span class=\"line\">   </span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total &quot;</span> &lt;&lt; a.<span class=\"built_in\">getTotal</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。</p>\n<h2 id=\"设计策略-1\"><a href=\"#设计策略-1\" class=\"headerlink\" title=\"设计策略\"></a>设计策略</h2><p>通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的<strong>封装性</strong>。</p>\n<p>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。</p>\n<h1 id=\"C-接口（抽象类）\"><a href=\"#C-接口（抽象类）\" class=\"headerlink\" title=\"C++ 接口（抽象类）\"></a>C++ 接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>\n<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>\n<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 纯虚函数</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>\n<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>\n<p>可用于实例化对象的类被称为<strong>具体类</strong>。</p>\n<h2 id=\"抽象类的实例\"><a href=\"#抽象类的实例\" class=\"headerlink\" title=\"抽象类的实例\"></a>抽象类的实例</h2><p>请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"comment\">// 基类class Shape &#123;public:</span></span><br><span class=\"line\">   <span class=\"comment\">// 提供接口框架的纯虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">      width = w;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">      height = h;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">   <span class=\"type\">int</span> width;</span><br><span class=\"line\">   <span class=\"type\">int</span> height;&#125;;</span><br><span class=\"line\"> <span class=\"comment\">// 派生类class Rectangle: public Shape&#123;public:</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">   &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span>: <span class=\"keyword\">public</span> Shape&#123;<span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (width * height)/<span class=\"number\">2</span>; </span><br><span class=\"line\">   &#125;&#125;;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   Triangle  Tri;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   Tri.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Tri.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class=\"built_in\">getArea</span>() &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total Rectangle area: <span class=\"number\">35</span>Total Triangle area: <span class=\"number\">17</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。</p>\n<h2 id=\"设计策略-2\"><a href=\"#设计策略-2\" class=\"headerlink\" title=\"设计策略\"></a>设计策略</h2><p>面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。</p>\n<p>外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。</p>\n<p>这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。</p>\n<h1 id=\"C-文件和流\"><a href=\"#C-文件和流\" class=\"headerlink\" title=\"C++ 文件和流\"></a>C++ 文件和流</h1><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>\n<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ofstream</td>\n<td align=\"left\">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>\n</tr>\n<tr>\n<td align=\"left\">ifstream</td>\n<td align=\"left\">该数据类型表示输入文件流，用于从文件读取信息。</td>\n</tr>\n<tr>\n<td align=\"left\">fstream</td>\n<td align=\"left\">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>\n</tr>\n</tbody></table>\n<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>\n<h2 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>\n<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式标志</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ios::app</td>\n<td align=\"left\">追加模式。所有写入都追加到文件末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::ate</td>\n<td align=\"left\">文件打开后定位到文件末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::in</td>\n<td align=\"left\">打开文件用于读取。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::out</td>\n<td align=\"left\">打开文件用于写入。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::trunc</td>\n<td align=\"left\">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>\n</tr>\n</tbody></table>\n<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream outfile;outfile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>\n\n<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fstream  afile;afile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关闭文件\"><a href=\"#关闭文件\" class=\"headerlink\" title=\"关闭文件\"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>\n<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>\n<h2 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h2><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>\n<h2 id=\"读取-写入实例\"><a href=\"#读取-写入实例\" class=\"headerlink\" title=\"读取 &amp; 写入实例\"></a>读取 &amp; 写入实例</h2><p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"type\">char</span> data[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 以写模式打开文件</span></span><br><span class=\"line\">   ofstream outfile;</span><br><span class=\"line\">   outfile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;afile.dat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Enter your name: &quot;</span>; </span><br><span class=\"line\">   cin.<span class=\"built_in\">getline</span>(data, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 向文件写入用户输入的数据</span></span><br><span class=\"line\">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Enter your age: &quot;</span>; </span><br><span class=\"line\">   cin &gt;&gt; data;</span><br><span class=\"line\">   cin.<span class=\"built_in\">ignore</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 再次向文件写入用户输入的数据</span></span><br><span class=\"line\">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 关闭打开的文件</span></span><br><span class=\"line\">   outfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 以读模式打开文件</span></span><br><span class=\"line\">   ifstream infile; </span><br><span class=\"line\">   infile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;afile.dat&quot;</span>); </span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class=\"line\">   infile &gt;&gt; data; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在屏幕上写入数据</span></span><br><span class=\"line\">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 再次从文件读取数据，并显示它</span></span><br><span class=\"line\">   infile &gt;&gt; data; </span><br><span class=\"line\">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 关闭打开的文件</span></span><br><span class=\"line\">   infile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$./a.outWriting to the fileEnter your name: ZaraEnter your age: <span class=\"number\">9</span>Reading from the fileZara9</span><br></pre></td></tr></table></figure>\n\n<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>\n<h2 id=\"文件位置指针\"><a href=\"#文件位置指针\" class=\"headerlink\" title=\"文件位置指针\"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>\n<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>\n<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-异常处理\"><a href=\"#C-异常处理\" class=\"headerlink\" title=\"C++ 异常处理\"></a>C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>\n<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>\n<ul>\n<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>\n<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>\n<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>\n</ul>\n<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch( ExceptionName e1 )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;catch( ExceptionName e2 )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;catch( ExceptionName eN )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>\n<h2 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>\n<p>以下是尝试除以零时抛出异常的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">division</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Division by zero condition!&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (a/b);&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch( ExceptionName e )&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理 ExceptionName 异常的代码&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch(...)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 能处理任何异常的代码&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;double division(int a, int b)&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Division by zero condition!&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (a/b);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> x = <span class=\"number\">50</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"type\">double</span> z = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     z = <span class=\"built_in\">division</span>(x, y);</span><br><span class=\"line\">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class=\"line\">   &#125;<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Division by zero condition!</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-标准的异常\"><a href=\"#C-标准的异常\" class=\"headerlink\" title=\"C++ 标准的异常\"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg\" alt=\"img\"></p>\n<p>下表是对上面层次结构中出现的每个异常的说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">异常</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>std::exception</strong></td>\n<td align=\"left\">该异常是所有标准 C++ 异常的父类。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_alloc</td>\n<td align=\"left\">该异常可以通过 <strong>new</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_cast</td>\n<td align=\"left\">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_exception</td>\n<td align=\"left\">这在处理 C++ 程序中无法预期的异常时非常有用。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_typeid</td>\n<td align=\"left\">该异常可以通过 <strong>typeid</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>std::logic_error</strong></td>\n<td align=\"left\">理论上可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::domain_error</td>\n<td align=\"left\">当使用了一个无效的数学域时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::invalid_argument</td>\n<td align=\"left\">当使用了无效的参数时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::length_error</td>\n<td align=\"left\">当创建了太长的 std::string 时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::out_of_range</td>\n<td align=\"left\">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=\"\"></a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>std::runtime_error</strong></td>\n<td align=\"left\">理论上不可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::overflow_error</td>\n<td align=\"left\">当发生数学上溢时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::range_error</td>\n<td align=\"left\">当尝试存储超出范围的值时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::underflow_error</td>\n<td align=\"left\">当发生数学下溢时，会抛出该异常。</td>\n</tr>\n</tbody></table>\n<h2 id=\"定义新的异常\"><a href=\"#定义新的异常\" class=\"headerlink\" title=\"定义新的异常\"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;exception&gt;</span>using namespace std;struct MyException : public exception&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"title\">what</span> <span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">throw</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C++ Exception&quot;</span>;</span><br><span class=\"line\">  &#125;&#125;;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">MyException</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(MyException&amp; e)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(std::exception&amp; e)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//其他的错误</span></span><br><span class=\"line\">  &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这将产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyException caught</span><br><span class=\"line\">C++ Exception</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>\n<h1 id=\"C-动态内存\"><a href=\"#C-动态内存\" class=\"headerlink\" title=\"C++ 动态内存\"></a>C++ 动态内存</h1><p>了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：</p>\n<ul>\n<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>\n<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>\n</ul>\n<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>\n<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>\n<p>如果您不需要动态分配内存，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>\n<h2 id=\"new-和-delete-运算符\"><a href=\"#new-和-delete-运算符\" class=\"headerlink\" title=\"new 和 delete 运算符\"></a>new 和 delete 运算符</h2><p>下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> data-type;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>data-type</strong> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 <strong>new</strong> 运算符来完成这点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存</span></span><br></pre></td></tr></table></figure>\n\n<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>;<span class=\"keyword\">if</span>( !(pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span> ))&#123;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>malloc()</strong> 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>\n<p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> pvalue;        <span class=\"comment\">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 初始化为 null 的指针</span></span><br><span class=\"line\">   pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span>;   <span class=\"comment\">// 为变量请求内存</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   *pvalue = <span class=\"number\">29494.99</span>;     <span class=\"comment\">// 在分配的地址存储值</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> pvalue;         <span class=\"comment\">// 释放内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of pvalue : <span class=\"number\">29495</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组的动态内存分配\"><a href=\"#数组的动态内存分配\" class=\"headerlink\" title=\"数组的动态内存分配\"></a>数组的动态内存分配</h2><p>假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* pvalue  = <span class=\"literal\">NULL</span>;   <span class=\"comment\">// 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存</span></span><br></pre></td></tr></table></figure>\n\n<p>要删除我们刚才创建的数组，语句如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] pvalue;        <span class=\"comment\">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ROW = <span class=\"number\">2</span>;<span class=\"type\">int</span> COL = <span class=\"number\">3</span>;<span class=\"type\">double</span> **pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span>* [ROW]; <span class=\"comment\">// 为行分配内存// 为列分配内存for(int i = 0; i &lt; COL; i++) &#123;</span></span><br><span class=\"line\">    pvalue[i] = <span class=\"keyword\">new</span> <span class=\"type\">double</span>[COL];&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放多维数组内存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; COL; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] pvalue[i];&#125;<span class=\"keyword\">delete</span> [] pvalue;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象的动态内存分配\"><a href=\"#对象的动态内存分配\" class=\"headerlink\" title=\"对象的动态内存分配\"></a>对象的动态内存分配</h2><p>对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Box</span>() &#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;调用构造函数！&quot;</span> &lt;&lt;endl; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ~<span class=\"built_in\">Box</span>() &#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;调用析构函数！&quot;</span> &lt;&lt;endl; </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Box* myBoxArray = <span class=\"keyword\">new</span> Box[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> [] myBoxArray; <span class=\"comment\">// Delete array</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。</p>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-命名空间\"><a href=\"#C-命名空间\" class=\"headerlink\" title=\"C++ 命名空间\"></a>C++ 命名空间</h1><p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p>\n<p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</p>\n<p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>\n<h2 id=\"定义命名空间\"><a href=\"#定义命名空间\" class=\"headerlink\" title=\"定义命名空间\"></a>定义命名空间</h2><p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name &#123;   <span class=\"comment\">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name::code;  <span class=\"comment\">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>\n\n<p>让我们来看看命名空间如何为变量或函数等实体定义范围：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"comment\">// 第二个命名空间namespace second_space&#123;</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第一个命名空间中的函数</span></span><br><span class=\"line\">   first_space::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 调用第二个命名空间中的函数</span></span><br><span class=\"line\">   second_space::<span class=\"built_in\">func</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside first_spaceInside second_space</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"using-指令\"><a href=\"#using-指令\" class=\"headerlink\" title=\"using 指令\"></a>using 指令</h2><p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"comment\">// 第二个命名空间namespace second_space&#123;</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> first_space;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第一个命名空间中的函数</span></span><br><span class=\"line\">   <span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside first_space</span><br></pre></td></tr></table></figure>\n\n<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br></pre></td></tr></table></figure>\n\n<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 <strong>std</strong> 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using std::cout;int main ()&#123;   </span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;std::endl is used with std!&quot;</span> &lt;&lt; std::endl;      </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::endl is used with std!</span><br></pre></td></tr></table></figure>\n\n<p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>\n<h2 id=\"不连续的命名空间\"><a href=\"#不连续的命名空间\" class=\"headerlink\" title=\"不连续的命名空间\"></a>不连续的命名空间</h2><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p>\n<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"嵌套的命名空间\"><a href=\"#嵌套的命名空间\" class=\"headerlink\" title=\"嵌套的命名空间\"></a>嵌套的命名空间</h2><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name1 &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 代码声明</span></span><br><span class=\"line\">   <span class=\"keyword\">namespace</span> namespace_name2 &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 代码声明</span></span><br><span class=\"line\">   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 第二个命名空间</span></span><br><span class=\"line\">   <span class=\"keyword\">namespace</span> second_space&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> first_space::second_space;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第二个命名空间中的函数</span></span><br><span class=\"line\">   <span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside second_space</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-模板\"><a href=\"#C-模板\" class=\"headerlink\" title=\"C++ 模板\"></a>C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>\n<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>\n<p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector <int></strong> 或 **vector <string>**。</p>\n<p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p>\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><p>模板函数定义的一般形式如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">type</span>&gt; ret-type func-<span class=\"built_in\">name</span>(parameter list)&#123;   <span class=\"comment\">// 函数的主体&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>\n<p>下面是函数模板的实例，返回两个数种的最大值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>using namespace std;template <span class=\"string\">&lt;typename T&gt;</span>inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &lt; b ? b:a; &#125; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">39</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">20</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(i, j) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> f1 = <span class=\"number\">13.5</span>; </span><br><span class=\"line\">    <span class=\"type\">double</span> f2 = <span class=\"number\">20.7</span>; </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    string s1 = <span class=\"string\">&quot;Hello&quot;</span>; </span><br><span class=\"line\">    string s2 = <span class=\"string\">&quot;World&quot;</span>; </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Max</span>(i, j): <span class=\"number\">39</span>Max(f1, f2): <span class=\"number\">20.7</span>Max(s1, s2): World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">type</span>&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">class</span>-name &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>\n<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdexcept&gt;</span>using namespace std;template <span class=\"string\">&lt;class T&gt;</span>class Stack &#123; </span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>: </span><br><span class=\"line\">    vector&lt;T&gt; elems;     <span class=\"comment\">// 元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(T <span class=\"type\">const</span>&amp;)</span></span>;  <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span>;               <span class=\"comment\">// 出栈</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;            <span class=\"comment\">// 返回栈顶元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;       <span class=\"comment\">// 如果为空则返回真。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elems.<span class=\"built_in\">empty</span>(); </span><br><span class=\"line\">    &#125; &#125;; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"type\">void</span> Stack&lt;T&gt;::<span class=\"built_in\">push</span> (T <span class=\"type\">const</span>&amp; elem) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 追加传入元素的副本</span></span><br><span class=\"line\">    elems.<span class=\"built_in\">push_back</span>(elem);    &#125; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"type\">void</span> Stack&lt;T&gt;::<span class=\"built_in\">pop</span> () &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elems.<span class=\"built_in\">empty</span>()) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除最后一个元素</span></span><br><span class=\"line\">    elems.<span class=\"built_in\">pop_back</span>();         &#125; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;T Stack&lt;T&gt;::<span class=\"built_in\">top</span> () <span class=\"type\">const</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elems.<span class=\"built_in\">empty</span>()) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回最后一个元素的副本 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elems.<span class=\"built_in\">back</span>();      &#125; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        Stack&lt;<span class=\"type\">int</span>&gt;         intStack;  <span class=\"comment\">// int 类型的栈 </span></span><br><span class=\"line\">        Stack&lt;string&gt; stringStack;    <span class=\"comment\">// string 类型的栈 </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 操作 int 类型的栈 </span></span><br><span class=\"line\">        intStack.<span class=\"built_in\">push</span>(<span class=\"number\">7</span>); </span><br><span class=\"line\">        cout &lt;&lt; intStack.<span class=\"built_in\">top</span>() &lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 操作 string 类型的栈 </span></span><br><span class=\"line\">        stringStack.<span class=\"built_in\">push</span>(<span class=\"string\">&quot;hello&quot;</span>); </span><br><span class=\"line\">        cout &lt;&lt; stringStack.<span class=\"built_in\">top</span>() &lt;&lt; std::endl; </span><br><span class=\"line\">        stringStack.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">        stringStack.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">catch</span> (exception <span class=\"type\">const</span>&amp; ex) &#123; </span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class=\"built_in\">what</span>() &lt;&lt;endl; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>helloException: Stack&lt;&gt;::<span class=\"built_in\">pop</span>(): empty stack</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-预处理器\"><a href=\"#C-预处理器\" class=\"headerlink\" title=\"C++ 预处理器\"></a>C++ 预处理器</h1><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>\n<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>\n<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>\n<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。</p>\n<h2 id=\"define-预处理\"><a href=\"#define-预处理\" class=\"headerlink\" title=\"#define 预处理\"></a>#define 预处理</h2><p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>，指令的一般形式是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> macro-name replacement-text</span></span><br></pre></td></tr></table></figure>\n\n<p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> PI 3.14159int main ()&#123;     cout &lt;&lt; <span class=\"string\">&quot;Value of PI :&quot;</span> &lt;&lt; PI &lt;&lt; endl;     return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -E test.cpp &gt; test.p...<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;     cout &lt;&lt; <span class=\"string\">&quot;Value of PI :&quot;</span> &lt;&lt; <span class=\"number\">3.14159</span> &lt;&lt; endl;     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数宏\"><a href=\"#函数宏\" class=\"headerlink\" title=\"函数宏\"></a>函数宏</h2><p>您可以使用 #define 来定义一个带有参数的宏，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> MIN(a,b) (a&lt;b ? a : b)int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">   i = <span class=\"number\">100</span>;</span><br><span class=\"line\">   j = <span class=\"number\">30</span>;</span><br><span class=\"line\">   cout &lt;&lt;<span class=\"string\">&quot;较小的值为：&quot;</span> &lt;&lt; <span class=\"built_in\">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">较小的值为：<span class=\"number\">30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>\n<p>条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> NULL   #<span class=\"keyword\">define</span> NULL 0#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG   cerr &lt;&lt;<span class=\"string\">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; endl;#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 <strong>cerr</strong> 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0   不进行编译的代码#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>让我们尝试下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> DEBUG#<span class=\"keyword\">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">   i = <span class=\"number\">100</span>;</span><br><span class=\"line\">   j = <span class=\"number\">30</span>;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG</span></span><br><span class=\"line\">   cerr &lt;&lt;<span class=\"string\">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span>#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">   <span class=\"comment\">/* 这是注释部分 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"built_in\">MKSTR</span>(HELLO C++) &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt;<span class=\"string\">&quot;The minimum is &quot;</span> &lt;&lt; <span class=\"built_in\">MIN</span>(i, j) &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG</span></span><br><span class=\"line\">   cerr &lt;&lt;<span class=\"string\">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trace: Inside main functionThe minimum is <span class=\"number\">30</span>Trace: Coming out of main function</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"和-运算符\"><a href=\"#和-运算符\" class=\"headerlink\" title=\"# 和 ## 运算符\"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI&#x2F;ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p>\n<p>请看下面的宏定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> MKSTR( x ) #xint main ()&#123;    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HELLO C++</span><br></pre></td></tr></table></figure>\n\n<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>转换成了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;HELLO C++&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>## 运算符用于连接两个令牌。下面是一个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONCAT( x, y )  x ## y</span></span><br></pre></td></tr></table></figure>\n\n<p>当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> concat(a, b) a ## bint main()&#123;   int xy = 100;      cout &lt;&lt; concat(x, y);   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">concat</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>转换成了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; xy;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的预定义宏\"><a href=\"#C-中的预定义宏\" class=\"headerlink\" title=\"C++ 中的预定义宏\"></a>C++ 中的预定义宏</h2><p>C++ 提供了下表所示的一些预定义宏：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">宏</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>LINE</strong></td>\n<td align=\"left\">这会在程序编译时包含当前行号。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FILE</strong></td>\n<td align=\"left\">这会在程序编译时包含当前文件名。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>DATE</strong></td>\n<td align=\"left\">这会包含一个形式为 month&#x2F;day&#x2F;year 的字符串，它表示把源文件转换为目标代码的日期。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>TIME</strong></td>\n<td align=\"left\">这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</td>\n</tr>\n</tbody></table>\n<p>让我们看看上述这些宏的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of __LINE__ : <span class=\"number\">6</span>Value of __FILE__ : test.cppValue of __DATE__ : Feb <span class=\"number\">28</span> <span class=\"number\">2011</span>Value of __TIME__ : <span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">48</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-信号处理\"><a href=\"#C-信号处理\" class=\"headerlink\" title=\"C++ 信号处理\"></a>C++ 信号处理</h1><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>\n<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">信号</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SIGABRT</td>\n<td align=\"left\">程序的异常终止，如调用 <strong>abort</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGFPE</td>\n<td align=\"left\">错误的算术运算，比如除以零或导致溢出的操作。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGILL</td>\n<td align=\"left\">检测非法指令。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGINT</td>\n<td align=\"left\">接收到交互注意信号。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGSEGV</td>\n<td align=\"left\">非法访问内存。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGTERM</td>\n<td align=\"left\">发送到程序的终止请求。</td>\n</tr>\n</tbody></table>\n<h2 id=\"signal-函数\"><a href=\"#signal-函数\" class=\"headerlink\" title=\"signal() 函数\"></a>signal() 函数</h2><p>C++ 信号处理库提供了 <strong>signal</strong> 函数，用来捕获突发事件。以下是 signal() 函数的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span> (*<span class=\"built_in\">signal</span> (<span class=\"type\">int</span> sig, <span class=\"built_in\">void</span> (*func)(<span class=\"type\">int</span>)))(<span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>\n<p>让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 <strong>signal</strong> 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class=\"string\">&quot;) received.\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清理并关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 终止程序  </span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(signum);  &#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, signalHandler);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....</span><br></pre></td></tr></table></figure>\n\n<p>现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....<span class=\"function\">Interrupt <span class=\"title\">signal</span> <span class=\"params\">(<span class=\"number\">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"raise-函数\"><a href=\"#raise-函数\" class=\"headerlink\" title=\"raise() 函数\"></a>raise() 函数</h2><p>您可以使用函数 <strong>raise()</strong> 生成信号，该函数带有一个整数信号编号作为参数，语法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">raise</span> <span class=\"params\">(signal sig)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>sig</strong> 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class=\"string\">&quot;) received.\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清理并关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 终止程序 </span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(signum);  &#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, signalHandler);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++i)&#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>( i == <span class=\"number\">3</span> )&#123;</span><br><span class=\"line\">          <span class=\"built_in\">raise</span>( SIGINT);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....<span class=\"function\">Interrupt <span class=\"title\">signal</span> <span class=\"params\">(<span class=\"number\">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-多线程\"><a href=\"#C-多线程\" class=\"headerlink\" title=\"C++ 多线程\"></a>C++ 多线程</h1><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>\n<ul>\n<li>基于进程的多任务处理是程序的并发执行。</li>\n<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>\n</ul>\n<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>\n<p>本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU&#x2F;Linux、Mac OS X 和 Solaris。</p>\n<h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>pthread_create (thread, attr, start_routine, arg)</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">thread</td>\n<td align=\"left\">指向线程标识符指针。</td>\n</tr>\n<tr>\n<td align=\"left\">attr</td>\n<td align=\"left\">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>\n</tr>\n<tr>\n<td align=\"left\">start_routine</td>\n<td align=\"left\">线程运行函数起始地址，一旦线程被创建就会执行。</td>\n</tr>\n<tr>\n<td align=\"left\">arg</td>\n<td align=\"left\">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>\n</tr>\n</tbody></table>\n<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>\n<h2 id=\"终止线程\"><a href=\"#终止线程\" class=\"headerlink\" title=\"终止线程\"></a>终止线程</h2><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>pthread_exit (status)</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。</p>\n<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p>\n<h2 id=\"实例-25\"><a href=\"#实例-25\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出”Hello Runoob！”:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span><span class=\"comment\">// 必须的头文件是#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args)&#123;</span></span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello Runoob！&quot;</span> &lt;&lt; endl;&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> tids[NUM_THREADS];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">pthread_create</span>(&amp;tids[i], <span class=\"literal\">NULL</span>, say_hello, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           cout &lt;&lt; <span class=\"string\">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class=\"line\">    <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 -lpthread 库编译下面的程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o</span><br></pre></td></tr></table></figure>\n\n<p>现在，执行程序，将产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！</span><br></pre></td></tr></table></figure>\n\n<p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件名：test.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid)&#123;  </span></span><br><span class=\"line\">   <span class=\"comment\">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class=\"line\">   <span class=\"type\">int</span> tid = *((<span class=\"type\">int</span>*)threadid);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Hello Runoob! 线程 ID, &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">pthread_t</span> threads[NUM_THREADS];</span><br><span class=\"line\">   <span class=\"type\">int</span> indexes[NUM_THREADS];<span class=\"comment\">// 用数组来保存i的值</span></span><br><span class=\"line\">   <span class=\"type\">int</span> rc;</span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;main() : 创建线程, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      indexes[i] = i; <span class=\"comment\">//先保存i的值</span></span><br><span class=\"line\">      <span class=\"comment\">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_create</span>(&amp;threads[i], <span class=\"literal\">NULL</span>, </span><br><span class=\"line\">                          PrintHello, (<span class=\"type\">void</span> *)&amp;(indexes[i]));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在编译并执行程序，将产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o$ ./test.<span class=\"built_in\">omain</span>() : 创建线程, <span class=\"number\">0</span>main() : 创建线程, <span class=\"number\">1</span>main() : 创建线程, <span class=\"number\">2</span>main() : 创建线程, <span class=\"number\">3</span>main() : 创建线程, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">3</span>Hello Runoob! 线程 ID, <span class=\"number\">2</span>Hello Runoob! 线程 ID, <span class=\"number\">1</span>Hello Runoob! 线程 ID, <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向线程传递参数\"><a href=\"#向线程传递参数\" class=\"headerlink\" title=\"向线程传递参数\"></a>向线程传递参数</h2><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>using namespace std;#<span class=\"keyword\">define</span> NUM_THREADS     5struct thread_data&#123;   int  thread_id;   char *message;&#125;;void *PrintHello(void *threadarg)&#123;   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout <span class=\"string\">&lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;</span>thread_id ;   cout <span class=\"string\">&lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;</span>message &lt;&lt; endl;   pthread_exit(NULL);&#125;int main ()&#123;   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i &lt; NUM_THREADS; i++ )&#123;      cout &lt;&lt;<span class=\"string\">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;      td[i].thread_id = i;      td[i].message = <span class=\"string\">&quot;This is message&quot;</span>;      rc = pthread_create(&amp;threads[i], NULL,                          PrintHello, (void *)&amp;td[i]);      <span class=\"keyword\">if</span> (rc)&#123;         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;         exit(-1);      &#125;   &#125;   pthread_exit(NULL);&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o</span><br><span class=\"line\">$ ./test.<span class=\"function\">o</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">()</span> : 创建线程, <span class=\"number\">0</span>main() : 创建线程, <span class=\"number\">1</span>main() : 创建线程, <span class=\"number\">2</span>main() : 创建线程, <span class=\"number\">3</span>main() : 创建线程, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">3</span>Hello Runoob! 线程 ID, <span class=\"number\">2</span>Hello Runoob! 线程 ID, <span class=\"number\">1</span>Hello Runoob! 线程 ID, <span class=\"number\">0</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接和分离线程\"><a href=\"#连接和分离线程\" class=\"headerlink\" title=\"连接和分离线程\"></a>连接和分离线程</h2><p>我们可以使用以下两个函数来连接或分离线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pthread_join</span> (threadid, status) <span class=\"built_in\">pthread_detach</span> (threadid)</span><br></pre></td></tr></table></figure>\n\n<p>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>\n<p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span>using namespace std;#<span class=\"keyword\">define</span> NUM_THREADS     5void *wait(void *t)&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"type\">long</span> tid;</span><br><span class=\"line\"></span><br><span class=\"line\">   tid = (<span class=\"type\">long</span>)t;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class=\"string\">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> rc;</span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"type\">pthread_t</span> threads[NUM_THREADS];</span><br><span class=\"line\">   <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">   <span class=\"type\">void</span> *status;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_init</span>(&amp;attr);</span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_create</span>(&amp;threads[i], <span class=\"literal\">NULL</span>, wait, (<span class=\"type\">void</span> *)&amp;i );</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 删除属性，并等待其他线程</span></span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr);</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_join</span>(threads[i], &amp;status);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">main</span>() : creating thread, <span class=\"number\">0</span>main() : creating thread, <span class=\"number\">1</span>main() : creating thread, <span class=\"number\">2</span>main() : creating thread, <span class=\"number\">3</span>main() : creating thread, <span class=\"number\">4</span>Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">4</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">3</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">2</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">1</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">0</span>  ...exiting </span><br><span class=\"line\">Main: completed thread id :<span class=\"number\">0</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">1</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">2</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">3</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">4</span>  exiting with status :<span class=\"number\">0</span>Main: program exiting.</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-Web-编程\"><a href=\"#C-Web-编程\" class=\"headerlink\" title=\"C++ Web 编程\"></a>C++ Web 编程</h1><h2 id=\"什么是-CGI？\"><a href=\"#什么是-CGI？\" class=\"headerlink\" title=\"什么是 CGI？\"></a>什么是 CGI？</h2><ul>\n<li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li>\n<li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li>\n<li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li>\n<li>目前的版本是 CGI&#x2F;1.1，CGI&#x2F;1.2 版本正在推进中。</li>\n</ul>\n<h2 id=\"Web-浏览\"><a href=\"#Web-浏览\" class=\"headerlink\" title=\"Web 浏览\"></a>Web 浏览</h2><p>为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。</p>\n<ul>\n<li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li>\n<li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li>\n<li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li>\n</ul>\n<p>然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。</p>\n<p>公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。</p>\n<h2 id=\"CGI-架构图\"><a href=\"#CGI-架构图\" class=\"headerlink\" title=\"CGI 架构图\"></a>CGI 架构图</h2><p>下图演示了 CGI 的架构：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif\" alt=\"img\"></p>\n<h2 id=\"Web-服务器配置\"><a href=\"#Web-服务器配置\" class=\"headerlink\" title=\"Web 服务器配置\"></a>Web 服务器配置</h2><p>在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 &#x2F;var&#x2F;www&#x2F;cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 <strong>.cgi</strong>。</p>\n<p>默认情况下，Apache Web 服务器会配置在 &#x2F;var&#x2F;www&#x2F;cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory <span class=\"string\">&quot;/var/www/cgi-bin&quot;</span>&gt;   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all&lt;/Directory&gt; &lt;Directory <span class=\"string\">&quot;/var/www/cgi-bin&quot;</span>&gt;Options All&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。</p>\n<h2 id=\"第一个-CGI-程序\"><a href=\"#第一个-CGI-程序\" class=\"headerlink\" title=\"第一个 CGI 程序\"></a>第一个 CGI 程序</h2><p>请看下面的 C++ 程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;Hello World - 第一个 CGI 程序&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;h2&gt;Hello World! 这是我的第一个 CGI 程序&lt;/h2&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 &#x2F;var&#x2F;www&#x2F;cgi-bin 目录中。在运行 CGI 程序之前，请使用 <strong>chmod 755 cplusplus.cgi</strong> UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：</p>\n<h2 id=\"Hello-World-这是我的第一个-CGI-程序\"><a href=\"#Hello-World-这是我的第一个-CGI-程序\" class=\"headerlink\" title=\"Hello World! 这是我的第一个 CGI 程序\"></a>Hello World! 这是我的第一个 CGI 程序</h2><p>上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 <strong>Content-type:text&#x2F;html\\r\\n\\r\\n</strong>。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。</p>\n<h2 id=\"HTTP-头信息\"><a href=\"#HTTP-头信息\" class=\"headerlink\" title=\"HTTP 头信息\"></a>HTTP 头信息</h2><p>行 <strong>Content-type:text&#x2F;html\\r\\n\\r\\n</strong> 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP 字段名称: 字段内容 例如Content-type: text/html\\r\\n\\r\\n</span><br></pre></td></tr></table></figure>\n\n<p>还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">头信息</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Content-type:</td>\n<td align=\"left\">MIME 字符串，定义返回的文件格式。例如 Content-type:text&#x2F;html。</td>\n</tr>\n<tr>\n<td align=\"left\">Expires: Date</td>\n<td align=\"left\">信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td>\n</tr>\n<tr>\n<td align=\"left\">Location: URL</td>\n<td align=\"left\">这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td>\n</tr>\n<tr>\n<td align=\"left\">Last-modified: Date</td>\n<td align=\"left\">资源的最后修改日期。</td>\n</tr>\n<tr>\n<td align=\"left\">Content-length: N</td>\n<td align=\"left\">要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td>\n</tr>\n<tr>\n<td align=\"left\">Set-Cookie: String</td>\n<td align=\"left\">通过 <em>string</em> 设置 cookie。</td>\n</tr>\n</tbody></table>\n<h2 id=\"CGI-环境变量\"><a href=\"#CGI-环境变量\" class=\"headerlink\" title=\"CGI 环境变量\"></a>CGI 环境变量</h2><p>所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量名</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CONTENT_TYPE</td>\n<td align=\"left\">内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td>\n</tr>\n<tr>\n<td align=\"left\">CONTENT_LENGTH</td>\n<td align=\"left\">查询的信息长度。只对 POST 请求可用。</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP_COOKIE</td>\n<td align=\"left\">以键 &amp; 值对的形式返回设置的 cookies。</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP_USER_AGENT</td>\n<td align=\"left\">用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td>\n</tr>\n<tr>\n<td align=\"left\">PATH_INFO</td>\n<td align=\"left\">CGI 脚本的路径。</td>\n</tr>\n<tr>\n<td align=\"left\">QUERY_STRING</td>\n<td align=\"left\">通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td>\n</tr>\n<tr>\n<td align=\"left\">REMOTE_ADDR</td>\n<td align=\"left\">发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td>\n</tr>\n<tr>\n<td align=\"left\">REMOTE_HOST</td>\n<td align=\"left\">发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td>\n</tr>\n<tr>\n<td align=\"left\">REQUEST_METHOD</td>\n<td align=\"left\">用于发出请求的方法。最常见的方法是 GET 和 POST。</td>\n</tr>\n<tr>\n<td align=\"left\">SCRIPT_FILENAME</td>\n<td align=\"left\">CGI 脚本的完整路径。</td>\n</tr>\n<tr>\n<td align=\"left\">SCRIPT_NAME</td>\n<td align=\"left\">CGI 脚本的名称。</td>\n</tr>\n<tr>\n<td align=\"left\">SERVER_NAME</td>\n<td align=\"left\">服务器的主机名或 IP 地址。</td>\n</tr>\n<tr>\n<td align=\"left\">SERVER_SOFTWARE</td>\n<td align=\"left\">服务器上运行的软件的名称和版本。</td>\n</tr>\n</tbody></table>\n<p>下面的 CGI 程序列出了所有的 CGI 变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span>using namespace std;const string ENV[ 24 ] = &#123;                 </span></span><br><span class=\"line\">        <span class=\"string\">&quot;COMSPEC&quot;</span>, <span class=\"string\">&quot;DOCUMENT_ROOT&quot;</span>, <span class=\"string\">&quot;GATEWAY_INTERFACE&quot;</span>,   </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_ACCEPT&quot;</span>, <span class=\"string\">&quot;HTTP_ACCEPT_ENCODING&quot;</span>,    &amp;nbsnbsp;        </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>, <span class=\"string\">&quot;HTTP_CONNECTION&quot;</span>,         </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_HOST&quot;</span>, <span class=\"string\">&quot;HTTP_USER_AGENT&quot;</span>, <span class=\"string\">&quot;PATH&quot;</span>,            </span><br><span class=\"line\">        <span class=\"string\">&quot;QUERY_STRING&quot;</span>, <span class=\"string\">&quot;REMOTE_ADDR&quot;</span>, <span class=\"string\">&quot;REMOTE_PORT&quot;</span>,      </span><br><span class=\"line\">        <span class=\"string\">&quot;REQUEST_METHOD&quot;</span>, <span class=\"string\">&quot;REQUEST_URI&quot;</span>, <span class=\"string\">&quot;SCRIPT_FILENAME&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;SCRIPT_NAME&quot;</span>, <span class=\"string\">&quot;SERVER_ADDR&quot;</span>, <span class=\"string\">&quot;SERVER_ADMIN&quot;</span>,      </span><br><span class=\"line\">        <span class=\"string\">&quot;SERVER_NAME&quot;</span>,<span class=\"string\">&quot;SERVER_PORT&quot;</span>,<span class=\"string\">&quot;SERVER_PROTOCOL&quot;</span>,     </span><br><span class=\"line\">        <span class=\"string\">&quot;SERVER_SIGNATURE&quot;</span>,<span class=\"string\">&quot;SERVER_SOFTWARE&quot;</span> &#125;;   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 环境变量&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;table border = \\&quot;0\\&quot; cellspacing = \\&quot;2\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; ENV[ i ] &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 尝试检索环境变量的值</span></span><br><span class=\"line\">       <span class=\"type\">char</span> *value = <span class=\"built_in\">getenv</span>( ENV[ i ].<span class=\"built_in\">c_str</span>() );  </span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( value != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">         cout &lt;&lt; value;                                 </span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;环境变量不存在。&quot;</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;/tr&gt;\\n&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/table&gt;&lt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-CGI-库\"><a href=\"#C-CGI-库\" class=\"headerlink\" title=\"C++ CGI 库\"></a>C++ CGI 库</h2><p>在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 <a href=\"ftp://ftp.gnu.org/gnu/cgicc/\">ftp://ftp.gnu.org/gnu/cgicc/</a> 上下载这个 CGI 库，并按照下面的步骤安装库：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install</span><br></pre></td></tr></table></figure>\n\n<p>您可以点击 C++ CGI Lib Documentation，查看相关的库文档。</p>\n<h2 id=\"GET-和-POST-方法\"><a href=\"#GET-和-POST-方法\" class=\"headerlink\" title=\"GET 和 POST 方法\"></a>GET 和 POST 方法</h2><p>您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。</p>\n<h2 id=\"使用-GET-方法传递信息\"><a href=\"#使用-GET-方法传递信息\" class=\"headerlink\" title=\"使用 GET 方法传递信息\"></a>使用 GET 方法传递信息</h2><p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span></span><br></pre></td></tr></table></figure>\n\n<p>GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。</p>\n<p>当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。</p>\n<p>您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。</p>\n<h2 id=\"简单的-URL-实例：Get-方法\"><a href=\"#简单的-URL-实例：Get-方法\" class=\"headerlink\" title=\"简单的 URL 实例：Get 方法\"></a>简单的 URL 实例：Get 方法</h2><p>下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。</p>\n<p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p>\n<p>下面的实例生成 <strong>cpp_get.cgi</strong> CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>  using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;使用 GET 和 POST 方法&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;first_name&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;名：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered for first name&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;last_name&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp;fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;姓：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered for last name&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，编译上面的程序，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc</span><br></pre></td></tr></table></figure>\n\n<p>生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：</p>\n<p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p>\n<p>这会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">名：ZARA 姓：ALI</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单的表单实例：GET-方法\"><a href=\"#简单的表单实例：GET-方法\" class=\"headerlink\" title=\"简单的表单实例：GET 方法\"></a>简单的表单实例：GET 方法</h2><p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class=\"string\">&quot;get&quot;</span>&gt;名：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;first_name&quot;</span>&gt;  &lt;br /&gt; 姓：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;last_name&quot;</span> /&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。</p>\n<h2 id=\"使用-POST-方法传递信息\"><a href=\"#使用-POST-方法传递信息\" class=\"headerlink\" title=\"使用 POST 方法传递信息\"></a>使用 POST 方法传递信息</h2><p>一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。</p>\n<p>我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class=\"string\">&quot;post&quot;</span>&gt;名：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;first_name&quot;</span>&gt;&lt;br /&gt;姓：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;last_name&quot;</span> /&gt; &lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递复选框数据\"><a href=\"#向-CGI-程序传递复选框数据\" class=\"headerlink\" title=\"向 CGI 程序传递复选框数据\"></a>向 CGI 程序传递复选框数据</h2><p>当需要选择多个选项时，我们使用复选框。</p>\n<p>下面的 HTML 代码实例是一个带有两个复选框的表单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/cgi-bin/cpp_checkbox.cgi&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">method</span>=<span class=\"string\">&quot;POST&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">target</span>=<span class=\"string\">&quot;_blank&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maths&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;on&quot;</span> /&gt;</span> 数学<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;physics&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;on&quot;</span> /&gt;</span> 物理<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;选择学科&quot;</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">   <span class=\"type\">bool</span> maths_flag, physics_flag;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递复选框数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   maths_flag = formData.<span class=\"built_in\">queryCheckbox</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( maths_flag ) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Maths Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Maths Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   physics_flag = formData.<span class=\"built_in\">queryCheckbox</span>(<span class=\"string\">&quot;physics&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( physics_flag ) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Physics Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Physics Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递单选按钮数据\"><a href=\"#向-CGI-程序传递单选按钮数据\" class=\"headerlink\" title=\"向 CGI 程序传递单选按钮数据\"></a>向 CGI 程序传递单选按钮数据</h2><p>当只需要选择一个选项时，我们使用单选按钮。</p>\n<p>下面的 HTML 代码实例是一个带有两个单选按钮的表单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_radiobutton.cgi&quot;</span> </span><br><span class=\"line\">         method=<span class=\"string\">&quot;post&quot;</span> </span><br><span class=\"line\">         target=<span class=\"string\">&quot;_blank&quot;</span>&gt;&lt;input type=<span class=\"string\">&quot;radio&quot;</span> name=<span class=\"string\">&quot;subject&quot;</span> value=<span class=\"string\">&quot;maths&quot;</span> </span><br><span class=\"line\">                                    checked=<span class=\"string\">&quot;checked&quot;</span>/&gt; 数学 </span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;radio&quot;</span> name=<span class=\"string\">&quot;subject&quot;</span> value=<span class=\"string\">&quot;physics&quot;</span> /&gt; 物理&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;选择学科&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递单选按钮数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;subject&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Radio box selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递文本区域数据\"><a href=\"#向-CGI-程序传递文本区域数据\" class=\"headerlink\" title=\"向 CGI 程序传递文本区域数据\"></a>向 CGI 程序传递文本区域数据</h2><p>当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。</p>\n<p>下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/cgi-bin/cpp_textarea.cgi&quot; </span><br><span class=\"line\">         method=&quot;post&quot; </span><br><span class=\"line\">         target=&quot;_blank&quot;&gt;&lt;textarea name=&quot;textcontent&quot; cols=&quot;40&quot; rows=&quot;4&quot;&gt;请在这里输入文本...&lt;/textarea&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递文本区域数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;textcontent&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Text Content: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递下拉框数据\"><a href=\"#向-CGI-程序传递下拉框数据\" class=\"headerlink\" title=\"向 CGI 程序传递下拉框数据\"></a>向 CGI 程序传递下拉框数据</h2><p>当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。</p>\n<p>下面的 HTML 代码实例是一个带有下拉框的表单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_dropdown.cgi&quot;</span> </span><br><span class=\"line\">                       method=<span class=\"string\">&quot;post&quot;</span> target=<span class=\"string\">&quot;_blank&quot;</span>&gt;&lt;select name=<span class=\"string\">&quot;dropdown&quot;</span>&gt;&lt;option value=<span class=\"string\">&quot;Maths&quot;</span> selected&gt;数学&lt;/option&gt;&lt;option value=<span class=\"string\">&quot;Physics&quot;</span>&gt;物理&lt;/option&gt;&lt;/select&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span>/&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递下拉框数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;dropdown&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Value Selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在-CGI-中使用-Cookies\"><a href=\"#在-CGI-中使用-Cookies\" class=\"headerlink\" title=\"在 CGI 中使用 Cookies\"></a>在 CGI 中使用 Cookies</h2><p>HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。</p>\n<p>在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p>\n<h3 id=\"它是如何工作的\"><a href=\"#它是如何工作的\" class=\"headerlink\" title=\"它是如何工作的\"></a>它是如何工作的</h3><p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p>\n<p>cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：</p>\n<ul>\n<li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li>\n<li><strong>Domain :</strong> 网站的域名。</li>\n<li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li>\n<li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li>\n<li><strong>Name&#x3D;Value :</strong> cookie 以键值对的形式被设置和获取。</li>\n</ul>\n<h3 id=\"设置-Cookies\"><a href=\"#设置-Cookies\" class=\"headerlink\" title=\"设置 Cookies\"></a>设置 Cookies</h3><p>向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:UserID=XYZ;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Password=XYZ123;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Domain=www.w3cschool.cc;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Path=/perl;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;设置 cookies&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这个实例中，我们了解了如何设置 cookies。我们使用 <strong>Set-Cookie</strong> HTTP 头来设置 cookies。</p>\n<p>在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 <strong>“Content-type:text&#x2F;html\\r\\n\\r\\n</strong> 之前被设置的。</p>\n<p>编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：</p>\n<p>&#x2F;cgi-bin&#x2F;setcookies.cgi</p>\n<h3 id=\"获取-Cookies\"><a href=\"#获取-Cookies\" class=\"headerlink\" title=\"获取 Cookies\"></a>获取 Cookies</h3><p>检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1=value1;key2=value2;key3=value3....</span><br></pre></td></tr></table></figure>\n\n<p>下面的实例演示了如何获取 cookies。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc cgi;</span><br><span class=\"line\">   const_cookie_iterator cci;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;table border = \\&quot;0\\&quot; cellspacing = \\&quot;2\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 获取环境变量</span></span><br><span class=\"line\">   <span class=\"type\">const</span> CgiEnvironment&amp; env = cgi.<span class=\"built_in\">getEnvironment</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( cci = env.<span class=\"built_in\">getCookieList</span>().<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        cci != env.<span class=\"built_in\">getCookieList</span>().<span class=\"built_in\">end</span>(); </span><br><span class=\"line\">        ++cci )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; cci-&gt;<span class=\"built_in\">getName</span>() &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class=\"line\">      cout &lt;&lt; cci-&gt;<span class=\"built_in\">getValue</span>();                                 </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;/tr&gt;\\n&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/table&gt;&lt;\\n&quot;</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：</p>\n<p>&#x2F;cgi-bin&#x2F;getcookies.cgi</p>\n<p>这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件上传实例\"><a href=\"#文件上传实例\" class=\"headerlink\" title=\"文件上传实例\"></a>文件上传实例</h2><p>为了上传一个文件，HTML 表单必须把 enctype 属性设置为 <strong>multipart&#x2F;form-data</strong>。带有文件类型的 input 标签会创建一个 “Browse” 按钮。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">   &lt;form enctype=<span class=\"string\">&quot;multipart/form-data&quot;</span> </span><br><span class=\"line\">            action=<span class=\"string\">&quot;/cgi-bin/cpp_uploadfile.cgi&quot;</span> </span><br><span class=\"line\">            method=<span class=\"string\">&quot;post&quot;</span>&gt;</span><br><span class=\"line\">   &lt;p&gt;文件：&lt;input type=<span class=\"string\">&quot;file&quot;</span> name=<span class=\"string\">&quot;userfile&quot;</span> /&gt;&lt;/p&gt;</span><br><span class=\"line\">   &lt;p&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;上传&quot;</span> /&gt;&lt;/p&gt;</span><br><span class=\"line\">   &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的结果是下面的表单：</p>\n<p>文件：</p>\n<p><strong>注意：</strong>上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。</p>\n<p>下面是用于处理文件上传的脚本 <strong>cpp_uploadfile.cpp</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc cgi;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的文件上传&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 获取要被上传的文件列表</span></span><br><span class=\"line\">   const_file_iterator file = cgi.<span class=\"built_in\">getFile</span>(<span class=\"string\">&quot;userfile&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(file != cgi.<span class=\"built_in\">getFiles</span>().<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在 cout 中发送数据类型</span></span><br><span class=\"line\">      cout &lt;&lt; <span class=\"built_in\">HTTPContentHeader</span>(file-&gt;<span class=\"built_in\">getDataType</span>());</span><br><span class=\"line\">      <span class=\"comment\">// 在 cout 中写入内容</span></span><br><span class=\"line\">      file-&gt;<span class=\"built_in\">writeToStream</span>(cout);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;文件上传成功&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的实例是在 <strong>cout</strong> 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。</p>\n<h1 id=\"C-STL-教程\"><a href=\"#C-STL-教程\" class=\"headerlink\" title=\"C++ STL 教程\"></a>C++ STL 教程</h1><p>在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>\n<p>C++ 标准模板库的核心包括以下三个组件：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">组件</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">容器（Containers）</td>\n<td align=\"left\">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td align=\"left\">算法（Algorithms）</td>\n<td align=\"left\">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器（iterators）</td>\n<td align=\"left\">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody></table>\n<p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。</p>\n<p>下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 创建一个向量存储 int</span></span><br><span class=\"line\">   vector&lt;<span class=\"type\">int</span>&gt; vec; </span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 显示 vec 的原始大小</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 推入 5 个值到向量中</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">      vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 显示 vec 扩展后的大小</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 访问向量中的 5 个值</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用迭代器 iterator 访问值</span></span><br><span class=\"line\">   vector&lt;<span class=\"type\">int</span>&gt;::iterator v = vec.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">   <span class=\"keyword\">while</span>( v != vec.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class=\"line\">      v++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector size = <span class=\"number\">0</span>extended vector size = <span class=\"number\">5</span>value of vec [<span class=\"number\">0</span>] = <span class=\"number\">0</span>value of vec [<span class=\"number\">1</span>] = <span class=\"number\">1</span>value of vec [<span class=\"number\">2</span>] = <span class=\"number\">2</span>value of vec [<span class=\"number\">3</span>] = <span class=\"number\">3</span>value of vec [<span class=\"number\">4</span>] = <span class=\"number\">4</span>value of v = <span class=\"number\">0</span>value of v = <span class=\"number\">1</span>value of v = <span class=\"number\">2</span>value of v = <span class=\"number\">3</span>value of v = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>关于上面实例中所使用的各种函数，有几点要注意：</p>\n<ul>\n<li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li>\n<li>size( ) 函数显示向量的大小。</li>\n<li>begin( ) 函数返回一个指向向量开头的迭代器。</li>\n<li>end( ) 函数返回一个指向向量末尾的迭代器。</li>\n</ul>\n<h1 id=\"C-标准库\"><a href=\"#C-标准库\" class=\"headerlink\" title=\"C++ 标准库\"></a>C++ 标准库</h1><p>C++ 标准库可以分为两部分：</p>\n<ul>\n<li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li>\n<li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li>\n</ul>\n<p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p>\n<h2 id=\"标准函数库\"><a href=\"#标准函数库\" class=\"headerlink\" title=\"标准函数库\"></a>标准函数库</h2><p>标准函数库分为以下几类：</p>\n<ul>\n<li>输入&#x2F;输出 I&#x2F;O</li>\n<li>字符串和字符处理</li>\n<li>数学</li>\n<li>时间、日期和本地化</li>\n<li>动态分配</li>\n<li>其他</li>\n<li>宽字符函数</li>\n</ul>\n<h2 id=\"面向对象类库\"><a href=\"#面向对象类库\" class=\"headerlink\" title=\"面向对象类库\"></a>面向对象类库</h2><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p>\n<ul>\n<li>标准的 C++ I&#x2F;O 类</li>\n<li>String 类</li>\n<li>数值类</li>\n<li>STL 容器类</li>\n<li>STL 算法</li>\n<li>STL 函数对象</li>\n<li>STL 迭代器</li>\n<li>STL 分配器</li>\n<li>本地化库</li>\n<li>异常处理类</li>\n<li>杂项支持库</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>来源：<a href=\"https://github.com/0voice/cpp_new_features\">https://github.com/0voice/cpp_new_features</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>原文来自：<a href=\"https://github.com/GrindGold/CppGuide\">https://github.com/GrindGold/CppGuide</a></strong></p>\n<h1 id=\"C-教程\"><a href=\"#C-教程\" class=\"headerlink\" title=\"C++ 教程\"></a>C++ 教程</h1><p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png\"></p>\n<p>C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。</p>\n<p>本教程通过通俗易懂的语言来讲解 C++ 编程语言。</p>\n<p><strong>现在开始学习 C++ 编程！</strong></p>\n<h2 id=\"谁适合阅读本教程？\"><a href=\"#谁适合阅读本教程？\" class=\"headerlink\" title=\"谁适合阅读本教程？\"></a>谁适合阅读本教程？</h2><p>本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。</p>\n<h2 id=\"阅读本教程前，您需要了解的知识：\"><a href=\"#阅读本教程前，您需要了解的知识：\" class=\"headerlink\" title=\"阅读本教程前，您需要了解的知识：\"></a>阅读本教程前，您需要了解的知识：</h2><p>在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。</p>\n<h2 id=\"编译-执行-C-程序\"><a href=\"#编译-执行-C-程序\" class=\"headerlink\" title=\"编译&#x2F;执行 C++ 程序\"></a>编译&#x2F;执行 C++ 程序</h2><h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span> &lt;&lt; endl;    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n\n<p>你可以用 “\\n” 代替以上代码里的 “endl”。</p>\n<h1 id=\"C-简介\"><a href=\"#C-简介\" class=\"headerlink\" title=\"C++ 简介\"></a>C++ 简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>\n<p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p>\n<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p>\n<p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p>\n<p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>\n<h2 id=\"面向对象程序设计\"><a href=\"#面向对象程序设计\" class=\"headerlink\" title=\"面向对象程序设计\"></a>面向对象程序设计</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p>\n<ul>\n<li>封装</li>\n<li>抽象</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h2 id=\"标准库\"><a href=\"#标准库\" class=\"headerlink\" title=\"标准库\"></a>标准库</h2><p>标准的 C++ 由三个重要部分组成：</p>\n<ul>\n<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>\n<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>\n<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>\n</ul>\n<h2 id=\"ANSI-标准\"><a href=\"#ANSI-标准\" class=\"headerlink\" title=\"ANSI 标准\"></a>ANSI 标准</h2><p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>\n<p>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p>\n<h2 id=\"学习-C\"><a href=\"#学习-C\" class=\"headerlink\" title=\"学习 C++\"></a>学习 C++</h2><p>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</p>\n<p>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</p>\n<p>C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。</p>\n<h2 id=\"C-的使用\"><a href=\"#C-的使用\" class=\"headerlink\" title=\"C++ 的使用\"></a>C++ 的使用</h2><p>基本上每个应用程序领域的程序员都有使用 C++。</p>\n<p>C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。</p>\n<p>C++ 广泛用于教学和研究。</p>\n<p>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</p>\n<hr>\n<h2 id=\"标准化\"><a href=\"#标准化\" class=\"headerlink\" title=\"标准化\"></a>标准化</h2><table>\n<thead>\n<tr>\n<th align=\"left\">发布时间</th>\n<th align=\"left\">文档</th>\n<th align=\"left\">通称</th>\n<th align=\"left\">备注</th>\n<th align=\"left\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2015</td>\n<td align=\"left\">ISO&#x2F;IEC TS 19570:2015</td>\n<td align=\"left\">-</td>\n<td align=\"left\">用于并行计算的扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2015</td>\n<td align=\"left\">ISO&#x2F;IEC TS 18822:2015</td>\n<td align=\"left\">-</td>\n<td align=\"left\">文件系统</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2014</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:2014</td>\n<td align=\"left\">C++14</td>\n<td align=\"left\">第四个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2011</td>\n<td align=\"left\">ISO&#x2F;IEC TR 24733:2011</td>\n<td align=\"left\">-</td>\n<td align=\"left\">十进制浮点数扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2011</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:2011</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">第三个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2010</td>\n<td align=\"left\">ISO&#x2F;IEC TR 29124:2010</td>\n<td align=\"left\">-</td>\n<td align=\"left\">数学函数扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2007</td>\n<td align=\"left\">ISO&#x2F;IEC TR 19768:2007</td>\n<td align=\"left\">C++TR1</td>\n<td align=\"left\">C++技术报告：库扩展</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2006</td>\n<td align=\"left\">ISO&#x2F;IEC TR 18015:2006</td>\n<td align=\"left\">-</td>\n<td align=\"left\">C++性能技术报告</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2003</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:2003</td>\n<td align=\"left\">C++03</td>\n<td align=\"left\">第二个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">1998</td>\n<td align=\"left\">ISO&#x2F;IEC 14882:1998</td>\n<td align=\"left\">C++98</td>\n<td align=\"left\">第一个C++标准</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"C-环境设置\"><a href=\"#C-环境设置\" class=\"headerlink\" title=\"C++ 环境设置\"></a>C++ 环境设置</h1><h2 id=\"本地环境设置\"><a href=\"#本地环境设置\" class=\"headerlink\" title=\"本地环境设置\"></a>本地环境设置</h2><p>如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。</p>\n<h2 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h2><p>这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim&#x2F;vi。</p>\n<p>文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim&#x2F;vi 可用于 Windows 和 Linux&#x2F;UNIX 操作系统上。</p>\n<p>通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>\n<p>在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。</p>\n<h2 id=\"C-编译器\"><a href=\"#C-编译器\" class=\"headerlink\" title=\"C++ 编译器\"></a>C++ 编译器</h2><p>写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>\n<p>C++ 编译器用于把源代码编译成最终的可执行程序。</p>\n<p>大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>\n<p>最常用的免费可用的编译器是 GNU 的 C&#x2F;C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>\n<p>以下部分将指导您如何在不同的操作系统上安装 GNU 的 C&#x2F;C++ 编译器。这里同时提到 C&#x2F;C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。</p>\n<h2 id=\"安装-GNU-的-C-C-编译器\"><a href=\"#安装-GNU-的-C-C-编译器\" class=\"headerlink\" title=\"安装 GNU 的 C&#x2F;C++ 编译器\"></a>安装 GNU 的 C&#x2F;C++ 编译器</h2><h3 id=\"UNIX-Linux-上的安装\"><a href=\"#UNIX-Linux-上的安装\" class=\"headerlink\" title=\"UNIX&#x2F;Linux 上的安装\"></a>UNIX&#x2F;Linux 上的安装</h3><p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ -v</span><br></pre></td></tr></table></figure>\n\n<p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix</span><br><span class=\"line\">gcc version <span class=\"number\">4.1</span><span class=\"number\">.2</span> <span class=\"number\">20080704</span> (Red Hat <span class=\"number\">4.1</span><span class=\"number\">.2</span><span class=\"number\">-46</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果未安装 GCC，那么请按照 <a href=\"http://gcc.gnu.org/install/\">http://gcc.gnu.org/install/</a> 上的详细说明安装 GCC。</p>\n<h3 id=\"Mac-OS-X-上的安装\"><a href=\"#Mac-OS-X-上的安装\" class=\"headerlink\" title=\"Mac OS X 上的安装\"></a>Mac OS X 上的安装</h3><p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>\n<p>Xcode 目前可从 developer.apple.com&#x2F;technologies&#x2F;tools&#x2F; 上下载。</p>\n<h3 id=\"Windows-上的安装\"><a href=\"#Windows-上的安装\" class=\"headerlink\" title=\"Windows 上的安装\"></a>Windows 上的安装</h3><p>为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 <a href=\"http://www.mingw.org,进入/\">www.mingw.org，进入</a> MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p>\n<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>\n<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>\n<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p>\n<hr>\n<h2 id=\"使用-Visual-Studio-Graphical-Interface-编译\"><a href=\"#使用-Visual-Studio-Graphical-Interface-编译\" class=\"headerlink\" title=\"使用 Visual Studio (Graphical Interface) 编译\"></a>使用 Visual Studio (Graphical Interface) 编译</h2><p>1、下载及安装 Visual Studio Community 2015。</p>\n<p>2、打开 Visual Studio Community</p>\n<p>3、点击 File -&gt; New -&gt; Project</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png\" alt=\"img\"></p>\n<p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png\" alt=\"img\"></p>\n<p>5、点击 OK。</p>\n<p>6、在以下窗口中点击 Next</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png\" alt=\"img\"></p>\n<p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：</p>\n<p>8、右击文件夹 Source File 并点击 Add –&gt; New Item… :</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png\" alt=\"img\"></p>\n<p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png\" alt=\"img\"></p>\n<p>10、拷贝以下代码到 main.cpp 中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>int main()&#123;</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>界面如下所示：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png\" alt=\"img\"></p>\n<p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png\" alt=\"img\"></p>\n<p>12、完成以上操作后，你可以看到以下输出：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png\" alt=\"img\"></p>\n<hr>\n<h2 id=\"g-应用说明\"><a href=\"#g-应用说明\" class=\"headerlink\" title=\"g++ 应用说明\"></a>g++ 应用说明</h2><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc main.cpp -lstdc++ -o main</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最简单的编译方式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure>\n\n<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./a.outHello, world!</span><br></pre></td></tr></table></figure>\n\n<p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>\n\n<p>执行 helloworld:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./helloworldHello, world!</span><br></pre></td></tr></table></figure>\n\n<p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure>\n\n<p>生成一个 runoob 可执行文件。</p>\n<p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -g -Wall -std=c++<span class=\"number\">11</span> main.cpp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g-常用命令选项\"><a href=\"#g-常用命令选项\" class=\"headerlink\" title=\"g++ 常用命令选项\"></a>g++ 常用命令选项</h3><table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-ansi</td>\n<td align=\"left\">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>\n</tr>\n<tr>\n<td align=\"left\">-c</td>\n<td align=\"left\">只编译并生成目标文件。</td>\n</tr>\n<tr>\n<td align=\"left\">-DMACRO</td>\n<td align=\"left\">以字符串”1”定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td align=\"left\">-DMACRO&#x3D;DEFN</td>\n<td align=\"left\">以字符串”DEFN”定义 MACRO 宏。</td>\n</tr>\n<tr>\n<td align=\"left\">-E</td>\n<td align=\"left\">只运行 C 预编译器。</td>\n</tr>\n<tr>\n<td align=\"left\">-g</td>\n<td align=\"left\">生成调试信息。GNU 调试器可利用该信息。</td>\n</tr>\n<tr>\n<td align=\"left\">-IDIRECTORY</td>\n<td align=\"left\">指定额外的头文件搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td align=\"left\">-LDIRECTORY</td>\n<td align=\"left\">指定额外的函数库搜索路径DIRECTORY。</td>\n</tr>\n<tr>\n<td align=\"left\">-lLIBRARY</td>\n<td align=\"left\">连接时搜索指定的函数库LIBRARY。</td>\n</tr>\n<tr>\n<td align=\"left\">-m486</td>\n<td align=\"left\">针对 486 进行代码优化。</td>\n</tr>\n<tr>\n<td align=\"left\">-o</td>\n<td align=\"left\">FILE 生成指定的输出文件。用在生成可执行文件时。</td>\n</tr>\n<tr>\n<td align=\"left\">-O0</td>\n<td align=\"left\">不进行优化处理。</td>\n</tr>\n<tr>\n<td align=\"left\">-O</td>\n<td align=\"left\">或 -O1 优化生成代码。</td>\n</tr>\n<tr>\n<td align=\"left\">-O2</td>\n<td align=\"left\">进一步优化。</td>\n</tr>\n<tr>\n<td align=\"left\">-O3</td>\n<td align=\"left\">比 -O2 更进一步优化，包括 inline 函数。</td>\n</tr>\n<tr>\n<td align=\"left\">-shared</td>\n<td align=\"left\">生成共享目标文件。通常用在建立共享库时。</td>\n</tr>\n<tr>\n<td align=\"left\">-static</td>\n<td align=\"left\">禁止使用共享连接。</td>\n</tr>\n<tr>\n<td align=\"left\">-UMACRO</td>\n<td align=\"left\">取消对 MACRO 宏的定义。</td>\n</tr>\n<tr>\n<td align=\"left\">-w</td>\n<td align=\"left\">不生成任何警告信息。</td>\n</tr>\n<tr>\n<td align=\"left\">-Wall</td>\n<td align=\"left\">生成所有警告信息。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-基本语法\"><a href=\"#C-基本语法\" class=\"headerlink\" title=\"C++ 基本语法\"></a>C++ 基本语法</h1><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>\n<ul>\n<li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>\n<li><strong>类 -</strong> 类可以定义为描述对象行为&#x2F;状态的模板&#x2F;蓝图。</li>\n<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>\n<li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>\n</ul>\n<h2 id=\"C-程序结构\"><a href=\"#C-程序结构\" class=\"headerlink\" title=\"C++ 程序结构\"></a>C++ 程序结构</h2><p>让我们看一段简单的代码，可以输出单词 <em>Hello World</em>。</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; <span class=\"comment\">// main() 是程序开始执行的地方 </span></span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World   return 0;</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们讲解一下上面这段程序：</p>\n<ul>\n<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。</li>\n<li>行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>\n<li>下一行 <strong>&#x2F;&#x2F; main() 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 &#x2F;&#x2F; 开头，在行末结束。</li>\n<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>\n<li>下一行 <strong>cout &lt;&lt; “Hello World”;</strong> 会在屏幕上显示消息 “Hello World”。</li>\n<li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li>\n</ul>\n<h2 id=\"编译-执行-C-程序-1\"><a href=\"#编译-执行-C-程序-1\" class=\"headerlink\" title=\"编译 &amp; 执行 C++ 程序\"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>\n<ul>\n<li>打开一个文本编辑器，添加上述代码。</li>\n<li>保存文件为 hello.cpp。</li>\n<li>打开命令提示符，进入到保存文件所在的目录。</li>\n<li>键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li>\n<li>现在，键入 ‘ a.out’ 来运行程序。</li>\n<li>您可以看到屏幕上显示 ‘ Hello World ‘。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ hello.cpp$ ./a.outHello World</span><br></pre></td></tr></table></figure>\n\n<p>请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。</p>\n<p>您也可以使用 makefile 来编译 C&#x2F;C++ 程序。</p>\n<h2 id=\"C-中的分号-块\"><a href=\"#C-中的分号-块\" class=\"headerlink\" title=\"C++ 中的分号 &amp; 块\"></a>C++ 中的分号 &amp; 块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>\n<p>例如，下面是三个不同的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y;y = y+<span class=\"number\">1</span>;<span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>块是一组使用大括号括起来的按逻辑连接的语句。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y;y = y+<span class=\"number\">1</span>;<span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = y; y = y+<span class=\"number\">1</span>; <span class=\"built_in\">add</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-标识符\"><a href=\"#C-标识符\" class=\"headerlink\" title=\"C++ 标识符\"></a>C++ 标识符</h2><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>\n<p>C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p>\n<p>下面列出几个有效的标识符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-关键字\"><a href=\"#C-关键字\" class=\"headerlink\" title=\"C++ 关键字\"></a>C++ 关键字</h2><p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>\n<table>\n<thead>\n<tr>\n<th>asm</th>\n<th>else</th>\n<th>new</th>\n<th>this</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed</td>\n<td>using</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch</td>\n<td>while</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"三字符组\"><a href=\"#三字符组\" class=\"headerlink\" title=\"三字符组\"></a>三字符组</h2><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p>\n<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</p>\n<p>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>\n<p>下面列出了最常用的三字符序列：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">三字符组</th>\n<th align=\"left\">替换</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">??&#x3D;</td>\n<td align=\"left\">#</td>\n</tr>\n<tr>\n<td align=\"left\">??&#x2F;</td>\n<td align=\"left\">\\</td>\n</tr>\n<tr>\n<td align=\"left\">??’</td>\n<td align=\"left\">^</td>\n</tr>\n<tr>\n<td align=\"left\">??(</td>\n<td align=\"left\">[</td>\n</tr>\n<tr>\n<td align=\"left\">??)</td>\n<td align=\"left\">]</td>\n</tr>\n<tr>\n<td align=\"left\">??!</td>\n<td align=\"left\">|</td>\n</tr>\n<tr>\n<td align=\"left\">??&lt;</td>\n<td align=\"left\">{</td>\n</tr>\n<tr>\n<td align=\"left\">??&gt;</td>\n<td align=\"left\">}</td>\n</tr>\n<tr>\n<td align=\"left\">??-</td>\n<td align=\"left\">~</td>\n</tr>\n</tbody></table>\n<p>如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：”…?””?…”或者转义序列：”…??…”。</p>\n<p>从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项&#x2F;Zc:trigraphs</p>\n<p>g++仍默认支持三字符组，但会给出编译警告。</p>\n<h2 id=\"C-中的空格\"><a href=\"#C-中的空格\" class=\"headerlink\" title=\"C++ 中的空格\"></a>C++ 中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>\n<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> age;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fruit = apples + oranges;   <span class=\"comment\">// 获取水果的总数</span></span><br></pre></td></tr></table></figure>\n\n<p>fruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>\n<h1 id=\"C-注释\"><a href=\"#C-注释\" class=\"headerlink\" title=\"C++ 注释\"></a>C++ 注释</h1><p>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</p>\n<p>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</p>\n<p>C++ 注释以 &#x2F;* 开始，以 *&#x2F; 终止。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 这是注释 */</span><span class=\"comment\">/* C++ 注释也可以</span></span><br><span class=\"line\"><span class=\"comment\"> * 跨行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>注释也能以 &#x2F;&#x2F; 开始，直到行末为止。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;main()&#123;</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span>; <span class=\"comment\">// 输出 Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译时，编译器会忽略 <strong>&#x2F;&#x2F; 输出 Hello World</strong>，最后会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<p>在 &#x2F;* 和 <em>&#x2F; 注释内部，&#x2F;&#x2F; 字符没有特殊的含义。在 &#x2F;&#x2F; 注释内，&#x2F;</em> 和 *&#x2F; 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">/* 用于输出 Hello World 的注释</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-数据类型\"><a href=\"#C-数据类型\" class=\"headerlink\" title=\"C++ 数据类型\"></a>C++ 数据类型</h1><p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</p>\n<p>您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。</p>\n<h2 id=\"基本的内置类型\"><a href=\"#基本的内置类型\" class=\"headerlink\" title=\"基本的内置类型\"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">布尔型</td>\n<td align=\"left\">bool</td>\n</tr>\n<tr>\n<td align=\"left\">字符型</td>\n<td align=\"left\">char</td>\n</tr>\n<tr>\n<td align=\"left\">整型</td>\n<td align=\"left\">int</td>\n</tr>\n<tr>\n<td align=\"left\">浮点型</td>\n<td align=\"left\">float</td>\n</tr>\n<tr>\n<td align=\"left\">双浮点型</td>\n<td align=\"left\">double</td>\n</tr>\n<tr>\n<td align=\"left\">无类型</td>\n<td align=\"left\">void</td>\n</tr>\n<tr>\n<td align=\"left\">宽字符型</td>\n<td align=\"left\">wchar_t</td>\n</tr>\n</tbody></table>\n<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>short</li>\n<li>long</li>\n</ul>\n<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">位</th>\n<th align=\"left\">范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127 或者 0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">signed char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">0 到 4294967295</td>\n</tr>\n<tr>\n<td align=\"left\">signed int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">0 到 65,535</td>\n</tr>\n<tr>\n<td align=\"left\">signed short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">signed long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">0 to 18,446,744,073,709,551,615</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">+&#x2F;- 3.4e +&#x2F;- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">long double</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">wchar_t</td>\n<td align=\"left\">2 或 4 个字节</td>\n<td align=\"left\">1 个宽字符</td>\n</tr>\n</tbody></table>\n<p>从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。</p>\n<p>下面实例会输出您电脑上各种数据类型的大小。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;   </span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of char : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">char</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of short int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">short</span> <span class=\"type\">int</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of long int : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">int</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of float : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) &lt;&lt; endl;   </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of double : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">double</span>) &lt;&lt; endl;  </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Size of wchar_t : &quot;</span> &lt;&lt; <span class=\"built_in\">sizeof</span>(<span class=\"type\">wchar_t</span>) &lt;&lt; endl;   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本实例使用了 <strong>endl</strong>，这将在每一行后插入一个换行符，&lt;&lt; 运算符用于向屏幕传多个值。我们也使用 <strong>sizeof()</strong> 函数来获取各种数据类型的大小。</p>\n<p>当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Size of <span class=\"type\">char</span> : <span class=\"number\">1</span>Size of <span class=\"type\">int</span> : <span class=\"number\">4</span>Size of <span class=\"type\">short</span> <span class=\"type\">int</span> : <span class=\"number\">2</span>Size of <span class=\"type\">long</span> <span class=\"type\">int</span> : <span class=\"number\">8</span>Size of <span class=\"type\">float</span> : <span class=\"number\">4</span>Size of <span class=\"type\">double</span> : <span class=\"number\">8</span>Size of <span class=\"type\">wchar_t</span> : <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typedef-声明\"><a href=\"#typedef-声明\" class=\"headerlink\" title=\"typedef 声明\"></a>typedef 声明</h2><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> type newname;</span><br></pre></td></tr></table></figure>\n\n<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> feet;</span><br></pre></td></tr></table></figure>\n\n<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feet distance;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">enum</span>-name &#123; list of names &#125; var-list;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。</p>\n<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">color</span> &#123; red, green, blue &#125; c;c = blue;</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">color</span> &#123; red, green=<span class=\"number\">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。</p>\n<h1 id=\"C-变量类型\"><a href=\"#C-变量类型\" class=\"headerlink\" title=\"C++ 变量类型\"></a>C++ 变量类型</h1><p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>\n<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>\n<p>基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">bool</td>\n<td align=\"left\">存储值 true 或 false。</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">通常是一个八位字节（一个字节）。这是一个整数类型。</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">对机器而言，整数的最自然的大小。</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">单精度浮点值。</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">双精度浮点值。</td>\n</tr>\n<tr>\n<td align=\"left\">void</td>\n<td align=\"left\">表示类型的缺失。</td>\n</tr>\n<tr>\n<td align=\"left\">wchar_t</td>\n<td align=\"left\">宽字符类型。</td>\n</tr>\n</tbody></table>\n<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>\n<p>下面我们将讲解如何定义、声明和使用各种类型的变量。</p>\n<h2 id=\"C-中的变量定义\"><a href=\"#C-中的变量定义\" class=\"headerlink\" title=\"C++ 中的变量定义\"></a>C++ 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type variable_list;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>    i, j, k;<span class=\"type\">char</span>   c, ch;<span class=\"type\">float</span>  f, salary;<span class=\"type\">double</span> d;</span><br></pre></td></tr></table></figure>\n\n<p>行 <strong>int i, j, k;</strong> 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。</p>\n<p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type variable_name = value;</span><br></pre></td></tr></table></figure>\n\n<p>下面列举几个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> d = <span class=\"number\">3</span>, f = <span class=\"number\">5</span>;   </span><br><span class=\"line\">\t<span class=\"comment\">// d 和 f 的声明 int d = 3, f = 5;          </span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义并初始化 d 和 fbyte z = 22;               </span></span><br><span class=\"line\">\t<span class=\"comment\">// 定义并初始化 zchar x = &#x27;x&#x27;;              </span></span><br><span class=\"line\">\t<span class=\"comment\">// 变量 x 的值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>\n<h2 id=\"C-中的变量声明\"><a href=\"#C-中的变量声明\" class=\"headerlink\" title=\"C++ 中的变量声明\"></a>C++ 中的变量声明</h2><p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>\n<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>\n<h2 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 变量声明extern int a, b;extern int c;extern float f;</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 变量定义</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"type\">int</span> c;</span><br><span class=\"line\">  <span class=\"type\">float</span> f;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; c &lt;&lt; endl ;</span><br><span class=\"line\"></span><br><span class=\"line\">  f = <span class=\"number\">70.0</span>/<span class=\"number\">3.0</span>;</span><br><span class=\"line\">  cout &lt;&lt; f &lt;&lt; endl ;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3023.3333</span></span><br></pre></td></tr></table></figure>\n\n<p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数声明int func();int main()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数调用</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"built_in\">func</span>();&#125;<span class=\"comment\">// 函数定义int func()&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的左值（Lvalues）和右值（Rvalues）\"><a href=\"#C-中的左值（Lvalues）和右值（Rvalues）\" class=\"headerlink\" title=\"C++ 中的左值（Lvalues）和右值（Rvalues）\"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>C++ 中有两种类型的表达式：</p>\n<ul>\n<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>\n<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>\n</ul>\n<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> g = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span> = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-变量作用域\"><a href=\"#C-变量作用域\" class=\"headerlink\" title=\"C++ 变量作用域\"></a>C++ 变量作用域</h1><p>作用域是程序的一个区域，一般来说有三个地方可以声明变量：</p>\n<ul>\n<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>\n<li>在函数参数的定义中声明的变量，称为形式参数。</li>\n<li>在所有函数外部声明的变量，称为全局变量。</li>\n</ul>\n<p>我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。</p>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"type\">int</span> c;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; c;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 全局变量声明int g;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> a, b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  g = a + b;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 全局变量声明int g = 20;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"type\">int</span> g = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化局部变量和全局变量\"><a href=\"#初始化局部变量和全局变量\" class=\"headerlink\" title=\"初始化局部变量和全局变量\"></a>初始化局部变量和全局变量</h2><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">初始化默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">int</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">‘\\0’</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">pointer</td>\n<td align=\"left\">NULL</td>\n</tr>\n</tbody></table>\n<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p>\n<h1 id=\"C-常量\"><a href=\"#C-常量\" class=\"headerlink\" title=\"C++ 常量\"></a>C++ 常量</h1><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>\n<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>\n<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>\n<h2 id=\"整数常量\"><a href=\"#整数常量\" class=\"headerlink\" title=\"整数常量\"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>\n<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>\n<p>下面列举几个整数常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">212</span>         <span class=\"comment\">// 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀</span></span><br></pre></td></tr></table></figure>\n\n<p>以下是各种类型的整数常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">85</span>         <span class=\"comment\">// 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"浮点常量\"><a href=\"#浮点常量\" class=\"headerlink\" title=\"浮点常量\"></a>浮点常量</h2><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>\n<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>\n<p>下面列举几个浮点常量的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3.14159</span>       <span class=\"comment\">// 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"布尔常量\"><a href=\"#布尔常量\" class=\"headerlink\" title=\"布尔常量\"></a>布尔常量</h2><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>\n<ul>\n<li><strong>true</strong> 值代表真。</li>\n<li><strong>false</strong> 值代表假。</li>\n</ul>\n<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>\n<h2 id=\"字符常量\"><a href=\"#字符常量\" class=\"headerlink\" title=\"字符常量\"></a>字符常量</h2><p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>\n<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。</p>\n<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">转义序列</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">\\</td>\n<td align=\"left\">\\ 字符</td>\n</tr>\n<tr>\n<td align=\"left\">&#39;</td>\n<td align=\"left\">‘ 字符</td>\n</tr>\n<tr>\n<td align=\"left\">&quot;</td>\n<td align=\"left\">“ 字符</td>\n</tr>\n<tr>\n<td align=\"left\">?</td>\n<td align=\"left\">? 字符</td>\n</tr>\n<tr>\n<td align=\"left\">\\a</td>\n<td align=\"left\">警报铃声</td>\n</tr>\n<tr>\n<td align=\"left\">\\b</td>\n<td align=\"left\">退格键</td>\n</tr>\n<tr>\n<td align=\"left\">\\f</td>\n<td align=\"left\">换页符</td>\n</tr>\n<tr>\n<td align=\"left\">\\n</td>\n<td align=\"left\">换行符</td>\n</tr>\n<tr>\n<td align=\"left\">\\r</td>\n<td align=\"left\">回车</td>\n</tr>\n<tr>\n<td align=\"left\">\\t</td>\n<td align=\"left\">水平制表符</td>\n</tr>\n<tr>\n<td align=\"left\">\\v</td>\n<td align=\"left\">垂直制表符</td>\n</tr>\n<tr>\n<td align=\"left\">\\ooo</td>\n<td align=\"left\">一到三位的八进制数</td>\n</tr>\n<tr>\n<td align=\"left\">\\xhh . . .</td>\n<td align=\"left\">一个或多个数字的十六进制数</td>\n</tr>\n</tbody></table>\n<p>下面的实例显示了一些转义序列字符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello\\tWorld\\n\\n&quot;</span>;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello   World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串常量\"><a href=\"#字符串常量\" class=\"headerlink\" title=\"字符串常量\"></a>字符串常量</h2><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>\n<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>\n<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;quot;hello, dear&quot;</span><span class=\"string\">&quot;hello, \\dear&quot;</span><span class=\"string\">&quot;hello, &quot;</span> <span class=\"string\">&quot;d&quot;</span> <span class=\"string\">&quot;ear&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p>在 C++ 中，有两种简单的定义常量的方式：</p>\n<ul>\n<li>使用 <strong>#define</strong> 预处理器。</li>\n<li>使用 <strong>const</strong> 关键字。</li>\n</ul>\n<h2 id=\"define-预处理器\"><a href=\"#define-预处理器\" class=\"headerlink\" title=\"#define 预处理器\"></a>#define 预处理器</h2><p>下面是使用 #define 预处理器定义常量的形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> identifier value</span></span><br></pre></td></tr></table></figure>\n\n<p>具体请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> LENGTH 10   #<span class=\"keyword\">define</span> WIDTH  5#<span class=\"keyword\">define</span> NEWLINE <span class=\"string\">&#x27;\\n&#x27;</span>int main()&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> area;  </span><br><span class=\"line\">   </span><br><span class=\"line\">   area = LENGTH * WIDTH;</span><br><span class=\"line\">   cout &lt;&lt; area;</span><br><span class=\"line\">   cout &lt;&lt; NEWLINE;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h2><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> type variable = value;</span><br></pre></td></tr></table></figure>\n\n<p>具体请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">int</span>  LENGTH = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">int</span>  WIDTH  = <span class=\"number\">5</span>;</span><br><span class=\"line\">   <span class=\"type\">const</span> <span class=\"type\">char</span> NEWLINE = <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> area;  </span><br><span class=\"line\">   </span><br><span class=\"line\">   area = LENGTH * WIDTH;</span><br><span class=\"line\">   cout &lt;&lt; area;</span><br><span class=\"line\">   cout &lt;&lt; NEWLINE;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，把常量定义为大写字母形式，是一个很好的编程实践。</p>\n<h1 id=\"C-修饰符类型\"><a href=\"#C-修饰符类型\" class=\"headerlink\" title=\"C++ 修饰符类型\"></a>C++ 修饰符类型</h1><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>\n<p>下面列出了数据类型修饰符：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>long</li>\n<li>short</li>\n</ul>\n<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>\n<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>\n<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> x;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> y;</span><br></pre></td></tr></table></figure>\n\n<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 这个程序演示了有符号整数和无符号整数之间的差别</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">short</span> <span class=\"type\">int</span> i;           <span class=\"comment\">// 有符号短整数</span></span><br><span class=\"line\">   <span class=\"type\">short</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> j;  <span class=\"comment\">// 无符号短整数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   j = <span class=\"number\">50000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   i = j;</span><br><span class=\"line\">   cout &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; j;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的程序运行时，会输出下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">-15536</span> <span class=\"number\">50000</span></span><br></pre></td></tr></table></figure>\n\n<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>\n<h2 id=\"C-中的类型限定符\"><a href=\"#C-中的类型限定符\" class=\"headerlink\" title=\"C++ 中的类型限定符\"></a>C++ 中的类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">限定符</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">const</td>\n<td align=\"left\"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>\n</tr>\n<tr>\n<td align=\"left\">volatile</td>\n<td align=\"left\">修饰符 <strong>volatile</strong> 告诉编译器，变量的值可能以程序未明确指定的方式被改变。</td>\n</tr>\n<tr>\n<td align=\"left\">restrict</td>\n<td align=\"left\">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-存储类\"><a href=\"#C-存储类\" class=\"headerlink\" title=\"C++ 存储类\"></a>C++ 存储类</h1><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>\n<ul>\n<li>auto</li>\n<li>register</li>\n<li>static</li>\n<li>extern</li>\n<li>mutable</li>\n<li>thread_local (C++11)</li>\n</ul>\n<p>从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>\n<h2 id=\"auto-存储类\"><a href=\"#auto-存储类\" class=\"headerlink\" title=\"auto 存储类\"></a>auto 存储类</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>\n<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。</p>\n<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>\n<p>auto f&#x3D;3.14;    &#x2F;&#x2F;doubleauto s(“hello”);  &#x2F;&#x2F;const char<em>auto z &#x3D; new auto(9); &#x2F;&#x2F; int</em>auto x1 &#x3D; 5, x2 &#x3D; 5.0, x3&#x3D;’r’;&#x2F;&#x2F;错误，必须是初始化为同一类型</p>\n<h2 id=\"register-存储类\"><a href=\"#register-存储类\" class=\"headerlink\" title=\"register 存储类\"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>\n<p>{  register int miles;}</p>\n<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>\n<h2 id=\"static-存储类\"><a href=\"#static-存储类\" class=\"headerlink\" title=\"static 存储类\"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>\n<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>\n<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>\n<h2 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"comment\">// 函数声明 void func(void); </span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">10</span>; <span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"built_in\">func</span>();    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"comment\">// 函数定义void func( void )&#123;</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> i = <span class=\"number\">5</span>; <span class=\"comment\">// 局部静态变量</span></span><br><span class=\"line\">    i++;    std::cout &lt;&lt; <span class=\"string\">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;    std::cout &lt;&lt; <span class=\"string\">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 i 为 <span class=\"number\">6</span> , 变量 count 为 <span class=\"number\">9</span>变量 i 为 <span class=\"number\">7</span> , 变量 count 为 <span class=\"number\">8</span>变量 i 为 <span class=\"number\">8</span> , 变量 count 为 <span class=\"number\">7</span>变量 i 为 <span class=\"number\">9</span> , 变量 count 为 <span class=\"number\">6</span>变量 i 为 <span class=\"number\">10</span> , 变量 count 为 <span class=\"number\">5</span>变量 i 为 <span class=\"number\">11</span> , 变量 count 为 <span class=\"number\">4</span>变量 i 为 <span class=\"number\">12</span> , 变量 count 为 <span class=\"number\">3</span>变量 i 为 <span class=\"number\">13</span> , 变量 count 为 <span class=\"number\">2</span>变量 i 为 <span class=\"number\">14</span> , 变量 count 为 <span class=\"number\">1</span>变量 i 为 <span class=\"number\">15</span> , 变量 count 为 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"extern-存储类\"><a href=\"#extern-存储类\" class=\"headerlink\" title=\"extern 存储类\"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>\n<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>\n<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>\n<p>第一个文件：main.cpp</p>\n<h2 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"type\">int</span> count ;<span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   count = <span class=\"number\">5</span>;   <span class=\"built_in\">write_extern</span>();&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个文件：support.cpp</p>\n<h2 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">extern</span> <span class=\"type\">int</span> count; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   std::cout &lt;&lt; <span class=\"string\">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure>\n\n<p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./writeCount is <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mutable-存储类\"><a href=\"#mutable-存储类\" class=\"headerlink\" title=\"mutable 存储类\"></a>mutable 存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>\n<h2 id=\"thread-local-存储类\"><a href=\"#thread-local-存储类\" class=\"headerlink\" title=\"thread_local 存储类\"></a>thread_local 存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>\n<p>thread_local 说明符可以与 static 或 extern 合并。</p>\n<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>\n<p>以下演示了可以被声明为 thread_local 的变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">thread_local</span> <span class=\"type\">int</span> x;  <span class=\"comment\">// 命名空间下的全局变量class X&#123;</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">thread_local</span> std::string s; <span class=\"comment\">// 类的static成员变量&#125;;static thread_local std::string X::s;  // X::s 是需要定义的</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">thread_local</span> std::vector&lt;<span class=\"type\">int</span>&gt; v;  <span class=\"comment\">// 本地变量&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-运算符\"><a href=\"#C-运算符\" class=\"headerlink\" title=\"C++ 运算符\"></a>C++ 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>\n<ul>\n<li>算术运算符</li>\n<li>关系运算符</li>\n<li>逻辑运算符</li>\n<li>位运算符</li>\n<li>赋值运算符</li>\n<li>杂项运算符</li>\n</ul>\n<p>本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p>下表显示了 C++ 支持的算术运算符。</p>\n<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">+</td>\n<td align=\"left\">把两个操作数相加</td>\n<td align=\"left\">A + B 将得到 30</td>\n</tr>\n<tr>\n<td align=\"left\">-</td>\n<td align=\"left\">从第一个操作数中减去第二个操作数</td>\n<td align=\"left\">A - B 将得到 -10</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td align=\"left\">把两个操作数相乘</td>\n<td align=\"left\">A * B 将得到 200</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;</td>\n<td align=\"left\">分子除以分母</td>\n<td align=\"left\">B &#x2F; A 将得到 2</td>\n</tr>\n<tr>\n<td align=\"left\">%</td>\n<td align=\"left\">取模运算符，整除后的余数</td>\n<td align=\"left\">B % A 将得到 0</td>\n</tr>\n<tr>\n<td align=\"left\">++</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html\">自增运算符</a>，整数值增加 1</td>\n<td align=\"left\">A++ 将得到 11</td>\n</tr>\n<tr>\n<td align=\"left\">–</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html\">自减运算符</a>，整数值减少 1</td>\n<td align=\"left\">A– 将得到 9</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的算术运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   c = a + b;   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a - b;   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a * b;   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a / b;   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a % b;   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"type\">int</span> d = <span class=\"number\">10</span>;   <span class=\"comment\">//  测试自增、自减</span></span><br><span class=\"line\">   c = d++;   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   d = <span class=\"number\">10</span>;    <span class=\"comment\">// 重新赋值</span></span><br><span class=\"line\">   c = d--;   cout &lt;&lt; <span class=\"string\">&quot;Line 7 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - c 的值是 <span class=\"number\">31L</span>ine <span class=\"number\">2</span> - c 的值是 <span class=\"number\">11L</span>ine <span class=\"number\">3</span> - c 的值是 <span class=\"number\">210L</span>ine <span class=\"number\">4</span> - c 的值是 <span class=\"number\">2L</span>ine <span class=\"number\">5</span> - c 的值是 <span class=\"number\">1L</span>ine <span class=\"number\">6</span> - c 的值是 <span class=\"number\">10L</span>ine <span class=\"number\">7</span> - c 的值是 <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>下表显示了 C++ 支持的关系运算符。</p>\n<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&#x3D;&#x3D;</td>\n<td align=\"left\">检查两个操作数的值是否相等，如果相等则条件为真。</td>\n<td align=\"left\">(A &#x3D;&#x3D; B) 不为真。</td>\n</tr>\n<tr>\n<td align=\"left\">!&#x3D;</td>\n<td align=\"left\">检查两个操作数的值是否相等，如果不相等则条件为真。</td>\n<td align=\"left\">(A !&#x3D; B) 为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;</td>\n<td align=\"left\">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &gt; B) 不为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;</td>\n<td align=\"left\">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &lt; B) 为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;&#x3D;</td>\n<td align=\"left\">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &gt;&#x3D; B) 不为真。</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;&#x3D;</td>\n<td align=\"left\">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>\n<td align=\"left\">(A &lt;&#x3D; B) 为真。</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-8\"><a href=\"#实例-8\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的关系运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-9\"><a href=\"#实例-9\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( a == b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - a 等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - a 不等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &lt; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - a 小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - a 不小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - a 大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - a 不大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"comment\">/* 改变 a 和 b 的值 */</span></span><br><span class=\"line\">   a = <span class=\"number\">5</span>;   b = <span class=\"number\">20</span>;   <span class=\"keyword\">if</span> ( a &lt;= b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 4 - a 小于或等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( b &gt;= a )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 5 - b 大于或等于 a&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - a 不等于 bLine <span class=\"number\">2</span> - a 不小于 bLine <span class=\"number\">3</span> - a 大于 bLine <span class=\"number\">4</span> - a 小于或等于 bLine <span class=\"number\">5</span> - b 大于或等于 a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>下表显示了 C++ 支持的关系逻辑运算符。</p>\n<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&amp;&amp;</td>\n<td align=\"left\">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>\n<td align=\"left\">(A &amp;&amp; B) 为假。</td>\n</tr>\n<tr>\n<td align=\"left\">||</td>\n<td align=\"left\">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>\n<td align=\"left\">(A || B) 为真。</td>\n</tr>\n<tr>\n<td align=\"left\">!</td>\n<td align=\"left\">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>\n<td align=\"left\">!(A &amp;&amp; B) 为真。</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-10\"><a href=\"#实例-10\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的逻辑运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-11\"><a href=\"#实例-11\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">5</span>;   <span class=\"type\">int</span> b = <span class=\"number\">20</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a &amp;&amp; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 1 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( a || b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 2 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"comment\">/* 改变 a 和 b 的值 */</span></span><br><span class=\"line\">   a = <span class=\"number\">0</span>;   b = <span class=\"number\">10</span>;   <span class=\"keyword\">if</span> ( a &amp;&amp; b )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 3 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 4 - 条件不为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !(a &amp;&amp; b) )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Line 5 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - 条件为真Line <span class=\"number\">2</span> - 条件为真Line <span class=\"number\">4</span> - 条件不为真Line <span class=\"number\">5</span> - 条件为真</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">p</th>\n<th align=\"left\">q</th>\n<th align=\"left\">p &amp; q</th>\n<th align=\"left\">p | q</th>\n<th align=\"left\">p ^ q</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p>\n<p>A &#x3D; 0011 1100</p>\n<p>B &#x3D; 0000 1101</p>\n<p>-—————-</p>\n<p>A&amp;B &#x3D; 0000 1100</p>\n<p>A|B &#x3D; 0011 1101</p>\n<p>A^B &#x3D; 0011 0001</p>\n<p>~A &#x3D; 1100 0011</p>\n<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&amp;</td>\n<td align=\"left\">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td align=\"left\">(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td align=\"left\">|</td>\n<td align=\"left\">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td align=\"left\">(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td align=\"left\">^</td>\n<td align=\"left\">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td align=\"left\">(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td align=\"left\">~</td>\n<td align=\"left\">二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td align=\"left\">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;&lt;</td>\n<td align=\"left\">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td align=\"left\">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;&gt;</td>\n<td align=\"left\">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td align=\"left\">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-12\"><a href=\"#实例-12\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的位运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-13\"><a href=\"#实例-13\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">60</span>;      <span class=\"comment\">// 60 = 0011 1100  </span></span><br><span class=\"line\">   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">13</span>;      <span class=\"comment\">// 13 = 0000 1101</span></span><br><span class=\"line\">   <span class=\"type\">int</span> c = <span class=\"number\">0</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\">   c = a &amp; b;             <span class=\"comment\">// 12 = 0000 1100</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a | b;             <span class=\"comment\">// 61 = 0011 1101</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a ^ b;             <span class=\"comment\">// 49 = 0011 0001</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = ~a;                <span class=\"comment\">// -61 = 1100 0011</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a &lt;&lt; <span class=\"number\">2</span>;            <span class=\"comment\">// 240 = 1111 0000</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   c = a &gt;&gt; <span class=\"number\">2</span>;            <span class=\"comment\">// 15 = 0000 1111</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">Line 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>下表列出了 C++ 支持的赋值运算符：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&#x3D;</td>\n<td align=\"left\">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>\n<td align=\"left\">C &#x3D; A + B 将把 A + B 的值赋给 C</td>\n</tr>\n<tr>\n<td align=\"left\">+&#x3D;</td>\n<td align=\"left\">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C +&#x3D; A 相当于 C &#x3D; C + A</td>\n</tr>\n<tr>\n<td align=\"left\">-&#x3D;</td>\n<td align=\"left\">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C -&#x3D; A 相当于 C &#x3D; C - A</td>\n</tr>\n<tr>\n<td align=\"left\">*&#x3D;</td>\n<td align=\"left\">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C *&#x3D; A 相当于 C &#x3D; C * A</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;&#x3D;</td>\n<td align=\"left\">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>\n<td align=\"left\">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>\n</tr>\n<tr>\n<td align=\"left\">%&#x3D;</td>\n<td align=\"left\">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>\n<td align=\"left\">C %&#x3D; A 相当于 C &#x3D; C % A</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;&lt;&#x3D;</td>\n<td align=\"left\">左移且赋值运算符</td>\n<td align=\"left\">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;&gt;&#x3D;</td>\n<td align=\"left\">右移且赋值运算符</td>\n<td align=\"left\">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>\n</tr>\n<tr>\n<td align=\"left\">&amp;&#x3D;</td>\n<td align=\"left\">按位与且赋值运算符</td>\n<td align=\"left\">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>\n</tr>\n<tr>\n<td align=\"left\">^&#x3D;</td>\n<td align=\"left\">按位异或且赋值运算符</td>\n<td align=\"left\">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>\n</tr>\n<tr>\n<td align=\"left\">|&#x3D;</td>\n<td align=\"left\">按位或且赋值运算符</td>\n<td align=\"left\">C |&#x3D; 2 等同于 C &#x3D; C | 2</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-14\"><a href=\"#实例-14\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的赋值运算符。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<h2 id=\"实例-15\"><a href=\"#实例-15\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">21</span>;   <span class=\"type\">int</span> c ; </span><br><span class=\"line\">   c =  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 1 - =  运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c +=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 2 - += 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c -=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 3 - -= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c *=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 4 - *= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c /=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 5 - /= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c  = <span class=\"number\">200</span>;   c %=  a;   cout &lt;&lt; <span class=\"string\">&quot;Line 6 - %= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &lt;&lt;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &gt;&gt;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c &amp;=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 9 - &amp;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c ^=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 10 - ^= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   c |=  <span class=\"number\">2</span>;   cout &lt;&lt; <span class=\"string\">&quot;Line 11 - |= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Line <span class=\"number\">1</span> - =  运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">2</span> - += 运算符实例，c 的值 = <span class=\"number\">42L</span>ine <span class=\"number\">3</span> - -= 运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">4</span> - *= 运算符实例，c 的值 = <span class=\"number\">441L</span>ine <span class=\"number\">5</span> - /= 运算符实例，c 的值 = <span class=\"number\">21L</span>ine <span class=\"number\">6</span> - %= 运算符实例，c 的值 = <span class=\"number\">11L</span>ine <span class=\"number\">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class=\"number\">44L</span>ine <span class=\"number\">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class=\"number\">11L</span>ine <span class=\"number\">9</span> - &amp;= 运算符实例，c 的值 = <span class=\"number\">2L</span>ine <span class=\"number\">10</span> - ^= 运算符实例，c 的值 = <span class=\"number\">0L</span>ine <span class=\"number\">11</span> - |= 运算符实例，c 的值 = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"杂项运算符\"><a href=\"#杂项运算符\" class=\"headerlink\" title=\"杂项运算符\"></a>杂项运算符</h2><p>下表列出了 C++ 支持的其他一些重要的运算符。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">运算符</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">sizeof</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html\">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td>\n</tr>\n<tr>\n<td align=\"left\">Condition ? X : Y</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html\">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-comma-operator.html\">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>\n</tr>\n<tr>\n<td align=\"left\">.（点）和 -&gt;（箭头）</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-member-operators.html\">成员运算符</a>用于引用类、结构和共用体的成员。</td>\n</tr>\n<tr>\n<td align=\"left\">Cast</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-casting-operators.html\">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td>\n</tr>\n<tr>\n<td align=\"left\">&amp;</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html\">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的实际地址。</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html\">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td>\n</tr>\n</tbody></table>\n<h2 id=\"C-中的运算符优先级\"><a href=\"#C-中的运算符优先级\" class=\"headerlink\" title=\"C++ 中的运算符优先级\"></a>C++ 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>\n<p>例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>\n<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类别</th>\n<th align=\"left\">运算符</th>\n<th align=\"left\">结合性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">后缀</td>\n<td align=\"left\">() [] -&gt; . ++ - -</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">一元</td>\n<td align=\"left\">+ - ! ~ ++ - - (type)* &amp; sizeof</td>\n<td align=\"left\">从右到左</td>\n</tr>\n<tr>\n<td align=\"left\">乘除</td>\n<td align=\"left\">* &#x2F; %</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">加减</td>\n<td align=\"left\">+ -</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">移位</td>\n<td align=\"left\">&lt;&lt; &gt;&gt;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">关系</td>\n<td align=\"left\">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">相等</td>\n<td align=\"left\">&#x3D;&#x3D; !&#x3D;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">位与 AND</td>\n<td align=\"left\">&amp;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">位异或 XOR</td>\n<td align=\"left\">^</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">位或 OR</td>\n<td align=\"left\">|</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">逻辑与 AND</td>\n<td align=\"left\">&amp;&amp;</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">逻辑或 OR</td>\n<td align=\"left\">||</td>\n<td align=\"left\">从左到右</td>\n</tr>\n<tr>\n<td align=\"left\">条件</td>\n<td align=\"left\">?:</td>\n<td align=\"left\">从右到左</td>\n</tr>\n<tr>\n<td align=\"left\">赋值</td>\n<td align=\"left\">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>\n<td align=\"left\">从右到左</td>\n</tr>\n<tr>\n<td align=\"left\">逗号</td>\n<td align=\"left\">,</td>\n<td align=\"left\">从左到右</td>\n</tr>\n</tbody></table>\n<h3 id=\"实例-16\"><a href=\"#实例-16\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>请看下面的实例，了解 C++ 中运算符的优先级。</p>\n<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>\n<p>对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 &#x2F;、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。</p>\n<h2 id=\"实例-17\"><a href=\"#实例-17\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">20</span>;   <span class=\"type\">int</span> b = <span class=\"number\">10</span>;   <span class=\"type\">int</span> c = <span class=\"number\">15</span>;   <span class=\"type\">int</span> d = <span class=\"number\">5</span>;   <span class=\"type\">int</span> e; </span><br><span class=\"line\">   e = (a + b) * c / d;      <span class=\"comment\">// ( 30 * 15 ) / 5</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;(a + b) * c / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = ((a + b) * c) / d;    <span class=\"comment\">// (30 * 15 ) / 5</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;((a + b) * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = (a + b) * (c / d);   <span class=\"comment\">// (30) * (15/5)</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;(a + b) * (c / d) 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class=\"line\">   e = a + (b * c) / d;     <span class=\"comment\">//  20 + (150/5)</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;a + (b * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ;  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a + b) * c / d 的值是 <span class=\"number\">90</span>((a + b) * c) / d 的值是 <span class=\"number\">90</span>(a + b) * (c / d) 的值是 <span class=\"number\">90</span>a + (b * c) / d 的值是 <span class=\"number\">50</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-循环\"><a href=\"#C-循环\" class=\"headerlink\" title=\"C++ 循环\"></a>C++ 循环</h1><p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>\n<p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p>\n<p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png\" alt=\"img\"></p>\n<h2 id=\"循环类型\"><a href=\"#循环类型\" class=\"headerlink\" title=\"循环类型\"></a>循环类型</h2><p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">循环类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">while 循环</td>\n<td align=\"left\">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>\n</tr>\n<tr>\n<td align=\"left\">for 循环</td>\n<td align=\"left\">多次执行一个语句序列，简化管理循环变量的代码。</td>\n</tr>\n<tr>\n<td align=\"left\">do…while 循环</td>\n<td align=\"left\">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>\n</tr>\n<tr>\n<td align=\"left\">嵌套循环</td>\n<td align=\"left\">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>\n</tr>\n</tbody></table>\n<h2 id=\"循环控制语句\"><a href=\"#循环控制语句\" class=\"headerlink\" title=\"循环控制语句\"></a>循环控制语句</h2><p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>\n<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">控制语句</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">break 语句</td>\n<td align=\"left\">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>\n</tr>\n<tr>\n<td align=\"left\">continue 语句</td>\n<td align=\"left\">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>\n</tr>\n<tr>\n<td align=\"left\">goto 语句</td>\n<td align=\"left\">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>\n</tr>\n</tbody></table>\n<h2 id=\"无限循环\"><a href=\"#无限循环\" class=\"headerlink\" title=\"无限循环\"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This loop will run forever.\\n&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>\n<p><strong>注意：</strong>您可以按 Ctrl + C 键终止一个无限循环。</p>\n<h1 id=\"C-判断\"><a href=\"#C-判断\" class=\"headerlink\" title=\"C++ 判断\"></a>C++ 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>\n<p>下面是大多数编程语言中典型的判断结构的一般形式：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png\" alt=\"img\"></p>\n<h2 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h2><p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">语句</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">if 语句</td>\n<td align=\"left\">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>\n</tr>\n<tr>\n<td align=\"left\">if…else 语句</td>\n<td align=\"left\">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>\n</tr>\n<tr>\n<td align=\"left\">嵌套 if 语句</td>\n<td align=\"left\">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>\n</tr>\n<tr>\n<td align=\"left\">switch 语句</td>\n<td align=\"left\">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>\n</tr>\n<tr>\n<td align=\"left\">嵌套 switch 语句</td>\n<td align=\"left\">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>\n</tr>\n</tbody></table>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"? : 运算符\"></a>? : 运算符</h2><p>我们已经在前面的章节中讲解了 <a href=\"https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html\"><strong>条件运算符 ? :</strong></a>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>\n\n<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>\n<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>\n<h1 id=\"C-函数\"><a href=\"#C-函数\" class=\"headerlink\" title=\"C++ 函数\"></a>C++ 函数</h1><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>\n<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>\n<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>\n<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>\n<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>\n<h2 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h2><p>C++ 中的函数定义的一般形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter list )</span></span>&#123;   body of the function&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>\n<ul>\n<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>\n<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>\n<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>\n<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>\n</ul>\n<h2 id=\"实例-18\"><a href=\"#实例-18\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数返回两个数中较大的那个数 int max(int num1, int num2) &#123;   // 局部变量声明   int result;    if (num1 &gt; num2)      result = num1;   else      result = num2;    return result; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>\n<p>函数声明包括以下几个部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>针对上面定义的函数 max()，以下是函数声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> num1, <span class=\"type\">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>\n<h2 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h2><p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>\n<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>\n<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"comment\">// 函数声明int max(int num1, int num2);</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> ret;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来获取最大值</span></span><br><span class=\"line\">   ret = <span class=\"built_in\">max</span>(a, b);</span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Max value is : &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 函数返回两个数中较大的那个数int max(int num1, int num2) &#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">if</span> (num1 &gt; num2)</span><br><span class=\"line\">      result = num1;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">      result = num2;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> result; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Max value is : <span class=\"number\">200</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>\n<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>\n<p>当调用函数时，有两种向函数传递参数的方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">调用类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html\">传值调用</a></td>\n<td align=\"left\">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html\">指针调用</a></td>\n<td align=\"left\">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html\">引用调用</a></td>\n<td align=\"left\">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody></table>\n<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。</p>\n<h2 id=\"参数的默认值\"><a href=\"#参数的默认值\" class=\"headerlink\" title=\"参数的默认值\"></a>参数的默认值</h2><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>\n<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b=<span class=\"number\">20</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = a + b;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (result);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> result;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来添加值</span></span><br><span class=\"line\">   result = <span class=\"built_in\">sum</span>(a, b);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 再次调用函数</span></span><br><span class=\"line\">   result = <span class=\"built_in\">sum</span>(a);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total value is :<span class=\"number\">300</span>Total value is :<span class=\"number\">120</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Lambda-函数与表达式\"><a href=\"#Lambda-函数与表达式\" class=\"headerlink\" title=\"Lambda 函数与表达式\"></a>Lambda 函数与表达式</h2><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>\n<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>\n<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)-&gt;<span class=\"keyword\">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有参数可以表示为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]&#123; ++global_x; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) -&gt; <span class=\"type\">int</span> &#123; <span class=\"type\">int</span> z = x + y; <span class=\"keyword\">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p>\n<p>如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。</p>\n<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]      <span class=\"comment\">// 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>\n\n<p>另外有一点需要注意。对于[&#x3D;]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">this</span>]() &#123; <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-数字\"><a href=\"#C-数字\" class=\"headerlink\" title=\"C++ 数字\"></a>C++ 数字</h1><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>\n<h2 id=\"C-定义数字\"><a href=\"#C-定义数字\" class=\"headerlink\" title=\"C++ 定义数字\"></a>C++ 定义数字</h2><p>我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 数字定义</span></span><br><span class=\"line\">   <span class=\"type\">short</span>  s;</span><br><span class=\"line\">   <span class=\"type\">int</span>    i;</span><br><span class=\"line\">   <span class=\"type\">long</span>   l;</span><br><span class=\"line\">   <span class=\"type\">float</span>  f;</span><br><span class=\"line\">   <span class=\"type\">double</span> d;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 数字赋值</span></span><br><span class=\"line\">   s = <span class=\"number\">10</span>;      </span><br><span class=\"line\">   i = <span class=\"number\">1000</span>;    </span><br><span class=\"line\">   l = <span class=\"number\">1000000</span>; </span><br><span class=\"line\">   f = <span class=\"number\">230.47</span>;  </span><br><span class=\"line\">   d = <span class=\"number\">30949.374</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 数字输出</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;short  s :&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;int    i :&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;long   l :&quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;float  f :&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;double d :&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">short</span>  s :<span class=\"number\">10</span><span class=\"type\">int</span>    i :<span class=\"number\">1000l</span>ong   l :<span class=\"number\">1000000f</span>loat  f :<span class=\"number\">230.47</span><span class=\"type\">double</span> d :<span class=\"number\">30949.4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-数学运算\"><a href=\"#C-数学运算\" class=\"headerlink\" title=\"C++ 数学运算\"></a>C++ 数学运算</h2><p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>\n<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>\n<p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><strong>double fabs(double);</strong> 该函数返回任意一个十进制数的绝对值。</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td>\n</tr>\n</tbody></table>\n<p>下面是一个关于数学运算的简单实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 数字定义</span></span><br><span class=\"line\">   <span class=\"type\">short</span>  s = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span>    i = <span class=\"number\">-1000</span>;</span><br><span class=\"line\">   <span class=\"type\">long</span>   l = <span class=\"number\">100000</span>;</span><br><span class=\"line\">   <span class=\"type\">float</span>  f = <span class=\"number\">230.47</span>;</span><br><span class=\"line\">   <span class=\"type\">double</span> d = <span class=\"number\">200.374</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 数学运算</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;sin(d) :&quot;</span> &lt;&lt; <span class=\"built_in\">sin</span>(d) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class=\"built_in\">abs</span>(i) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;floor(d) :&quot;</span> &lt;&lt; <span class=\"built_in\">floor</span>(d) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class=\"built_in\">sqrt</span>(f) &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class=\"built_in\">pow</span>(d, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sign</span>(d) :<span class=\"number\">-0.634939</span>abs(i)  :<span class=\"number\">1000f</span>loor(d) :<span class=\"number\">200</span>sqrt(f) :<span class=\"number\">15.1812</span>pow( d, <span class=\"number\">2</span> ) :<span class=\"number\">40149.7</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-随机数\"><a href=\"#C-随机数\" class=\"headerlink\" title=\"C++ 随机数\"></a>C++ 随机数</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>\n<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> i,j;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">   <span class=\"built_in\">srand</span>( (<span class=\"type\">unsigned</span>)<span class=\"built_in\">time</span>( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 生成 10 个随机数 */</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成实际的随机数</span></span><br><span class=\"line\">      j= <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">      cout &lt;&lt;<span class=\"string\">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">随机数： <span class=\"number\">1748144778</span>随机数： <span class=\"number\">630873888</span>随机数： <span class=\"number\">2134540646</span>随机数： <span class=\"number\">219404170</span>随机数： <span class=\"number\">902129458</span>随机数： <span class=\"number\">920445370</span>随机数： <span class=\"number\">1319072661</span>随机数： <span class=\"number\">257938873</span>随机数： <span class=\"number\">1256201101</span>随机数： <span class=\"number\">580322989</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-数组\"><a href=\"#C-数组\" class=\"headerlink\" title=\"C++ 数组\"></a>C++ 数组</h1><p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>\n<p>数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。</p>\n<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>\n<h2 id=\"声明数组\"><a href=\"#声明数组\" class=\"headerlink\" title=\"声明数组\"></a>声明数组</h2><p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure>\n\n<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n\n<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>\n<h2 id=\"初始化数组\"><a href=\"#初始化数组\" class=\"headerlink\" title=\"初始化数组\"></a>初始化数组</h2><p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">17.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>\n<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> balance[] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">17.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">balance[<span class=\"number\">4</span>] = <span class=\"number\">50.0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</p>\n<p><img src=\"https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg\" alt=\"数组表示\"></p>\n<h2 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> salary = balance[<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span>using std::setw;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> n[ <span class=\"number\">10</span> ]; <span class=\"comment\">// n 是一个包含 10 个整数的数组</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 初始化数组元素          </span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      n[ i ] = i + <span class=\"number\">100</span>; <span class=\"comment\">// 设置元素 i 为 i + 100</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Element&quot;</span> &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">13</span> ) &lt;&lt; <span class=\"string\">&quot;Value&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 输出数组中每个元素的值                     </span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">7</span> )&lt;&lt; j &lt;&lt; <span class=\"built_in\">setw</span>( <span class=\"number\">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的程序使用了 <strong>setw()</strong> 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element        Value</span><br><span class=\"line\">      <span class=\"number\">0</span>          <span class=\"number\">100</span></span><br><span class=\"line\">      <span class=\"number\">1</span>          <span class=\"number\">101</span></span><br><span class=\"line\">      <span class=\"number\">2</span>          <span class=\"number\">102</span></span><br><span class=\"line\">      <span class=\"number\">3</span>          <span class=\"number\">103</span></span><br><span class=\"line\">      <span class=\"number\">4</span>          <span class=\"number\">104</span></span><br><span class=\"line\">      <span class=\"number\">5</span>          <span class=\"number\">105</span></span><br><span class=\"line\">      <span class=\"number\">6</span>          <span class=\"number\">106</span></span><br><span class=\"line\">      <span class=\"number\">7</span>          <span class=\"number\">107</span></span><br><span class=\"line\">      <span class=\"number\">8</span>          <span class=\"number\">108</span></span><br><span class=\"line\">      <span class=\"number\">9</span>          <span class=\"number\">109</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中数组详解\"><a href=\"#C-中数组详解\" class=\"headerlink\" title=\"C++ 中数组详解\"></a>C++ 中数组详解</h2><p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">多维数组</td>\n<td align=\"left\">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td>\n</tr>\n<tr>\n<td align=\"left\">指向数组的指针</td>\n<td align=\"left\">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">传递数组给函数</td>\n<td align=\"left\">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">从函数返回数组</td>\n<td align=\"left\">C++ 允许从函数返回数组。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-字符串\"><a href=\"#C-字符串\" class=\"headerlink\" title=\"C++ 字符串\"></a>C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p>\n<ul>\n<li>C 风格字符串</li>\n<li>C++ 引入的 string 类类型</li>\n</ul>\n<h2 id=\"C-风格字符串\"><a href=\"#C-风格字符串\" class=\"headerlink\" title=\"C 风格字符串\"></a>C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>\n<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> greeting[<span class=\"number\">6</span>] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> greeting[] = <span class=\"string\">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>以下是 C&#x2F;C++ 中定义的字符串的内存表示：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg\" alt=\"img\"></p>\n<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。让我们尝试输出上面的字符串：</p>\n<h2 id=\"实例-19\"><a href=\"#实例-19\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> greeting[<span class=\"number\">6</span>] = &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;; </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Greeting message: &quot;</span>;   cout &lt;&lt; greeting &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Greeting message: Hello</span><br></pre></td></tr></table></figure>\n\n<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 目的</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>\n</tr>\n</tbody></table>\n<p>下面的实例使用了上述的一些函数：</p>\n<h2 id=\"实例-20\"><a href=\"#实例-20\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;Hello&quot;</span>;   <span class=\"type\">char</span> str2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;World&quot;</span>;   <span class=\"type\">char</span> str3[<span class=\"number\">11</span>];   <span class=\"type\">int</span>  len ; </span><br><span class=\"line\">   <span class=\"comment\">// 复制 str1 到 str3</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( str3, str1);   cout &lt;&lt; <span class=\"string\">&quot;strcpy( str3, str1) : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接 str1 和 str2</span></span><br><span class=\"line\">   <span class=\"built_in\">strcat</span>( str1, str2);   cout &lt;&lt; <span class=\"string\">&quot;strcat( str1, str2): &quot;</span> &lt;&lt; str1 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接后，str1 的总长度</span></span><br><span class=\"line\">   len = <span class=\"built_in\">strlen</span>(str1);   cout &lt;&lt; <span class=\"string\">&quot;strlen(str1) : &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcpy</span>( str3, str1) : <span class=\"built_in\">Hellostrcat</span>( str1, str2): <span class=\"built_in\">HelloWorldstrlen</span>(str1) : <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的-String-类\"><a href=\"#C-中的-String-类\" class=\"headerlink\" title=\"C++ 中的 String 类\"></a>C++ 中的 String 类</h2><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>\n<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>\n<h2 id=\"实例-21\"><a href=\"#实例-21\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   string str1 = <span class=\"string\">&quot;Hello&quot;</span>;   string str2 = <span class=\"string\">&quot;World&quot;</span>;   string str3;   <span class=\"type\">int</span>  len ; </span><br><span class=\"line\">   <span class=\"comment\">// 复制 str1 到 str3</span></span><br><span class=\"line\">   str3 = str1;   cout &lt;&lt; <span class=\"string\">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接 str1 和 str2</span></span><br><span class=\"line\">   str3 = str1 + str2;   cout &lt;&lt; <span class=\"string\">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"comment\">// 连接后，str3 的总长度</span></span><br><span class=\"line\">   len = str3.<span class=\"built_in\">size</span>();   cout &lt;&lt; <span class=\"string\">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str3 : Hellostr1 + str2 : HelloWorldstr3.<span class=\"built_in\">size</span>() :  <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-指针\"><a href=\"#C-指针\" class=\"headerlink\" title=\"C++ 指针\"></a>C++ 指针</h1><p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>\n<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  var1;</span><br><span class=\"line\">   <span class=\"type\">char</span> var2[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;var1 变量的地址： &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;var2 变量的地址： &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var1 变量的地址： <span class=\"number\">0xbfebd5c0</span>var2 变量的地址： <span class=\"number\">0xbfebd5b6</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。</p>\n<h2 id=\"什么是指针？\"><a href=\"#什么是指针？\" class=\"headerlink\" title=\"什么是指针？\"></a>什么是指针？</h2><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type *var-name;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>    *ip;    <span class=\"comment\">/* 一个整型的指针 */</span><span class=\"type\">double</span> *dp;    <span class=\"comment\">/* 一个 double 型的指针 */</span><span class=\"type\">float</span>  *fp;    <span class=\"comment\">/* 一个浮点型的指针 */</span><span class=\"type\">char</span>   *ch;    <span class=\"comment\">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>\n\n<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>\n<h2 id=\"C-中使用指针\"><a href=\"#C-中使用指针\" class=\"headerlink\" title=\"C++ 中使用指针\"></a>C++ 中使用指针</h2><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  var = <span class=\"number\">20</span>;   <span class=\"comment\">// 实际变量的声明</span></span><br><span class=\"line\">   <span class=\"type\">int</span>  *ip;        <span class=\"comment\">// 指针变量的声明</span></span><br><span class=\"line\"></span><br><span class=\"line\">   ip = &amp;var;       <span class=\"comment\">// 在指针变量中存储 var 的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of var variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; var &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出在指针变量中存储的地址</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Address stored in ip variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 访问指针中地址的值</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of *ip variable: &quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; *ip &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of var variable: <span class=\"number\">20</span>Address stored in ip variable: <span class=\"number\">0xbfc601ac</span>Value of *ip variable: <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-指针详解\"><a href=\"#C-指针详解\" class=\"headerlink\" title=\"C++ 指针详解\"></a>C++ 指针详解</h2><p>在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C++ Null 指针</td>\n<td align=\"left\">C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指针的算术运算</td>\n<td align=\"left\">可以对指针进行四种算术运算：++、–、+、-</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指针 vs 数组</td>\n<td align=\"left\">指针和数组之间有着密切的关系。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指针数组</td>\n<td align=\"left\">可以定义用来存储指针的数组。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 指向指针的指针</td>\n<td align=\"left\">C++ 允许指向指针的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 传递指针给函数</td>\n<td align=\"left\">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 从函数返回指针</td>\n<td align=\"left\">C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-引用\"><a href=\"#C-引用\" class=\"headerlink\" title=\"C++ 引用\"></a>C++ 引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\n<h2 id=\"C-引用-vs-指针\"><a href=\"#C-引用-vs-指针\" class=\"headerlink\" title=\"C++ 引用 vs 指针\"></a>C++ 引用 vs 指针</h2><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n<ul>\n<li>不存在空引用。引用必须连接到一块合法的内存。</li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>\n</ul>\n<h2 id=\"C-中创建引用\"><a href=\"#C-中创建引用\" class=\"headerlink\" title=\"C++ 中创建引用\"></a>C++ 中创建引用</h2><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">17</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以为 i 声明引用变量，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;    r = i;</span><br></pre></td></tr></table></figure>\n\n<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 声明简单的变量</span></span><br><span class=\"line\">   <span class=\"type\">int</span>    i;</span><br><span class=\"line\">   <span class=\"type\">double</span> d;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 声明引用变量</span></span><br><span class=\"line\">   <span class=\"type\">int</span>&amp;    r = i;</span><br><span class=\"line\">   <span class=\"type\">double</span>&amp; s = d;</span><br><span class=\"line\">   </span><br><span class=\"line\">   i = <span class=\"number\">5</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   d = <span class=\"number\">11.7</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of i : <span class=\"number\">5</span>Value of i reference : <span class=\"number\">5</span>Value of d : <span class=\"number\">11.7</span>Value of d reference : <span class=\"number\">11.7</span></span><br></pre></td></tr></table></figure>\n\n<p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">把引用作为参数</td>\n<td align=\"left\">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td>\n</tr>\n<tr>\n<td align=\"left\">把引用作为返回值</td>\n<td align=\"left\">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-日期-时间\"><a href=\"#C-日期-时间\" class=\"headerlink\" title=\"C++ 日期 &amp; 时间\"></a>C++ 日期 &amp; 时间</h1><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</p>\n<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>\n<p>结构类型 <strong>tm</strong> 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> tm_sec;   <span class=\"comment\">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_min;   <span class=\"comment\">// 分，范围从 0 到 59</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_hour;  <span class=\"comment\">// 小时，范围从 0 到 23</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_mday;  <span class=\"comment\">// 一月中的第几天，范围从 1 到 31</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_mon;   <span class=\"comment\">// 月，范围从 0 到 11</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_year;  <span class=\"comment\">// 自 1900 年起的年数</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_wday;  <span class=\"comment\">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_yday;  <span class=\"comment\">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class=\"line\">  <span class=\"type\">int</span> tm_isdst; <span class=\"comment\">// 夏令时&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是 C&#x2F;C++ 中关于日期和时间的重要函数。所有这些函数都是 C&#x2F;C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>time_t time(time_t *time);</strong> 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>char *ctime(const time_t *time);</strong> 该返回一个表示当地时间的字符串指针，字符串形式 <em>day month year hours:minutes:seconds year\\n\\0</em>。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>struct tm *localtime(const time_t *time);</strong> 该函数返回一个指向表示本地时间的 <strong>tm</strong> 结构的指针。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>clock_t clock(void);</strong> 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>char * asctime ( const struct tm * time );</strong> 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>struct tm *gmtime(const time_t *time);</strong> 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><strong>time_t mktime(struct tm *time);</strong> 该函数返回日历时间，相当于 time 所指向结构中存储的时间。</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><strong>double difftime ( time_t time2, time_t time1 );</strong> 该函数返回 time1 和 time2 之间相差的秒数。</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><strong>size_t strftime();</strong> 该函数可用于格式化日期和时间为指定的格式。</td>\n</tr>\n</tbody></table>\n<h2 id=\"当前日期和时间\"><a href=\"#当前日期和时间\" class=\"headerlink\" title=\"当前日期和时间\"></a>当前日期和时间</h2><p>下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 基于当前系统的当前日期/时间</span></span><br><span class=\"line\">   <span class=\"type\">time_t</span> now = <span class=\"built_in\">time</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 把 now 转换为字符串形式</span></span><br><span class=\"line\">   <span class=\"type\">char</span>* dt = <span class=\"built_in\">ctime</span>(&amp;now);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把 now 转换为 tm 结构</span></span><br><span class=\"line\">   tm *gmtm = <span class=\"built_in\">gmtime</span>(&amp;now);</span><br><span class=\"line\">   dt = <span class=\"built_in\">asctime</span>(gmtm);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">本地日期和时间：Sat Jan  <span class=\"number\">8</span> <span class=\"number\">20</span>:<span class=\"number\">07</span>:<span class=\"number\">41</span> <span class=\"number\">2011U</span>TC 日期和时间：Sun Jan  <span class=\"number\">9</span> <span class=\"number\">03</span>:<span class=\"number\">07</span>:<span class=\"number\">41</span> <span class=\"number\">2011</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用结构-tm-格式化时间\"><a href=\"#使用结构-tm-格式化时间\" class=\"headerlink\" title=\"使用结构 tm 格式化时间\"></a>使用结构 tm 格式化时间</h2><p><strong>tm</strong> 结构在 C&#x2F;C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>\n<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// 基于当前系统的当前日期/时间</span></span><br><span class=\"line\">   <span class=\"type\">time_t</span> now = <span class=\"built_in\">time</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Number of sec since January 1,1970:&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   tm *ltm = <span class=\"built_in\">localtime</span>(&amp;now);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出 tm 结构的各个组成部分</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Year: &quot;</span>&lt;&lt; <span class=\"number\">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Month: &quot;</span>&lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Day: &quot;</span>&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Time: &quot;</span>&lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_hour &lt;&lt; <span class=\"string\">&quot;:&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_min &lt;&lt; <span class=\"string\">&quot;:&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"number\">1</span> + ltm-&gt;tm_sec &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number of sec since January <span class=\"number\">1</span>, <span class=\"number\">1970</span>:<span class=\"number\">1294548238</span>Year: <span class=\"number\">2011</span>Month: <span class=\"number\">1</span>Day: <span class=\"number\">8</span>Time: <span class=\"number\">22</span>: <span class=\"number\">44</span>:<span class=\"number\">59</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-基本的输入输出\"><a href=\"#C-基本的输入输出\" class=\"headerlink\" title=\"C++ 基本的输入输出\"></a>C++ 基本的输入输出</h1><p>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</p>\n<p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>\n<h2 id=\"I-O-库头文件\"><a href=\"#I-O-库头文件\" class=\"headerlink\" title=\"I&#x2F;O 库头文件\"></a>I&#x2F;O 库头文件</h2><p>下列的头文件在 C++ 编程中很重要。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">头文件</th>\n<th align=\"left\">函数和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><iostream></td>\n<td align=\"left\">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\"><iomanip></td>\n<td align=\"left\">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td>\n</tr>\n<tr>\n<td align=\"left\"><fstream></td>\n<td align=\"left\">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>\n</tr>\n</tbody></table>\n<h2 id=\"标准输出流（cout）\"><a href=\"#标准输出流（cout）\" class=\"headerlink\" title=\"标准输出流（cout）\"></a>标准输出流（cout）</h2><p>预定义的对象 <strong>cout</strong> 是 <strong>ostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std; int main( )&#123;   char str[] = <span class=\"string\">&quot;Hello C++&quot;</span>;    cout &lt;&lt; <span class=\"string\">&quot;Value of str is : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of str is : Hello C++</span><br></pre></td></tr></table></figure>\n\n<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>\n<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>\n<h2 id=\"标准输入流（cin）\"><a href=\"#标准输入流（cin）\" class=\"headerlink\" title=\"标准输入流（cin）\"></a>标准输入流（cin）</h2><p>预定义的对象 <strong>cin</strong> 是 <strong>istream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std; int main( )&#123;  </span></span><br><span class=\"line\">\t<span class=\"type\">char</span> name[<span class=\"number\">50</span>];    cout &lt;&lt; <span class=\"string\">&quot;请输入您的名称： &quot;</span>;   </span><br><span class=\"line\">\tcin &gt;&gt; name;   cout &lt;&lt; <span class=\"string\">&quot;您的名称是： &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入您的名称： cplusplus您的名称是： cplusplus</span><br></pre></td></tr></table></figure>\n\n<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>\n<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure>\n\n<p>这相当于下面两个语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cin &gt;&gt; name;cin &gt;&gt; age;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标准错误流（cerr）\"><a href=\"#标准错误流（cerr）\" class=\"headerlink\" title=\"标准错误流（cerr）\"></a>标准错误流（cerr）</h2><p>预定义的对象 <strong>cerr</strong> 是 <strong>ostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>\n<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   cerr &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error message : Unable to read....</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标准日志流（clog）\"><a href=\"#标准日志流（clog）\" class=\"headerlink\" title=\"标准日志流（clog）\"></a>标准日志流（clog）</h2><p>预定义的对象 <strong>clog</strong> 是 <strong>ostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>\n<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> str[] = <span class=\"string\">&quot;Unable to read....&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   clog &lt;&lt; <span class=\"string\">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error message : Unable to read....</span><br></pre></td></tr></table></figure>\n\n<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>\n<h1 id=\"C-数据结构\"><a href=\"#C-数据结构\" class=\"headerlink\" title=\"C++ 数据结构\"></a>C++ 数据结构</h1><p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>\n<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>\n<ul>\n<li>Title ：标题</li>\n<li>Author ：作者</li>\n<li>Subject ：类目</li>\n<li>Book ID ：书的 ID</li>\n</ul>\n<h2 id=\"定义结构\"><a href=\"#定义结构\" class=\"headerlink\" title=\"定义结构\"></a>定义结构</h2><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">type_name</span> &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names;</span><br></pre></td></tr></table></figure>\n\n<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 <strong>Books</strong>，变量为 <strong>book</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span>&#123;   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];      <span class=\"type\">int</span>   book_id;&#125; book;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问结构成员\"><a href=\"#访问结构成员\" class=\"headerlink\" title=\"访问结构成员\"></a>访问结构成员</h2><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>\n<p>下面的实例演示了结构的用法：</p>\n<h2 id=\"实例-22\"><a href=\"#实例-22\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"><span class=\"comment\">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book1 信息</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;第一本书标题 : &quot;</span> &lt;&lt; Book1.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书作者 : &quot;</span> &lt;&lt; Book1.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书类目 : &quot;</span> &lt;&lt; Book1.subject &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第一本书 ID : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt;endl; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book2 信息</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;第二本书标题 : &quot;</span> &lt;&lt; Book2.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书作者 : &quot;</span> &lt;&lt; Book2.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书类目 : &quot;</span> &lt;&lt; Book2.subject &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;第二本书 ID : &quot;</span> &lt;&lt; Book2.book_id &lt;&lt;endl; </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : <span class=\"number\">12345</span>第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构作为函数参数\"><a href=\"#结构作为函数参数\" class=\"headerlink\" title=\"结构作为函数参数\"></a>结构作为函数参数</h2><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>\n<h2 id=\"实例-23\"><a href=\"#实例-23\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books book )</span></span>; </span><br><span class=\"line\"><span class=\"comment\">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book1 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( Book1 ); </span><br><span class=\"line\">   <span class=\"comment\">// 输出 Book2 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( Book2 ); </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books book )</span></span>&#123;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书作者 : &quot;</span> </span><br><span class=\"line\">   &lt;&lt; book.author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class=\"number\">12345</span>书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指向结构的指针\"><a href=\"#指向结构的指针\" class=\"headerlink\" title=\"指向结构的指针\"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span> *struct_pointer;</span><br></pre></td></tr></table></figure>\n\n<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>\n\n<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>\n\n<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>\n<h2 id=\"实例-24\"><a href=\"#实例-24\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( <span class=\"keyword\">struct</span> Books *book )</span></span>; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Books</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];   <span class=\"type\">int</span>   book_id;&#125;; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Books Book1;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class=\"line\">   Books Book2;        <span class=\"comment\">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Book1 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.title, <span class=\"string\">&quot;C++ 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book1.author, <span class=\"string\">&quot;Runoob&quot;</span>); </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book1.subject, <span class=\"string\">&quot;编程语言&quot;</span>);   Book1.book_id = <span class=\"number\">12345</span>; </span><br><span class=\"line\">   <span class=\"comment\">// Book2 详述</span></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.title, <span class=\"string\">&quot;CSS 教程&quot;</span>);   <span class=\"built_in\">strcpy</span>( Book2.author, <span class=\"string\">&quot;Runoob&quot;</span>);   </span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( Book2.subject, <span class=\"string\">&quot;前端技术&quot;</span>);   Book2.book_id = <span class=\"number\">12346</span>; </span><br><span class=\"line\">   <span class=\"comment\">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( &amp;Book1 ); </span><br><span class=\"line\">   <span class=\"comment\">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class=\"line\">   <span class=\"built_in\">printBook</span>( &amp;Book2 ); </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;<span class=\"comment\">// 该函数以结构指针作为参数void printBook( struct Books *book )&#123;</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书标题  : &quot;</span> &lt;&lt; book-&gt;title &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书作者 : &quot;</span> </span><br><span class=\"line\">   &lt;&lt; book-&gt;author &lt;&lt;endl;   cout &lt;&lt; <span class=\"string\">&quot;书类目 : &quot;</span> &lt;&lt; book-&gt;subject &lt;&lt;endl;   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;书 ID : &quot;</span> &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class=\"number\">12345</span>书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class=\"number\">12346</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typedef-关键字\"><a href=\"#typedef-关键字\" class=\"headerlink\" title=\"typedef 关键字\"></a>typedef 关键字</h2><p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span>  title[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  author[<span class=\"number\">50</span>];</span><br><span class=\"line\">   <span class=\"type\">char</span>  subject[<span class=\"number\">100</span>];</span><br><span class=\"line\">   <span class=\"type\">int</span>   book_id;&#125;Books;</span><br></pre></td></tr></table></figure>\n\n<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Books Book1, Book2;</span><br></pre></td></tr></table></figure>\n\n<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">int</span> *pint32;</span><br><span class=\"line\"> pint32 x, y, z;</span><br></pre></td></tr></table></figure>\n\n<p>x, y 和 z 都是指向长整型 long int 的指针。</p>\n<h1 id=\"C-类-对象\"><a href=\"#C-类-对象\" class=\"headerlink\" title=\"C++ 类 &amp; 对象\"></a>C++ 类 &amp; 对象</h1><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>\n<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。</p>\n<h2 id=\"C-类定义\"><a href=\"#C-类定义\" class=\"headerlink\" title=\"C++ 类定义\"></a>C++ 类定义</h2><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>\n<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;   <span class=\"keyword\">public</span>:      <span class=\"type\">double</span> length;   <span class=\"comment\">// Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>，这个我们稍后会进行讲解。</p>\n<h2 id=\"定义-C-对象\"><a href=\"#定义-C-对象\" class=\"headerlink\" title=\"定义 C++ 对象\"></a>定义 C++ 对象</h2><p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box Box1;          <span class=\"comment\">// 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>\n\n<p>对象 Box1 和 Box2 都有它们各自的数据成员。</p>\n<h2 id=\"访问数据成员\"><a href=\"#访问数据成员\" class=\"headerlink\" title=\"访问数据成员\"></a>访问数据成员</h2><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;   <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;   <span class=\"comment\">// 高度&#125;;int main( )&#123;</span></span><br><span class=\"line\">   Box Box1;        <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;        <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 用于存储体积</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// box 1 详述</span></span><br><span class=\"line\">   Box1.height = <span class=\"number\">5.0</span>; </span><br><span class=\"line\">   Box1.length = <span class=\"number\">6.0</span>; </span><br><span class=\"line\">   Box1.breadth = <span class=\"number\">7.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 2 详述</span></span><br><span class=\"line\">   Box2.height = <span class=\"number\">10.0</span>;</span><br><span class=\"line\">   Box2.length = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">   Box2.breadth = <span class=\"number\">13.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 1 的体积</span></span><br><span class=\"line\">   volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// box 2 的体积</span></span><br><span class=\"line\">   volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box1 的体积：<span class=\"number\">210B</span>ox2 的体积：<span class=\"number\">1560</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>\n<h1 id=\"类-对象详解\"><a href=\"#类-对象详解\" class=\"headerlink\" title=\"类 &amp; 对象详解\"></a>类 &amp; 对象详解</h1><p>到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">概念</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">类成员函数</td>\n<td align=\"left\">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td>\n</tr>\n<tr>\n<td align=\"left\">类访问修饰符</td>\n<td align=\"left\">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td>\n</tr>\n<tr>\n<td align=\"left\">构造函数 &amp; 析构函数</td>\n<td align=\"left\">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 拷贝构造函数</td>\n<td align=\"left\">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 友元函数</td>\n<td align=\"left\"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 内联函数</td>\n<td align=\"left\">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 中的 this 指针</td>\n<td align=\"left\">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 中指向类的指针</td>\n<td align=\"left\">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td>\n</tr>\n<tr>\n<td align=\"left\">C++ 类的静态成员</td>\n<td align=\"left\">类的数据成员和函数成员都可以被声明为静态的。</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-继承\"><a href=\"#C-继承\" class=\"headerlink\" title=\"C++ 继承\"></a>C++ 继承</h1><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>\n<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>\n<h2 id=\"基类-派生类\"><a href=\"#基类-派生类\" class=\"headerlink\" title=\"基类 &amp; 派生类\"></a>基类 &amp; 派生类</h2><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">derived</span>-<span class=\"keyword\">class</span>: access-specifier base-<span class=\"keyword\">class</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>\n<p>假设有一个基类 <strong>Shape</strong>，<strong>Rectangle</strong> 是它的派生类，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"comment\">// 基类class Shape &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width;</span><br><span class=\"line\">      <span class=\"type\">int</span> height;&#125;;<span class=\"comment\">// 派生类class Rectangle: public Shape&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: 35</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问控制和继承\"><a href=\"#访问控制和继承\" class=\"headerlink\" title=\"访问控制和继承\"></a>访问控制和继承</h2><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>\n<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">访问</th>\n<th align=\"left\">public</th>\n<th align=\"left\">protected</th>\n<th align=\"left\">private</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">同一个类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">派生类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\">外部的类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">no</td>\n<td align=\"left\">no</td>\n</tr>\n</tbody></table>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<h2 id=\"继承类型\"><a href=\"#继承类型\" class=\"headerlink\" title=\"继承类型\"></a>继承类型</h2><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>\n<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>\n<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>\n</ul>\n<h2 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>\n<p>C++ 类可以从多个类继承成员，语法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> &lt;派生类名&gt;:&lt;继承方式<span class=\"number\">1</span>&gt;&lt;基类名<span class=\"number\">1</span>&gt;,&lt;继承方式<span class=\"number\">2</span>&gt;&lt;基类名<span class=\"number\">2</span>&gt;,…&#123;&lt;派生类类体&gt;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;<span class=\"comment\">// 基类 Shapeclass Shape &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width;</span><br><span class=\"line\">      <span class=\"type\">int</span> height;&#125;;<span class=\"comment\">// 基类 PaintCostclass PaintCost &#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"type\">int</span> area)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> area * <span class=\"number\">70</span>;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"comment\">// 派生类class Rectangle: public Shape, public PaintCost&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   <span class=\"type\">int</span> area;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   area = Rect.<span class=\"built_in\">getArea</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出总花费</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getCost</span>(area) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: <span class=\"number\">35</span>Total paint cost: $<span class=\"number\">2450</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-重载运算符和重载函数\"><a href=\"#C-重载运算符和重载函数\" class=\"headerlink\" title=\"C++ 重载运算符和重载函数\"></a>C++ 重载运算符和重载函数</h1><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>\n<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>\n<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>\n<h2 id=\"C-中的函数重载\"><a href=\"#C-中的函数重载\" class=\"headerlink\" title=\"C++ 中的函数重载\"></a>C++ 中的函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>\n<p>下面的实例中，同名函数 <strong>print()</strong> 被用于输出不同的数据类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">printData</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span>  f)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">char</span>* c)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Printing character: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   printData pd;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Call print to print integer</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">// Call print to print float</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"number\">500.263</span>);</span><br><span class=\"line\">   <span class=\"comment\">// Call print to print character</span></span><br><span class=\"line\">   pd.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello C++&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Printing <span class=\"type\">int</span>: <span class=\"number\">5</span>Printing <span class=\"type\">float</span>: <span class=\"number\">500.263</span>Printing character: Hello C++</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的运算符重载\"><a href=\"#C-中的运算符重载\" class=\"headerlink\" title=\"C++ 中的运算符重载\"></a>C++ 中的运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>\n<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>\n\n<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp;, <span class=\"type\">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>\n\n<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 <strong>this</strong> 运算符进行访问，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"type\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          length = len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setBreadth</span><span class=\"params\">( <span class=\"type\">double</span> bre )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          breadth = bre;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">( <span class=\"type\">double</span> hei )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          height = hei;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class=\"line\">      Box <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Box&amp; b)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         Box box;</span><br><span class=\"line\">         box.length = <span class=\"keyword\">this</span>-&gt;length + b.length;</span><br><span class=\"line\">         box.breadth = <span class=\"keyword\">this</span>-&gt;breadth + b.breadth;</span><br><span class=\"line\">         box.height = <span class=\"keyword\">this</span>-&gt;height + b.height;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度&#125;;// 程序的主函数int main( )&#123;</span></span><br><span class=\"line\">   Box Box1;                <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;                <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   Box Box3;                <span class=\"comment\">// 声明 Box3，类型为 Box</span></span><br><span class=\"line\">   <span class=\"type\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 把体积存储在该变量中</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box1 详述</span></span><br><span class=\"line\">   Box1.<span class=\"built_in\">setLength</span>(<span class=\"number\">6.0</span>); </span><br><span class=\"line\">   Box1.<span class=\"built_in\">setBreadth</span>(<span class=\"number\">7.0</span>); </span><br><span class=\"line\">   Box1.<span class=\"built_in\">setHeight</span>(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box2 详述</span></span><br><span class=\"line\">   Box2.<span class=\"built_in\">setLength</span>(<span class=\"number\">12.0</span>); </span><br><span class=\"line\">   Box2.<span class=\"built_in\">setBreadth</span>(<span class=\"number\">13.0</span>); </span><br><span class=\"line\">   Box2.<span class=\"built_in\">setHeight</span>(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box1 的体积</span></span><br><span class=\"line\">   volume = Box1.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// Box2 的体积</span></span><br><span class=\"line\">   volume = Box2.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把两个对象相加，得到 Box3</span></span><br><span class=\"line\">   Box3 = Box1 + Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box3 的体积</span></span><br><span class=\"line\">   volume = Box3.<span class=\"built_in\">getVolume</span>();</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Volume of Box1 : <span class=\"number\">210</span>Volume of Box2 : <span class=\"number\">1560</span>Volume of Box3 : <span class=\"number\">5400</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可重载运算符-不可重载运算符\"><a href=\"#可重载运算符-不可重载运算符\" class=\"headerlink\" title=\"可重载运算符&#x2F;不可重载运算符\"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p>\n<table>\n<thead>\n<tr>\n<th>+</th>\n<th>-</th>\n<th>*</th>\n<th>&#x2F;</th>\n<th>%</th>\n<th>^</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>|</td>\n<td>~</td>\n<td>!</td>\n<td>,</td>\n<td>&#x3D;</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>&gt;</td>\n<td>&lt;&#x3D;</td>\n<td>&gt;&#x3D;</td>\n<td>++</td>\n<td>–</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>&gt;&gt;</td>\n<td>&#x3D;&#x3D;</td>\n<td>!&#x3D;</td>\n<td>&amp;&amp;</td>\n<td>||</td>\n</tr>\n<tr>\n<td>+&#x3D;</td>\n<td>-&#x3D;</td>\n<td>&#x2F;&#x3D;</td>\n<td>%&#x3D;</td>\n<td>^&#x3D;</td>\n<td>&amp;&#x3D;</td>\n</tr>\n<tr>\n<td>|&#x3D;</td>\n<td>*&#x3D;</td>\n<td>&lt;&lt;&#x3D;</td>\n<td>&gt;&gt;&#x3D;</td>\n<td>[]</td>\n<td>()</td>\n</tr>\n<tr>\n<td>-&gt;</td>\n<td>-&gt;*</td>\n<td>new</td>\n<td>new []</td>\n<td>delete</td>\n<td>delete []</td>\n</tr>\n</tbody></table>\n<p>下面是不可重载的运算符列表：</p>\n<table>\n<thead>\n<tr>\n<th>::</th>\n<th>.*</th>\n<th>.</th>\n<th>?:</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"运算符重载实例\"><a href=\"#运算符重载实例\" class=\"headerlink\" title=\"运算符重载实例\"></a>运算符重载实例</h2><p>下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">运算符和实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">一元运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">二元运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">关系运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">输入&#x2F;输出运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">++ 和 – 运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">赋值运算符重载</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">函数调用运算符 () 重载</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">下标运算符 [] 重载</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">类成员访问运算符 -&gt; 重载</td>\n</tr>\n</tbody></table>\n<h1 id=\"C-多态\"><a href=\"#C-多态\" class=\"headerlink\" title=\"C++ 多态\"></a>C++ 多态</h1><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>\n<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>\n<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> using namespace std;</span></span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span>: <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Rectangle</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>):<span class=\"built_in\">Shape</span>(a, b) &#123; &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span>: <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Triangle</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>):<span class=\"built_in\">Shape</span>(a, b) &#123; &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">area</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height / <span class=\"number\">2</span>); </span><br><span class=\"line\">      &#125;&#125;;<span class=\"comment\">// 程序的主函数int main( )&#123;</span></span><br><span class=\"line\">   Shape *shape;</span><br><span class=\"line\">   <span class=\"function\">Rectangle <span class=\"title\">rec</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\">   <span class=\"function\">Triangle  <span class=\"title\">tri</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 存储矩形的地址</span></span><br><span class=\"line\">   shape = &amp;rec;</span><br><span class=\"line\">   <span class=\"comment\">// 调用矩形的求面积函数 area</span></span><br><span class=\"line\">   shape-&gt;<span class=\"built_in\">area</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 存储三角形的地址</span></span><br><span class=\"line\">   shape = &amp;tri;</span><br><span class=\"line\">   <span class=\"comment\">// 调用三角形的求面积函数 area</span></span><br><span class=\"line\">   shape-&gt;<span class=\"built_in\">area</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Parent <span class=\"keyword\">class</span> <span class=\"title class_\">areaParent</span> <span class=\"keyword\">class</span> <span class=\"title class_\">area</span></span><br></pre></td></tr></table></figure>\n\n<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>\n<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rectangle <span class=\"keyword\">class</span> <span class=\"title class_\">areaTriangle</span> <span class=\"keyword\">class</span> <span class=\"title class_\">area</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>\n<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>\n<h2 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h2><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>\n<p>我们可以把基类中的虚函数 area() 改写如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"type\">int</span> width, height;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Shape</span>( <span class=\"type\">int</span> a=<span class=\"number\">0</span>, <span class=\"type\">int</span> b=<span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         width = a;</span><br><span class=\"line\">         height = b;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// pure virtual function</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D; 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p>\n<h1 id=\"C-数据抽象\"><a href=\"#C-数据抽象\" class=\"headerlink\" title=\"C++ 数据抽象\"></a>C++ 数据抽象</h1><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>\n<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>\n<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>\n<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>\n<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为<strong>数据抽象</strong>提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>\n<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>\n<p>在 C++ 中，我们使用<strong>类</strong>来定义我们自己的抽象数据类型（ADT）。您可以使用类 <strong>ostream</strong> 的 <strong>cout</strong> 对象来输出数据到标准输出，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main( )&#123;   cout &lt;&lt; <span class=\"string\">&quot;Hello C++&quot;</span> &lt;&lt;endl;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，您不需要理解 <strong>cout</strong> 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。</p>\n<h2 id=\"访问标签强制抽象\"><a href=\"#访问标签强制抽象\" class=\"headerlink\" title=\"访问标签强制抽象\"></a>访问标签强制抽象</h2><p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p>\n<ul>\n<li>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。</li>\n<li>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。</li>\n</ul>\n<p>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p>\n<h2 id=\"数据抽象的好处\"><a href=\"#数据抽象的好处\" class=\"headerlink\" title=\"数据抽象的好处\"></a>数据抽象的好处</h2><p>数据抽象有两个重要的优势：</p>\n<ul>\n<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>\n<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>\n</ul>\n<p>如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。</p>\n<h2 id=\"数据抽象的实例\"><a href=\"#数据抽象的实例\" class=\"headerlink\" title=\"数据抽象的实例\"></a>数据抽象的实例</h2><p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      <span class=\"built_in\">Adder</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        total = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> number)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          total += number;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getTotal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 对外隐藏的数据</span></span><br><span class=\"line\">      <span class=\"type\">int</span> total;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Adder a;</span><br><span class=\"line\">   </span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total &quot;</span> &lt;&lt; a.<span class=\"built_in\">getTotal</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是用户不需要了解的，但又是类能正常工作所必需的。</p>\n<h2 id=\"设计策略\"><a href=\"#设计策略\" class=\"headerlink\" title=\"设计策略\"></a>设计策略</h2><p>抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。</p>\n<p>在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。</p>\n<h1 id=\"C-数据封装\"><a href=\"#C-数据封装\" class=\"headerlink\" title=\"C++ 数据封装\"></a>C++ 数据封装</h1><p>所有的 C++ 程序都有以下两个基本要素：</p>\n<ul>\n<li><strong>程序语句（代码）：</strong>这是程序中执行动作的部分，它们被称为函数。</li>\n<li><strong>程序数据：</strong>数据是程序的信息，会受到程序函数的影响。</li>\n</ul>\n<p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即<strong>数据隐藏</strong>。</p>\n<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>\n<p>C++ 通过创建<strong>类</strong>来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度</span></span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。</p>\n<p>为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 <strong>public</strong> 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。</p>\n<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。</p>\n<h2 id=\"数据封装的实例\"><a href=\"#数据封装的实例\" class=\"headerlink\" title=\"数据封装的实例\"></a>数据封装的实例</h2><p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      <span class=\"built_in\">Adder</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        total = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> number)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          total += number;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 对外的接口</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getTotal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 对外隐藏的数据</span></span><br><span class=\"line\">      <span class=\"type\">int</span> total;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Adder a;</span><br><span class=\"line\">   </span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">   a.<span class=\"built_in\">addNum</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total &quot;</span> &lt;&lt; a.<span class=\"built_in\">getTotal</span>() &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total <span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。</p>\n<h2 id=\"设计策略-1\"><a href=\"#设计策略-1\" class=\"headerlink\" title=\"设计策略\"></a>设计策略</h2><p>通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的<strong>封装性</strong>。</p>\n<p>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。</p>\n<h1 id=\"C-接口（抽象类）\"><a href=\"#C-接口（抽象类）\" class=\"headerlink\" title=\"C++ 接口（抽象类）\"></a>C++ 接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>\n<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>\n<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 纯虚函数</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"type\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"type\">double</span> height;      <span class=\"comment\">// 高度&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>\n<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>\n<p>可用于实例化对象的类被称为<strong>具体类</strong>。</p>\n<h2 id=\"抽象类的实例\"><a href=\"#抽象类的实例\" class=\"headerlink\" title=\"抽象类的实例\"></a>抽象类的实例</h2><p>请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> <span class=\"comment\">// 基类class Shape &#123;public:</span></span><br><span class=\"line\">   <span class=\"comment\">// 提供接口框架的纯虚函数</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">      width = w;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">      height = h;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">protected</span>:</span><br><span class=\"line\">   <span class=\"type\">int</span> width;</span><br><span class=\"line\">   <span class=\"type\">int</span> height;&#125;;</span><br><span class=\"line\"> <span class=\"comment\">// 派生类class Rectangle: public Shape&#123;public:</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (width * height); </span><br><span class=\"line\">   &#125;&#125;;<span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span>: <span class=\"keyword\">public</span> Shape&#123;<span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> (width * height)/<span class=\"number\">2</span>; </span><br><span class=\"line\">   &#125;&#125;;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   Triangle  Tri;</span><br><span class=\"line\"> </span><br><span class=\"line\">   Rect.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class=\"built_in\">getArea</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   Tri.<span class=\"built_in\">setWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Tri.<span class=\"built_in\">setHeight</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class=\"built_in\">getArea</span>() &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total Rectangle area: <span class=\"number\">35</span>Total Triangle area: <span class=\"number\">17</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。</p>\n<h2 id=\"设计策略-2\"><a href=\"#设计策略-2\" class=\"headerlink\" title=\"设计策略\"></a>设计策略</h2><p>面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。</p>\n<p>外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。</p>\n<p>这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。</p>\n<h1 id=\"C-文件和流\"><a href=\"#C-文件和流\" class=\"headerlink\" title=\"C++ 文件和流\"></a>C++ 文件和流</h1><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>\n<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ofstream</td>\n<td align=\"left\">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>\n</tr>\n<tr>\n<td align=\"left\">ifstream</td>\n<td align=\"left\">该数据类型表示输入文件流，用于从文件读取信息。</td>\n</tr>\n<tr>\n<td align=\"left\">fstream</td>\n<td align=\"left\">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>\n</tr>\n</tbody></table>\n<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>\n<h2 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>\n<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式标志</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ios::app</td>\n<td align=\"left\">追加模式。所有写入都追加到文件末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::ate</td>\n<td align=\"left\">文件打开后定位到文件末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::in</td>\n<td align=\"left\">打开文件用于读取。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::out</td>\n<td align=\"left\">打开文件用于写入。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::trunc</td>\n<td align=\"left\">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>\n</tr>\n</tbody></table>\n<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream outfile;outfile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>\n\n<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fstream  afile;afile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关闭文件\"><a href=\"#关闭文件\" class=\"headerlink\" title=\"关闭文件\"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>\n<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>\n<h2 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h2><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>\n<h2 id=\"读取-写入实例\"><a href=\"#读取-写入实例\" class=\"headerlink\" title=\"读取 &amp; 写入实例\"></a>读取 &amp; 写入实例</h2><p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"type\">char</span> data[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 以写模式打开文件</span></span><br><span class=\"line\">   ofstream outfile;</span><br><span class=\"line\">   outfile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;afile.dat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Enter your name: &quot;</span>; </span><br><span class=\"line\">   cin.<span class=\"built_in\">getline</span>(data, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 向文件写入用户输入的数据</span></span><br><span class=\"line\">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Enter your age: &quot;</span>; </span><br><span class=\"line\">   cin &gt;&gt; data;</span><br><span class=\"line\">   cin.<span class=\"built_in\">ignore</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 再次向文件写入用户输入的数据</span></span><br><span class=\"line\">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 关闭打开的文件</span></span><br><span class=\"line\">   outfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 以读模式打开文件</span></span><br><span class=\"line\">   ifstream infile; </span><br><span class=\"line\">   infile.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;afile.dat&quot;</span>); </span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class=\"line\">   infile &gt;&gt; data; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在屏幕上写入数据</span></span><br><span class=\"line\">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 再次从文件读取数据，并显示它</span></span><br><span class=\"line\">   infile &gt;&gt; data; </span><br><span class=\"line\">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 关闭打开的文件</span></span><br><span class=\"line\">   infile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$./a.outWriting to the fileEnter your name: ZaraEnter your age: <span class=\"number\">9</span>Reading from the fileZara9</span><br></pre></td></tr></table></figure>\n\n<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>\n<h2 id=\"文件位置指针\"><a href=\"#文件位置指针\" class=\"headerlink\" title=\"文件位置指针\"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>\n<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>\n<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-异常处理\"><a href=\"#C-异常处理\" class=\"headerlink\" title=\"C++ 异常处理\"></a>C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>\n<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>\n<ul>\n<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>\n<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>\n<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>\n</ul>\n<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch( ExceptionName e1 )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;catch( ExceptionName e2 )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;catch( ExceptionName eN )&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// catch 块&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>\n<h2 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>\n<p>以下是尝试除以零时抛出异常的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">division</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Division by zero condition!&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (a/b);&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch( ExceptionName e )&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 处理 ExceptionName 异常的代码&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 保护代码&#125;catch(...)&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 能处理任何异常的代码&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;double division(int a, int b)&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Division by zero condition!&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (a/b);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> x = <span class=\"number\">50</span>;</span><br><span class=\"line\">   <span class=\"type\">int</span> y = <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"type\">double</span> z = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     z = <span class=\"built_in\">division</span>(x, y);</span><br><span class=\"line\">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class=\"line\">   &#125;<span class=\"built_in\">catch</span> (<span class=\"type\">const</span> <span class=\"type\">char</span>* msg) &#123;</span><br><span class=\"line\">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Division by zero condition!</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-标准的异常\"><a href=\"#C-标准的异常\" class=\"headerlink\" title=\"C++ 标准的异常\"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg\" alt=\"img\"></p>\n<p>下表是对上面层次结构中出现的每个异常的说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">异常</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>std::exception</strong></td>\n<td align=\"left\">该异常是所有标准 C++ 异常的父类。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_alloc</td>\n<td align=\"left\">该异常可以通过 <strong>new</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_cast</td>\n<td align=\"left\">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_exception</td>\n<td align=\"left\">这在处理 C++ 程序中无法预期的异常时非常有用。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_typeid</td>\n<td align=\"left\">该异常可以通过 <strong>typeid</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>std::logic_error</strong></td>\n<td align=\"left\">理论上可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::domain_error</td>\n<td align=\"left\">当使用了一个无效的数学域时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::invalid_argument</td>\n<td align=\"left\">当使用了无效的参数时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::length_error</td>\n<td align=\"left\">当创建了太长的 std::string 时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::out_of_range</td>\n<td align=\"left\">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=\"\"></a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>std::runtime_error</strong></td>\n<td align=\"left\">理论上不可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::overflow_error</td>\n<td align=\"left\">当发生数学上溢时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::range_error</td>\n<td align=\"left\">当尝试存储超出范围的值时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::underflow_error</td>\n<td align=\"left\">当发生数学下溢时，会抛出该异常。</td>\n</tr>\n</tbody></table>\n<h2 id=\"定义新的异常\"><a href=\"#定义新的异常\" class=\"headerlink\" title=\"定义新的异常\"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;exception&gt;</span>using namespace std;struct MyException : public exception&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"title\">what</span> <span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"title\">throw</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C++ Exception&quot;</span>;</span><br><span class=\"line\">  &#125;&#125;;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">MyException</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(MyException&amp; e)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(std::exception&amp; e)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//其他的错误</span></span><br><span class=\"line\">  &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这将产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyException caught</span><br><span class=\"line\">C++ Exception</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>\n<h1 id=\"C-动态内存\"><a href=\"#C-动态内存\" class=\"headerlink\" title=\"C++ 动态内存\"></a>C++ 动态内存</h1><p>了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：</p>\n<ul>\n<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>\n<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>\n</ul>\n<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>\n<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>\n<p>如果您不需要动态分配内存，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>\n<h2 id=\"new-和-delete-运算符\"><a href=\"#new-和-delete-运算符\" class=\"headerlink\" title=\"new 和 delete 运算符\"></a>new 和 delete 运算符</h2><p>下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> data-type;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>data-type</strong> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 <strong>new</strong> 运算符来完成这点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存</span></span><br></pre></td></tr></table></figure>\n\n<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>;<span class=\"keyword\">if</span>( !(pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span> ))&#123;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>malloc()</strong> 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>\n<p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> pvalue;        <span class=\"comment\">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">double</span>* pvalue  = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 初始化为 null 的指针</span></span><br><span class=\"line\">   pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span>;   <span class=\"comment\">// 为变量请求内存</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   *pvalue = <span class=\"number\">29494.99</span>;     <span class=\"comment\">// 在分配的地址存储值</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> pvalue;         <span class=\"comment\">// 释放内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of pvalue : <span class=\"number\">29495</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组的动态内存分配\"><a href=\"#数组的动态内存分配\" class=\"headerlink\" title=\"数组的动态内存分配\"></a>数组的动态内存分配</h2><p>假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* pvalue  = <span class=\"literal\">NULL</span>;   <span class=\"comment\">// 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存</span></span><br></pre></td></tr></table></figure>\n\n<p>要删除我们刚才创建的数组，语句如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span> [] pvalue;        <span class=\"comment\">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ROW = <span class=\"number\">2</span>;<span class=\"type\">int</span> COL = <span class=\"number\">3</span>;<span class=\"type\">double</span> **pvalue  = <span class=\"keyword\">new</span> <span class=\"type\">double</span>* [ROW]; <span class=\"comment\">// 为行分配内存// 为列分配内存for(int i = 0; i &lt; COL; i++) &#123;</span></span><br><span class=\"line\">    pvalue[i] = <span class=\"keyword\">new</span> <span class=\"type\">double</span>[COL];&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放多维数组内存：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; COL; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] pvalue[i];&#125;<span class=\"keyword\">delete</span> [] pvalue;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象的动态内存分配\"><a href=\"#对象的动态内存分配\" class=\"headerlink\" title=\"对象的动态内存分配\"></a>对象的动态内存分配</h2><p>对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"built_in\">Box</span>() &#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;调用构造函数！&quot;</span> &lt;&lt;endl; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ~<span class=\"built_in\">Box</span>() &#123; </span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;调用析构函数！&quot;</span> &lt;&lt;endl; </span><br><span class=\"line\">      &#125;&#125;;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span>&#123;</span><br><span class=\"line\">   Box* myBoxArray = <span class=\"keyword\">new</span> Box[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">delete</span> [] myBoxArray; <span class=\"comment\">// Delete array</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。</p>\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-命名空间\"><a href=\"#C-命名空间\" class=\"headerlink\" title=\"C++ 命名空间\"></a>C++ 命名空间</h1><p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p>\n<p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</p>\n<p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>\n<h2 id=\"定义命名空间\"><a href=\"#定义命名空间\" class=\"headerlink\" title=\"定义命名空间\"></a>定义命名空间</h2><p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name &#123;   <span class=\"comment\">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name::code;  <span class=\"comment\">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>\n\n<p>让我们来看看命名空间如何为变量或函数等实体定义范围：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"comment\">// 第二个命名空间namespace second_space&#123;</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第一个命名空间中的函数</span></span><br><span class=\"line\">   first_space::<span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 调用第二个命名空间中的函数</span></span><br><span class=\"line\">   second_space::<span class=\"built_in\">func</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside first_spaceInside second_space</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"using-指令\"><a href=\"#using-指令\" class=\"headerlink\" title=\"using 指令\"></a>using 指令</h2><p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"comment\">// 第二个命名空间namespace second_space&#123;</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> first_space;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第一个命名空间中的函数</span></span><br><span class=\"line\">   <span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside first_space</span><br></pre></td></tr></table></figure>\n\n<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br></pre></td></tr></table></figure>\n\n<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 <strong>std</strong> 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using std::cout;int main ()&#123;   </span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;std::endl is used with std!&quot;</span> &lt;&lt; std::endl;      </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::endl is used with std!</span><br></pre></td></tr></table></figure>\n\n<p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>\n<h2 id=\"不连续的命名空间\"><a href=\"#不连续的命名空间\" class=\"headerlink\" title=\"不连续的命名空间\"></a>不连续的命名空间</h2><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p>\n<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"嵌套的命名空间\"><a href=\"#嵌套的命名空间\" class=\"headerlink\" title=\"嵌套的命名空间\"></a>嵌套的命名空间</h2><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> namespace_name1 &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 代码声明</span></span><br><span class=\"line\">   <span class=\"keyword\">namespace</span> namespace_name2 &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 代码声明</span></span><br><span class=\"line\">   &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;<span class=\"comment\">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 第二个命名空间</span></span><br><span class=\"line\">   <span class=\"keyword\">namespace</span> second_space&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> first_space::second_space;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// 调用第二个命名空间中的函数</span></span><br><span class=\"line\">   <span class=\"built_in\">func</span>();</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inside second_space</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-模板\"><a href=\"#C-模板\" class=\"headerlink\" title=\"C++ 模板\"></a>C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>\n<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>\n<p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector <int></strong> 或 **vector <string>**。</p>\n<p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p>\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><p>模板函数定义的一般形式如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">type</span>&gt; ret-type func-<span class=\"built_in\">name</span>(parameter list)&#123;   <span class=\"comment\">// 函数的主体&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>\n<p>下面是函数模板的实例，返回两个数种的最大值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>using namespace std;template <span class=\"string\">&lt;typename T&gt;</span>inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &lt; b ? b:a; &#125; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">39</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">20</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(i, j) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">double</span> f1 = <span class=\"number\">13.5</span>; </span><br><span class=\"line\">    <span class=\"type\">double</span> f2 = <span class=\"number\">20.7</span>; </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    string s1 = <span class=\"string\">&quot;Hello&quot;</span>; </span><br><span class=\"line\">    string s2 = <span class=\"string\">&quot;World&quot;</span>; </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class=\"built_in\">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Max</span>(i, j): <span class=\"number\">39</span>Max(f1, f2): <span class=\"number\">20.7</span>Max(s1, s2): World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">type</span>&gt; <span class=\"keyword\">class</span> <span class=\"title class_\">class</span>-name &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>\n<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdexcept&gt;</span>using namespace std;template <span class=\"string\">&lt;class T&gt;</span>class Stack &#123; </span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>: </span><br><span class=\"line\">    vector&lt;T&gt; elems;     <span class=\"comment\">// 元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(T <span class=\"type\">const</span>&amp;)</span></span>;  <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span>;               <span class=\"comment\">// 出栈</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;            <span class=\"comment\">// 返回栈顶元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;       <span class=\"comment\">// 如果为空则返回真。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elems.<span class=\"built_in\">empty</span>(); </span><br><span class=\"line\">    &#125; &#125;; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"type\">void</span> Stack&lt;T&gt;::<span class=\"built_in\">push</span> (T <span class=\"type\">const</span>&amp; elem) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 追加传入元素的副本</span></span><br><span class=\"line\">    elems.<span class=\"built_in\">push_back</span>(elem);    &#125; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"type\">void</span> Stack&lt;T&gt;::<span class=\"built_in\">pop</span> () &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elems.<span class=\"built_in\">empty</span>()) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除最后一个元素</span></span><br><span class=\"line\">    elems.<span class=\"built_in\">pop_back</span>();         &#125; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;T Stack&lt;T&gt;::<span class=\"built_in\">top</span> () <span class=\"type\">const</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elems.<span class=\"built_in\">empty</span>()) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">out_of_range</span>(<span class=\"string\">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回最后一个元素的副本 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elems.<span class=\"built_in\">back</span>();      &#125; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        Stack&lt;<span class=\"type\">int</span>&gt;         intStack;  <span class=\"comment\">// int 类型的栈 </span></span><br><span class=\"line\">        Stack&lt;string&gt; stringStack;    <span class=\"comment\">// string 类型的栈 </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 操作 int 类型的栈 </span></span><br><span class=\"line\">        intStack.<span class=\"built_in\">push</span>(<span class=\"number\">7</span>); </span><br><span class=\"line\">        cout &lt;&lt; intStack.<span class=\"built_in\">top</span>() &lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 操作 string 类型的栈 </span></span><br><span class=\"line\">        stringStack.<span class=\"built_in\">push</span>(<span class=\"string\">&quot;hello&quot;</span>); </span><br><span class=\"line\">        cout &lt;&lt; stringStack.<span class=\"built_in\">top</span>() &lt;&lt; std::endl; </span><br><span class=\"line\">        stringStack.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">        stringStack.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"built_in\">catch</span> (exception <span class=\"type\">const</span>&amp; ex) &#123; </span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class=\"built_in\">what</span>() &lt;&lt;endl; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>helloException: Stack&lt;&gt;::<span class=\"built_in\">pop</span>(): empty stack</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-预处理器\"><a href=\"#C-预处理器\" class=\"headerlink\" title=\"C++ 预处理器\"></a>C++ 预处理器</h1><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>\n<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>\n<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>\n<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。</p>\n<h2 id=\"define-预处理\"><a href=\"#define-预处理\" class=\"headerlink\" title=\"#define 预处理\"></a>#define 预处理</h2><p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>，指令的一般形式是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> macro-name replacement-text</span></span><br></pre></td></tr></table></figure>\n\n<p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> PI 3.14159int main ()&#123;     cout &lt;&lt; <span class=\"string\">&quot;Value of PI :&quot;</span> &lt;&lt; PI &lt;&lt; endl;     return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$gcc -E test.cpp &gt; test.p...<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;     cout &lt;&lt; <span class=\"string\">&quot;Value of PI :&quot;</span> &lt;&lt; <span class=\"number\">3.14159</span> &lt;&lt; endl;     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数宏\"><a href=\"#函数宏\" class=\"headerlink\" title=\"函数宏\"></a>函数宏</h2><p>您可以使用 #define 来定义一个带有参数的宏，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> MIN(a,b) (a&lt;b ? a : b)int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">   i = <span class=\"number\">100</span>;</span><br><span class=\"line\">   j = <span class=\"number\">30</span>;</span><br><span class=\"line\">   cout &lt;&lt;<span class=\"string\">&quot;较小的值为：&quot;</span> &lt;&lt; <span class=\"built_in\">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">较小的值为：<span class=\"number\">30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>\n<p>条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> NULL   #<span class=\"keyword\">define</span> NULL 0#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG   cerr &lt;&lt;<span class=\"string\">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; endl;#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 <strong>cerr</strong> 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0   不进行编译的代码#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>让我们尝试下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> DEBUG#<span class=\"keyword\">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)int main ()&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">   i = <span class=\"number\">100</span>;</span><br><span class=\"line\">   j = <span class=\"number\">30</span>;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG</span></span><br><span class=\"line\">   cerr &lt;&lt;<span class=\"string\">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span>#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">   <span class=\"comment\">/* 这是注释部分 */</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"built_in\">MKSTR</span>(HELLO C++) &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt;<span class=\"string\">&quot;The minimum is &quot;</span> &lt;&lt; <span class=\"built_in\">MIN</span>(i, j) &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">ifdef</span> DEBUG</span></span><br><span class=\"line\">   cerr &lt;&lt;<span class=\"string\">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trace: Inside main functionThe minimum is <span class=\"number\">30</span>Trace: Coming out of main function</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"和-运算符\"><a href=\"#和-运算符\" class=\"headerlink\" title=\"# 和 ## 运算符\"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI&#x2F;ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p>\n<p>请看下面的宏定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> MKSTR( x ) #xint main ()&#123;    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HELLO C++</span><br></pre></td></tr></table></figure>\n\n<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>转换成了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;HELLO C++&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>## 运算符用于连接两个令牌。下面是一个实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CONCAT( x, y )  x ## y</span></span><br></pre></td></tr></table></figure>\n\n<p>当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;#<span class=\"keyword\">define</span> concat(a, b) a ## bint main()&#123;   int xy = 100;      cout &lt;&lt; concat(x, y);   return 0;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">concat</span>(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>转换成了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; xy;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-中的预定义宏\"><a href=\"#C-中的预定义宏\" class=\"headerlink\" title=\"C++ 中的预定义宏\"></a>C++ 中的预定义宏</h2><p>C++ 提供了下表所示的一些预定义宏：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">宏</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>LINE</strong></td>\n<td align=\"left\">这会在程序编译时包含当前行号。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FILE</strong></td>\n<td align=\"left\">这会在程序编译时包含当前文件名。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>DATE</strong></td>\n<td align=\"left\">这会包含一个形式为 month&#x2F;day&#x2F;year 的字符串，它表示把源文件转换为目标代码的日期。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>TIME</strong></td>\n<td align=\"left\">这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</td>\n</tr>\n</tbody></table>\n<p>让我们看看上述这些宏的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of __LINE__ : <span class=\"number\">6</span>Value of __FILE__ : test.cppValue of __DATE__ : Feb <span class=\"number\">28</span> <span class=\"number\">2011</span>Value of __TIME__ : <span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">48</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-信号处理\"><a href=\"#C-信号处理\" class=\"headerlink\" title=\"C++ 信号处理\"></a>C++ 信号处理</h1><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>\n<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">信号</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SIGABRT</td>\n<td align=\"left\">程序的异常终止，如调用 <strong>abort</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGFPE</td>\n<td align=\"left\">错误的算术运算，比如除以零或导致溢出的操作。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGILL</td>\n<td align=\"left\">检测非法指令。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGINT</td>\n<td align=\"left\">接收到交互注意信号。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGSEGV</td>\n<td align=\"left\">非法访问内存。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGTERM</td>\n<td align=\"left\">发送到程序的终止请求。</td>\n</tr>\n</tbody></table>\n<h2 id=\"signal-函数\"><a href=\"#signal-函数\" class=\"headerlink\" title=\"signal() 函数\"></a>signal() 函数</h2><p>C++ 信号处理库提供了 <strong>signal</strong> 函数，用来捕获突发事件。以下是 signal() 函数的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span> (*<span class=\"built_in\">signal</span> (<span class=\"type\">int</span> sig, <span class=\"built_in\">void</span> (*func)(<span class=\"type\">int</span>)))(<span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>\n<p>让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 <strong>signal</strong> 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class=\"string\">&quot;) received.\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清理并关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 终止程序  </span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(signum);  &#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, signalHandler);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....</span><br></pre></td></tr></table></figure>\n\n<p>现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....<span class=\"function\">Interrupt <span class=\"title\">signal</span> <span class=\"params\">(<span class=\"number\">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"raise-函数\"><a href=\"#raise-函数\" class=\"headerlink\" title=\"raise() 函数\"></a>raise() 函数</h2><p>您可以使用函数 <strong>raise()</strong> 生成信号，该函数带有一个整数信号编号作为参数，语法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">raise</span> <span class=\"params\">(signal sig)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>sig</strong> 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class=\"string\">&quot;) received.\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清理并关闭</span></span><br><span class=\"line\">    <span class=\"comment\">// 终止程序 </span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(signum);  &#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class=\"line\">    <span class=\"built_in\">signal</span>(SIGINT, signalHandler);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++i)&#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>( i == <span class=\"number\">3</span> )&#123;</span><br><span class=\"line\">          <span class=\"built_in\">raise</span>( SIGINT);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Going to sleep....Going to sleep....Going to sleep....<span class=\"function\">Interrupt <span class=\"title\">signal</span> <span class=\"params\">(<span class=\"number\">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-多线程\"><a href=\"#C-多线程\" class=\"headerlink\" title=\"C++ 多线程\"></a>C++ 多线程</h1><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>\n<ul>\n<li>基于进程的多任务处理是程序的并发执行。</li>\n<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>\n</ul>\n<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>\n<p>本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU&#x2F;Linux、Mac OS X 和 Solaris。</p>\n<h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>pthread_create (thread, attr, start_routine, arg)</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">thread</td>\n<td align=\"left\">指向线程标识符指针。</td>\n</tr>\n<tr>\n<td align=\"left\">attr</td>\n<td align=\"left\">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>\n</tr>\n<tr>\n<td align=\"left\">start_routine</td>\n<td align=\"left\">线程运行函数起始地址，一旦线程被创建就会执行。</td>\n</tr>\n<tr>\n<td align=\"left\">arg</td>\n<td align=\"left\">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>\n</tr>\n</tbody></table>\n<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>\n<h2 id=\"终止线程\"><a href=\"#终止线程\" class=\"headerlink\" title=\"终止线程\"></a>终止线程</h2><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>pthread_exit (status)</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。</p>\n<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p>\n<h2 id=\"实例-25\"><a href=\"#实例-25\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出”Hello Runoob！”:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span><span class=\"comment\">// 必须的头文件是#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args)&#123;</span></span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Hello Runoob！&quot;</span> &lt;&lt; endl;&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> tids[NUM_THREADS];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">pthread_create</span>(&amp;tids[i], <span class=\"literal\">NULL</span>, say_hello, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           cout &lt;&lt; <span class=\"string\">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class=\"line\">    <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 -lpthread 库编译下面的程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o</span><br></pre></td></tr></table></figure>\n\n<p>现在，执行程序，将产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！</span><br></pre></td></tr></table></figure>\n\n<p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//文件名：test.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid)&#123;  </span></span><br><span class=\"line\">   <span class=\"comment\">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class=\"line\">   <span class=\"type\">int</span> tid = *((<span class=\"type\">int</span>*)threadid);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Hello Runoob! 线程 ID, &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">pthread_t</span> threads[NUM_THREADS];</span><br><span class=\"line\">   <span class=\"type\">int</span> indexes[NUM_THREADS];<span class=\"comment\">// 用数组来保存i的值</span></span><br><span class=\"line\">   <span class=\"type\">int</span> rc;</span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;main() : 创建线程, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      indexes[i] = i; <span class=\"comment\">//先保存i的值</span></span><br><span class=\"line\">      <span class=\"comment\">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_create</span>(&amp;threads[i], <span class=\"literal\">NULL</span>, </span><br><span class=\"line\">                          PrintHello, (<span class=\"type\">void</span> *)&amp;(indexes[i]));</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在编译并执行程序，将产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o$ ./test.<span class=\"built_in\">omain</span>() : 创建线程, <span class=\"number\">0</span>main() : 创建线程, <span class=\"number\">1</span>main() : 创建线程, <span class=\"number\">2</span>main() : 创建线程, <span class=\"number\">3</span>main() : 创建线程, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">3</span>Hello Runoob! 线程 ID, <span class=\"number\">2</span>Hello Runoob! 线程 ID, <span class=\"number\">1</span>Hello Runoob! 线程 ID, <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向线程传递参数\"><a href=\"#向线程传递参数\" class=\"headerlink\" title=\"向线程传递参数\"></a>向线程传递参数</h2><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>using namespace std;#<span class=\"keyword\">define</span> NUM_THREADS     5struct thread_data&#123;   int  thread_id;   char *message;&#125;;void *PrintHello(void *threadarg)&#123;   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout <span class=\"string\">&lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;</span>thread_id ;   cout <span class=\"string\">&lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;</span>message &lt;&lt; endl;   pthread_exit(NULL);&#125;int main ()&#123;   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i &lt; NUM_THREADS; i++ )&#123;      cout &lt;&lt;<span class=\"string\">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;      td[i].thread_id = i;      td[i].message = <span class=\"string\">&quot;This is message&quot;</span>;      rc = pthread_create(&amp;threads[i], NULL,                          PrintHello, (void *)&amp;td[i]);      <span class=\"keyword\">if</span> (rc)&#123;         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;         exit(-1);      &#125;   &#125;   pthread_exit(NULL);&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ g++ test.cpp -lpthread -o test.o</span><br><span class=\"line\">$ ./test.<span class=\"function\">o</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">()</span> : 创建线程, <span class=\"number\">0</span>main() : 创建线程, <span class=\"number\">1</span>main() : 创建线程, <span class=\"number\">2</span>main() : 创建线程, <span class=\"number\">3</span>main() : 创建线程, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">4</span>Hello Runoob! 线程 ID, <span class=\"number\">3</span>Hello Runoob! 线程 ID, <span class=\"number\">2</span>Hello Runoob! 线程 ID, <span class=\"number\">1</span>Hello Runoob! 线程 ID, <span class=\"number\">0</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接和分离线程\"><a href=\"#连接和分离线程\" class=\"headerlink\" title=\"连接和分离线程\"></a>连接和分离线程</h2><p>我们可以使用以下两个函数来连接或分离线程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pthread_join</span> (threadid, status) <span class=\"built_in\">pthread_detach</span> (threadid)</span><br></pre></td></tr></table></figure>\n\n<p>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>\n<p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span>using namespace std;#<span class=\"keyword\">define</span> NUM_THREADS     5void *wait(void *t)&#123;</span></span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"type\">long</span> tid;</span><br><span class=\"line\"></span><br><span class=\"line\">   tid = (<span class=\"type\">long</span>)t;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class=\"string\">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> rc;</span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\">   <span class=\"type\">pthread_t</span> threads[NUM_THREADS];</span><br><span class=\"line\">   <span class=\"type\">pthread_attr_t</span> attr;</span><br><span class=\"line\">   <span class=\"type\">void</span> *status;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_init</span>(&amp;attr);</span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_create</span>(&amp;threads[i], <span class=\"literal\">NULL</span>, wait, (<span class=\"type\">void</span> *)&amp;i );</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 删除属性，并等待其他线程</span></span><br><span class=\"line\">   <span class=\"built_in\">pthread_attr_destroy</span>(&amp;attr);</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i=<span class=\"number\">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class=\"line\">      rc = <span class=\"built_in\">pthread_join</span>(threads[i], &amp;status);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rc)&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">   <span class=\"built_in\">pthread_exit</span>(<span class=\"literal\">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">main</span>() : creating thread, <span class=\"number\">0</span>main() : creating thread, <span class=\"number\">1</span>main() : creating thread, <span class=\"number\">2</span>main() : creating thread, <span class=\"number\">3</span>main() : creating thread, <span class=\"number\">4</span>Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">4</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">3</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">2</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">1</span>  ...exiting </span><br><span class=\"line\">Sleeping in thread </span><br><span class=\"line\">Thread with id : <span class=\"number\">0</span>  ...exiting </span><br><span class=\"line\">Main: completed thread id :<span class=\"number\">0</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">1</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">2</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">3</span>  exiting with status :<span class=\"number\">0</span>Main: completed thread id :<span class=\"number\">4</span>  exiting with status :<span class=\"number\">0</span>Main: program exiting.</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C-Web-编程\"><a href=\"#C-Web-编程\" class=\"headerlink\" title=\"C++ Web 编程\"></a>C++ Web 编程</h1><h2 id=\"什么是-CGI？\"><a href=\"#什么是-CGI？\" class=\"headerlink\" title=\"什么是 CGI？\"></a>什么是 CGI？</h2><ul>\n<li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li>\n<li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li>\n<li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li>\n<li>目前的版本是 CGI&#x2F;1.1，CGI&#x2F;1.2 版本正在推进中。</li>\n</ul>\n<h2 id=\"Web-浏览\"><a href=\"#Web-浏览\" class=\"headerlink\" title=\"Web 浏览\"></a>Web 浏览</h2><p>为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。</p>\n<ul>\n<li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li>\n<li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li>\n<li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li>\n</ul>\n<p>然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。</p>\n<p>公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。</p>\n<h2 id=\"CGI-架构图\"><a href=\"#CGI-架构图\" class=\"headerlink\" title=\"CGI 架构图\"></a>CGI 架构图</h2><p>下图演示了 CGI 的架构：</p>\n<p><img src=\"https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif\" alt=\"img\"></p>\n<h2 id=\"Web-服务器配置\"><a href=\"#Web-服务器配置\" class=\"headerlink\" title=\"Web 服务器配置\"></a>Web 服务器配置</h2><p>在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 &#x2F;var&#x2F;www&#x2F;cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 <strong>.cgi</strong>。</p>\n<p>默认情况下，Apache Web 服务器会配置在 &#x2F;var&#x2F;www&#x2F;cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory <span class=\"string\">&quot;/var/www/cgi-bin&quot;</span>&gt;   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all&lt;/Directory&gt; &lt;Directory <span class=\"string\">&quot;/var/www/cgi-bin&quot;</span>&gt;Options All&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。</p>\n<h2 id=\"第一个-CGI-程序\"><a href=\"#第一个-CGI-程序\" class=\"headerlink\" title=\"第一个 CGI 程序\"></a>第一个 CGI 程序</h2><p>请看下面的 C++ 程序：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;Hello World - 第一个 CGI 程序&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;h2&gt;Hello World! 这是我的第一个 CGI 程序&lt;/h2&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 &#x2F;var&#x2F;www&#x2F;cgi-bin 目录中。在运行 CGI 程序之前，请使用 <strong>chmod 755 cplusplus.cgi</strong> UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：</p>\n<h2 id=\"Hello-World-这是我的第一个-CGI-程序\"><a href=\"#Hello-World-这是我的第一个-CGI-程序\" class=\"headerlink\" title=\"Hello World! 这是我的第一个 CGI 程序\"></a>Hello World! 这是我的第一个 CGI 程序</h2><p>上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 <strong>Content-type:text&#x2F;html\\r\\n\\r\\n</strong>。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。</p>\n<h2 id=\"HTTP-头信息\"><a href=\"#HTTP-头信息\" class=\"headerlink\" title=\"HTTP 头信息\"></a>HTTP 头信息</h2><p>行 <strong>Content-type:text&#x2F;html\\r\\n\\r\\n</strong> 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP 字段名称: 字段内容 例如Content-type: text/html\\r\\n\\r\\n</span><br></pre></td></tr></table></figure>\n\n<p>还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">头信息</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Content-type:</td>\n<td align=\"left\">MIME 字符串，定义返回的文件格式。例如 Content-type:text&#x2F;html。</td>\n</tr>\n<tr>\n<td align=\"left\">Expires: Date</td>\n<td align=\"left\">信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td>\n</tr>\n<tr>\n<td align=\"left\">Location: URL</td>\n<td align=\"left\">这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td>\n</tr>\n<tr>\n<td align=\"left\">Last-modified: Date</td>\n<td align=\"left\">资源的最后修改日期。</td>\n</tr>\n<tr>\n<td align=\"left\">Content-length: N</td>\n<td align=\"left\">要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td>\n</tr>\n<tr>\n<td align=\"left\">Set-Cookie: String</td>\n<td align=\"left\">通过 <em>string</em> 设置 cookie。</td>\n</tr>\n</tbody></table>\n<h2 id=\"CGI-环境变量\"><a href=\"#CGI-环境变量\" class=\"headerlink\" title=\"CGI 环境变量\"></a>CGI 环境变量</h2><p>所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量名</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CONTENT_TYPE</td>\n<td align=\"left\">内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td>\n</tr>\n<tr>\n<td align=\"left\">CONTENT_LENGTH</td>\n<td align=\"left\">查询的信息长度。只对 POST 请求可用。</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP_COOKIE</td>\n<td align=\"left\">以键 &amp; 值对的形式返回设置的 cookies。</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP_USER_AGENT</td>\n<td align=\"left\">用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td>\n</tr>\n<tr>\n<td align=\"left\">PATH_INFO</td>\n<td align=\"left\">CGI 脚本的路径。</td>\n</tr>\n<tr>\n<td align=\"left\">QUERY_STRING</td>\n<td align=\"left\">通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td>\n</tr>\n<tr>\n<td align=\"left\">REMOTE_ADDR</td>\n<td align=\"left\">发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td>\n</tr>\n<tr>\n<td align=\"left\">REMOTE_HOST</td>\n<td align=\"left\">发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td>\n</tr>\n<tr>\n<td align=\"left\">REQUEST_METHOD</td>\n<td align=\"left\">用于发出请求的方法。最常见的方法是 GET 和 POST。</td>\n</tr>\n<tr>\n<td align=\"left\">SCRIPT_FILENAME</td>\n<td align=\"left\">CGI 脚本的完整路径。</td>\n</tr>\n<tr>\n<td align=\"left\">SCRIPT_NAME</td>\n<td align=\"left\">CGI 脚本的名称。</td>\n</tr>\n<tr>\n<td align=\"left\">SERVER_NAME</td>\n<td align=\"left\">服务器的主机名或 IP 地址。</td>\n</tr>\n<tr>\n<td align=\"left\">SERVER_SOFTWARE</td>\n<td align=\"left\">服务器上运行的软件的名称和版本。</td>\n</tr>\n</tbody></table>\n<p>下面的 CGI 程序列出了所有的 CGI 变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span>using namespace std;const string ENV[ 24 ] = &#123;                 </span></span><br><span class=\"line\">        <span class=\"string\">&quot;COMSPEC&quot;</span>, <span class=\"string\">&quot;DOCUMENT_ROOT&quot;</span>, <span class=\"string\">&quot;GATEWAY_INTERFACE&quot;</span>,   </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_ACCEPT&quot;</span>, <span class=\"string\">&quot;HTTP_ACCEPT_ENCODING&quot;</span>,    &amp;nbsnbsp;        </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>, <span class=\"string\">&quot;HTTP_CONNECTION&quot;</span>,         </span><br><span class=\"line\">        <span class=\"string\">&quot;HTTP_HOST&quot;</span>, <span class=\"string\">&quot;HTTP_USER_AGENT&quot;</span>, <span class=\"string\">&quot;PATH&quot;</span>,            </span><br><span class=\"line\">        <span class=\"string\">&quot;QUERY_STRING&quot;</span>, <span class=\"string\">&quot;REMOTE_ADDR&quot;</span>, <span class=\"string\">&quot;REMOTE_PORT&quot;</span>,      </span><br><span class=\"line\">        <span class=\"string\">&quot;REQUEST_METHOD&quot;</span>, <span class=\"string\">&quot;REQUEST_URI&quot;</span>, <span class=\"string\">&quot;SCRIPT_FILENAME&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;SCRIPT_NAME&quot;</span>, <span class=\"string\">&quot;SERVER_ADDR&quot;</span>, <span class=\"string\">&quot;SERVER_ADMIN&quot;</span>,      </span><br><span class=\"line\">        <span class=\"string\">&quot;SERVER_NAME&quot;</span>,<span class=\"string\">&quot;SERVER_PORT&quot;</span>,<span class=\"string\">&quot;SERVER_PROTOCOL&quot;</span>,     </span><br><span class=\"line\">        <span class=\"string\">&quot;SERVER_SIGNATURE&quot;</span>,<span class=\"string\">&quot;SERVER_SOFTWARE&quot;</span> &#125;;   <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 环境变量&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;table border = \\&quot;0\\&quot; cellspacing = \\&quot;2\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; ENV[ i ] &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 尝试检索环境变量的值</span></span><br><span class=\"line\">       <span class=\"type\">char</span> *value = <span class=\"built_in\">getenv</span>( ENV[ i ].<span class=\"built_in\">c_str</span>() );  </span><br><span class=\"line\">       <span class=\"keyword\">if</span> ( value != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">         cout &lt;&lt; value;                                 </span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         cout &lt;&lt; <span class=\"string\">&quot;环境变量不存在。&quot;</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       cout &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;/tr&gt;\\n&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/table&gt;&lt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-CGI-库\"><a href=\"#C-CGI-库\" class=\"headerlink\" title=\"C++ CGI 库\"></a>C++ CGI 库</h2><p>在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 <a href=\"ftp://ftp.gnu.org/gnu/cgicc/\">ftp://ftp.gnu.org/gnu/cgicc/</a> 上下载这个 CGI 库，并按照下面的步骤安装库：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install</span><br></pre></td></tr></table></figure>\n\n<p>您可以点击 C++ CGI Lib Documentation，查看相关的库文档。</p>\n<h2 id=\"GET-和-POST-方法\"><a href=\"#GET-和-POST-方法\" class=\"headerlink\" title=\"GET 和 POST 方法\"></a>GET 和 POST 方法</h2><p>您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。</p>\n<h2 id=\"使用-GET-方法传递信息\"><a href=\"#使用-GET-方法传递信息\" class=\"headerlink\" title=\"使用 GET 方法传递信息\"></a>使用 GET 方法传递信息</h2><p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span></span><br></pre></td></tr></table></figure>\n\n<p>GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。</p>\n<p>当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。</p>\n<p>您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。</p>\n<h2 id=\"简单的-URL-实例：Get-方法\"><a href=\"#简单的-URL-实例：Get-方法\" class=\"headerlink\" title=\"简单的 URL 实例：Get 方法\"></a>简单的 URL 实例：Get 方法</h2><p>下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。</p>\n<p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p>\n<p>下面的实例生成 <strong>cpp_get.cgi</strong> CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>  using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">   </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;使用 GET 和 POST 方法&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;first_name&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;名：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered for first name&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;last_name&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp;fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;姓：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered for last name&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，编译上面的程序，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc</span><br></pre></td></tr></table></figure>\n\n<p>生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：</p>\n<p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p>\n<p>这会产生以下结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">名：ZARA 姓：ALI</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单的表单实例：GET-方法\"><a href=\"#简单的表单实例：GET-方法\" class=\"headerlink\" title=\"简单的表单实例：GET 方法\"></a>简单的表单实例：GET 方法</h2><p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class=\"string\">&quot;get&quot;</span>&gt;名：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;first_name&quot;</span>&gt;  &lt;br /&gt; 姓：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;last_name&quot;</span> /&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。</p>\n<h2 id=\"使用-POST-方法传递信息\"><a href=\"#使用-POST-方法传递信息\" class=\"headerlink\" title=\"使用 POST 方法传递信息\"></a>使用 POST 方法传递信息</h2><p>一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。</p>\n<p>我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class=\"string\">&quot;post&quot;</span>&gt;名：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;first_name&quot;</span>&gt;&lt;br /&gt;姓：&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;last_name&quot;</span> /&gt; &lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递复选框数据\"><a href=\"#向-CGI-程序传递复选框数据\" class=\"headerlink\" title=\"向 CGI 程序传递复选框数据\"></a>向 CGI 程序传递复选框数据</h2><p>当需要选择多个选项时，我们使用复选框。</p>\n<p>下面的 HTML 代码实例是一个带有两个复选框的表单：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/cgi-bin/cpp_checkbox.cgi&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">method</span>=<span class=\"string\">&quot;POST&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">target</span>=<span class=\"string\">&quot;_blank&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maths&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;on&quot;</span> /&gt;</span> 数学<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;physics&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;on&quot;</span> /&gt;</span> 物理<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;选择学科&quot;</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">   <span class=\"type\">bool</span> maths_flag, physics_flag;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递复选框数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   maths_flag = formData.<span class=\"built_in\">queryCheckbox</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( maths_flag ) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Maths Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Maths Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   physics_flag = formData.<span class=\"built_in\">queryCheckbox</span>(<span class=\"string\">&quot;physics&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>( physics_flag ) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Physics Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Physics Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递单选按钮数据\"><a href=\"#向-CGI-程序传递单选按钮数据\" class=\"headerlink\" title=\"向 CGI 程序传递单选按钮数据\"></a>向 CGI 程序传递单选按钮数据</h2><p>当只需要选择一个选项时，我们使用单选按钮。</p>\n<p>下面的 HTML 代码实例是一个带有两个单选按钮的表单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_radiobutton.cgi&quot;</span> </span><br><span class=\"line\">         method=<span class=\"string\">&quot;post&quot;</span> </span><br><span class=\"line\">         target=<span class=\"string\">&quot;_blank&quot;</span>&gt;&lt;input type=<span class=\"string\">&quot;radio&quot;</span> name=<span class=\"string\">&quot;subject&quot;</span> value=<span class=\"string\">&quot;maths&quot;</span> </span><br><span class=\"line\">                                    checked=<span class=\"string\">&quot;checked&quot;</span>/&gt; 数学 </span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;radio&quot;</span> name=<span class=\"string\">&quot;subject&quot;</span> value=<span class=\"string\">&quot;physics&quot;</span> /&gt; 物理&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;选择学科&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递单选按钮数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;subject&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Radio box selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递文本区域数据\"><a href=\"#向-CGI-程序传递文本区域数据\" class=\"headerlink\" title=\"向 CGI 程序传递文本区域数据\"></a>向 CGI 程序传递文本区域数据</h2><p>当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。</p>\n<p>下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=&quot;/cgi-bin/cpp_textarea.cgi&quot; </span><br><span class=\"line\">         method=&quot;post&quot; </span><br><span class=\"line\">         target=&quot;_blank&quot;&gt;&lt;textarea name=&quot;textcontent&quot; cols=&quot;40&quot; rows=&quot;4&quot;&gt;请在这里输入文本...&lt;/textarea&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递文本区域数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;textcontent&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Text Content: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;No text entered&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"向-CGI-程序传递下拉框数据\"><a href=\"#向-CGI-程序传递下拉框数据\" class=\"headerlink\" title=\"向 CGI 程序传递下拉框数据\"></a>向 CGI 程序传递下拉框数据</h2><p>当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。</p>\n<p>下面的 HTML 代码实例是一个带有下拉框的表单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;/cgi-bin/cpp_dropdown.cgi&quot;</span> </span><br><span class=\"line\">                       method=<span class=\"string\">&quot;post&quot;</span> target=<span class=\"string\">&quot;_blank&quot;</span>&gt;&lt;select name=<span class=\"string\">&quot;dropdown&quot;</span>&gt;&lt;option value=<span class=\"string\">&quot;Maths&quot;</span> selected&gt;数学&lt;/option&gt;&lt;option value=<span class=\"string\">&quot;Physics&quot;</span>&gt;物理&lt;/option&gt;&lt;/select&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span>/&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc formData;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;向 CGI 程序传递下拉框数据&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   form_iterator fi = formData.<span class=\"built_in\">getElement</span>(<span class=\"string\">&quot;dropdown&quot;</span>);  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>( !fi-&gt;<span class=\"built_in\">isEmpty</span>() &amp;&amp; fi != (*formData).<span class=\"built_in\">end</span>()) &#123;  </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;Value Selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在-CGI-中使用-Cookies\"><a href=\"#在-CGI-中使用-Cookies\" class=\"headerlink\" title=\"在 CGI 中使用 Cookies\"></a>在 CGI 中使用 Cookies</h2><p>HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。</p>\n<p>在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p>\n<h3 id=\"它是如何工作的\"><a href=\"#它是如何工作的\" class=\"headerlink\" title=\"它是如何工作的\"></a>它是如何工作的</h3><p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p>\n<p>cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：</p>\n<ul>\n<li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li>\n<li><strong>Domain :</strong> 网站的域名。</li>\n<li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li>\n<li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li>\n<li><strong>Name&#x3D;Value :</strong> cookie 以键值对的形式被设置和获取。</li>\n</ul>\n<h3 id=\"设置-Cookies\"><a href=\"#设置-Cookies\" class=\"headerlink\" title=\"设置 Cookies\"></a>设置 Cookies</h3><p>向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:UserID=XYZ;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Password=XYZ123;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Domain=www.w3cschool.cc;\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Set-Cookie:Path=/perl;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;设置 cookies&quot;</span> &lt;&lt; endl;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这个实例中，我们了解了如何设置 cookies。我们使用 <strong>Set-Cookie</strong> HTTP 头来设置 cookies。</p>\n<p>在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 <strong>“Content-type:text&#x2F;html\\r\\n\\r\\n</strong> 之前被设置的。</p>\n<p>编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：</p>\n<p>&#x2F;cgi-bin&#x2F;setcookies.cgi</p>\n<h3 id=\"获取-Cookies\"><a href=\"#获取-Cookies\" class=\"headerlink\" title=\"获取 Cookies\"></a>获取 Cookies</h3><p>检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1=value1;key2=value2;key3=value3....</span><br></pre></td></tr></table></figure>\n\n<p>下面的实例演示了如何获取 cookies。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc cgi;</span><br><span class=\"line\">   const_cookie_iterator cci;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;table border = \\&quot;0\\&quot; cellspacing = \\&quot;2\\&quot;&gt;&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// 获取环境变量</span></span><br><span class=\"line\">   <span class=\"type\">const</span> CgiEnvironment&amp; env = cgi.<span class=\"built_in\">getEnvironment</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( cci = env.<span class=\"built_in\">getCookieList</span>().<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        cci != env.<span class=\"built_in\">getCookieList</span>().<span class=\"built_in\">end</span>(); </span><br><span class=\"line\">        ++cci )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; cci-&gt;<span class=\"built_in\">getName</span>() &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class=\"line\">      cout &lt;&lt; cci-&gt;<span class=\"built_in\">getValue</span>();                                 </span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;&lt;/td&gt;&lt;/tr&gt;\\n&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/table&gt;&lt;\\n&quot;</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;br/&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：</p>\n<p>&#x2F;cgi-bin&#x2F;getcookies.cgi</p>\n<p>这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件上传实例\"><a href=\"#文件上传实例\" class=\"headerlink\" title=\"文件上传实例\"></a>文件上传实例</h2><p>为了上传一个文件，HTML 表单必须把 enctype 属性设置为 <strong>multipart&#x2F;form-data</strong>。带有文件类型的 input 标签会创建一个 “Browse” 按钮。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">   &lt;form enctype=<span class=\"string\">&quot;multipart/form-data&quot;</span> </span><br><span class=\"line\">            action=<span class=\"string\">&quot;/cgi-bin/cpp_uploadfile.cgi&quot;</span> </span><br><span class=\"line\">            method=<span class=\"string\">&quot;post&quot;</span>&gt;</span><br><span class=\"line\">   &lt;p&gt;文件：&lt;input type=<span class=\"string\">&quot;file&quot;</span> name=<span class=\"string\">&quot;userfile&quot;</span> /&gt;&lt;/p&gt;</span><br><span class=\"line\">   &lt;p&gt;&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;上传&quot;</span> /&gt;&lt;/p&gt;</span><br><span class=\"line\">   &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的结果是下面的表单：</p>\n<p>文件：</p>\n<p><strong>注意：</strong>上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。</p>\n<p>下面是用于处理文件上传的脚本 <strong>cpp_uploadfile.cpp</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span>  #<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/CgiDefs.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/Cgicc.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class=\"keyword\">include</span> <span class=\"string\">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class=\"line\">   Cgicc cgi;</span><br><span class=\"line\"></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;Content-type:text/html\\r\\n\\r\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;title&gt;CGI 中的文件上传&lt;/title&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 获取要被上传的文件列表</span></span><br><span class=\"line\">   const_file_iterator file = cgi.<span class=\"built_in\">getFile</span>(<span class=\"string\">&quot;userfile&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(file != cgi.<span class=\"built_in\">getFiles</span>().<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在 cout 中发送数据类型</span></span><br><span class=\"line\">      cout &lt;&lt; <span class=\"built_in\">HTTPContentHeader</span>(file-&gt;<span class=\"built_in\">getDataType</span>());</span><br><span class=\"line\">      <span class=\"comment\">// 在 cout 中写入内容</span></span><br><span class=\"line\">      file-&gt;<span class=\"built_in\">writeToStream</span>(cout);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;文件上传成功&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span>;</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;&lt;/html&gt;\\n&quot;</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的实例是在 <strong>cout</strong> 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。</p>\n<h1 id=\"C-STL-教程\"><a href=\"#C-STL-教程\" class=\"headerlink\" title=\"C++ STL 教程\"></a>C++ STL 教程</h1><p>在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>\n<p>C++ 标准模板库的核心包括以下三个组件：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">组件</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">容器（Containers）</td>\n<td align=\"left\">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td align=\"left\">算法（Algorithms）</td>\n<td align=\"left\">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器（iterators）</td>\n<td align=\"left\">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody></table>\n<p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。</p>\n<p>下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span>using namespace std;</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 创建一个向量存储 int</span></span><br><span class=\"line\">   vector&lt;<span class=\"type\">int</span>&gt; vec; </span><br><span class=\"line\">   <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 显示 vec 的原始大小</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 推入 5 个值到向量中</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">      vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 显示 vec 扩展后的大小</span></span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 访问向量中的 5 个值</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用迭代器 iterator 访问值</span></span><br><span class=\"line\">   vector&lt;<span class=\"type\">int</span>&gt;::iterator v = vec.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">   <span class=\"keyword\">while</span>( v != vec.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class=\"line\">      v++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当上面的代码被编译和执行时，它会产生下列结果：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector size = <span class=\"number\">0</span>extended vector size = <span class=\"number\">5</span>value of vec [<span class=\"number\">0</span>] = <span class=\"number\">0</span>value of vec [<span class=\"number\">1</span>] = <span class=\"number\">1</span>value of vec [<span class=\"number\">2</span>] = <span class=\"number\">2</span>value of vec [<span class=\"number\">3</span>] = <span class=\"number\">3</span>value of vec [<span class=\"number\">4</span>] = <span class=\"number\">4</span>value of v = <span class=\"number\">0</span>value of v = <span class=\"number\">1</span>value of v = <span class=\"number\">2</span>value of v = <span class=\"number\">3</span>value of v = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p>关于上面实例中所使用的各种函数，有几点要注意：</p>\n<ul>\n<li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li>\n<li>size( ) 函数显示向量的大小。</li>\n<li>begin( ) 函数返回一个指向向量开头的迭代器。</li>\n<li>end( ) 函数返回一个指向向量末尾的迭代器。</li>\n</ul>\n<h1 id=\"C-标准库\"><a href=\"#C-标准库\" class=\"headerlink\" title=\"C++ 标准库\"></a>C++ 标准库</h1><p>C++ 标准库可以分为两部分：</p>\n<ul>\n<li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li>\n<li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li>\n</ul>\n<p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p>\n<h2 id=\"标准函数库\"><a href=\"#标准函数库\" class=\"headerlink\" title=\"标准函数库\"></a>标准函数库</h2><p>标准函数库分为以下几类：</p>\n<ul>\n<li>输入&#x2F;输出 I&#x2F;O</li>\n<li>字符串和字符处理</li>\n<li>数学</li>\n<li>时间、日期和本地化</li>\n<li>动态分配</li>\n<li>其他</li>\n<li>宽字符函数</li>\n</ul>\n<h2 id=\"面向对象类库\"><a href=\"#面向对象类库\" class=\"headerlink\" title=\"面向对象类库\"></a>面向对象类库</h2><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p>\n<ul>\n<li>标准的 C++ I&#x2F;O 类</li>\n<li>String 类</li>\n<li>数值类</li>\n<li>STL 容器类</li>\n<li>STL 算法</li>\n<li>STL 函数对象</li>\n<li>STL 迭代器</li>\n<li>STL 分配器</li>\n<li>本地化库</li>\n<li>异常处理类</li>\n<li>杂项支持库</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>来源：<a href=\"https://github.com/0voice/cpp_new_features\">https://github.com/0voice/cpp_new_features</a></p>\n"},{"title":"回调机制","date":"2023-08-28T17:12:29.000Z","_content":"\n#### __1、C语言中的回调__ \n&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：\n\n```C++\nint max(int x, int y) { return x > y ? x : y; }\n\nint main(void) {\n    /* p 是函数指针 */\n    int (*p)(int, int) = &max; // &可以省略 \n    int a, b, c, d;\n    printf(\"请输入三个数字:\");\n    scanf(\"%d %d %d\", &a, &b, &c);\n    /* 与直接调用函数等价，d = max(max(a, b), c) */\n    d = p(p(a, b), c);\n    printf(\"最大的数字是: %d\\n\", d);\n    return 0;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp; 输出的结果：\n\n```shell\n请输入三个数字:1 2 3 \n最大的数字是: 3\n```\n\n&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： \n\n```shell\n16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709\n```\n\n#### __2、什么是回调__\n\n&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。\n\n&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。\n\n![程序调用的几种方式](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：\n\n* 属于工作流的一个部分； \n\n* 必须按照工作流指定的调用约定来申明（定义）； \n\n* 他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。","source":"_posts/回调机制.md","raw":"---\ntitle: 回调机制\ndate: 2023-08-29 01:12:29\ncategories: \n- 基本功\n- 编程基础\n- 编程理论\ntags:\n- C++\n- Java\n- 回调\n---\n\n#### __1、C语言中的回调__ \n&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：\n\n```C++\nint max(int x, int y) { return x > y ? x : y; }\n\nint main(void) {\n    /* p 是函数指针 */\n    int (*p)(int, int) = &max; // &可以省略 \n    int a, b, c, d;\n    printf(\"请输入三个数字:\");\n    scanf(\"%d %d %d\", &a, &b, &c);\n    /* 与直接调用函数等价，d = max(max(a, b), c) */\n    d = p(p(a, b), c);\n    printf(\"最大的数字是: %d\\n\", d);\n    return 0;\n}\n```\n\n&ensp;&ensp;&ensp;&ensp; 输出的结果：\n\n```shell\n请输入三个数字:1 2 3 \n最大的数字是: 3\n```\n\n&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： \n\n```shell\n16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709\n```\n\n#### __2、什么是回调__\n\n&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。\n\n&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 \n\n&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。\n\n![程序调用的几种方式](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：\n\n* 属于工作流的一个部分； \n\n* 必须按照工作流指定的调用约定来申明（定义）； \n\n* 他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。","slug":"回调机制","published":1,"updated":"2023-08-29T15:26:11.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm1hvz6m0015uywxhzhpe0yt","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"1、C语言中的回调\"><a href=\"#1、C语言中的回调\" class=\"headerlink\" title=\"1、C语言中的回调\"></a><strong>1、C语言中的回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* p 是函数指针 */</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>) = &amp;max; <span class=\"comment\">// &amp;可以省略 </span></span><br><span class=\"line\">    <span class=\"type\">int</span> a, b, c, d;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入三个数字:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">    <span class=\"comment\">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class=\"line\">    d = <span class=\"built_in\">p</span>(<span class=\"built_in\">p</span>(a, b), c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大的数字是: %d\\n&quot;</span>, d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 输出的结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入三个数字:1 2 3 </span><br><span class=\"line\">最大的数字是: 3</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、什么是回调\"><a href=\"#2、什么是回调\" class=\"headerlink\" title=\"2、什么是回调\"></a><strong>2、什么是回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true\" alt=\"程序调用的几种方式\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：</p>\n<ul>\n<li><p>属于工作流的一个部分； </p>\n</li>\n<li><p>必须按照工作流指定的调用约定来申明（定义）； </p>\n</li>\n<li><p>他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、C语言中的回调\"><a href=\"#1、C语言中的回调\" class=\"headerlink\" title=\"1、C语言中的回调\"></a><strong>1、C语言中的回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y ? x : y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* p 是函数指针 */</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>) = &amp;max; <span class=\"comment\">// &amp;可以省略 </span></span><br><span class=\"line\">    <span class=\"type\">int</span> a, b, c, d;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入三个数字:&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">    <span class=\"comment\">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class=\"line\">    d = <span class=\"built_in\">p</span>(<span class=\"built_in\">p</span>(a, b), c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;最大的数字是: %d\\n&quot;</span>, d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 输出的结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请输入三个数字:1 2 3 </span><br><span class=\"line\">最大的数字是: 3</span><br></pre></td></tr></table></figure>\n\n<p>&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、什么是回调\"><a href=\"#2、什么是回调\" class=\"headerlink\" title=\"2、什么是回调\"></a><strong>2、什么是回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 </p>\n<p>&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true\" alt=\"程序调用的几种方式\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：</p>\n<ul>\n<li><p>属于工作流的一个部分； </p>\n</li>\n<li><p>必须按照工作流指定的调用约定来申明（定义）； </p>\n</li>\n<li><p>他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clm1hvz660007uywxghhuhy1c","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6i000ruywxaj78c1ib"},{"post_id":"clm1hvz660007uywxghhuhy1c","category_id":"clm1hvz6d000iuywxda9u3vnp","_id":"clm1hvz6j000vuywxglu63q6a"},{"post_id":"clm1hvz6b000cuywx14zvdru7","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6o001huywx8zrn3lmm"},{"post_id":"clm1hvz6b000cuywx14zvdru7","category_id":"clm1hvz6d000iuywxda9u3vnp","_id":"clm1hvz6o001iuywxh7b0dpff"},{"post_id":"clm1hvz6g000puywx6y4w92v5","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6r0020uywx6q5f20is"},{"post_id":"clm1hvz6g000puywx6y4w92v5","category_id":"clm1hvz6p001tuywx46v86zk9","_id":"clm1hvz6r0022uywx8og63spu"},{"post_id":"clm1hvz5x0001uywxakhleuix","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6s0025uywx9o012gqn"},{"post_id":"clm1hvz5x0001uywxakhleuix","category_id":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6s0028uywxg5yv1t0t"},{"post_id":"clm1hvz5x0001uywxakhleuix","category_id":"clm1hvz6q001xuywx4700bul7","_id":"clm1hvz6s002auywx7sjo3aus"},{"post_id":"clm1hvz6j000uuywxfwpmgjl8","category_id":"clm1hvz6s0026uywxcogm0xye","_id":"clm1hvz6s002euywxc6it90df"},{"post_id":"clm1hvz6m0013uywx90nfb5ix","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6u002suywxcx8z1ek6"},{"post_id":"clm1hvz6m0013uywx90nfb5ix","category_id":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6u002uuywx9kwadckj"},{"post_id":"clm1hvz6m0013uywx90nfb5ix","category_id":"clm1hvz6q001xuywx4700bul7","_id":"clm1hvz6v002wuywxfr6d4ncl"},{"post_id":"clm1hvz6m0015uywxhzhpe0yt","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6v002zuywxg2va2tja"},{"post_id":"clm1hvz6m0015uywxhzhpe0yt","category_id":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6v0032uywx3oclf5mx"},{"post_id":"clm1hvz6m0015uywxhzhpe0yt","category_id":"clm1hvz6u002quywx6eqqc3fm","_id":"clm1hvz6v0035uywx6ydk60ui"},{"post_id":"clm1hvz6c000huywx2p27aj6b","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6w003guywxgr9c9e3f"},{"post_id":"clm1hvz6c000huywx2p27aj6b","category_id":"clm1hvz6v0038uywxdcmu08yi","_id":"clm1hvz6w003iuywxh9md8c6o"},{"post_id":"clm1hvz6h000quywx4odo3ta3","category_id":"clm1hvz6r0021uywxhrug7owt","_id":"clm1hvz6w003quywx4gvi6q0y"},{"post_id":"clm1hvz6h000quywx4odo3ta3","category_id":"clm1hvz6w003luywx7g8d6x9t","_id":"clm1hvz6x003tuywxde7i5jw1"},{"post_id":"clm1hvz670008uywxb8frep5i","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6x003uuywx41416k95"},{"post_id":"clm1hvz670008uywxb8frep5i","category_id":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6x003xuywx7drh3epf"},{"post_id":"clm1hvz670008uywxb8frep5i","category_id":"clm1hvz6s002buywxbsn5grri","_id":"clm1hvz6x003yuywxf6vc5mq4"},{"post_id":"clm1hvz670008uywxb8frep5i","category_id":"clm1hvz6w003puywxeg6lf74w","_id":"clm1hvz6y0041uywx4mz0df73"},{"post_id":"clm1hvz6j000xuywxb1sj5ppn","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6y0043uywx06w5dpcy"},{"post_id":"clm1hvz6j000xuywxb1sj5ppn","category_id":"clm1hvz6w003suywxg9nkbgfs","_id":"clm1hvz6y0047uywx72cg7j42"},{"post_id":"clm1hvz6k0010uywxgoa7exrh","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6y0049uywx0d6288yh"},{"post_id":"clm1hvz6k0010uywxgoa7exrh","category_id":"clm1hvz6t002iuywx0n1veyxm","_id":"clm1hvz6y004duywx0ugt83vq"},{"post_id":"clm1hvz6k0010uywxgoa7exrh","category_id":"clm1hvz6x003wuywx9pzv5umj","_id":"clm1hvz6y004fuywxgb0zdx0m"},{"post_id":"clm1hvz6a000buywx0rfk0xtn","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6z004iuywx98ugef2j"},{"post_id":"clm1hvz6a000buywx0rfk0xtn","category_id":"clm1hvz6t002luywxcyf052il","_id":"clm1hvz6z004kuywx2pt1aye0"},{"post_id":"clm1hvz6a000buywx0rfk0xtn","category_id":"clm1hvz6x0040uywxfkcubim2","_id":"clm1hvz6z004muywx0tyl8o1e"},{"post_id":"clm1hvz610003uywxepe7gi93","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6z004puywx1ce9ej19"},{"post_id":"clm1hvz610003uywxepe7gi93","category_id":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6z004quywxaumu4r3e"},{"post_id":"clm1hvz610003uywxepe7gi93","category_id":"clm1hvz6s002buywxbsn5grri","_id":"clm1hvz6z004suywx8dqpct38"},{"post_id":"clm1hvz610003uywxepe7gi93","category_id":"clm1hvz6w003puywxeg6lf74w","_id":"clm1hvz6z004tuywxdotf86e3"},{"post_id":"clm1hvz6c000fuywxhbuzgtqj","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6z004uuywx7mbgfeay"},{"post_id":"clm1hvz6c000fuywxhbuzgtqj","category_id":"clm1hvz6t002iuywx0n1veyxm","_id":"clm1hvz6z004vuywxaehw8m0p"},{"post_id":"clm1hvz6c000fuywxhbuzgtqj","category_id":"clm1hvz6y004cuywxc1jf0yl2","_id":"clm1hvz6z004wuywxhm8672lk"},{"post_id":"clm1hvz640006uywx64ct1u5u","category_id":"clm1hvz630004uywx7ft82n6c","_id":"clm1hvz6z004xuywx8d126hf3"},{"post_id":"clm1hvz640006uywx64ct1u5u","category_id":"clm1hvz6g000nuywx0p5qdgzo","_id":"clm1hvz6z004yuywx13p6aqct"},{"post_id":"clm1hvz640006uywx64ct1u5u","category_id":"clm1hvz6v0033uywxh6f736jc","_id":"clm1hvz6z004zuywx1k897a5i"},{"post_id":"clm1hvz640006uywx64ct1u5u","category_id":"clm1hvz6z004huywx0may706u","_id":"clm1hvz6z0050uywxhhfgdv6u"},{"post_id":"clm1hvz6e000luywxd06j9n1u","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6z0051uywx5b6b70og"},{"post_id":"clm1hvz6e000luywxd06j9n1u","category_id":"clm1hvz6t002luywxcyf052il","_id":"clm1hvz6z0052uywx9k778w4b"},{"post_id":"clm1hvz6e000luywxd06j9n1u","category_id":"clm1hvz6z004nuywx921pd8kg","_id":"clm1hvz6z0053uywx0ncd0g2q"},{"post_id":"clm1hvz6e000muywx2ufig5ia","category_id":"clm1hvz6j000yuywx1m807tnp","_id":"clm1hvz6z0054uywx2uhu6zpg"},{"post_id":"clm1hvz6e000muywx2ufig5ia","category_id":"clm1hvz6t002luywxcyf052il","_id":"clm1hvz6z0055uywx108h98mq"},{"post_id":"clm1hvz6e000muywx2ufig5ia","category_id":"clm1hvz6z004ruywxberq4s44","_id":"clm1hvz6z0056uywx1hbc010j"}],"PostTag":[{"post_id":"clm1hvz5x0001uywxakhleuix","tag_id":"clm1hvz640005uywx895591fd","_id":"clm1hvz6c000guywx9jcha6kb"},{"post_id":"clm1hvz5x0001uywxakhleuix","tag_id":"clm1hvz68000auywxga8v16r4","_id":"clm1hvz6d000juywx0vng2x9j"},{"post_id":"clm1hvz610003uywxepe7gi93","tag_id":"clm1hvz68000auywxga8v16r4","_id":"clm1hvz6j000wuywx8duzcyvd"},{"post_id":"clm1hvz610003uywxepe7gi93","tag_id":"clm1hvz6e000kuywx6dv26cjl","_id":"clm1hvz6k000zuywxe891fwce"},{"post_id":"clm1hvz610003uywxepe7gi93","tag_id":"clm1hvz6g000ouywx2zs35bor","_id":"clm1hvz6m0012uywxds93dbjz"},{"post_id":"clm1hvz6m0013uywx90nfb5ix","tag_id":"clm1hvz640005uywx895591fd","_id":"clm1hvz6n0017uywx725zd7qh"},{"post_id":"clm1hvz6m0013uywx90nfb5ix","tag_id":"clm1hvz68000auywxga8v16r4","_id":"clm1hvz6n0018uywx02013m4l"},{"post_id":"clm1hvz640006uywx64ct1u5u","tag_id":"clm1hvz6i000tuywxgchs5k2e","_id":"clm1hvz6n001buywx941l9u75"},{"post_id":"clm1hvz640006uywx64ct1u5u","tag_id":"clm1hvz6l0011uywx7kio3zza","_id":"clm1hvz6o001duywxbdrbfzwp"},{"post_id":"clm1hvz640006uywx64ct1u5u","tag_id":"clm1hvz6g000ouywx2zs35bor","_id":"clm1hvz6o001fuywx7jat2oi2"},{"post_id":"clm1hvz660007uywxghhuhy1c","tag_id":"clm1hvz6n001auywxbe1i1es5","_id":"clm1hvz6p001kuywxab7r1x5j"},{"post_id":"clm1hvz660007uywxghhuhy1c","tag_id":"clm1hvz6o001euywxc7yb1azm","_id":"clm1hvz6p001muywx5umy7ua7"},{"post_id":"clm1hvz670008uywxb8frep5i","tag_id":"clm1hvz68000auywxga8v16r4","_id":"clm1hvz6p001suywx8iwr5l2f"},{"post_id":"clm1hvz670008uywxb8frep5i","tag_id":"clm1hvz6e000kuywx6dv26cjl","_id":"clm1hvz6q001uuywxgonq46v1"},{"post_id":"clm1hvz670008uywxb8frep5i","tag_id":"clm1hvz6g000ouywx2zs35bor","_id":"clm1hvz6q001wuywx1fosd1v0"},{"post_id":"clm1hvz6a000buywx0rfk0xtn","tag_id":"clm1hvz6p001ruywxey68bufa","_id":"clm1hvz6r001yuywx1ggq6exx"},{"post_id":"clm1hvz6b000cuywx14zvdru7","tag_id":"clm1hvz6n001auywxbe1i1es5","_id":"clm1hvz6r0024uywx8q4leofv"},{"post_id":"clm1hvz6b000cuywx14zvdru7","tag_id":"clm1hvz6o001euywxc7yb1azm","_id":"clm1hvz6s0027uywx07s42rfp"},{"post_id":"clm1hvz6c000fuywxhbuzgtqj","tag_id":"clm1hvz6r0023uywxalll10ly","_id":"clm1hvz6s002duywxej5s2g9s"},{"post_id":"clm1hvz6c000fuywxhbuzgtqj","tag_id":"clm1hvz6s0029uywxfe1h9zoy","_id":"clm1hvz6s002guywxeoxlhnt3"},{"post_id":"clm1hvz6c000huywx2p27aj6b","tag_id":"clm1hvz6s002cuywxdkqcbemq","_id":"clm1hvz6t002kuywx558q55wc"},{"post_id":"clm1hvz6c000huywx2p27aj6b","tag_id":"clm1hvz6s002huywxb5617f80","_id":"clm1hvz6u002muywx1i3k9muc"},{"post_id":"clm1hvz6e000luywxd06j9n1u","tag_id":"clm1hvz6t002juywxd4kdd6vo","_id":"clm1hvz6v002yuywxcf6x4z0g"},{"post_id":"clm1hvz6e000luywxd06j9n1u","tag_id":"clm1hvz6u002nuywx7rq3cqbc","_id":"clm1hvz6v0030uywx3zregr4c"},{"post_id":"clm1hvz6e000luywxd06j9n1u","tag_id":"clm1hvz6u002puywxhcqxab4n","_id":"clm1hvz6v0034uywx9h9n3c7e"},{"post_id":"clm1hvz6e000luywxd06j9n1u","tag_id":"clm1hvz6u002ruywxg5tg0jgu","_id":"clm1hvz6v0036uywx70i28rrx"},{"post_id":"clm1hvz6e000muywx2ufig5ia","tag_id":"clm1hvz6u002vuywxhez5bhgx","_id":"clm1hvz6v0039uywx6i26gzrx"},{"post_id":"clm1hvz6e000muywx2ufig5ia","tag_id":"clm1hvz6u002ruywxg5tg0jgu","_id":"clm1hvz6v003auywx2d336wx5"},{"post_id":"clm1hvz6g000puywx6y4w92v5","tag_id":"clm1hvz6v0037uywxcvmzdsih","_id":"clm1hvz6v003duywx158b086v"},{"post_id":"clm1hvz6h000quywx4odo3ta3","tag_id":"clm1hvz640005uywx895591fd","_id":"clm1hvz6w003huywxcg71axlb"},{"post_id":"clm1hvz6h000quywx4odo3ta3","tag_id":"clm1hvz68000auywxga8v16r4","_id":"clm1hvz6w003juywxagod4s6p"},{"post_id":"clm1hvz6h000quywx4odo3ta3","tag_id":"clm1hvz6v003buywx9s6shmne","_id":"clm1hvz6w003muywx4gx56q0m"},{"post_id":"clm1hvz6j000uuywxfwpmgjl8","tag_id":"clm1hvz6w003euywx6pznaq10","_id":"clm1hvz6w003nuywxhttm0bog"},{"post_id":"clm1hvz6j000xuywxb1sj5ppn","tag_id":"clm1hvz6w003kuywxapre603w","_id":"clm1hvz6y0042uywx74ua2bid"},{"post_id":"clm1hvz6j000xuywxb1sj5ppn","tag_id":"clm1hvz6w003ouywx0jc2bykv","_id":"clm1hvz6y0044uywx4h255v8c"},{"post_id":"clm1hvz6j000xuywxb1sj5ppn","tag_id":"clm1hvz6w003ruywx2csn6ci4","_id":"clm1hvz6y0048uywxa7kj43sb"},{"post_id":"clm1hvz6j000xuywxb1sj5ppn","tag_id":"clm1hvz6x003vuywx864z459q","_id":"clm1hvz6y004auywx6jhaa5f7"},{"post_id":"clm1hvz6k0010uywxgoa7exrh","tag_id":"clm1hvz6r0023uywxalll10ly","_id":"clm1hvz6y004euywx9idu6o7s"},{"post_id":"clm1hvz6k0010uywxgoa7exrh","tag_id":"clm1hvz6y0045uywxaxzbc65i","_id":"clm1hvz6z004guywx8rsmh2yy"},{"post_id":"clm1hvz6m0015uywxhzhpe0yt","tag_id":"clm1hvz640005uywx895591fd","_id":"clm1hvz6z004juywx6uc713kt"},{"post_id":"clm1hvz6m0015uywxhzhpe0yt","tag_id":"clm1hvz68000auywxga8v16r4","_id":"clm1hvz6z004luywx1jnmbbar"},{"post_id":"clm1hvz6m0015uywxhzhpe0yt","tag_id":"clm1hvz6v003buywx9s6shmne","_id":"clm1hvz6z004ouywx41wycjaa"}],"Tag":[{"name":"C++","_id":"clm1hvz640005uywx895591fd"},{"name":"Java","_id":"clm1hvz68000auywxga8v16r4"},{"name":"JVM","_id":"clm1hvz6e000kuywx6dv26cjl"},{"name":"基础知识","_id":"clm1hvz6g000ouywx2zs35bor"},{"name":"Go","_id":"clm1hvz6i000tuywxgchs5k2e"},{"name":"GPM","_id":"clm1hvz6l0011uywx7kio3zza"},{"name":"计算机网络","_id":"clm1hvz6n001auywxbe1i1es5"},{"name":"IP数据报","_id":"clm1hvz6o001euywxc7yb1azm"},{"name":"数据库","_id":"clm1hvz6p001ruywxey68bufa"},{"name":"云计算领域","_id":"clm1hvz6r0023uywxalll10ly"},{"name":"K8S","_id":"clm1hvz6s0029uywxfe1h9zoy"},{"name":"Qt","_id":"clm1hvz6s002cuywxdkqcbemq"},{"name":"桌面开发","_id":"clm1hvz6s002huywxb5617f80"},{"name":"Tomcat","_id":"clm1hvz6t002juywxd4kdd6vo"},{"name":"Java Web","_id":"clm1hvz6u002nuywx7rq3cqbc"},{"name":"Servlet","_id":"clm1hvz6u002puywxhcqxab4n"},{"name":"Java EE","_id":"clm1hvz6u002ruywxg5tg0jgu"},{"name":"Spring","_id":"clm1hvz6u002vuywxhez5bhgx"},{"name":"操作系统","_id":"clm1hvz6v0037uywxcvmzdsih"},{"name":"回调","_id":"clm1hvz6v003buywx9s6shmne"},{"name":"工具类","_id":"clm1hvz6w003euywx6pznaq10"},{"name":"工作","_id":"clm1hvz6w003kuywxapre603w"},{"name":"问题记录","_id":"clm1hvz6w003ouywx0jc2bykv"},{"name":"线上事故","_id":"clm1hvz6w003ruywx2csn6ci4"},{"name":"MyBatis","_id":"clm1hvz6x003vuywx864z459q"},{"name":"Docker","_id":"clm1hvz6y0045uywxaxzbc65i"}]}}