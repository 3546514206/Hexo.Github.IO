<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人简历</title>
    <url>/2024/03/28/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/1.JPEG"><br><img src="/pic/%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/2.JPEG"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>个人简历</tag>
      </tags>
  </entry>
  <entry>
    <title>这些年背过的面试题——JVM篇</title>
    <url>/2024/03/23/%E8%BF%99%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94JVM%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; <strong>1、JVM运行时数据区域</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%BF%99%E4%BA%9B%E5%B9%B4%E8%83%8C%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94JVM%E7%AF%87/%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.webp" alt="内存划分"></p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>Heap(堆)：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配。堆细分：新生代、老年代，对于新生代又分为：Eden 区和 Surviver1 和 Surviver2 区。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>方法区：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 对于 JVM 的方法区也可以称之为永久区，它储存的是已经被 java 虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；当应用中的 Java 类过多时，比如 Spring 等一些使用动态代理的框架生成了很多类，如果占用空间超出了我们的设定值，就会发生元空间溢出。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>虚拟机栈：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 虚拟机栈是线程私有的，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的栈帧，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（局部变量表、操作数栈 、动态链接 、返回地址）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<p>&ensp;&ensp;&ensp;&ensp; 局部变量表：局部变量表是一组变量值存储空间，用来存放方法参数、方法内部定义的局部变量。底层是变量槽（variable slot）</p>
<p>&ensp;&ensp;&ensp;&ensp; 操作数栈：是用来记录一个方法在执行的过程中，字节码指令向操作数栈中进行入栈和出栈的过程。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种字节码指令往操作数栈中入栈和出栈。</p>
<p>&ensp;&ensp;&ensp;&ensp; 动态链接：因为字节码文件中有很多符号的引用，这些符号引用一部分会在类加载的解析阶段或第一次使用的时候转化成直接引用，这种称为静态解析；另一部分会在运行期间转化为直接引用，称为动态链接。</p>
<p>&ensp;&ensp;&ensp;&ensp; 返回地址（returnAddress）：类型（指向了一条字节码指令的地址）</p>
<p>&ensp;&ensp;&ensp;&ensp; JIT即时编译器（Just In Time Compiler），简称 JIT 编译器: </p>
<p>&ensp;&ensp;&ensp;&ensp; 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>一些值得反复回味的话</title>
    <url>/2024/03/16/%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E5%8F%8D%E5%A4%8D%E5%9B%9E%E5%91%B3%E7%9A%84%E8%AF%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; <strong>1、</strong> 好的婚姻先靠筛选，其次才是经营。一个人人品不行，骨子里带着自私狭隘，另一方无论想如何经营，都不可能经营出好的婚姻。在这个过程中，想要经营的那一方，他（她）的人生是舒展不开的——男人女人都一样。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>2、</strong> 不要试图去改变别人，你改变不了。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>3、</strong> 当世上所有人都把欲望当理想，把世故当成熟，把麻木当深沉，把怯懦当稳健，把油滑当智慧，那只能说明这个社会的底线已被击穿。所以，你们没有资格说我的勇敢是莽撞，执着是偏激，求知是无知，其情深幼稚。当那些兜售社会经验的流氓，朝我的梦想投来轻蔑一笑的时候，我会毫不犹豫的还你一句，“去**的”！</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>一个粗心的Java并发问题</title>
    <url>/2024/03/15/%E4%B8%80%E4%B8%AA%E7%B2%97%E5%BF%83%E7%9A%84Java%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%B8%AA%E7%B2%97%E5%BF%83%E7%9A%84Java%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.jpg" alt="问题描述"><br><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%B8%AA%E7%B2%97%E5%BF%83%E7%9A%84Java%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/%E9%97%AE%E9%A2%98%E8%AF%A6%E6%83%85.jpg" alt="问题详情"><br><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%B8%AA%E7%B2%97%E5%BF%83%E7%9A%84Java%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BE%AE%E8%A7%82%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5.jpg" alt="微观场景下的多线程执行情况"><br><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%B8%AA%E7%B2%97%E5%BF%83%E7%9A%84Java%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/%E4%BF%AE%E5%A4%8D%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81.jpg" alt="修复之后的代码"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>http是个高冷的女孩</title>
    <url>/2024/03/07/http%E6%98%AF%E4%B8%AA%E9%AB%98%E5%86%B7%E7%9A%84%E5%A5%B3%E5%AD%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E7%AC%94%E8%AE%B0/http%E6%98%AF%E4%B8%AA%E9%AB%98%E5%86%B7%E7%9A%84%E5%A5%B3%E5%AD%A9/http%E6%98%AF%E4%B8%AA%E9%AB%98%E5%86%B7%E7%9A%84%E5%A5%B3%E5%AD%A9.jpg" alt="http是个高冷的女孩"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>编程界等级划分</title>
    <url>/2024/03/05/%E7%BC%96%E7%A8%8B%E5%B1%8A%E7%AD%89%E7%BA%A7%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%95%8C%E7%AD%89%E7%BA%A7%E5%88%92%E5%88%86/%E7%BC%96%E7%A8%8B%E5%B1%8A%E4%BF%AE%E7%82%BC%E7%AD%89%E7%BA%A7.drawio.png" alt="编程界等级划分"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网发展的历程</title>
    <url>/2024/03/03/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%9A%84%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%91%E5%B1%95%E7%9A%84%E5%8E%86%E7%A8%8B/%E4%BA%92%E8%81%94%E7%BD%91%E5%8E%86%E5%8F%B2.jpeg" alt="粒子物理学"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>String引用传值问题</title>
    <url>/2024/03/01/String%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; Java 中是没有引用传递的，Java 中只有值传递。Java 中所谓的引用传递，也只是传递了”引用变量保存的地址值”。 Java 中判断”引用传递”有没有达到你预期的效果，前提要基于内存模型，并结合你的上下文，根据有没有利用引用变量”传递”的这个地址值去修改实际内存对象的数据来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.zjnu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 杨海波</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/2/29 20:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> String 引用传值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;out&quot;</span>;</span><br><span class="line">        <span class="comment">// str = &quot;out2&quot;;</span></span><br><span class="line">        f01(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工程实践表明，java 中没有引用传递，只有值传递。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Java 中所谓的引用传递，也只是传递了&quot;引用变量保存的地址值&quot;，如果无法做到</span></span><br><span class="line"><span class="comment">     * 根据这个引用指向的地址去修改实际对象的值，那么函数外部的实际对象无法被修改。</span></span><br><span class="line"><span class="comment">     * 特别的，String 是不可变对象：</span></span><br><span class="line"><span class="comment">     * 在 test01 这个例子中， 外部的 &#x27; str = &quot;out2&quot;;  这行代码只是在方法区的</span></span><br><span class="line"><span class="comment">     * 字符串常量池新建了一个字符串常量对象 &quot;out2&quot;,并将该对象的地址赋值给引用变</span></span><br><span class="line"><span class="comment">     * 量 str。内部的 str = &quot;in&quot;; 也是同理，但是当 f01 函数执行 str = &quot;in&quot;; </span></span><br><span class="line"><span class="comment">     * 这行代码时，引用变量保存的值（该值是尊从值传递的）是新的字符串常量对象 &quot;in&quot; </span></span><br><span class="line"><span class="comment">     * 的地址，当 f01 执行完毕，这个值尊从函数作用域规则消失了。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f01</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;in&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决办法如下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringWrapper</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWrapper</span>(<span class="string">&quot;out&quot;</span>);</span><br><span class="line">        f02(str);</span><br><span class="line">        System.out.println(str.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f02</span><span class="params">(StringWrapper str)</span> &#123;</span><br><span class="line">        str.value = <span class="string">&quot;in&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StringWrapper</span> &#123;</span><br><span class="line">        <span class="comment">// 实际值</span></span><br><span class="line">        <span class="keyword">public</span> String value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StringWrapper</span><span class="params">(String value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生之于服务端开发</title>
    <url>/2024/02/29/%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B9%8B%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 每个服务端开发人员都应该了解云原生。云原生视角，是一个全栈的服务端视角—自下而上从硬件设备到应用架构。在云原生视角下回过头来看服务端开发的问题，有点降维打击的感觉。现在看服务端开发的问题，再复杂的问题，也只是局部的一个点，很小的问题。</p>
]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算领域</tag>
      </tags>
  </entry>
  <entry>
    <title>做自己尊重的人</title>
    <url>/2024/02/16/%E5%81%9A%E8%87%AA%E5%B7%B1%E5%B0%8A%E9%87%8D%E7%9A%84%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 从物理学来说，无机的原子逆热力学第二定律出现生物是奇迹；从生物学来说，按进化规律产生遗传信息指导组装人类是奇迹。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 超越化学反应结果的每个个体都是值得珍惜的奇迹；超越动物欲望总和的每个个体都应做自己尊重的人。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 过去、现在、将来，能够完全知道个人行为和思想的只有自己；世界上很多文化借助宗教信仰来指导人们生活的信念和世俗行为；而对于无神论者—也就是大多数中国人—来说，自我尊重是重要的正道。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 在我加入社会后看到各种离奇现象，知道自己更多弱点和缺陷，可能还遇到小难大灾后，如何在诱惑和艰难中保持人性的尊严、赢得自己的尊重并非易事，却很值得。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 这不是：自恋、自大、自负、自夸、自欺、自闭、自怜，而是：自信、自豪、自量、自知、自省、自赎、自勉、自强。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 自尊支撑自由之精神、自主之工作、自在之生活。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 我希望：退休之日，我觉得职业中的自己值得尊重；迟暮之年，我感到生活中的自己值得尊重。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 在我所含全部原子再度按热力学第二定律回归自然之前，它们既经历过物性的神奇，也产生过人性的可爱。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信的5种方式</title>
    <url>/2024/02/04/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是类UNIX操作系统（如Linux）中常见的5种通讯机制。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F.jpeg" alt="进程间通信的5种方式"></p>
<p>&ensp;&ensp;&ensp;&ensp; 管道（Pipes）:管道是指连接两个或多个进程的输入和输出，常用于流式传输数据。例如，shell脚本通常使用管道运算符“|” 将命令链接在一起：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/syslog | grep &#x27;error&#x27; | less</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 消息队列（Message Queues）：消息队列通过允许进程以消息的形式交换数据来提供异步通信。写入队列的消息按先进先出的顺序处理。</p>
<p>例如，服务器可能将作业分派到队列中，消费守护进程从中拉取并独立处理。</p>
<p>&ensp;&ensp;&ensp;&ensp; 信号（Signals）：信号提供了一种通知系统，能够让进程立即收到重要事件，如被强制终止。例如，SIGKILL提供了一种可靠的方法来结束无响应的应用程序。</p>
<p>&ensp;&ensp;&ensp;&ensp; 信号量（Semaphores）：信号量是是一种在多线程环境中使用的同步机制，旨在确保多个线程不会同时访问同一块共享内存区域或其他临界资源。</p>
<p>&ensp;&ensp;&ensp;&ensp; 共享内存（Shared Memory）：共享内存是允许直接访问共享内存区域，以便多个进程可以高效地读取和修改数据，而无需复制。一个示例用例是处理大型图像帧的程序，其中多个进程可以同时访问和处理图像的不同部分。</p>
<p>&ensp;&ensp;&ensp;&ensp; 这些IPC机制有时被组合在一起以实现高效的进程通信。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS是如何工作的</title>
    <url>/2024/02/04/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 超文本传输协议安全（HTTPS）是超文本传输协议（HTTP）的扩展。</p>
<p>&ensp;&ensp;&ensp;&ensp; HTTPS使用传输层安全协议（TLS）来传输加密数据。如果数据在网上被劫持，劫持者得到的只是二进制代码。那么数据是如何加密和解密的呢？</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.jpeg" alt="HTTPS是如何工作的"></p>
<ul>
<li><p>步骤1 - 客户端（浏览器）和服务器建立TCP连接。</p>
</li>
<li><p>步骤2 - 客户端向服务器发送“客户端hello”。该消息包含一组必要的加密算法（密码套件）以及它可以支持的最新TLS版本。服务器通过发送“服务器hello”来响应，以便浏览器知道它是否支持算法和TLS版本。服务器然后向客户端发送SSL证书。证书包含公钥、主机名、过期日期等。客户端验证证书。</p>
</li>
<li><p>步骤3 - 在验证SSL证书后，客户端生成会话密钥并使用公钥对其进行加密。服务器接收加密的会话密钥并使用私钥进行解密。</p>
</li>
<li><p>步骤4 - 现在客户端和服务器都持有相同的会话密钥（对称加密），加密数据通过安全的双向通道进行传输。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 为什么HTTPS在数据传输期间会切换到对称加密？主要有两个原因：</p>
<ul>
<li><p>1、安全：非对称加密只适用于单向。这意味着如果服务器尝试将加密数据发送回客户端，任何人都可以使用公钥解密数据。</p>
</li>
<li><p>2、服务器资源：非对称加密增加了大量的数学开销。它不适合长会话中的数据传输。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ组件的封装</title>
    <url>/2024/01/31/MQ%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 之前给人封装的一套消息发送工具。类层次设计得挺有感觉的。</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/MQ%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/MQ%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85.png" alt="MQ组件的封装"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>理解JavaScript中的对象与new命令</title>
    <url>/2023/12/13/%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8Enew%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、对象是什么"><a href="#1、对象是什么" class="headerlink" title="1、对象是什么"></a><strong>1、对象是什么</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>&ensp;&ensp;&ensp;&ensp; 每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>&ensp;&ensp;&ensp;&ensp; 那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<ul>
<li>对象是单个实物的抽象。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<ul>
<li>对象是一个容器，封装了属性（property）和方法（method）。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<h4 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a><strong>2、构造函数</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>&ensp;&ensp;&ensp;&ensp; 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<p>&ensp;&ensp;&ensp;&ensp; JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>&ensp;&ensp;&ensp;&ensp; 构造函数就是一个普通的函数，但具有自己的特征和用法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>&ensp;&ensp;&ensp;&ensp; 构造函数的特点有两个。</p>
<ul>
<li><p>函数体内部使用了this关键字，代表了所要生成的对象实例。</p>
</li>
<li><p>生成对象的时候，必须使用new命令。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 下面先介绍new命令。</p>
<h4 id="3、New命令"><a href="#3、New命令" class="headerlink" title="3、New命令"></a><strong>3、New命令</strong></h4><h4 id="3-1、基本用法"><a href="#3-1、基本用法" class="headerlink" title="3.1、基本用法"></a><strong>3.1、基本用法</strong></h4><p>&ensp;&ensp;&ensp;&ensp; new命令的作用，就是执行构造函数，返回一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vobj = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">vobj.<span class="property">price</span> <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle得到了price属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，值是1000。</p>
<p>&ensp;&ensp;&ensp;&ensp; 使用new命令时，根据需要，构造函数也可以接受参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line"><span class="comment">// 不推荐的写法</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？</p>
<p>&ensp;&ensp;&ensp;&ensp; 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="title class_">Vehicle</span>();</span><br><span class="line">v <span class="comment">// undefined</span></span><br><span class="line">price <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的算法时间复杂度由小到大依次为</title>
    <url>/2023/12/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%94%B1%E5%B0%8F%E5%88%B0%E5%A4%A7%E4%BE%9D%E6%AC%A1%E4%B8%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)(立方阶) &lt; O(2^n) (指数阶) &lt; O(n!)</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="常见的算法时间复杂度"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子物理学大地图</title>
    <url>/2023/12/06/%E7%B2%92%E5%AD%90%E7%89%A9%E7%90%86%E5%AD%A6%E5%A4%A7%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%B2%92%E5%AD%90%E7%89%A9%E7%90%86%E5%AD%A6%E5%A4%A7%E5%9B%BE/%E7%B2%92%E5%AD%90%E7%89%A9%E7%90%86%E5%AD%A6.png" alt="粒子物理学"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>粒子物理</tag>
      </tags>
  </entry>
  <entry>
    <title>浅述Java对象的内存布局</title>
    <url>/2023/12/05/%E6%B5%85%E8%BF%B0Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; Java的实例对象、数组对象在内存中的组成包括如下三部分：对象头Hearder、实例数据、内存填充。示意图如下所示： </p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%B5%85%E8%BF%B0Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%93%E6%9E%84.png" alt="对象头结构"></p>
<ul>
<li>对象头：其主要包括两部分数据：Mark Word、Class对象指针。特别地对于数组对象而言，其还包括了数组长度数据。在64位的HotSpot虚拟机下，Mark Word占8个字节，其记录了Hash Code、GC信息、锁信息等相关信息；而Class对象指针则指向该实例的Class对象，在开启指针压缩的情况下占用4个字节，否则占8个字节；如果其是一个数组对象，则还需要4个字节用于记录数组长度信息。这里列出64位HotSpot虚拟机Mark Word的具体含义，以供参考。需要注意的是在下图的Mark Word中，左侧为高字节，右侧为低字节。</li>
</ul>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%B5%85%E8%BF%B0Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%86%E8%8A%82.jpg" alt="对象头细节"></p>
<ul>
<li><p>实例数据：用于存放该对象的实例数据。</p>
</li>
<li><p>内存填充：64位的HotSpot要求Java对象地址按8字节对齐，即每个对象所占内存的字节数必须是8字节的整数倍。因此Java对象需要通过内存填充来满足对齐要求。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一键部署单机K8S环境</title>
    <url>/2023/12/04/%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%8D%95%E6%9C%BAK8S%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">IP地址,默认为本机第一块网卡IP地址(不包含lo网卡)</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机名称,默认为当前主机名称</span></span><br><span class="line">hostName=master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker版本</span></span><br><span class="line">dockerVersion=20.10.6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Kubernetes版本</span></span><br><span class="line">k8sVersion=1.23.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pod网段</span></span><br><span class="line">podSubnet=&quot;10.244.0.0/16&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Service网段</span></span><br><span class="line">serviceSubnet=&quot;10.10.0.0/16&quot;</span><br><span class="line"></span><br><span class="line">networkCheck()&#123;</span><br><span class="line">ping -c 1 www.baidu.com &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">	action &quot;外网权限检查:&quot;</span><br><span class="line">else</span><br><span class="line">	action &quot;外网权限检查:&quot;</span><br><span class="line">	echo &quot;此脚本需要访问外网权限才可成功执行,退出脚本&quot;</span><br><span class="line">	exit 5</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line">cpuCheck()&#123;</span><br><span class="line">cpuCores=$(grep -c ^processor /proc/cpuinfo)</span><br><span class="line">if [[ $&#123;cpuCores&#125; -lt 2 ]];then</span><br><span class="line">	action &quot;CPU配置检查:&quot; false</span><br><span class="line">	echo -e &quot;\033[32m# 当前主机CPU $&#123;cpuCores&#125;核 &lt; 2核,不满足安装K8s最低需求,请检查配置\033[0m&quot;</span><br><span class="line">	exit 5</span><br><span class="line">else</span><br><span class="line">	action &quot;CPU配置检查:&quot; </span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menoryCheck()&#123;</span><br><span class="line">menorySize=$(free -m|grep -i mem|awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [[ $&#123;menorySize&#125; -lt 1800 ]];then</span><br><span class="line">        action &quot;内存配置检查:&quot; false</span><br><span class="line">        echo -e &quot;\033[32m# 当前主机内存 $&#123;menorySize&#125;M &lt; 1800M(2G),不满足安装K8s最低需求,请检查配置\033[0m&quot;</span><br><span class="line">	exit 5</span><br><span class="line">else</span><br><span class="line">        action &quot;内存配置检查:&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stopFirewall()&#123;</span><br><span class="line">systemctl disable firewalld --now &amp;&gt;/dev/null</span><br><span class="line">setenforce 0 &amp;&gt;/dev/null</span><br><span class="line">sed  -i.$(date +%F) -r &#x27;s/SELINUX=[ep].*/SELINUX=disabled/g&#x27; /etc/selinux/config</span><br><span class="line"></span><br><span class="line">if (grep SELINUX=disabled /etc/selinux/config) &amp;&gt;/dev/null;then</span><br><span class="line">	action &quot;关闭防火墙:&quot;</span><br><span class="line">else</span><br><span class="line">	action &quot;关闭防火墙:&quot; false</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hostName()&#123;</span><br><span class="line">if [[ -z $&#123;ip&#125; ]];then</span><br><span class="line">	ip=$(ip addr | grep -oP &#x27;(?&lt;=inet\s)\d+\.\d+\.\d+\.\d+&#x27;|egrep -v &quot;127.0.0.1|172.17.0.1&quot;|awk NR==1)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -z $&#123;hostName&#125; ]];then</span><br><span class="line">	hostName=&quot;$&#123;HOSTNAME&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if ! (egrep -w &quot;$&#123;ip&#125; +$&#123;hostName&#125;&quot; /etc/hosts) &amp;&gt;/dev/null;then</span><br><span class="line">	hostnamectl set-hostname $&#123;hostName&#125;</span><br><span class="line">	echo &quot;$&#123;ip&#125; $&#123;hostName&#125;&quot; &gt;&gt; /etc/hosts</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if (egrep -w &quot;$&#123;ip&#125; +$&#123;hostName&#125;&quot; /etc/hosts) &amp;&gt;/dev/null;then</span><br><span class="line">	action &quot;添加本地域名解析:&quot;</span><br><span class="line">else</span><br><span class="line">        action &quot;添加本地域名解析:&quot; false</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeSync()&#123;</span><br><span class="line">if ! (which ntpdate &amp;&gt;/dev/null);then</span><br><span class="line">	echo -e &quot;\033[32m# ntpdate未安装,开始进行安装....\033[0m&quot;</span><br><span class="line">	(yum -y install ntpdate) &amp;&gt;/dev/null;sleep 0.3</span><br><span class="line">	if (which ntpdate &amp;&gt;/dev/null);then</span><br><span class="line">		action &quot;ntpdate安装成功:&quot;</span><br><span class="line">	fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if (ntpdate ntp1.aliyun.com &amp;&gt;/dev/null);then</span><br><span class="line">	if ! (egrep &quot;ntpdate +ntp1.aliyun.com&quot; /var/spool/cron/root &amp;&gt;/dev/null);then</span><br><span class="line">		echo &quot;0 1 * * * ntpdate ntp1.aliyun.com&quot; &gt;&gt; /var/spool/cron/root</span><br><span class="line">	fi</span><br><span class="line">		action &quot;时间同步:&quot;</span><br><span class="line">else</span><br><span class="line">	action &quot;时间同步:&quot; false</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swapOff()&#123;</span><br><span class="line">swapoff --all</span><br><span class="line">sed -i -r &#x27;/swap/ s/^/#/&#x27; /etc/fstab</span><br><span class="line"></span><br><span class="line">if [[ $(free | grep -i swap | awk &#x27;&#123;print $2&#125;&#x27;) -eq 0 ]]; then</span><br><span class="line">    action &quot;关闭交换分区:&quot;</span><br><span class="line">else</span><br><span class="line">    action &quot;关闭交换分区:&quot; false</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addKernelArg()&#123;</span><br><span class="line">KernelArg=(&quot;net.bridge.bridge-nf-call-ip6tables&quot; &quot;net.bridge.bridge-nf-call-iptables&quot; &quot;net.ipv4.ip_forward&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断内核参数是否存在,如果不存在则添加</span></span><br><span class="line">for ((i=0;i&lt;$&#123;#KernelArg[@]&#125;;i++))do</span><br><span class="line">	if [[ $(sysctl -n $&#123;KernelArg[i]&#125;) -ne 1 ]];then</span><br><span class="line">		echo &quot;$&#123;KernelArg[i]&#125; = 1&quot; &gt;&gt; /etc/sysctl.d/kubernetes.conf</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">modprobe br_netfilter &amp;&gt;/dev/null</span><br><span class="line">sysctl -p /etc/sysctl.d/kubernetes.conf &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line">if [[ $(sysctl -n $&#123;KernelArg[0]&#125;) -eq 1 &amp;&amp; $(sysctl -n $&#123;KernelArg[1]&#125;) -eq 1 &amp;&amp; $(sysctl -n $&#123;KernelArg[2]&#125;) -eq 1 ]]; then</span><br><span class="line">		action &quot;添加内核参数:&quot;</span><br><span class="line">	else</span><br><span class="line">		action &quot;添加内核参数:&quot; false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipvs()&#123;</span><br><span class="line">if (command -v ipset &amp;&gt;/dev/null &amp;&amp; command -v ipvsadm &amp;&gt;/dev/null);then</span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4  </span><br><span class="line">EOF</span><br><span class="line">	chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">	/etc/sysconfig/modules/ipvs.modules</span><br><span class="line">else</span><br><span class="line">	echo -e &quot;\033[32m# ipvs未安装,开始进行安装....\033[0m&quot;</span><br><span class="line">	yum -y install ipset ipvsadm &amp;&gt;/dev/null</span><br><span class="line">	if (command -v ipset &amp;&gt;/dev/null &amp;&amp; command -v ipvsadm &amp;&gt;/dev/null);then</span><br><span class="line">		action &quot;ipvs安装成功:&quot;</span><br><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4  </span><br><span class="line">EOF</span><br><span class="line">	        chmod +x /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">        	/etc/sysconfig/modules/ipvs.modules</span><br><span class="line"></span><br><span class="line">	fi</span><br><span class="line">fi</span><br><span class="line">modprobe br_netfilter &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line">if (lsmod | grep -q -e ip_vs -e nf_conntrack_ipv4)&amp;&gt;/dev/null; then</span><br><span class="line">	action &quot;启用ipvs模块:&quot; </span><br><span class="line">else</span><br><span class="line">	action &quot;启用ipvs模块:&quot; false</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line">dockerInstall()&#123;</span><br><span class="line">if ! (command -v docker &amp;&gt;/dev/null);then</span><br><span class="line">	echo -e &quot;\033[32m# Docker未安装,开始进行安装....\033[0m&quot;</span><br><span class="line">	(curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo) &amp;&gt;/dev/null</span><br><span class="line">	(wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo) &amp;&gt;/dev/null</span><br><span class="line">	(yum install -y yum-utils) &amp;&gt;/dev/null</span><br><span class="line">	(yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo) &amp;&gt;/dev/null</span><br><span class="line">	(yum install docker-ce-$&#123;dockerVersion&#125; docker-ce-cli-$&#123;dockerVersion&#125; -y) &amp;&gt;/dev/null</span><br><span class="line">	if (command -v docker &amp;&gt;/dev/null);then</span><br><span class="line">		action &quot;Docker安装成功:&quot;</span><br><span class="line">	else</span><br><span class="line">		action &quot;Docker安装成功:&quot; false</span><br><span class="line">	fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /etc/docker &amp;&gt;/dev/null</span><br><span class="line">if [[ -f /etc/docker/daemon.json ]];then</span><br><span class="line">	mv /etc/docker/daemon.json&#123;,.$(date +%F)&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://aoewjvel.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">(systemctl enable docker --now) &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line">if [[ -f /etc/docker/daemon.json ]];then</span><br><span class="line">	action &quot;Docker镜像加速源:&quot;</span><br><span class="line">else</span><br><span class="line">	action &quot;Docker镜像加速源:&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k8sInstall()&#123;</span><br><span class="line">k8scommand=(&quot;kubeadm&quot; &quot;kubelet&quot; &quot;kubectl&quot;)</span><br><span class="line"></span><br><span class="line">if [[ -f /etc/yum.repos.d/kubernetes.repo ]];then</span><br><span class="line">	mv /etc/yum.repos.d/kubernetes.repo&#123;,.$(date +%F)&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[32m# 正在安装K8S,请耐心等待......\033[0m&quot;</span><br><span class="line">(yum -y install --setopt=obsoletes=0 kubeadm-$&#123;k8sVersion&#125; kubelet-$&#123;k8sVersion&#125; kubectl-$&#123;k8sVersion&#125;) &amp;&gt;/dev/null</span><br><span class="line">systemctl enable kubelet.service --now  &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line">for ((i=0;i&lt;$&#123;#k8scommand[@]&#125;;i++))do</span><br><span class="line">	if (command -v $&#123;k8scommand[i]&#125; &amp;&gt;/dev/null);then</span><br><span class="line">		action &quot;安装$&#123;k8scommand[i]&#125;组件:&quot;</span><br><span class="line">	else</span><br><span class="line">		action &quot;安装$&#123;k8scommand[i]&#125;组件:&quot; false</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k8sInit()&#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过hosts文件获取IP地址</span></span><br><span class="line">if [[ -z $&#123;ip&#125; ]];then</span><br><span class="line">	ip=$(grep $&#123;HOSTNAME&#125; /etc/hosts|awk &#x27;&#123;print $1&#125;&#x27;| awk NR==1)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -f /root/kubeadm-config.yaml ]];then</span><br><span class="line">	mv /root/kubeadm-config.yaml&#123;,.$(date +%F)&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /root/kubeadm-config.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: $&#123;ip&#125;</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: $&#123;hostName&#125;</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: $&#123;k8sVersion&#125;</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: $&#123;serviceSubnet&#125;</span><br><span class="line">  podSubnet: $&#123;podSubnet&#125;</span><br><span class="line">scheduler: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs</span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">if [[ -f /root/kubeadm-config.yaml ]];then</span><br><span class="line">        action &quot;生成K8s初始化文件:&quot;</span><br><span class="line">else</span><br><span class="line">        action &quot;生成K8s初始化文件:&quot; false</span><br><span class="line">fi</span><br><span class="line">echo -e &quot;\033[32m# K8s初始化中,时间可能较长,可以使用 tailf k8s_init.log 可追踪整个过程....\033[0m&quot;</span><br><span class="line">echo </span><br><span class="line">kubeadm init --config /root/kubeadm-config.yaml --ignore-preflight-errors=SystemVerification &amp;&gt;k8s_init.log</span><br><span class="line">if [[ $? -eq 0 ]];then</span><br><span class="line">	action &quot;K8s初始化:&quot;</span><br><span class="line">	mkdir -p $HOME/.kube</span><br><span class="line">	sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">	sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">else</span><br><span class="line">	action &quot;K8s初始化:&quot; false</span><br><span class="line">	exit 5</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k8sNetwork()&#123;</span><br><span class="line">(wget -O /root/calico.yaml https://gitee.com/qinziteng/K8S/raw/master/YMAL/calico.yaml) &amp;&gt;/dev/null</span><br><span class="line">(kubectl apply -f  /root/calico.yaml) &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line">if [[ $? -eq 0 ]];then</span><br><span class="line">	action &quot;K8s网络插件:&quot;</span><br><span class="line">else</span><br><span class="line">	action &quot;K8s网络插件:&quot;  false</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k8sTaint()&#123;</span><br><span class="line">(kubectl taint nodes --all node-role.kubernetes.io/master-) &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line">if [[ $? -eq 0 ]];then</span><br><span class="line">        action &quot;设置Master节点可调度:&quot;</span><br><span class="line">else</span><br><span class="line">        action &quot;设置Master节点可调度:&quot; false</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">confCheck()&#123;</span><br><span class="line">cpuCheck</span><br><span class="line">menoryCheck</span><br><span class="line">networkCheck</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initEnv()&#123;</span><br><span class="line">clear;echo &quot;一键部署单机版K8S脚本&quot;</span><br><span class="line">hostName</span><br><span class="line">stopFirewall</span><br><span class="line">swapOff</span><br><span class="line">timeSync</span><br><span class="line">ipvs</span><br><span class="line">addKernelArg</span><br><span class="line">dockerInstall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k8s()&#123;</span><br><span class="line">clear;k8sInstall</span><br><span class="line">k8sInit</span><br><span class="line">k8sNetwork</span><br><span class="line">k8sTaint</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo -e &quot;\033[32m# K8s单机版部署完成,等待Pod全部运行成功即可使用 使用 kubectl get pods -n kube-system 关注Pod状态...\033[0m&quot;</span><br><span class="line">bash</span><br><span class="line">&#125;</span><br><span class="line">confCheck</span><br><span class="line">initEnv</span><br><span class="line">k8s</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>K8S</tag>
        <tag>安装部署</tag>
      </tags>
  </entry>
  <entry>
    <title>三高：高可用、高性能、高扩展</title>
    <url>/2023/12/04/%E4%B8%89%E9%AB%98%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 我们经常被要求设计高可用性、高可扩展性和高性能。上图包含了针对“三高”的常见解决方案。</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E4%B8%89%E9%AB%98%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E6%89%A9%E5%B1%95/640.gif" alt="git 分支模型"></p>
<p><strong>高可用性</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 这意味着我们需要确保系统高水平的正常运行时间。我们经常将设计目标描述为“3个9”或“4个9”。“4个9”，即99.99%的正常运行时间，意味着服务每天只能停机8.64秒。 为了实现高可用性，我们需要在系统中增加冗余节点。 有以下几种方法可以做到这一点：</p>
<ul>
<li><p>hot-hot结构：两个实例接收相同的输入并将输出发送到下游服务。如果其中一个实例停机，另一个实例可以立即接管。由于双方都向下游发送输出，下游系统需要进行重复数据删除。</p>
</li>
<li><p>hot-warm结构：两个实例接收相同的输入，只有hot实例将输出发送到下游服务。如果hot实例发生故障，warm实例将接管并开始向下游服务发送输出。</p>
</li>
<li><p>single-leader Cluster：一个leader实例从上游系统接收数据并复制到其他副本。</p>
</li>
<li><p>Leaderless cluster：在这种类型的集群中没有领导者。任何写入操作都会被复制到其他实例。只要写入实例的数量加上读取实例的数量大于实例的总数，我们就会得到有效数据。</p>
</li>
</ul>
<p><strong>高性能</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 这意味着服务需要在一段时间内处理大量请求。常用的指标是QPS（每秒查询数）或TPS（每秒事务数）。为了实现高性能，我们经常在架构中添加缓存，这样请求就可以在不命中数据库或磁盘等较慢的I&#x2F;O设备的情况下返回。我们还可以增加计算密集型任务的线程数量。然而，添加太多线程可能会降低性能。最后，我们需要识别系统中的瓶颈并提高其性能。使用异步处理通常可以有效地隔离繁重的组件。</p>
<p><strong>高可扩展性</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 这意味着系统可以快速轻松地扩展以容纳更多容量（横向可扩展性）或更多功能（纵向可扩展性）。通常，我们会观察响应时间以决定是否需要扩展系统。为了实现高可扩展性，重要的是将服务的职责分离。为此，微服务被广泛采用。我们还利用服务注册表和负载均衡器将请求路由到适当的实例。</p>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Hotspot源码目录结构</title>
    <url>/2023/12/04/Hotspot%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Hotspot%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/Hotspot%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Hotspot源码目录结构"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>数学地图</title>
    <url>/2023/12/02/%E6%95%B0%E5%AD%A6%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6%E5%9C%B0%E5%9B%BE/TheMapofMathematics.png" alt="git 分支模型"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>对修饰符final和static的浅析</title>
    <url>/2023/12/01/%E5%AF%B9%E4%BF%AE%E9%A5%B0%E7%AC%A6final%E5%92%8Cstatic%E7%9A%84%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1、static修饰符</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 被static修饰的变量和方法，被类的所有实例所共享。加载类时只分配一次内存。</p>
<ul>
<li>静态变量：可以直接通过类名来访问 Person.a;</li>
<li>态方法：可以直接通过类名来访问 Person.say();静态方法内，可以访问静态变量，但是不能使用this关键字且不能访问实例变量，因为被所有实例所共有,无法判断属于哪个实例对象；</li>
<li>静态代码块：java虚拟机在加载类时就执行静态代码块。</li>
</ul>
<p><strong>2、final修饰符</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 有final修饰表示最终（不可再修改）的意思：</p>
<ul>
<li>final类：不能被继承（即没有子类）；</li>
<li>final方法：不能被子类的方法覆盖（final不用来修饰构造方法，父类与子类之间的构造方法不存在覆盖关系，final修饰是没有意义的）；</li>
<li>final修饰的变量：即常量，常量只能被赋值一次，之后不能改变。</li>
</ul>
<p><strong>3、静态常量</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 静态常量属于编译时常量（final static int a&#x3D;2*3;）在编译的时就能计算出具体的值)，在编译的时候将这个值就放入到常量池中，a被访问时类是不会被初始化的（这是类的被动使用）。访问类的静态变量或静态方法的时候类会被初始化（这是类的主动使用）。而静态变量只会在类初始化的时候才会被赋值。具体细节请参考“类的生命周期”：加载（堆区、方法区）——连接（验证、准备（静态变量分配内存、设置默认初始值为0）、解析（符号引用替换为直接引用，即指针指向方法区的内存位置））——初始化（程序对类或接口主动使用的时候才会被初始化）。</p>
<p><strong>4、类的初始化化时机</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 类的初始化阶段java虚拟机会为类的static静态变量赋予初始值(这和准备阶段设置默认初始值为0是不一样的)。只有类的主动使用才会初始化类。</p>
<p><strong>4.1、类的主动使用</strong></p>
<ul>
<li><p>创建类的实例：用new语句创建实例 Person ps&#x3D;new Person()。</p>
</li>
<li><p>调用类的静态变量或对静态变量赋值：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person&#123; </span><br><span class="line">    //这和final static int a=2*3;是有区别的</span><br><span class="line">    static int a=2*3;  </span><br><span class="line">    </span><br><span class="line">    static&#123;  </span><br><span class="line">        //Java在定义一个类的时候里面只能放方法和属性，这是规定死了的。System.out.println()是在调用一个叫println的函数，这里是函数的调用而不是类里面定义一个函数。所以需要用static代码块</span><br><span class="line">        System.out.println(&quot;init Person&quot;); //static声明的静态代码块，使得类在初始化的时候会被调用而不需要创建实例对象。它这时候就不在任何一个方法中。</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 调用的时候写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这样就可以在不new一个Person实例的情况下，来初始化Person类了。调用类的静态方法</span><br><span class="line">System.out.println(&quot;a=&quot;+Person.a);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用java API中的反射方法：Class.forName(“Person”);</li>
<li>初始化子类的时候会先初始化父类(但”父类”是接口的时候，不会先初始化它所实现的接口的，只有在程序在使用接口的静态变量时才会使静态接口初始化)。</li>
<li>Java 虚拟机启动时被标明为启动类的类。</li>
</ul>
<p><strong>4.2、类的被动使用</strong></p>
<ul>
<li>final 类型的静态变量在编译的时候能计算出值（即编译时常量，在编译的时候将这个值就放入到常量池中了）：注： final类型的静态变量在编译的时候不能计算出变量的值(即运行时常量)的时候是会被初始化的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//变量a是编译时常量</span><br><span class="line">final static int a=2*3;                 </span><br><span class="line">//变量a不是是编译时常量（即运行时常量）</span><br><span class="line">final static int a=(int)Math.random();  </span><br></pre></td></tr></table></figure>

<ul>
<li>“父类”是接口的时候，不会先初始化它所实现的接口的，只有在程序在使用接口的静态变量时才会使静态接口初始化。</li>
<li>ClassLoader类的loadClass(“Person”)方法的时候，只是对类的加载，不是初始Class.forName(“Person”);才会初始化。</li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript执行上下文</title>
    <url>/2023/11/30/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1、什么是执行上下文？</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 简而言之，执行上下文是计算和执行 JavaScript 代码环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。一个执行上下文包含：scope(作用域)、variable object(变量对象)、this value(this 值)。</p>
<p><strong>2、执行上下文的类型</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; JavaScript 中有三种执行上下文类型：</p>
<ul>
<li>全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li>
<li>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li>
<li>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</li>
</ul>
<p><strong>3、执行栈</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）的数据结构，被用来存储代码运行时创建的所有执行上下文。</p>
<p>&ensp;&ensp;&ensp;&ensp; 当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行处于栈顶的执行上下文的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。让我们通过下面的代码示例来理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = &#x27;Hello World!&#x27;;</span><br><span class="line"></span><br><span class="line">function first() &#123;</span><br><span class="line">  console.log(&#x27;Inside first function&#x27;);</span><br><span class="line">  second();</span><br><span class="line">  console.log(&#x27;Again inside first function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;</span><br><span class="line">  console.log(&#x27;Inside second function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">console.log(&#x27;Inside Global Execution Context&#x27;);</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 first() 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/%E8%BF%90%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="IP报文结构"></p>
<p>&ensp;&ensp;&ensp;&ensp; 当从 first() 函数内部调用 second() 函数时，JavaScript 引擎为 second() 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 second() 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 first() 函数的执行上下文。当 first() 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<p><strong>4、怎么创建执行上下文</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 到现在，我们已经看过 JavaScript 怎样管理执行上下文了，现在让我们了解 JavaScript 引擎是怎样创建执行上下文的。创建执行上下文有两个阶段：1） 创建阶段 和 2） 执行阶段。</p>
<p><strong>4.2、执行上下文的创建阶段（ES5及其以后规范）</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 创建阶段做三件事：1）this 值的决定，即我们所熟知的 this 绑定。2）创建词法环境组件。3）创建变量环境组件。</p>
<p>&ensp;&ensp;&ensp;&ensp; 所以执行上下文的伪代码表示可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2.1、this 绑定</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let foo = &#123;           // PS:对象的花括号理解为作用域可能不太妥，理解为&quot;属于&quot;也许更为准确</span><br><span class="line">  baz: function() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.baz();   // &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span><br><span class="line">             // 对象 &#x27;foo&#x27; 调用</span><br><span class="line">let bar = foo.baz;</span><br><span class="line"></span><br><span class="line">bar();       // &#x27;this&#x27; 指向全局 window 对象，因为</span><br><span class="line">             // 没有指定引用对象</span><br></pre></td></tr></table></figure>

<p><strong>4.2.2、词法环境</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 官方的 ES6 文档把词法环境定义为：</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用outer词法环境的空值组成。</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 简单来说词法环境是一种持有标识符—变量映射的结构。（这里的标识符指的是变量&#x2F;函数的名字，而变量是对实际对象[包含函数类型对象]或原始数据的引用）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 现在，在词法环境的内部有两个组件：(1) 环境记录器：环境记录器是存储变量和函数声明的实际位置。 (2) 一个外部环境的引用：外部环境的引用意味着它可以访问其父级词法环境（作用域）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 词法环境有两种类型：1）全局词法环境（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object&#x2F;Array&#x2F;等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this的值指向全局对象。2）函数词法环境，函数内部用户定义的变量存储在函数环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</p>
<p>&ensp;&ensp;&ensp;&ensp; 环境记录器也有两种类型：1）声明式环境记录器存储变量、函数和参数；2）对象环境记录器用来定义出现在全局上下文中的变量和函数的关系。简而言之，在全局环境中，环境记录器是对象环境记录器。在函数环境中，环境记录器是声明式环境记录器。</p>
<p>&ensp;&ensp;&ensp;&ensp; 对于函数环境，声明式环境记录器还包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。抽象地讲，词法环境在伪代码中看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;    // 全局词法环境的外部环境引用为null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2.3、变量环境</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 变量环境同样是一个词法环境，所以它有着上面定义的词法环境的所有属性，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。在 ES6 中，词法环境组件和变量环境组件的一个不同点就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。我们看点样例代码来理解上面的概念：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 20;</span><br><span class="line">const b = 30;</span><br><span class="line">var c;</span><br><span class="line"></span><br><span class="line">function multiply(e, f) &#123;</span><br><span class="line"> var g = 20;</span><br><span class="line"> return e * f * g * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(20, 30);</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 运行上述JS代码所创建的执行上下文的伪代码看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局执行上下文</span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  // this 绑定  </span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">  // 词法环境</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    // 环境记录器(对象环境记录器)  </span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 标识符绑定，词法环境对应的是let,const还有函数声明</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    // 外部环境引用(全局执行上下文的外部环境引用都是null)</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 变量环境</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    // 环境记录器(全局执行上下文的词法环境和变量环境的环境记录器都是对象环境记录器)  </span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 函数执行上下文</span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    </span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 只有遇到调用函数 multiply 时，函数执行上下文才会被创建。可能你已经注意到 let 和 const 定义的变量并没有关联任何值，但 var 定义的变量被设成了 undefined。这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）。这就是为什么你可以在声明之前访问 var 定义的变量（虽然是 undefined），但是在声明之前访问 let 和 const 的变量会得到一个引用错误。这就是我们说的变量声明提升。</p>
<p><strong>4.3、执行上下文的执行阶段</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 这是整篇文章中最简单的部分。在此阶段，完成对所有这些变量的分配，最后执行代码。需要注意的是：在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC层次关系图</title>
    <url>/2023/11/30/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 总体而言，JDBC包含以下几大角色 : Driver、DriverManager、Connection、Statement、ResultSet。这几大角色之间的层次关系如下图所示：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="JDBC层次关系结构"></p>
<p>&ensp;&ensp;&ensp;&ensp; Connection表示与特定数据库的连接，可以获取到数据库的一些信息，这些信息包括：其表信息，应该支持的SQL语法，数据库内有什么存储过程，此链接功能的信息等等。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/Connecyion.png" alt="Connection"></p>
<p>&ensp;&ensp;&ensp;&ensp; Statement 的功能在于根据传入的sql语句，将传入sql经过整理组合成数据库能够识别的sql语句(对于静态的sql语句，不需要整理组合；而对于预编译sql语句和批量语句，则需要整理)，然后传递sql请求，之后会得到返回的结果。对于查询sql，结果会以ResultSet的形式返回。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/statement.png" alt="Connection"></p>
<p>&ensp;&ensp;&ensp;&ensp; 当Statement查询sql执行后，会得到ResultSet对象，ResultSet对象是sql语句查询的结果，作为数据库结果的映射，其映射关系如下图所示。ResultSet对从数据库返回的结果进行了封装，使用迭代器的模式逐条取出结果集中的记录。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/ResultSet.png" alt="ResultSet"></p>
<p>&ensp;&ensp;&ensp;&ensp; 工作时序图：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JDBC%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发体系</title>
    <url>/2023/11/29/%E5%89%8D%E6%AE%B5%E5%BC%80%E5%8F%91%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BD%93%E7%B3%BB/%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.jpg" alt="现代前端开发"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>技术体系</tag>
      </tags>
  </entry>
  <entry>
    <title>前端量子特效</title>
    <url>/2023/11/29/%E5%89%8D%E7%AB%AF%E9%87%8F%E5%AD%90%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E7%AC%94%E8%AE%B0/%E9%9A%8F%E7%AC%94/%E5%89%8D%E7%AB%AF%E9%87%8F%E5%AD%90%E7%89%B9%E6%95%88/%E9%87%8F%E5%AD%90%E7%BA%A0%E7%BC%A0%E7%89%B9%E6%95%88.gif" alt="前端量子特效"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java技术全栈图</title>
    <url>/2023/11/29/Java%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%E6%8A%80%E6%9C%AF%E5%85%A8%E6%A0%88%E5%9B%BE/Java%E4%BD%93%E7%B3%BB%E5%9B%BE%E5%86%8C.jpg" alt="Java技术全栈图"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>技术体系</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的队列</title>
    <url>/2023/11/28/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 队列是系统中广泛使用的流行数据结构。上图显示了我们经常使用的4种不同类型的队列。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%9F%E5%88%97/640.gif" alt="常见的队列"></p>
<ul>
<li><strong>简单的FIFO队列</strong></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 简单队列遵循 FIFO（先进先出）。新元素插入到队列的尾部，元素从队列的头部移除。如果我们想在收到付款响应时向用户发送电子邮件通知，我们可以使用 FIFO 队列。电子邮件将以与付款响应相同的顺序发送。</p>
<ul>
<li><strong>环形队列</strong></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 环形队列也称为环形缓冲区或环形缓冲区。它的最后一个元素链接到第一个元素。插入发生在队列的前端，删除发生在队列的末尾。</p>
<p>&ensp;&ensp;&ensp;&ensp; 一个著名的实现是LMAX的低延迟环形缓冲区。交易组件通过环形缓冲区相互通信。这是在内存中实现的，速度非常快。</p>
<ul>
<li><strong>优先队列</strong></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 优先级队列中的元素具有预定义的优先级。我们从队列中取出具有最高（或最低）优先级的元素。在幕后，它使用最大堆或最小堆实现，其中具有最大或最低优先级的元素位于堆的根。</p>
<p>&ensp;&ensp;&ensp;&ensp; 一个典型的用例是将病情最严重的患者分配到急诊室，而将其他患者分配到普通病房。</p>
<ul>
<li><strong>Deque</strong></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; Deque 也称为双端队列。插入和删除可以在头部和尾部同时发生。Deque 支持 FIFO 和 LIFO（后进先出），因此我们可以使用它来实现堆栈数据结构。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的左值（Lvalues）和右值（Rvalues）</title>
    <url>/2023/11/24/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; C++ 中有两种类型的表达式：</p>
<ul>
<li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java资源大全</title>
    <url>/2023/11/16/Java%E8%B5%84%E6%BA%90%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java资源大全中文版"><a href="#Java资源大全中文版" class="headerlink" title="Java资源大全中文版"></a>Java资源大全中文版</h1><p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/akullpp/awesome-java">awesome-java</a> 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 <a href="http://www.importnew.com/14429.html">ImportNew</a>。</p>
<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>
<hr>
<h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul>
<li>基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。</li>
<li>整理后的内容，将收录在<a href="http://www.importnew.com/">伯乐在线资源频道</a>。可参考已整理的内容：<ul>
<li>《<a href="http://www.importnew.com/owner/">OWNER：Java配置文件解决方案</a>》</li>
<li>《<a href="http://www.importnew.com/spring-boot/">Spring Boot：简化Spring应用初始搭建以及开发过程</a>》</li>
<li>《<a href="http://www.importnew.com/sonarqube/">SonarQube：开源的代码质量管理工具</a>》</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><!-- 从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。

不过加入前，有几个小要求：

* 英文还不错，能读懂英文并用自己的话复述；
* 在用 Java；

如有兴趣，请加 QQ：50872495。加 Q 时请注明「Java大全」 -->

<hr>
<h3 id="如何为列表贡献新资源？"><a href="#如何为列表贡献新资源？" class="headerlink" title="如何为列表贡献新资源？"></a>如何为列表贡献新资源？</h3><p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p>
<ul>
<li>请确保推荐的资源自己使用过</li>
<li>提交PR时请注明推荐理由</li>
</ul>
<p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p>
<p>感谢您的贡献！</p>
<hr>
<h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul>
<li><p>维护者：<a href="https://github.com/tangyouhua">tangyouhua</a></p>
</li>
<li><p>贡献者：<a href="https://github.com/tangyouhua">tangyouhua</a>、<a href="https://github.com/kingzone">kingzone</a>、<a href="https://github.com/llhua2329">llhua2329</a>、<a href="https://github.com/BadCoderChou">BadCoderChou</a>、<a href="http://www.importnew.com/members/anankun/">anankun</a>、<a href="http://www.importnew.com/members/jianghehe/">贺贺</a>、<a href="http://www.importnew.com/members/petra/">大彭</a>、<a href="https://github.com/wing00yf/">superXiaoFan</a>、<a href="http://www.importnew.com/members/3951356/">javayrf</a>、<a href="http://www.importnew.com/members/John%20Smith/">John Smith</a>、<a href="http://www.importnew.com/members/jaler/">Jaler</a>、<a href="http://www.importnew.com/members/fdconan/">JM</a>、<a href="http://www.importnew.com/members/zy124348985/">dreamkidd</a>、<a href="http://www.importnew.com/members/cheenlie">cheenlie</a>、<a href="http://www.importnew.com/members/zhangQian1991">zhangQian1991</a>、<a href="http://www.importnew.com/members/wt726553124/">王涛</a>、<a href="http://www.importnew.com/members/xun_cui">马</a>、<a href="http://www.importnew.com/members/xuhf_1988/">vvkee</a>、<a href="http://www.importnew.com/members/yangxy81118">凝枫</a>、<a href="https://github.com/luhaixun">haixunlu</a>、<a href="http://www.importnew.com/members/milly/">milly</a>、<a href="http://www.importnew.com/members/xuhf_1988/">Hodur</a>、<a href="http://www.importnew.com/members/FakeHank">FakeHank</a>、<a href="http://www.importnew.com/members/%E8%BF%9E%E4%B9%90/">连乐</a>、<a href="http://www.importnew.com/members/UncleTim/">UncleTim</a>、<a href="http://www.importnew.com/members/sunbiaobiao">sunbiaobiao</a>、<a href="http://www.importnew.com/members/wx2702327993/">zhiguo</a>、<a href="http://www.importnew.com/members/zhongjianno1/">光光头去打酱油</a>、<a href="http://www.importnew.com/members/TonyAaron/">云中游</a>、<a href="http://www.importnew.com/members/zemo/">Zemo</a>、<a href="https://github.com/sdcuike">sdcuike</a>、<a href="https://github.com/danielwii">danielwii</a>、<a href="http://www.importnew.com/members/q1118024125/">oneDay</a>、<a href="https://github.com/dfghj44444">邢敏</a>、<a href="https://github.com/heikehuan">heikehuan</a>、<a href="https://github.com/fgcui1204">fgcui1204</a>、<a href="https://github.com/wenxueliu">wenxueliu</a>、<a href="https://github.com/node">Gentle Yang</a>、<a href="http://www.importnew.com/author/huangxiaofei/">黄小非</a>、<a href="http://www.importnew.com/members/wtgn1m1/">wangtg</a>、<a href="http://www.importnew.com/members/2937134480/">百焱</a>、<a href="http://www.importnew.com/members/2480130384/">胡不GUI</a>、<a href="http://www.importnew.com/members/mtHzm/">Another_mt</a>、<a href="http://www.importnew.com/members/adonis/">Rainbow</a>、<a href="http://www.importnew.com/members/menghuanqiqi">super^糖</a>、<a href="http://www.importnew.com/members/huangyuliang/">黄余粮</a>、<a href="http://www.importnew.com/members/sunbojian100/">Sun</a>、<a href="https://github.com/SoberChina">李伟高</a>、<a href="https://github.com/q977734161">lixiaobao</a>、<a href="https://github.com/XuZhongCN">許中</a>、<a href="https://github.com/eiDear">eiDear</a>、<a href="https://github.com/click33">click33</a>、You</p>
</li>
</ul>
<p>注：名单不分排名，不定期补充更新</p>
<hr>
<!-- ### 奖励计划

虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：

* 整理超过 20 个资源后，可在伯乐在线上开通打赏；
* 每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；
* [奖励详情](http://www.importnew.com/rewards/)

* * * -->
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#awesome-java-cn">Java资源大全中文版</a><ul>
<li><a href="#ancients">古董级工具</a></li>
<li><a href="#build">构建工具</a></li>
<li><a href="#bytecode-manipulation">字节码操作</a></li>
<li><a href="#cluster-management">集群管理</a></li>
<li><a href="#code-analysis">代码分析</a></li>
<li><a href="#compiler-compiler">编译器生成工具</a></li>
<li><a href="#configuration">外部配置工具</a></li>
<li><a href="#constraint-satisfaction-problem-solver">约束满足问题求解程序</a></li>
<li><a href="#continuous-integration">持续集成</a></li>
<li><a href="#csv">CSV解析</a></li>
<li><a href="#data-structures">数据结构</a></li>
<li><a href="#database">数据库</a></li>
<li><a href="#date-and-time">时间日期工具库</a></li>
<li><a href="#dependency-injection">依赖注入</a></li>
<li><a href="#development">开发流程增强工具</a></li>
<li><a href="#distributed-applications">分布式应用</a></li>
<li><a href="#distributed-databases">分布式数据库</a></li>
<li><a href="#distribution">发布</a></li>
<li><a href="#document-processing">文档处理工具</a></li>
<li><a href="#functional-programming">函数式编程</a></li>
<li><a href="#game-development">游戏开发</a></li>
<li><a href="#gui">GUI</a></li>
<li><a href="#high-performance">高性能计算</a></li>
<li><a href="#ide">IDE</a></li>
<li><a href="#imagery">图像处理</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#jvm-and-jdk">JVM与JDK</a></li>
<li><a href="#languages">基于JVM的语言</a></li>
<li><a href="#logging">日志</a></li>
<li><a href="#machine-learning">机器学习</a></li>
<li><a href="#messaging">消息传递</a></li>
<li><a href="#miscellaneous">杂项</a></li>
<li><a href="#monitoring">应用监控工具</a></li>
<li><a href="#native">原生开发库</a></li>
<li><a href="#natural-language-processing">自然语言处理</a></li>
<li><a href="#networking">网络</a></li>
<li><a href="#orm">ORM</a></li>
<li><a href="#pdf">PDF</a></li>
<li><a href="#performance-analysis">性能分析</a></li>
<li><a href="#reactive-libraries">响应式开发库</a></li>
<li><a href="#rest-frameworks">REST框架</a></li>
<li><a href="#science">科学计算与分析</a></li>
<li><a href="#search">搜索引擎</a></li>
<li><a href="#security">安全</a></li>
<li><a href="#serialization">序列化</a></li>
<li><a href="#server">应用服务器</a></li>
<li><a href="#template-engine">模板引擎</a></li>
<li><a href="#testing">测试</a></li>
<li><a href="#utility">通用工具库</a></li>
<li><a href="#web-crawling">网络爬虫</a></li>
<li><a href="#web-frameworks">Web框架</a></li>
<li><a href="#Business-Process-Management">业务流程管理套件</a></li>
</ul>
</li>
<li><a href="#resources">资源</a><ul>
<li><a href="#communities">社区</a></li>
<li><a href="#influential-books">有影响力的书</a></li>
<li><a href="#podcasts">播客</a></li>
<li><a href="#weibo-weixin">微博、微信公众号</a></li>
<li><a href="#twitter">Twitter</a></li>
<li><a href="#websites">知名网站</a></li>
</ul>
</li>
</ul>
<h2 id="ancients">古董级工具</h2>

<p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-ant/">Apache Ant</a>：基于XML的构建管理工具。<a href="http://ant.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/cglib/">cglib</a>：字节码生成库。<a href="https://github.com/cglib/cglib">官网</a></li>
<li><a href="http://www.importnew.com/glassfish/">GlassFish</a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a href="https://glassfish.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/hudson/">Hudson</a>：持续集成服务器，目前仍在活跃开发。<a href="http://hudson-ci.org/">官网</a></li>
<li><a href="http://www.importnew.com/javaserver-faces/">JavaServer Faces</a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a href="https://javaserverfaces.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/javaserver-pages/">JavaServer Pages</a>：支持自定义标签库的网站通用模板库。<a href="https://jsp.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/liquibase/">Liquibase</a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a href="http://www.liquibase.org/">官网</a></li>
</ul>
<h3 id="build">构建工具</h3>

<p><em>构建及应用依赖关系处理工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/maven/">Apache Maven</a>：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。<a href="http://maven.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/bazel/">Bazel</a>：来自Google的构建工具，可以快速、可靠地构建代码。<a href="http://bazel.io/">官网</a></li>
<li><a href="http://www.importnew.com/gradle/">Gradle</a>：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。<a href="http://gradle.org/">官网</a></li>
<li><a href="http://www.importnew.com/buck/">Buck</a>：Facebook构建工具。<a href="https://buckbuild.com/">官网</a></li>
</ul>
<h3 id="bytecode-manipulation">字节码操作</h3>

<p><em>编程方式操作字节码的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/asm/">ASM</a>：通用底层字节码操作和分析开发库。<a href="http://asm.ow2.org/">官网</a></li>
<li><a href="http://www.importnew.com/byte-buddy/">Byte Buddy</a>：使用流式API进一步简化字节码生成。<a href="http://bytebuddy.net/">官网</a></li>
<li><a href="http://www.importnew.com/byteman/">Byteman</a>：在运行时通过DSL（规则）操作字节码进行测试和故障排除。<a href="http://byteman.jboss.org/">官网</a></li>
<li><a href="http://www.importnew.com/javassist/">Javassist</a>：一个简化字节码编辑尝试。<a href="http://jboss-javassist.github.io/javassist">官网</a></li>
</ul>
<h3 id="cluster-management">集群管理</h3>

<p><em>在集群内动态管理应用程序的框架。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-aurora/">Apache Aurora</a>：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。<a href="http://aurora.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/singularity/">Singularity</a>：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。<a href="http://getsingularity.com/">官网</a></li>
</ul>
<h3 id="code-analysis">代码分析</h3>

<p><em>测量代码指标和质量工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/checkstyle/">Checkstyle</a>：代码编写规范和标准静态分析工具。<a href="https://github.com/checkstyle/checkstyle">官网</a></li>
<li><a href="http://www.importnew.com/error-prone/">Error Prone</a>：将常见编程错误作为运行时错误报告。<a href="https://github.com/google/error-prone">官网</a></li>
<li>FindBugs：通过字节码静态分析查找隐藏bug。<a href="http://findbugs.sourceforge.net/">官网</a></li>
<li><a href="http://www.importnew.com/jqassistant/">jQAssistant</a>：使用基于Neo4J查询语言进行代码静态分析。<a href="http://jqassistant.org/">官网</a></li>
<li><a href="http://www.importnew.com/pmd/">PMD</a>：对源代码分析查找不良的编程习惯。<a href="https://github.com/pmd/pmd">官网</a></li>
<li><a href="http://www.importnew.com/sonarqube/">SonarQube</a>：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。<a href="http://www.sonarqube.org/">官网</a></li>
</ul>
<h3 id="compiler-compiler">编译器生成工具</h3>

<p><em>用来创建解析器、解释器或编译器的框架。</em></p>
<ul>
<li><a href="http://www.importnew.com/antlr/">ANTLR</a>：复杂的全功能自顶向下解析框架。<a href="http://www.antlr.org/">官网</a></li>
<li><a href="http://www.importnew.com/javacc/">JavaCC</a>：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。<a href="https://javacc.org/">官网</a></li>
</ul>
<h3 id="configuration">外部配置工具</h3>

<p><em>支持外部配置的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/config/">config</a>：针对JVM语言的配置库。<a href="https://github.com/typesafehub/config">官网</a></li>
<li><a href="http://www.importnew.com/owner/">owner</a>：减少冗余配置属性。<a href="https://github.com/lviggiano/owner">官网</a></li>
</ul>
<h3 id="constraint-satisfaction-problem-solver">约束满足问题求解程序</h3>

<p><em>帮助解决约束满足问题的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/choco/">Choco</a>：可直接使用的约束满足问题求解程序，使用了约束规划技术。<a href="http://choco-solver.org/">官网</a></li>
<li><a href="http://www.importnew.com/jacop/">JaCoP</a>：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。<a href="https://github.com/radsz/jacop/">官网</a></li>
<li><a href="http://www.importnew.com/optaplanner/">OptaPlanner</a>：业务规划与资源调度优化求解程序。<a href="http://www.optaplanner.org/">官网</a></li>
<li><a href="http://www.importnew.com/sat4j/">Sat4J</a>：逻辑代数与优化问题最先进的求解程序。<a href="http://www.sat4j.org/">官网</a></li>
</ul>
<h3 id="continuous-integration">持续集成</h3>

<ul>
<li><a href="http://www.importnew.com/bamboo/">Bamboo</a>：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。<a href="https://www.atlassian.com/software/bamboo">官网</a></li>
<li>CircleCI：提供托管服务，可以免费试用。<a href="https://circleci.com/">官网</a></li>
<li><a href="http://www.importnew.com/codeship/">Codeship</a>：提供托管服务，提供有限的免费模式。<a href="https://codeship.com/features">官网</a></li>
<li><a href="hao.importnew.com/fabric8/">fabric8</a>：容器集成平台。<a href="http://fabric8.io/">官网</a></li>
<li><a href="http://www.importnew.com/go/">Go</a>：ThoughtWork开源解决方案。<a href="https://www.gocd.io/">官网</a></li>
<li><a href="http://www.importnew.com/jenkins/">Jenkins</a>：支持基于服务器的部署服务。<a href="http://jenkins-ci.org/">官网</a></li>
<li><a href="http://www.importnew.com/teamcity/">TeamCity</a>：JetBrain的持续集成解决方案，有免费版。<a href="http://www.jetbrains.com/teamcity/">官网</a></li>
<li><a href="http://www.importnew.com/travis/">Travis</a>：通常用作开源项目的托管服务。<a href="https://travis-ci.org/">官网</a></li>
<li><a href="http://www.importnew.com/buildkite/">Buildkite</a>: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。<a href="https://buildkite.com/">官网</a></li>
</ul>
<h3 id="csv">CSV解析</h3>

<p><em>简化CSV数据读写的框架与开发库</em></p>
<ul>
<li><a href="http://www.importnew.com/univocity-parsers/">uniVocity-parsers</a>：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。<a href="https://github.com/uniVocity/univocity-parsers">官网</a></li>
</ul>
<h3 id="database">数据库</h3>

<p><em>简化数据库交互的相关工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-phoenix/">Apache Phoenix</a>：HBase针对低延时应用程序的高性能关系数据库层。<a href="http://phoenix.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/crate/">Crate</a>：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。<a href="https://crate.io/">官网</a></li>
<li><a href="http://www.importnew.com/flyway/">Flyway</a>：简单的数据库迁移工具。<a href="http://flywaydb.org/">官网</a></li>
<li><a href="http://www.importnew.com/h2/">H2</a>：小型SQL数据库，以可以作为内存数据库使用著称。<a href="http://h2database.com/">官网</a></li>
<li><a href="http://www.importnew.com/hikaricp/">HikariCP</a>：高性能JDBC连接工具。<a href="https://github.com/brettwooldridge/HikariCP">官网</a></li>
<li><a href="http://www.importnew.com/jdbi/">JDBI</a>：便捷的JDBC抽象。<a href="http://jdbi.org/">官网</a></li>
<li><a href="http://www.importnew.com/jooq/">jOOQ</a>：为SQL schema生成typesafe代码。<a href="http://www.jooq.org/">官网</a></li>
<li><a href="http://www.importnew.com/mapdb/">MapDB</a>：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。<a href="http://www.mapdb.org/">官网</a></li>
<li><a href="http://www.importnew.com/presto/">Presto</a>：针对大数据的分布式SQL查询引擎。<a href="https://github.com/facebook/presto">官网</a></li>
<li><a href="http://www.importnew.com/querydsl/">Querydsl</a>：Typesafe统一查询。<a href="http://www.querydsl.com/">官网</a></li>
</ul>
<h3 id="data-structures">数据结构</h3>

<ul>
<li><a href="http://www.importnew.com/apache-parquet/">Apache Parquet</a>：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。<a href="http://parquet.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/protobuf/">Protobuf</a>：Google数据交换格式。<a href="https://github.com/google/protobuf">官网</a></li>
<li><a href="http://www.importnew.com/sbe/">SBE</a>：简单二进制编码，是最快速的消息格式之一。<a href="https://github.com/real-logic/simple-binary-encoding">官网</a></li>
<li><a href="http://www.importnew.com/wire/">Wire</a>：整洁轻量级协议缓存。<a href="https://github.com/square/wire">官网</a></li>
</ul>
<h3 id="date-and-time">时间日期工具库</h3>

<p><em>处理时间和日期的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/joda-time/">Joda-Time</a>：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。<a href="http://www.joda.org/joda-time/">官网</a></li>
<li><a href="http://www.importnew.com/time4j/">Time4J</a>：高级时间和日期库。<a href="https://github.com/MenoData/Time4J">官网</a></li>
<li><a href="http://www.importnew.com/ThreeTen/">ThreeTen</a>：JSR-310实现，为JDK提供更具特点的时间和日期API。<a href="http://www.threeten.org/">官网</a></li>
</ul>
<h3 id="dependency-injection">依赖注入</h3>

<p><em>帮实现依赖翻转范式的开发库。</em> <a href="https://en.wikipedia.org/wiki/Inversion_of_control">官网</a></p>
<ul>
<li><a href="http://www.importnew.com/apache-deltaspike/">Apache DeltaSpike</a>：CDI扩展框架。<a href="https://deltaspike.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/dagger2/">Dagger2</a>：编译时注入框架，不需要使用反射。<a href="http://google.github.io/dagger/">官网</a></li>
<li><a href="http://www.importnew.com/guice/">Guice</a>：可以匹敌Dagger的轻量级注入框架。<a href="https://github.com/google/guice">官网</a></li>
<li><a href="http://www.importnew.com/hk2/">HK2</a>：轻量级动态依赖注入框架。<a href="https://hk2.java.net/">官网</a></li>
</ul>
<h3 id="development">开发流程增强工具</h3>

<p><em>从最基本的层面增强开发流程。</em></p>
<ul>
<li><a href="http://www.importnew.com/adt4j/">ADT4J</a>：针对代数数据类型的JSR-269代码生成器。<a href="https://github.com/sviperll/adt4j">官网</a></li>
<li><a href="http://www.importnew.com/aspectj/">AspectJ</a>：面向切面编程（AOP）的无缝扩展。<a href="https://eclipse.org/aspectj/">官网</a></li>
<li><a href="http://www.importnew.com/auto/">Auto</a>：源代码生成器集合。<a href="https://github.com/google/auto">官网</a></li>
<li><a href="http://www.importnew.com/dcevm/">DCEVM</a>：通过修改JVM在运行时支持对已加载的类进行无限次重定义。<a href="http://dcevm.github.io/">官网</a></li>
<li>HotswapAgent：支持无限次重定义运行时类与资源。<a href="https://github.com/HotswapProjects/HotswapAgent">官网</a></li>
<li>Immutables：类似Scala的条件类。<a href="http://immutables.github.io/">官网</a></li>
<li>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。<a href="https://github.com/jhipster/generator-jhipster">官网</a></li>
<li><a href="http://www.importnew.com/jrebel/">JRebel</a>：无需重新部署，可以即时重新加载代码与配置的商业软件。<a href="http://zeroturnaround.com/software/jrebel/">官网</a></li>
<li>Lombok：减少冗余的代码生成器。<a href="https://projectlombok.org/">官网</a></li>
<li>Spring Loaded：类重载代理。<a href="https://github.com/spring-projects/spring-loaded">官网</a></li>
<li><a href="http://www.importnew.com/vert-x/">vert.x</a>：多语言事件驱动应用框架。<a href="http://vertx.io/">官网</a></li>
</ul>
<h3 id="distributed-applications">分布式应用</h3>

<p><em>用来编写分布式容错应用的开发库和框架。</em></p>
<ul>
<li><a href="http://www.importnew.com/akka/">Akka</a>：用来编写分布式容错并发事件驱动应用程序的工具和运行时。<a href="http://akka.io/">官网</a></li>
<li><a href="http://www.importnew.com/storm/">Apache Storm</a>：实时计算系统。<a href="http://storm.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/zookeeper/">Apache ZooKeeper</a>：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。<a href="http://zookeeper.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/Hazelcast/">Hazelcast</a>：高可扩展内存数据网格。<a href="http://hazelcast.org/">官网</a></li>
<li><a href="http://www.importnew.com/hystrix/">Hystrix</a>：提供延迟和容错。<a href="https://github.com/Netflix/Hystrix">官网</a></li>
<li><a href="http://www.importnew.com/jgroups/">JGroups</a>：提供可靠的消息传递和集群创建的工具。<a href="http://www.jgroups.org/">官网</a></li>
<li><a href="http://www.importnew.com/orbit/">Orbit</a>：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。<a href="http://orbit.bioware.com/">官网</a></li>
<li><a href="http://www.importnew.com/quasar/">Quasar</a>：为JVM提供轻量级线程和角色。<a href="http://www.paralleluniverse.co/quasar/">官网</a></li>
</ul>
<h3 id="distributed-databases">分布式数据库</h3>

<p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em></p>
<ul>
<li><a href="http://www.importnew.com/cassandra/">Apache Cassandra</a>：列式数据库，可用性高且没有单点故障。<a href="http://cassandra.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/hbase/">Apache HBase</a>：针对大数据的Hadoop数据库。<a href="http://hbase.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/druid/">Druid</a>：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。<a href="http://druid.io/">官网</a></li>
<li><a href="http://www.importnew.com/infinispan/">Infinispan</a>：针对缓存的高并发键值对数据存储。<a href="http://infinispan.org/">官网</a></li>
<li><a href="">TiDB</a>：开源分布式HTAP数据库，结合了传统的RDBMS和NoSQL的最佳特性。<a href="https://pingcap.com/">官网</a></li>
</ul>
<h3 id="distribution">发布</h3>

<p><em>以本机格式发布应用程序的工具。</em></p>
<ul>
<li>Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。<a href="https://bintray.com/">官网</a></li>
<li><a href="http://www.importnew.com/central-repository/">Central Repository</a>：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central <a href="http://search.maven.org/">官网</a>Repository，也可以在所有其他构建工具中使用。</li>
<li>IzPack：为跨平台部署建立创作工具（Authoring Tool）。<a href="http://izpack.org/">官网</a></li>
<li>JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。<a href="https://jitpack.io/">官网</a></li>
<li>Launch4j：将JAR包装为轻量级本机Windows可执行程序。<a href="http://launch4j.sourceforge.net/">官网</a></li>
<li>Nexus：支持代理和缓存功能的二进制管理工具。<a href="http://www.sonatype.com/nexus">官网</a></li>
<li>packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。<a href="https://github.com/libgdx/packr/">官网</a></li>
</ul>
<h3 id="document-processing">文档处理工具</h3>

<p><em>处理Office文档的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/poi/">Apache POI</a>：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。<a href="http://poi.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/documents4j/">documents4j</a>：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。<a href="http://documents4j.com/">官网</a></li>
<li><a href="http://www.importnew.com/jopendocument/">jOpenDocument</a>：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。<a href="http://www.jopendocument.org/">官网</a></li>
</ul>
<h3 id="functional-programming">函数式编程</h3>

<p><em>函数式编程支持库。</em></p>
<ul>
<li>Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。<a href="https://github.com/aol/cyclops">官网</a></li>
<li>Fugue：Guava的函数式编程扩展。<a href="https://bitbucket.org/atlassian/fugue">官网</a></li>
<li>Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。<a href="http://www.functionaljava.org/">官网</a></li>
<li>Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。<a href="http://javaslang.com/">官网</a></li>
<li>jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。<a href="https://github.com/jOOQ/jOOL">官网</a></li>
</ul>
<h3 id="game-development">游戏开发</h3>

<p><em>游戏开发框架。</em></p>
<ul>
<li><a href="http://www.importnew.com/jmonkeyengine/">jMonkeyEngine</a>：现代3D游戏开发引擎。<a href="http://jmonkeyengine.org/">官网</a></li>
<li><a href="http://www.importnew.com/libgdx/">libGDX</a>：全面的跨平台高级框架。<a href="https://libgdx.badlogicgames.com/">官网</a></li>
<li><a href="http://www.importnew.com/lwjgl/">LWJGL</a>：对OpenGL&#x2F;CL&#x2F;AL等技术进行抽象的健壮框架。<a href="https://www.lwjgl.org/">官网</a></li>
<li>jPCT：基于OpenGL技术开发的3D图形引擎。纯Java的3D引擎。<a href="http://www.jpct.net/">官网</a></li>
</ul>
<h3 id="gui">GUI</h3>

<p><em>现代图形化用户界面开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/javafx/">JavaFX</a>：Swing的后继者。<a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">官网</a></li>
<li><a href="http://www.importnew.com/scene_builder/">Scene Builder</a>：开发JavaFX应用的可视化布局工具。<a href="http://docs.oracle.com/javase/8/scene-builder-2/get-started-tutorial/overview.htm#JSBGS164">官网</a></li>
</ul>
<h3 id="high-performance">高性能计算</h3>

<p><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em></p>
<ul>
<li>Agrona：高性能应用中常见的数据结构和工具方法。<a href="https://github.com/real-logic/Agrona">官网</a></li>
<li>Disruptor：线程间消息传递开发库。<a href="http://lmax-exchange.github.io/disruptor/">官网</a></li>
<li>fastutil：快速紧凑的特定类型集合（Collection）。<a href="http://fastutil.di.unimi.it/">官网</a></li>
<li>GS Collections：受Smalltalk启发的集合框架。<a href="https://github.com/goldmansachs/gs-collections">官网</a></li>
<li><a href="http://www.importnew.com/hppc/">HPPC</a>：基础类型集合。<a href="http://labs.carrotsearch.com/hppc.html">官网</a></li>
<li>Javolution：实时和嵌入式系统的开发库。<a href="http://javolution.org/">官网</a></li>
<li><a href="http://www.importnew.com/jctools/">JCTools</a>：JDK中缺失的并发工具。<a href="https://github.com/JCTools/JCTools">官网</a></li>
<li><a href="http://www.importnew.com/koloboke/">Koloboke</a>：Hash set和hash map。<a href="https://github.com/OpenHFT/Koloboke">官网</a></li>
<li>Trove：基础类型集合。<a href="http://trove.starlight-systems.com/">官网</a></li>
<li>High-scale-lib:Cliff Click 个人开发的高性能并发库<a href="https://github.com/stephenc/high-scale-lib">官网</a></li>
</ul>
<h3 id="ide">IDE</h3>

<p><em>简化开发的集成开发环境。</em></p>
<ul>
<li><a href="http://www.importnew.com/eclipse/">Eclipse</a>：老牌开源项目，支持多种插件和编程语言。<a href="http://www.eclipse.org/">官网</a></li>
<li><a href="http://www.importnew.com/intellij-idea/">IntelliJ IDEA</a>：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。<a href="http://www.jetbrains.com/idea/">官网</a></li>
<li><a href="http://www.importnew.com/netbeans/">NetBeans</a>：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。<a href="https://netbeans.org/">官网</a></li>
<li><a href="http://www.importnew.com/scala-ide/">Scala IDE</a>：一款基于Eclipse开源平台打造的Scala集成开发环境。<a href="http://scala-ide.org/">官网</a></li>
<li><a href="http://www.importnew.com/springsource-tool-suite/">SpringSource Tool Suite（STS）</a>:一款基于Eclipse开源平台打造的Spring应用开发环境。<a href="http://spring.io/tools/sts/">官网</a></li>
</ul>
<h3 id="imagery">图像处理</h3>

<p><em>创建、评价和操作图片的支持库。</em></p>
<ul>
<li><a href="http://www.importnew.com/imgscalr/">Imgscalr</a>：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。<a href="https://github.com/thebuzzmedia/imgscalr">官网</a></li>
<li><a href="http://www.importnew.com/picasso/">Picasso</a>：安卓图片下载和图片缓存开发库。<a href="http://square.github.io/picasso/">官网</a></li>
<li><a href="http://www.importnew.com/thumbnailator/">Thumbnailator</a>：Thumbnailator是一个高质量Java缩略图开发库。<a href="https://github.com/coobird/thumbnailator">官网</a></li>
<li><a href="http://www.importnew.com/zxing/">ZXing</a>：支持多种格式的一维、二维条形码图片处理开发库。<a href="https://github.com/zxing/zxing">官网</a></li>
<li><a href="http://www.importnew.com/im4java/">im4java</a>: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。<a href="http://im4java.sourceforge.net/">官网</a></li>
<li>Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。<a href="http://xmlgraphics.apache.org/batik/">官网</a></li>
</ul>
<h3 id="json">JSON</h3>

<p><em>简化JSON处理的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/genson/">Genson</a>：强大且易于使用的Java到JSON转换开发库。<a href="http://owlike.github.io/genson">官网</a></li>
<li><a href="http://www.importnew.com/gson/">Gson</a>：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。<a href="https://github.com/google/gson">官网</a></li>
<li><a href="http://www.importnew.com/jackson/">Jackson</a>：与GSON类似，在频繁使用时性能更佳。<a href="http://wiki.fasterxml.com/JacksonHome">官网</a></li>
<li><a href="http://www.importnew.com/logansquare/">LoganSquare</a>：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。<a href="https://github.com/bluelinelabs/LoganSquare">官网</a></li>
<li><a href="http://www.importnew.com/fastjson/">Fastjson</a>：一个Java语言编写的高性能功能完善的JSON库。<a href="https://github.com/Alibaba/fastjson">官网</a></li>
<li>Kyro：快速、高效、自动化的Java对象序列化和克隆库。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li>
</ul>
<h3 id="jvm-and-jdk">JVM与JDK</h3>

<p><em>目前的JVM和JDK实现。</em></p>
<ul>
<li><a href="http://www.importnew.com/jdk-9/">JDK 9</a>：JDK 9的早期访问版本。<a href="https://jdk9.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/openjdk/">OpenJDK</a>：JDK开源实现。<a href="http://openjdk.java.net/">官网</a></li>
</ul>
<h3 id="languages">基于JVM的语言</h3>

<p><em>除Java外，可以用来编写JVM应用程序的编程语言。</em></p>
<ul>
<li>Scala：融合了面向对象和函数式编程思想的静态类型编程语言。<a href="http://www.scala-lang.org/">官网</a></li>
<li><a href="http://www.importnew.com/groovy/">Groovy</a>：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。<a href="http://www.groovy-lang.org/">官网</a></li>
<li>Clojure：可看做现代版Lisp的动态类型语言。<a href="http://clojure.org/">官网</a></li>
<li>Ceylon：RedHat开发的面向对象静态类型编程语言。<a href="http://ceylon-lang.org/">官网</a></li>
<li>Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。<a href="http://kotlinlang.org/">官网</a></li>
<li><a href="http://www.importnew.com/xtend/">Xtend</a>：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。<a href="http://www.eclipse.org/xtend/">官网</a></li>
</ul>
<h3 id="logging">日志</h3>

<p><em>记录应用程序行为日志的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/log4j2/">Apache Log4j 2</a>：使用强大的插件和配置架构进行完全重写。<a href="http://logging.apache.org/log4j/">官网</a></li>
<li><a href="http://www.importnew.com/kibana/">kibana</a>：分析及可视化日志文件。<a href="https://www.elastic.co/products/kibana">官网</a></li>
<li><a href="http://www.importnew.com/logback/">Logback</a>：强健的日期开发库，通过Groovy提供很多有趣的选项。<a href="http://logback.qos.ch/">官网</a></li>
<li><a href="http://www.importnew.com/logstash/">logstash</a>：日志文件管理工具。<a href="https://www.elastic.co/products/logstash">官网</a></li>
<li><a href="http://www.importnew.com/metrics/">Metrics</a>：通过JMX或HTTP发布参数，并且支持存储到数据库。<a href="https://github.com/dropwizard/metrics">官网</a></li>
<li><a href="http://www.importnew.com/slf4j/">SLF4J</a>：日志抽象层，需要与具体的实现配合使用。<a href="http://www.slf4j.org/">官网</a></li>
</ul>
<h3 id="machine-learning">机器学习</h3>

<p><em>提供具体统计算法的工具。其算法可从数据中学习。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-flink/">Apache Flink</a>：快速、可靠的大规模数据处理引擎。<a href="https://flink.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/apache-hadoop/">Apache Hadoop</a>：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a href="http://hadoop.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/apache-mahout/">Apache Mahout</a>：专注协同过滤、聚类和分类的可扩展算法。<a href="https://mahout.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/apache-spark/">Apache Spark</a>：开源数据分析集群计算框架。<a href="http://spark.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/deepdive/">DeepDive</a>：从非结构化数据建立结构化信息并集成到已有数据库的工具。<a href="http://deepdive.stanford.edu/">官网</a></li>
<li><a href="http://www.importnew.com/deeplearning4j/">Deeplearning4j</a>：分布式多线程深度学习开发库。<a href="http://deeplearning4j.org/">官网</a></li>
<li><a href="http://www.importnew.com/h2o/">H2O</a>：用作大数据统计的分析引擎。<a href="http://h2o.ai/">官网</a></li>
<li><a href="http://www.importnew.com/weka/">Weka</a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。<a href="http://www.cs.waikato.ac.nz/ml/weka/">官网</a></li>
<li><a href="http://www.importnew.com/quickml/">QuickML</a>：高效机器学习库。<a href="http://quickml.org/">官网</a>、<a href="https://github.com/sanity/quickml">GitHub</a></li>
</ul>
<h3 id="messaging">消息传递</h3>

<p><em>在客户端之间进行消息传递，确保协议独立性的工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/aeron/">Aeron</a>：高效可扩展的单播、多播消息传递工具。<a href="https://github.com/real-logic/Aeron">官网</a></li>
<li><a href="http://www.importnew.com/activemq/">Apache ActiveMQ</a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a href="http://activemq.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/apache-camel/">Apache Camel</a>：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。<a href="http://camel.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/kafka/">Apache Kafka</a>：高吞吐量分布式消息系统。<a href="http://kafka.apache.org/">官网</a></li>
<li><a href="http://rocketmq.apache.org/">Apache RocketMQ</a>: Apache RocketMQ是一个开源的分布式消息传递和流数据平台。<a href="http://rocketmq.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/hermes/">Hermes</a>：快速、可靠的消息代理（Broker），基于Kafka构建。<a href="http://hermes.allegro.tech/">官网</a></li>
<li>JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。<a href="http://hornetq.jboss.org/">官网</a></li>
<li><a href="http://www.importnew.com/jeromq/">JeroMQ</a>：ZeroMQ的纯Java实现。<a href="https://github.com/zeromq/jeromq">官网</a></li>
<li><a href="http://www.importnew.com/smack/">Smack</a>：跨平台XMPP客户端函数库。<a href="https://github.com/igniterealtime/Smack/">官网</a></li>
<li>Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 <a href="http://www.igniterealtime.org/projects/openfire/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Openfire">GitHub</a></li>
<li>Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 <a href="http://www.igniterealtime.org/projects/spark/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Spark">GitHub</a></li>
<li>Tigase： 是一个轻量级的可伸缩的 Jabber&#x2F;XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 <a href="http://www.tigase.net/">官网</a></li>
</ul>
<h3 id="miscellaneous">杂项</h3>

<p><em>未分类其它资源。</em></p>
<ul>
<li>Design Patterns：实现并解释了最常见的设计模式。<a href="https://github.com/iluwatar/java-design-patterns">官网</a></li>
<li>Jimfs：内存文件系统。<a href="https://github.com/google/jimfs">官网</a></li>
<li>Lanterna：类似curses的简单console文本GUI函数库。<a href="https://code.google.com/p/lanterna/">官网</a></li>
<li>LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。<a href="http://lightadmin.org/">官网</a></li>
<li>OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。<a href="http://openrefine.org/">官网</a></li>
<li>RoboVM：Java编写原生iOS应用。<a href="https://robovm.com/">官网</a></li>
<li><a href="http://www.importnew.com/quartz/">Quartz</a>：强大的任务调度库.<a href="http://www.quartz-scheduler.org/">官网</a></li>
</ul>
<h3 id="monitoring">应用监控工具</h3>

<p><em>监控生产环境中应用程序的工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/appdynamics/">AppDynamics</a>：性能监测商业工具。<a href="http://www.appdynamics.com/">官网</a></li>
<li><a href="http://www.importnew.com/javamelody/">JavaMelody</a>：性能监测和分析工具。<a href="https://github.com/javamelody/javamelody">官网</a></li>
<li><a href="http://www.importnew.com/Kamon/">Kamon</a>：Kamon用来监测在JVM上运行的应用程序。<a href="http://www.kamon.io/">官网</a></li>
<li><a href="http://www.importnew.com/new-relic/">New Relic</a>：性能监测商业工具。<a href="http://newrelic.com/">官网</a></li>
<li>SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。<a href="https://sematext.com/spm/">官网</a></li>
<li><a href="http://www.importnew.com/overops_takipi/">OverOps(Takipi)</a>：产品运行时错误监测及调试商业工具。<a href="https://www.takipi.com/">官网</a></li>
</ul>
<h3 id="native">原生开发库</h3>

<p><em>用来进行特定平台开发的原生开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/jna/">JNA</a>：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。<a href="https://github.com/java-native-access/jna">官网</a></li>
</ul>
<h3 id="natural-language-processing">自然语言处理</h3>

<p><em>用来专门处理文本的函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-opennlp/">Apache OpenNLP</a>：处理类似分词等常见任务的工具。<a href="https://opennlp.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/stanford_corenlp/">CoreNLP</a>：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。<a href="http://nlp.stanford.edu/software/coenlp.shtml">官网</a></li>
<li><a href="http://www.importnew.com/lingpipe/">LingPipe</a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。<a href="http://alias-i.com/lingpipe/">官网</a></li>
<li><a href="http://www.importnew.com/mallet/">Mallet</a>：统计学自然语言处理、文档分类、聚类、主题建模等。<a href="http://mallet.cs.umass.edu/">官网</a></li>
</ul>
<h3 id="networking">网络</h3>

<p><em>网络编程函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/async-http-client/">Async Http Client</a>：异步HTTP和WebSocket客户端函数库。<a href="https://github.com/AsyncHttpClient/async-http-client">官网</a></li>
<li><a href="http://www.importnew.com/grizzly/">Grizzly</a>：NIO框架，在Glassfish中作为网络层使用。<a href="https://grizzly.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/netty/">Netty</a>：构建高性能网络应用程序开发框架。<a href="http://netty.io/">官网</a></li>
<li><a href="http://www.importnew.com/okhttp/">OkHttp</a>：一个Android和Java应用的HTTP+SPDY客户端。<a href="http://square.github.io/okhttp/">官网</a></li>
<li>Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。<a href="http://undertow.io/">官网</a></li>
<li>unirest-java: Unirest 是一个轻量级的 HTTP 请求库，涵盖 Node、Ruby、Java、PHP、Python、Objective-C、.NET 等多种语言。可发起 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 请求。<a href="http://unirest.io/java">官网</a></li>
<li>brpc-java: java版baidu rpc框架，高性能、多协议、易扩展、低耦合。<a href="https://github.com/baidu/brpc-java">官网</a></li>
</ul>
<h3 id="orm">ORM</h3>

<p><em>处理对象持久化的API。</em></p>
<ul>
<li><a href="http://www.importnew.com/ebean/">Ebean</a>：支持快速数据访问和编码的ORM框架。<a href="http://ebean-orm.github.io/">官网</a></li>
<li><a href="http://www.importnew.com/eclipselink/">EclipseLink</a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。<a href="https://www.eclipse.org/eclipselink/">官网</a></li>
<li><a href="http://www.importnew.com/hibernate/">Hibernate</a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。<a href="http://hibernate.org/orm/">官网</a></li>
<li><a href="http://www.importnew.com/mybatis/">MyBatis</a>：带有存储过程或者SQL语句的耦合对象（Couples object）。<a href="http://mybatis.github.io/mybatis-3/">官网</a></li>
<li><a href="http://www.importnew.com/ormlite/">OrmLite</a>：轻量级开发包，免除了其它ORM产品中的复杂性和开销。<a href="http://ormlite.com/">官网</a></li>
<li>Nutz：另一个SSH。<a href="http://nutzam.com/">官网</a>，<a href="https://github.com/nutzam/nutz">Github</a>，<a href="https://nutz.cn/">论坛</a></li>
<li>JFinal：JAVA WEB + ORM框架。<a href="http://www.jfinal.com/">官网</a>，<a href="https://github.com/jfinal/jfinal">Github</a></li>
<li><a href="http://openjpa.apache.org/">Apache OpenJPA</a>: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 <a href="http://openjpa.apache.org/">官网</a></li>
</ul>
<h3 id="pdf">PDF</h3>

<p><em>用来帮助创建PDF文件的资源。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache_fop/">Apache FOP</a>：从XSL-FO创建PDF。<a href="http://xmlgraphics.apache.org/fop/">官网</a></li>
<li><a href="http://www.importnew.com/apache-pdfbox/">Apache PDFBox</a>：用来创建和操作PDF的工具集。<a href="http://pdfbox.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/dynamicreports/">DynamicReports</a>：JasperReports的精简版。<a href="http://dynamicreports.org/">官网</a></li>
<li><a href="http://www.importnew.com/flyingsaucer/">flyingsaucer</a>：XML&#x2F;XHTML和CSS 2.1渲染器。<a href="https://github.com/flyingsaucerproject/flyingsaucer">官网</a></li>
<li><a href="http://www.importnew.com/itext/">iText</a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。<a href="http://itextpdf.com/">官网</a></li>
<li><a href="http://www.importnew.com/jasperreports/">JasperReports</a>：一个复杂的报表引擎。<a href="http://community.jaspersoft.com/project/jasperreports-library">官网</a></li>
</ul>
<h3 id="performance-analysis">性能分析</h3>

<p><em>性能分析、性能剖析及基准测试工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/jhiccup/">jHiccup</a>：提供平台中JVM暂停的日志和记录。<a href="https://github.com/giltene/jHiccup">官网</a></li>
<li><a href="http://www.importnew.com/jmh/">JMH</a>：JVM基准测试工具。<a href="http://openjdk.java.net/projects/code-tools/jmh/">官网</a></li>
<li><a href="http://www.importnew.com/jprofiler/">JProfiler</a>：商业分析器。<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网</a></li>
<li><a href="http://www.importnew.com/latencyutils/">LatencyUtils</a>：测量和报告延迟的工具。<a href="https://github.com/LatencyUtils/LatencyUtils">官网</a></li>
<li><a href="http://www.importnew.com/visualvm/">VisualVM</a>：对运行中的应用程序信息提供了可视化界面。<a href="http://visualvm.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/yourkit-java-profiler/">YourKit Java Profiler</a>：商业分析器。<a href="https://www.yourkit.com/features/">官网</a></li>
</ul>
<h3 id="reactive-libraries">响应式开发库</h3>

<p><em>用来开发响应式应用程序的开发库。</em></p>
<ul>
<li><a href="http://www.importnew.com/reactive-streams/">Reactive Streams</a>：异步流处理标准，支持非阻塞式反向压力（backpressure）。<a href="https://github.com/reactive-streams/reactive-streams-jv/">官网</a></li>
<li><a href="http://www.importnew.com/reactor/">Reactor</a>：构建响应式快速数据（fast-data）应用程序的开发库。<a href="http://projectreactor.io/">官网</a></li>
<li><a href="http://www.importnew.com/rxjava/">RxJava</a>：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。<a href="https://github.com/ReactiveX/RxJava">官网</a></li>
</ul>
<h3 id="rest-frameworks">REST框架</h3>

<p><em>用来创建RESTful 服务的框架。</em></p>
<ul>
<li><a href="http://www.importnew.com/dropwizard/">Dropwizard</a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。<a href="https://dropwizard.github.io/drpwizard/">官网</a></li>
<li><a href="http://www.importnew.com/feign/">Feign</a>：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。<a href="https://github.com/Netflix/feign">官网</a></li>
<li>Jersey：JAX-RS参考实现。<a href="https://jersey.java.net/">官网</a></li>
<li><a href="http://www.importnew.com/resteasy/">RESTEasy</a>：经过JAX-RS规范完全认证的可移植实现。<a href="http://resteasy.jboss.org/">官网</a></li>
<li><a href="http://www.importnew.com/restexpress/">RestExpress</a>：一个Java类型安全的REST客户端。<a href="https://github.com/RestExpress/RestExpress">官网</a></li>
<li><a href="http://www.importnew.com/restx/">RestX</a>：基于注解处理和编译时源码生成的框架。<a href="http://restx.io/">官网</a></li>
<li><a href="http://www.importnew.com/retrofit/">Retrofit</a>：类型安全的REST客户端。<a href="http://square.github.io/retrofit/">官网</a></li>
<li><a href="http://www.importnew.com/sparkjava/">Spark</a>：受到Sinatra启发的Java REST框架。<a href="http://sparkjava.com/">官网</a></li>
<li><a href="http://www.importnew.com/swagger/">Swagger</a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。<a href="http://swagger.io/">官网</a></li>
<li><a href="http://www.importnew.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://lets-blade.com/">官网</a></li>
</ul>
<h3 id="science">科学计算与分析</h3>

<p><em>用于科学计算和分析的函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/datamelt/">DataMelt</a>：用于科学计算、数据分析及数据可视化的开发环境。<a href="http://jwork.org/dmelt/">官网</a></li>
<li><a href="http://www.importnew.com/jgrapht/">JGraphT</a>：支持数学图论对象和算法的图形库。<a href="https://github.com/jgrapht/jgrapht">官网</a></li>
<li><a href="http://www.importnew.com/jscience/">JScience</a>：用来进行科学测量和单位的一组类。<a href="http://jscience.org/">官网</a></li>
</ul>
<h3 id="search">搜索引擎</h3>

<p><em>文档索引引擎，用于搜索和分析。</em></p>
<ul>
<li><a href="http://www.importnew.com/solr/">Apache Solr</a>：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。<a href="http://lucene.apache.org/solr/">官网</a></li>
<li>Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。<a href="http://www.elsticsearch.org/">官网</a></li>
<li>Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。<a href="http://lucene.apache.org/">官网</a></li>
</ul>
<h3 id="security">安全</h3>

<p><em>用于处理安全、认证、授权或会话管理的函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/shiro/">Apache Shiro</a>：执行认证、授权、加密和会话管理。<a href="http://shiro.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/bouncy-castle/">Bouncy Castle</a>，涵盖了从基础的帮助函数到PGP&#x2F;SMIME操作。<a href="https://www.bouncycastle.org/java.html">官网</a>：多途加密开发库。支持JCA提供者（JCA provider)</li>
<li><a href="http://www.importnew.com/cryptomator/">Cryptomator</a>：在云上进行客户端跨平台透明加密。<a href="https://cryptomator.org/">官网</a></li>
<li><a href="http://www.importnew.com/keycloak/">Keycloak</a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。<a href="http://keycloak.jboss.org/">官网</a></li>
<li><a href="http://www.importnew.com/picketlink/">PicketLink</a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。<a href="http://picketlink.org/">官网</a></li>
<li><a href="https://github.com/dromara/sa-token">Sa-Token</a>：Sa-Token 是一个轻量级 Java 权限认证框架，主要解决：登录认证、权限认证、Session会话、单点登录、OAuth2.0、微服务网关鉴权 等一系列权限相关问题。<a href="https://sa-token.dev33.cn/">官网</a></li>
</ul>
<h3 id="serialization">序列化</h3>

<p><em>用来高效处理序列化的函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/flatbuffers/">FlatBuffers</a>：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。<a href="https://github.com/google/flatbuffers">官网</a></li>
<li><a href="http://www.importnew.com/kryo/">Kryo</a>：快速、高效的对象图形序列化框架。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li>
<li><a href="http://www.importnew.com/fst/">FST</a>：提供兼容JDK的高性能对象图形序列化。<a href="https://github.com/RuedigerMoeller/fast-serialization">官网</a></li>
<li><a href="http://www.importnew.com/messagepack/">MessagePack</a>：一种高效的二进制序列化格式。<a href="https://github.com/msgpack/msgpack-java">官网</a></li>
</ul>
<h3 id="server">应用服务器</h3>

<p><em>用来部署应用程序的服务器。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-tomcat/">Apache Tomcat</a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。<a href="http://tomcat.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/tomee/">Apache TomEE</a>：Tomcat加Java EE。<a href="http://tomee.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/jetty/">Jetty</a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。<a href="http://www.eclipse.org/jetty/">官网</a></li>
<li><a href="http://www.importnew.com/websphere-liberty/">WebSphere Liberty</a>：轻量级、模块化应用服务器，由IBM开发。<a href="https://developer.ibm.com/wasdev/">官网</a></li>
<li><a href="http://www.importnew.com/wildfly/">WildFly</a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。<a href="http://www.wildfly.org/">官网</a></li>
</ul>
<h3 id="template-engine">模板引擎</h3>

<p><em>在模板中替换表达式的工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/velocity/">Apache Velocity</a>：提供HTML页面模板、email模板和通用开源代码生成器模板。<a href="http://velocity.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/freemarker/">FreeMarker</a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。<a href="http://freemarker.org/">官网</a></li>
<li><a href="http://www.importnew.com/handlebars-java/">Handlebars.java</a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。<a href="http://jknack.github.io/handlebars.java/">官网</a></li>
<li><a href="http://www.importnew.com/thymeleaf/">Thymeleaf</a>：旨在替换JSP，支持XML文件的工具。<a href="http://www.thymeleaf.org/">官网</a></li>
<li><a href="http://ibeetl.com/">Beetl</a>：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。<a href="http://ibeetl.com/">官网</a></li>
</ul>
<h3 id="testing">测试</h3>

<p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em></p>
<ul>
<li><a href="http://www.importnew.com/jmeter/">Apache JMeter</a>：功能性测试和性能评测。<a href="http://jmeter.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/arquillian/">Arquillian</a>：集成测试和功能行测试平台，集成Java EE容器。<a href="http://arquillian.org/">官网</a></li>
<li><a href="http://www.importnew.com/assertj/">AssertJ</a>：支持流式断言提高测试的可读性。<a href="http://joel-costigliola.github.io/assertj/">官网</a></li>
<li><a href="http://www.importnew.com/awaitility/">Awaitility</a>：用来同步异步操作的DSL。<a href="https://github.com/jayway/awaitility">官网</a></li>
<li><a href="http://www.importnew.com/cucumber-jvm/">Cucumber</a>：BDD测试框架。<a href="https://github.com/cucumber/cucumber-jvm">官网</a></li>
<li>Gatling：设计为易于使用、可维护的和高性能负载测试工具。<a href="http://gatling.io/">官网</a></li>
<li><a href="http://www.importnew.com/hamcrest/">Hamcrest</a>：可用来灵活创建意图（intent）表达式的匹配器。<a href="http://hamcrest.org/JavaHamcrest/">官网</a></li>
<li>JMockit：用来模拟静态、final方法等。<a href="http://jmockit.org/">官网</a></li>
<li><a href="http://www.importnew.com/junit/">JUnit</a>：通用测试框架。<a href="http://junit.org/">官网</a></li>
<li><a href="http://www.importnew.com/mockito/">Mockito</a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。<a href="https://github.com/mockito/mockito">官网</a></li>
<li><a href="http://www.importnew.com/powermock/">PowerMock</a>： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。<a href="https://github.com/jayway/powermock">官网</a></li>
<li><a href="http://www.importnew.com/rest-assured/">REST Assured</a>：为REST&#x2F;HTTP服务提供方便测试的Java DSL。<a href="https://github.com/jayway/rest-assured">官网</a></li>
<li><a href="http://www.importnew.com/selenide/">Selenide</a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。<a href="http://selenide.org/">官网</a></li>
<li><a href="http://www.importnew.com/selenium/">Selenium</a>：为Web应用程序提供可移植软件测试框架。<a href="http://docs.seleniumhq.org/">官网</a></li>
<li><a href="http://www.importnew.com/spock/">Spock</a>：JUnit-compatible framework featuring an expressive Groovy-derived specification language.<a href="http://docs.spockframework.org/">官网</a>兼容JUnit框架，支持衍生的Groovy范的语言。</li>
<li><a href="http://www.importnew.com/testng/">TestNG</a>：测试框架。<a href="http://testng.org/">官网</a></li>
<li><a href="http://www.importnew.com/truth/">Truth</a>：Google的断言和命题（proposition）框架。<a href="https://github.com/google/truth">官网</a></li>
<li><a href="http://www.importnew.com/unitils/">Unitils</a>：模块化测试函数库，支持单元测试和集成测试。<a href="http://www.unitils.org/">官网</a></li>
<li><a href="http://www.importnew.com/wiremock/">WireMock</a>：Web Service测试桩（Stub）和模拟函数。<a href="http://wiremock.org/">官网</a></li>
</ul>
<h3 id="utility">通用工具库</h3>

<p><em>通用工具类函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-commons/">Apache Commons</a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。<a href="http://commons.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/args4j/">args4j</a>：命令行参数解析器。<a href="http://args4j.kohsuke.org/">官网</a></li>
<li><a href="http://www.importnew.com/crash/">CRaSH</a>：为运行进行提供CLI。<a href="http://www.crashub.org/">官网</a></li>
<li><a href="http://www.importnew.com/gephi/">Gephi</a>：可视化跨平台网络图形化操作程序。<a href="https://github.com/gephi/gephi/">官网</a></li>
<li><a href="http://www.importnew.com/guava/">Guava</a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I&#x2F;O等。<a href="https://github.com/google/guava">官网</a></li>
<li><a href="http://www.importnew.com/jade/">JADE</a>：构建、调试多租户系统的框架和环境。<a href="http://jade.tilab.com/">官网</a></li>
<li><a href="http://www.importnew.com/javatuples/">javatuples</a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。<a href="http://www.javatuples.org/">官网</a></li>
<li><a href="http://www.importnew.com/jcommander/">JCommander</a>：命令行参数解析器。<a href="http://jcommander.org/">官网</a></li>
<li><a href="http://www.importnew.com/protege/">Protégé</a>：提供存在论（ontology）编辑器以及构建知识系统的框架。<a href="http://protege.stanford.edu/">官网</a></li>
<li><a href="https://github.com/looly/hutool">Hutool</a>：一个Java工具集，缓存、HTTP、加密解密、DFA、JSON、分组配置文件、数据库操作、图片验证码、Excel读写、定时任务、模板引擎、邮件、Servlet、二维码、Emoji、分词等一系列工具类。<a href="https://hutool.cn/">官网</a></li>
</ul>
<h3 id="web-crawling">网络爬虫</h3>

<p><em>用于分析网站内容的函数库。</em></p>
<ul>
<li><a href="http://www.importnew.com/nutch/">Apache Nutch</a>：可用于生产环境的高度可扩展、可伸缩的网络爬虫。<a href="http://nutch.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/crawler4j/">Crawler4j</a>：简单的轻量级网络爬虫。<a href="https://github.com/yasserg/crawler4j">官网</a></li>
<li><a href="http://www.importnew.com/jsoup/">JSoup</a>：刮取、解析、操作和清理HTML。<a href="http://jsoup.org/">官网</a></li>
<li><a href="https://github.com/code4craft/webmagic/">webmagic</a>：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。</li>
</ul>
<h3 id="web-frameworks">Web框架</h3>

<p><em>用于处理Web应用程序不同层次间通讯的框架。</em></p>
<ul>
<li><a href="http://www.importnew.com/apache-tapestry/">Apache Tapestry</a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。<a href="http://tapestry.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/apache-wicket/">Apache Wicket</a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。<a href="http://wicket.apache.org/">官网</a></li>
<li><a href="http://www.importnew.com/gwt/">Google Web Toolkit</a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP <a href="http://www.gwtproject.org/">官网</a>API、JUnit集成、国际化支持和GUI控件。</li>
<li><a href="http://www.importnew.com/grails/">Grails</a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。<a href="https://grails.org/">官网</a></li>
<li><a href="http://www.importnew.com/ninja/">Ninja</a>：Java全栈Web开发框架。非常稳固、快速和高效。<a href="http://www.ninjaframework.org/">官网</a></li>
<li><a href="http://www.importnew.com/pippo/">Pippo</a>：小型、高度模块化的类Sinatra框架。<a href="http://www.pippo.ro/">官网</a></li>
<li><a href="http://www.importnew.com/play-framework/">Play</a>：使用约定而非配置，支持代码热加载并在浏览器中显示错误。<a href="https://www.playframework.com/">官网</a></li>
<li><a href="http://www.importnew.com/primefaces/">PrimeFaces</a>：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。<a href="http://primefaces.org/">官网</a></li>
<li><a href="http://www.importnew.com/ratpack/">Ratpack</a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。<a href="https://ratpack.io/">官网</a></li>
<li><a href="http://www.importnew.com/spring-boot/">Spring Boot</a>：微框架，简化了Spring新程序的开发过程。<a href="http://projects.spring.io/spring-boot/">官网</a></li>
<li><a href="http://www.importnew.com/spring-framework/">Spring</a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。<a href="http://projects.spring.io/spring-framework/">官网</a></li>
<li><a href="http://www.importnew.com/vaadin/">Vaadin</a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。<a href="https://vaadin.com/">官网</a></li>
<li><a href="http://www.importnew.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://lets-blade.com/">官网</a></li>
</ul>
<h3 id="Business-Process-Management">业务流程管理套件</h3>

<p><em>流程驱动的软件系统构建。</em></p>
<ul>
<li><a href="http://www.importnew.com/jbpm/">jBPM</a>：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。<a href="http://www.jbpm.org/">官网</a></li>
<li>Activity：轻量级工作流和业务流程管理框架。<a href="http://www.activiti.org/">官网</a> <a href="https://github.com/Activiti/Activiti">github</a></li>
</ul>
<h2 id="resources">资源</h2>
<h3 id="communities">社区</h3>

<ul>
<li>r&#x2F;java：Reddit的Java子社区。<a href="https://www.reddit.com/r/java">官网</a></li>
<li>stackoverflow：问答平台。<a href="http://stackoverflow.com/questions/tagged/java">官网</a></li>
<li>vJUG：虚拟Java用户组。<a href="http://virtualjug.com/">官网</a></li>
<li>java8 新特性教程例子。<a href="https://github.com/winterbe/java8-tutorial">github</a></li>
</ul>
<h3 id="influential-books">有影响力的书</h3>

<p><em>具有广泛影响且值得阅读的Java经典书籍。</em></p>
<ul>
<li><a href="http://www.importnew.com/effective-java/">Effective Java (2nd Edition)</a></li>
<li><a href="http://www.importnew.com/java-8-in-action/">Java 8 in Action</a></li>
<li><a href="http://www.importnew.com/java-concurrency-in-practice/">Java Concurrency in Practice | Java并发编程实战</a></li>
<li><a href="http://www.importnew.com/thinking-in-java/">Thinking in Java | Java编程思想</a></li>
<li><a href="http://www.importnew.com/java-puzzlers/">Java Puzzlers | Java解惑</a></li>
</ul>
<h3 id="podcasts">播客</h3>

<p><em>可以一边编程一边听的东西。</em></p>
<ul>
<li>Java Council：<a href="http://virtualjug.com/#podcast/">官网</a></li>
<li>Java Posse：Discontinued as of 02&#x2F;2015.<a href="http://www.javaposse.com/">官网</a></li>
</ul>
<h3 id="weibo-weixin">微博、微信公众号</h3>

<ul>
<li>ImportNew：是最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。<br><br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg"></li>
<li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li>
</ul>
<h3 id="twitter">Twitter</h3>

<ul>
<li><a href="https://twitter.com/AdamBien/">Adam Bien</a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li>
<li><a href="https://twitter.com/agoncal/">Antonio Goncalves</a>：Java Champion、JUG Leader、Devoxx France、Java EE 6&#x2F;7、JCP、作家。</li>
<li><a href="https://twitter.com/arungupta/">Arun Gupta</a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li>
<li><a href="https://twitter.com/brunoborges">Bruno Borges</a>：Oracle产品经理、Java Jock。</li>
<li><a href="https://twitter.com/edburns">Ed Burns</a>：Oracle技术团队顾问。</li>
<li><a href="https://twitter.com/baeldung">Eugen Paraschiv</a>：Spring安全课程作者。</li>
<li><a href="https://twitter.com/JavaFXpert">James Weaver</a>：Java、JavaFX、IoT开发者、作者和演讲者。</li>
<li><a href="https://twitter.com/Java_EE/">Java EE</a>：Java EE Twitter官方账号。</li>
<li><a href="https://twitter.com/Oraclejavamag">Java Magazine</a>：Java杂志官方账号。</li>
<li><a href="https://twitter.com/javanetbuzz/">Java.net</a>：Java.net官方账号。</li>
<li><a href="https://twitter.com/java/">Java</a>：Java Twitter官方账号。</li>
<li><a href="https://twitter.com/javinpaul">Javin Paul</a>：知名Java博客作者。</li>
<li><a href="https://twitter.com/lukaseder">Lukas Eder</a>：Data Geekery（jOOQ）创始人兼CEO。</li>
<li><a href="https://twitter.com/mariofusco">Mario Fusco</a>：RedHatter、JUG协调、活跃讲师和作者。</li>
<li><a href="https://twitter.com/mreinhold">Mark Reinhold</a>：Oracle首席架构师、Java平台开发组。</li>
<li><a href="https://twitter.com/karianna">Martijn Verburg</a>：London JUG co-leader、演讲者、作家、Java Champion等。</li>
<li><a href="https://twitter.com/OpenJDK">OpenJDK</a>：OpenJDK官方账号。</li>
<li><a href="https://twitter.com/reza_rahman">Reza Rahman</a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li>
<li><a href="https://twitter.com/sjmaple">Simon Maple</a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li>
<li><a href="https://twitter.com/jodastephen">Stephen Colebourne</a>： Java Champion、演讲者。</li>
<li><a href="https://twitter.com/kablosna">Tim Boudreau</a>：作家、NetBeans大牛。</li>
<li><a href="https://twitter.com/trisha_gee">Trisha Gee</a>：Java Champion、演讲者。</li>
</ul>
<h3 id="weibo-weixin">微博、微信公众号</h3>

<ul>
<li>ImportNew 微博：<a href="http://weibo.com/importnew">@ImportNew</a></li>
<li>ImportNew：最受欢迎的、专注Java技术分享的微信公众号。专注Java技术分享，包括Java基础技术、进阶技能、架构设计和Java技术领域动态等。<br><br><img src="http://ww2.sinaimg.cn/small/63918611gw1epb2c7rv2uj20460463ym.jpg" width=150 height=150></li>
</ul>
<h3 id="websites">知名网站</h3>

<p><em>值得关注的Java技术站点。</em></p>
<h4>中文站点</h4>

<ul>
<li><a href="http://www.importnew.com/">ImportNew</a>（ImportNew 专注 Java 技术）</li>
</ul>
<h4>英文站点</h4>

<ul>
<li><a href="https://android-arsenal.com/">Android Arsenal</a></li>
<li><a href="http://www.importnew.com/google-java-style/">Google Java Style</a>：<a href="https://google.github.io/styleguide/javaguide.html">官网</a></li>
<li><a href="http://www.importnew.com/infoq/">InfoQ</a>：<a href="http://www.infoq.com/">官网</a></li>
<li><a href="http://www.javacodegeeks.com/">Java Code Geeks</a></li>
<li><a href="http://blog.jooq.org/">Java, SQL, and jOOQ</a></li>
<li><a href="http://java.net/">Java.net</a></li>
<li><a href="http://java.dzone.com/">Javalobby</a></li>
<li><a href="http://www.importnew.com/javaworld/">JavaWorld</a>：<a href="http://www.javaworld.com/">官网</a></li>
<li><a href="http://www.importnew.com/jaxenter/">JAXenter</a>：<a href="https://jaxenter.com/">官网</a></li>
<li><a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a></li>
<li><a href="http://www.importnew.com/javaspecialists/">The Java Specialist’ Newsletter</a>：<a href="http://www.javaspecialists.eu/archive/archive.jsp">官网</a></li>
<li><a href="http://blog.takipi.com/">The Takipi Blog</a></li>
<li><a href="http://www.importnew.com/theserverside/">TheServerSide.com</a>：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。<a href="http://www.theserverside.com/">官网</a></li>
<li><a href="http://www.thoughts-on-java.org/">Thoughts On Java</a></li>
<li><a href="http://vanillajava.blogspot.ch/">Vanilla Java</a></li>
<li><a href="http://vladmihalcea.com/">Vlad Mihalcea on Hibernate</a></li>
<li><a href="https://www.voxxed.com/">Voxxed</a></li>
<li><a href="http://www.importnew.com/onjava/">OnJava</a>：O’Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。<a href="http://www.onjava.com/">官网</a></li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>资源汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>go 语言学习路线</title>
    <url>/2023/11/13/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%8E%86%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%8E%86%E8%B7%AF%E7%BA%BF/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E5%8E%86%E8%B7%AF%E7%BA%BF.drawio.png" alt="Go语言学习路线"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes的网络模型：Overlay和Underlay</title>
    <url>/2023/11/08/Kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOverlay%E5%92%8CUnderlay/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 本文分别介绍 Overlay 网络模型和 Underlay 网络模型。</p>
<p>&ensp;&ensp;&ensp;&ensp; Overlay 网络模型物理网络模型中，连通多个物理网桥上的主机的一个简单办法是通过媒介直接连接这些网桥设备，各个主机处于同一个局域网（LAN）之中，管理员只需要确保各个网桥上每个主机的 IP 地址不相互冲突即可。类似地，若能够直接连接宿主机上的虚拟网桥形成一个大的局域网，就能在数据链路层打通各宿主机上的内部网络，让容器可通过自有IP地址直接通信。为避免各容器间的 IP 地址冲突，一个常见的解决方案是将每个宿主机分配到同一网络中的不同子网，各主机基于自有子网向其容器分配 IP 地址。</p>
<p>&ensp;&ensp;&ensp;&ensp; 显然，主机间的网络通信只能经由主机上可对外通信的网络接口进行，跨主机在数据链路层直接连接虚拟网桥的需求必然难以实现，除非借助宿主机间的通信网络构建的通信“隧道”进行数据帧转发。这种于某个通信网络之上构建出的另一个逻辑通信网络通常即 10.1.2 节提及的 Overlay 网络或Underlay 网络。图 10-7 为 Overlay 网络功能示意图。</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/Kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOverlay%E5%92%8CUnderlay/overlay%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="图 10-7 Overlay网络功能示意图"></p>
<p>&ensp;&ensp;&ensp;&ensp; 隧道转发的本质是将容器双方的通信报文分别封装成各自宿主机之间的报文，借助宿主机的网络“隧道”完成数据交换。这种虚拟网络的基本要求是各宿主机只需支持隧道协议即可，对于底层网络没有特殊要求。VXLAN 协议是目前最流行的 Overlay 网络隧道协议之一，它也是由 IETF 定义的 NVO3（Network Virtualization over Layer 3）标准技术之一，采用 L2 over L4（MAC-in-UDP）的报文封装模式，将二层报文用三层协议进行封装，可实现二层网络在三层范围内进行扩展，将“二层域”突破规模限制形成“大二层域”。</p>
<p>&ensp;&ensp;&ensp;&ensp; 那么，同一大二层域就类似于传统网络中 VLAN（虚拟局域网）的概念，只不过在 VXLAN 网络中，它被称作 Bridge-Domain，以下简称为 BD。类似于不同的 VLAN 需要通过 VLAN ID 进行区分，各 BD 要通过 VNI 加以标识。但是，为了确保 VXLAN 机制通信过程的正确性，涉及 VXLAN 通信的 IP 报文一律不能分片，这就要求物理网络的链路层实现中必须提供足够大的 MTU 值，或修改其 MTU 值以保证 VXLAN 报文的顺利传输。不过，降低默认MTU 值，以及额外的头部开销，必然会影响到报文传输性能。VXLAN 的显著的优势之一是对底层网络没有侵入性，管理员只需要在原有网络之上添加一些额外设备即可构建出虚拟的逻辑网络来。这个额外添加的设备称为 VTEP（VXLAN Tunnel Endpoints），它工作于 VXLAN 网络的边缘，负责相关协议报文的封包和解包等操作，从作用来说相当于 VXLAN 隧道的出入口设备。VTEP 代表着一类支持 VXLAN 协议的交换机，而支持 VXLAN 协议的操作系统也可将一台主机模拟为 VTEP，Linux 内核自 3.7 版本开始通过 vxlan 内核模块原生支持此协议。于是，各主机上由虚拟网桥构建的 LAN 便可借助 vxlan 内核模块模拟的 VTEP 设备与其他主机上的 VTEP 设备进行对接，形成隧道网络。同一个二层域内的各 VTEP 之间都需要建立 VXLAN 隧道，因此跨主机的容器间直接进行二层通信的 VXLAN 隧道是各 VTEP 之间的点对点隧道，如图 10-8 所示。</p>
<p>![图10-8 Linux VTEP](&#x2F;pic&#x2F;工程&#x2F;云计算&#x2F;K8S&#x2F;Kubernetes的网络模型：Overlay和Underlay&#x2F;Linux VTEP.png)</p>
<p>&ensp;&ensp;&ensp;&ensp; 对于 Flannel 来说，这个 VTEP 设备就是各节点上生成 flannel.1 网络接口，其中的“1”是 VXLAN 中的 BD 标识 VNI，因而同一 Kubernetes 集群上所有节点的 VTEP 设备属于 VNI 为 1 的同一个 BD。</p>
<p>&ensp;&ensp;&ensp;&ensp; 类似 VLAN 的工作机制，相同 VXLAN VNI 在不同 VTEP 之间的通信要借助二层网关来完成，而不同 VXLAN 之间，或者 VXLAN同非 VXLAN 之间的通信则需经由三层网关实现。VXLAN 支持使用集中式和分布式两种形式的网关：前者支持流量的集中管理，配置和维护较为简单，但转发效率不高，且容易出现瓶颈和网关可用性问题；后者以各节点为二层或三层网关，消除了瓶颈。然而，VXLAN 网络中的容器在首次通信之前，源 VTEP 又如何得知目标服务器在哪一个VTEP，并选择正确的路径传输通信报文呢？</p>
<p>&ensp;&ensp;&ensp;&ensp; 常见的解决思路一般有两种：多播和控制中心。</p>
<p>&ensp;&ensp;&ensp;&ensp; 多播是指同一个 BD 内的各 VTEP 加入同一个多播域中，通过多播报文查询目标容器所在的目标 VTEP。</p>
<p>&ensp;&ensp;&ensp;&ensp; 而控制中心则在某个共享的存储服务上保存所有容器子网及相关VTEP的映射信息，各主机上运行着相关的守护进程，并通过与控制中心的通信获取相关的映射信息。Flannel 默认的 VXLAN 后端采用的是后一种方式，它把网络配置信息存储在 etcd 系统上。Linux 内核自 3.7 版本开始支持vxlan 模块，此前的内核版本可以使用 UDP、IPIP 或 GRE 隧道技术。事实上，考虑到当今公有云底层网络的功能限制，Overlay 网络反倒是一种最为可行的容器网络解决方案，仅那些更注重网络性能的场景才会选择 Underlay 网络。</p>
<p>&ensp;&ensp;&ensp;&ensp; Underlay 网络模型：Underlay 网络就是传统 IT 基础设施网络，由交换机和路由器等设备组成，借助以太网协议、路由协议和VLAN 协议等驱动，它还是 Overlay 网络的底层网络，为 Overlay 网络提供数据通信服务。容器网络中的 Underlay 网络是指借助驱动程序将宿主机的底层网络接口直接暴露给容器使用的一种网络构建技术，较为常见的解决方案有 MAC VLAN、IP VLAN 和直接路由等。</p>
<p> &ensp;&ensp;&ensp;&ensp; <strong>MAC VLAN：</strong> MAC VLAN 支持在同一个以太网接口上虚拟出多个网络接口，每个虚拟接口都拥有唯一的 MAC 地址，并可按需配置 IP 地址。通常这类虚拟接口被网络工程师称作子接口，但在 MAC VLAN 中更常用上层或下层接口来表述。与 Bridge 模式相比，MAC VLAN 不再依赖虚拟网桥、NAT 和端口映射，它允许容器以虚拟接口方式直接连接物理接口。图 10-9 给出了 Bridge 与 MAC VLAN 网络对比示意图。</p>
<p> <img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/Kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOverlay%E5%92%8CUnderlay/Bridge%E4%B8%8EMAC.webp" alt="图10-9 Bridge与MAC"></p>
<p> &ensp;&ensp;&ensp;&ensp; MAC VLAN 有 Private、VEPA、Bridge 和Passthru 几种工作模式，它们各自的工作特性如下。</p>
<ul>
<li>Private：禁止构建在同一物理接口上的多个 MAC VLAN 实例（容器接口）彼此间的通信，即便外部的物理交换机支持“发夹模式”也不行。</li>
<li>VPEA：允许构建在同一物理接口上的多个 MAC VLAN 实例（容器接口）彼此间的通信，但需要外部交换机启用发夹模式，或者存在报文转发功能的路由器设备。</li>
<li>Bridge：将物理接口配置为网桥，从而允许同一物理接口上的多个 MAC VLAN 实例基于此网桥直接通信，而无须依赖外部的物理交换机来交换报文；此为最常用的模式，甚至还是 Docker 容器唯一支持的模式。</li>
<li>Passthru：允许其中一个 MAC VLAN 实例直接连接物理接口。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 由上述工作模式可知，除了 Passthru 模式外的容器流量将被 MAC VLAN 过滤而无法与底层主机通信，从而将主机与其运行的容器完全隔离，其隔离级别甚至高于网桥式网络模型，这对于有多租户需求的场景尤为有用。由于各实例都有专用的 MAC 地址，因此 MAC VLAN 允许传输广播和多播流量，但它要求物理接口工作于混杂模式，考虑到很多公有云环境中并不允许使用混杂模式，这意味着 MAC VLAN 更适用于本地网络环境。需要注意的是，MAC VLAN 为每个容器使用一个唯一的 MAC 地址，这可能会导致具有安全策略以防止 MAC 欺骗的交换机出现问题，因为这类交换机的每个接口只允许连接一个 MAC 地址。另外，有些物理网卡存在可支撑的 MAC 地址数量上限。</p>
<p> &ensp;&ensp;&ensp;&ensp; <strong>IP VLAN</strong> IP VLAN 类似于 MAC VLAN，它同样创建新的虚拟网络接口并为每个接口分配唯一的 IP 地址，不同之处在于，每个虚拟接口将共享使用物理接口的 MAC 地址，从而不再违反防止 MAC 欺骗的交换机的安全策略，且不要求在物理接口上启用混杂模式，如图 10-10 所示。</p>
<p>![图10-10 MAC VLAN对比IP VLAN](&#x2F;pic&#x2F;工程&#x2F;云计算&#x2F;K8S&#x2F;Kubernetes的网络模型：Overlay和Underlay&#x2F;MAC VLAN对比IP VLAN.png)</p>
<p>&ensp;&ensp;&ensp;&ensp; IP VLAN 有 L2 和 L3 两种模型，其中 IP VLAN L2 的工作模式类似于 MAC VLAN Bridge 模式，上层接口（物理接口）被用作网桥或交换机，负责为下层接口交换报文。</p>
<p>&ensp;&ensp;&ensp;&ensp; 而 IP VLAN L3 模式中，上层接口扮演路由器的角色，负责为各下层接口路由报文，如图 10-11 所示。IP VLAN L2 模型与MAC VLAN Bridge 模型都支持 ARP 协议和广播流量，它们拥有直接接入网桥设备的网络接口，能够通过 802.1d 数据包进行泛洪和 MAC 地址学习。但 IP VLAN L3 模式下，网络栈在容器内处理，不支持多播或广播流量，从这个意义上讲，它的运行模式与路由器的报文处理机制相同。虽然支持多种网络模型，但 MAC VLAN 和 IP VLAN 不能同时在同一物理接口上使用。Linux 内核文档中强调，MAC VLAN 和 IP VLAN 具有较高的相似度，因此，通常仅在必须使用 IP VLAN 的场景中才不使用 MAC VLAN。一般说来，强依赖于 IP VLAN 的场景有如下几个：</p>
<ul>
<li>Linux 主机连接到的外部交换机或路由器启用了防止 MAC 地址欺骗的安全策略；</li>
<li>虚拟接口的需求数量超出物理接口能够支撑的容量上限，并且将接口置于混杂模式会给性能带来较大的负面影响；</li>
<li>将虚拟接口放入不受信任的网络名称空间中可能会导致恶意的滥用。</li>
</ul>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/Kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOverlay%E5%92%8CUnderlay/VLAN%E7%9A%84L2%E5%92%8CL3%E6%A8%A1%E5%9E%8B.png" alt="图10-11 IP VLAN的L2和L3模型"></p>
<p>&ensp;&ensp;&ensp;&ensp; 需要注意的是，Linux 内核自 4.2 版本后才支持 IP VLAN 网络驱动，且在 Linux 主机上使用 ip link 命令创建的 802.1q配置接口不具有持久性，因此需依赖管理员通过网络启动脚本保持配置。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>直接路由</strong> “直接路由”模型放弃了跨主机容器在 L2 的连通性，而专注于通过路由协议提供容器在 L3 的通信方案。这种解决方案因为更易于集成到现在的数据中心的基础设施之上，便捷地连接容器和主机，并在报文过滤和隔离方面有着更好的扩展能力及更精细的控制模型，因而成为容器化网络较为流行的解决方案之一。</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/Kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOverlay%E5%92%8CUnderlay/%E7%9B%B4%E6%8E%A5%E8%B7%AF%E7%94%B1%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图10-12 直接路由虚拟网络示意图"></p>
<p>一个常用的直接路由解决方案如图 10-12 所示，每个主机上的各容器在二层通过网桥连通，网关指向当前主机上的网桥接口地址。跨主机的容器间通信，需要依据主机上的路由表指示完成报文路由，因此每个主机的物理接口地址都有可能成为另一个主机路由报文中的“下一跳”，这就要求各主机的物理接口必须位于同一个 L2 网络中。于是，在较大规模的主机集群中，问题的关键便转向如何更好地为每个主机维护路由表信息。常见的解决方案有：</p>
<ul>
<li>Flannel host-gw 使用存储总线 etcd 和工作在每个节点上的 flanneld 进程动态维护路由；</li>
<li>Calico 使用 BGP（Border Gateway Protocol）协议在主机集群中自动分发和学习路由信息。与 Flannel 不同的是，Calico 并不会为容器在主机上使用网桥，而是仅为每个容器生成一对 veth 设备，留在主机上的那一端会在主机上生成目标地址，作为当前容器的路由条目，如图 10-13 所示。</li>
</ul>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/Kubernetes%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOverlay%E5%92%8CUnderlay/Calico%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图10-13 Calico的直接路由模型示意图"></p>
<p>&ensp;&ensp;&ensp;&ensp; Calico 的直接路由模型示意图显然，较 Overlay 来说，无论是 MAC VLAN、IP VLAN 还是直接路由机制的 Underlay 网络模型的实现，它们因无须额外的报文开销而通常有着更好的性能表现，但对底层网络有着更多的限制条件。</p>
]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>K8S</tag>
        <tag>工程</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言包相关概念</title>
    <url>/2023/11/06/Go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、包的相关概念"><a href="#1、包的相关概念" class="headerlink" title="1、包的相关概念"></a><strong>1、包的相关概念</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Go 语言是使用包来组织源代码的，并实现命名空间的管理。任何源代码文件必须属于某个包。源码文件的第一行有效代码必须是 package pacakgeName 语句，通过该语句声明自己所在的包。</p>
<h4 id="2、包的特征"><a href="#2、包的特征" class="headerlink" title="2、包的特征"></a><strong>2、包的特征</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 所有的 .go 文件，除了空行和注释，都应该在第一行声明自己所属的包。即所有代码都必须组织在 package 中。包的结构特点有：</p>
<ul>
<li>源文件头部以 package 声明包名称；</li>
<li>包由同一目录下的多个源码文件组成，即一个目录下的同级文件属于同一个包；</li>
<li>每个包都在一个单独的目录里；</li>
<li>包所在的目录名最好不用 main 、 all 、 std 这三个保留名称；</li>
<li>可执行文件必须包含 package main 和入口函数 main ， main 包是 Go 语言程序的入口包，一个 Go 语言程序必须有且仅有一个 main 包，并且，一个 main 包中也必须有且仅有一个 main 函数。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件；</li>
<li>不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。这意味着，同一个目录下的所有 .go 文件必须声明同一个包名；</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 包中成员以名称首字母大小写决定访问权限。该规则适用于全局变量、全局常量、类型、结构字段、函数、方法等。</p>
<ul>
<li>Public : 首字母大写，可被包外访问；</li>
<li>internal : 首字母小写，仅包内成员可以访问；</li>
</ul>
<h4 id="3、包名约束"><a href="#3、包名约束" class="headerlink" title="3、包名约束"></a><strong>3、包名约束</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 给包命名的惯例是使用包所在目录的名字。给包及其目录命名时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。<br>&ensp;&ensp;&ensp;&ensp; 记住，并不需要所有包的名字都与别的包不同，因为导入包时是使用全路径的，所以可以区分同名的不同包。<br>&ensp;&ensp;&ensp;&ensp; 一般情况下，包被导入后会使用你的包名作为默认的名字，不过这个导入后的名字可以修改。这个特性在需要导入不同目录的同名包时很有用。</p>
<p>&ensp;&ensp;&ensp;&ensp; 关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况:</p>
<ul>
<li>包对应一个可执行程序，也就是 main 包，这时候 main 包本身的导入路径是无关紧要的。名字为 main 的包是给 go build 构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</li>
<li>包所在的目录中可能有一些文件名是以 _test.go 为后缀的 Go 源文件（译注：前面必须有其它的字符，因为以 _ 或 . 开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以 _test 为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以 _test 为后缀包名的测试外部扩展包都由 go test 命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖。</li>
<li>一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in&#x2F;yaml.v2” 这种情况下包的名字并不包含版本号后缀，而是 yaml 。</li>
</ul>
<h4 id="4、main-包"><a href="#4、main-包" class="headerlink" title="4、main 包"></a><strong>4、main 包</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在 Go 语言里，命名为 main 的包具有特殊的含义。 Go 语言的编译程序会试图把这种名字的包编译为二进制可执行文件。所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。<br>&ensp;&ensp;&ensp;&ensp; 当编译器发现某个包的名字为 main 时，它一定也会发现名为 main() 的函数，否则不会创建可执行文件。 main() 函数是程序的入口，所以，如果没有这个函数，程序就没有办法开始执行。程序编译时，会使用声明 main 包代码所在目录的目录名作为二进制可执行文件的文件名。</p>
<p>&ensp;&ensp;&ensp;&ensp; 而且通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。</p>
<h4 id="5、包的声明"><a href="#5、包的声明" class="headerlink" title="5、包的声明"></a><strong>5、包的声明</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在 Go 语言中，代码包中的源码文件名可以是任意的，这些任意名称的源码文件都必须以包声明语句作为文件中代码的第一行。比如 src 目录下的代码包 common&#x2F;upload 包中的所有源码文件都要先声明自己属于common&#x2F;upload 包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> upload</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; package 是 Go 语言中用于包声明语句的关键字。 Go 语言规定包声明中的包名为代码包路径的最后一个元素。如上，common&#x2F;upload 包的包路径为 common&#x2F;upload ，而包声明中的包名则为 upload 。而针对源码文件（即包含 main 函数的 .go 文件），无论存放在哪个包中，它都必须声明为属于 main 包。</p>
<h4 id="6、包的引入"><a href="#6、包的引入" class="headerlink" title="6、包的引入"></a><strong>6、包的引入</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 标准包的源码位于 $GOROOT&#x2F;src&#x2F; 下面，标准包可以直接引用。自定义的包和第三方包的源码必须放到 $GOPATH&#x2F;src&#x2F; 目录下才能被引用。导入包需要使用关键字 import ，它会告诉编译器你想引用该位置的包内的代码。如果需要导入多个包，习惯上是将 import 语句包装在一个导入块中。包的引用路径有两种写法， 一种是绝对路径，另一种是相对路径。要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包的路径&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 注意事项：</p>
<ul>
<li>import 导入语句通常放在源码文件开头包声明语句的下面；</li>
<li>导入的包名需要使用双引号包裹起来；</li>
<li>包名是从GOPATH&#x2F;src&#x2F; 后开始计算的，使用&#x2F; 进行路径分隔。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 包的导入有两种写法，分别是单行导入和多行导入。</p>
<ul>
<li><p>单行导入:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包 1 的路径&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;包 2 的路径&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;包 1 的路径&quot;</span></span><br><span class="line">    <span class="string">&quot;包 2 的路径&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-1、包的绝对路径"><a href="#6-1、包的绝对路径" class="headerlink" title="6.1、包的绝对路径"></a><strong>6.1、包的绝对路径</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 包的绝对路径就是 $GOROOT&#x2F;src 或 $GOPATH&#x2F;src 后面包的源码的全路径，比如下面的包引用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;common/upload&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;database/sql/driver&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;database/sql&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; upload 包是自定义的包，其源码位于 $GOPATH&#x2F;src&#x2F;common&#x2F;upload 目录下，代码包导入使用的路径就是代码包在工作区的 src 目录下的相对路径，比如 upload 的绝对路径为 &#x2F;home&#x2F;setsunayang&#x2F;gocode&#x2F;src&#x2F;common&#x2F;upload ，而 &#x2F;home&#x2F;setsunayang&#x2F;gocode 是被包含在环境变量 GOPATH 中的工作区目录路径，则其代码包导入路径就是 common&#x2F;upload。</p>
<p>&ensp;&ensp;&ensp;&ensp; sql 和 driver 包的源码分别位于 $GOROOT&#x2F;src&#x2F;database&#x2F;sql 和 $GOROOT&#x2F;src&#x2F;database&#x2F;sql&#x2F;driver 下。</p>
<p>&ensp;&ensp;&ensp;&ensp; 编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。一旦编译器找到一个满足 import 语句的包，就停止进一步查找。</p>
<h4 id="6-2、相对路径引用"><a href="#6-2、相对路径引用" class="headerlink" title="6.2、相对路径引用"></a><strong>6.2、相对路径引用</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 相对路径只能用于引用 $GOPATH 下的包，标准包的引用只能使用全路径引用。比如下面两个包：包 a 的路径是 $GOPATH&#x2F;src&#x2F;lab&#x2F;a ，包 b 的源码路径为 $GOPATH&#x2F;src&#x2F;lab&#x2F;b ，假设 b 引用了 a 包，则可以使用相对路径引用方式。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对路径引用</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../a&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 绝对路径引用</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;lab/a&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3、引用格式"><a href="#6-3、引用格式" class="headerlink" title="6.3、引用格式"></a><strong>6.3、引用格式</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 常用的包引用有以下 4 种格式，我们以 fmt 包为例进行说明。</p>
<ul>
<li>标准引用方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt”</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 此时可以用 fmt. </p>
<ul>
<li>别名引用方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> F <span class="string">&quot;fmt”</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 此时相当于给包 fmt 起了个别名 F ，用 F. 代替标准的 fmt.作为前缀引用 fmt 包内可导出元素。</p>
<ul>
<li>省略引用方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 此时相当于把包 fmt 的命名空间直接合并到当前程序的命名空间中，使用 fmt 包内可导出元素可以不用前缀 fmt. ，直接引用。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不需要加前级fmt.</span></span><br><span class="line">    Println(<span class="string">&quot;hello , world”)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>仅执行包初始化 init 函数</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 使用标准格式引用包，但是代码中却没有使用包，编译器会报错。如果包中有 init 初始化函数，则通过 import packageName 这种方式引用包，仅执行包的初始化函数，即使包没有 init 初始化函数，也不会引发编译器报错。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  _ <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 下划线字符 _ 在 Go 语言里称为空白标识符，这个标识符用来抛弃不想继续使用的值，如给导入的包赋予一个空名字，或者忽略函数返回的你不感兴趣的值。</p>
<ul>
<li>远程导入</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; Go 工具链会使用导入路径确定需要获取的代码在网络的什么地方。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/net/http&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 用导入路径编译程序时， go build 命令会使用 GOPATH 的设置，在磁盘上搜索这个包。</p>
<p>&ensp;&ensp;&ensp;&ensp; 事实上，这个导入路径代表一个 URL ，指向 GitHub 上的代码库。如果路径包含 URL ，可以使用 Go 工具链从分布式版本控制系统获取包，并把包的源代码保存在 GOPATH 指向的路径里与 URL 匹配的目录里。</p>
<p>&ensp;&ensp;&ensp;&ensp; 这个获取过程使用 go get 命令完成。go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其它包。由于 go get 的这种递归特性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。</p>
<h4 id="6-3、综合实践"><a href="#6-3、综合实践" class="headerlink" title="6.3、综合实践"></a><strong>6.3、综合实践</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当导入多个代码包时，需要用圆括号括起它们，且每个代码包名独占一行。在调用被导入代码包中的函数或使用其中的结构体、变量或常量时，需要使用包路径的最后一个元素加 . 的方式指定代码所在的包。</p>
<p>&ensp;&ensp;&ensp;&ensp; 例如，如果我们有两个包 logging 和 go_lib&#x2F;logging , 并且有相同的方法 logging_print() ，且有一个源码文件需要导入这两个包（标准引用）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;logging&quot;</span></span><br><span class="line">    <span class="string">&quot;go_lib/logging&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 则这句代码 logging.logging_print() 就会引起冲突， Go 语言无法知道 logging.Xxx() 代表的是哪一个包。所以，在 Go 语言中，如果在同一个源码文件中使用上述方法导入多个代码包，那么代码包路径的最后一个元素不可以重复。</p>
<p>&ensp;&ensp;&ensp;&ensp; 如果用这段代码包导入代码，在编译代码时，Go 语言会抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">”logging redeclared as imported package name”</span><br></pre></td></tr></table></figure>

<p>的错误。如果确实需要导入，当有这类重复时，我们可以给它们起个别名来区别（别名引用）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    la <span class="string">&quot;logging&quot;</span></span><br><span class="line">    lb <span class="string">&quot;go_lib/logging&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>调用包中的代码以如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger la.Logger = la.logging_print()</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 这里不必给每个引起冲突的代码包都起一个别名，只要能够区分它们就可以了。如果我们想直接调用某个依赖包的程序，就可以用 . 来代替别名（省略引用）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">&quot;logging&quot;</span></span><br><span class="line">    lb <span class="string">&quot;go_lib/logging&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在当前源码文件中，可以直接进行代码调用了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger Logger = logging_print()</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; Go 语言把变量、常量、函数、结构体和接口统称为程序实体，而把它们的名字统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线 ”_”，并且，首字母不能是数字。标识符的首字母的大小写控制着对应程序实体的访问权限。</p>
<p>&ensp;&ensp;&ensp;&ensp; 如果标识符的首字母是大写的，那么它对应的程序实体就可以被本代码包之外的代码访问到，也可以称其为可导出的。否则对应的程序实体就只能被本包内的代码访问。当然，还需要有以下两个额外条件：</p>
<ul>
<li>(1)、程序实体必须是非局部的。局部程序实体是被定义在函数或结构体的内部。</li>
<li>(2)、代码包所在的目录必须被包含在环境变量 GOPATH 中的工作区目录中。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 如果代码包 logging 中有一个叫做 getSimpleLogger 的函数，那么光从这个函数的名字上我们就可以看出，这个函数是不能被包外代码调用的。</p>
<p>&ensp;&ensp;&ensp;&ensp; 如果我们只想初始化某个代码包而不需要在当前源码文件中使用那个代码包中的任何代码，即可以用 _ 来代替别名（仅执行包初始化 init 函数的引用方式）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;logging&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="6-5、注意事项"><a href="#6-5、注意事项" class="headerlink" title="6.5、注意事项"></a><strong>6.5、注意事项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 一个包可以有多个 init 函数，包加载会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。</p>
<p>&ensp;&ensp;&ensp;&ensp; 包不能出现循环引用。比如包 a 引用了包 b ，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。</p>
<p>&ensp;&ensp;&ensp;&ensp; 包的重复引用是允许的。比如包 a 引用了包 b 和包 c ，包 b 和包 c 都引用了包 d 。这种场景相当于重复引用了d，这种情况是允许的， 并且 Go 编译器保证 d 的 init 函数只会执行一次。</p>
<h4 id="7、包初始化"><a href="#7、包初始化" class="headerlink" title="7、包初始化"></a><strong>7、包初始化</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在 Go 语言中，可以有专门的函数负责代码包初始化。这个函数需要无参数声明和结果声明，且名称必须为 init ，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;Initialize&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; Go 语言会在程序真正执行前对整个程序的依赖进行分析，并初始化相关的代码包。也就是说，所有的代码包初始化函数都会在 main 函数（命令源码文件中的入口函数）之前执行完成，而且只会执行一次。并且，当前代码包中的所有全局变量的初始化都会在代码包初始化函数执行前完成。这就避免了在代码包初始化函数对某个变量进行赋值之后又被该变量声明中赋予的值覆盖掉的问题。</p>
<p>&ensp;&ensp;&ensp;&ensp; 每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。所有被编译器发现的 init 函数都会安排在 main 函数之前执行。 init 函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。</p>
<p>&ensp;&ensp;&ensp;&ensp; Go 里面有两个保留的函数： init 函数（能够应用于所有的 package ）和 main 函数（只能应用于 package main ）。这两个函数在定义时不能有任何的参数和返回值。</p>
<p>&ensp;&ensp;&ensp;&ensp; 虽然一个 package 里面可以写任意多个 init 函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个 package 中每个文件只写一个 init 函数。</p>
<p>&ensp;&ensp;&ensp;&ensp; Go 程序会自动调用 init() 和 main() ，所以不需要在任何地方调用这两个函数。每个 package 中的 init 函数都是可选的，但 package main 只能包含一个 main 函数。</p>
<p>&ensp;&ensp;&ensp;&ensp; 程序的初始化和执行都起始于 main 包。如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 fmt 包，但它只会被导入一次，因为没有必要导入多次）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 init 函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init 函数（如果存在的话），最后执行 main 函数。下图详细地解释了整个执行过程：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="包的初始化过程"></p>
<p>&ensp;&ensp;&ensp;&ensp; init 函数特征总结：</p>
<ul>
<li>每个源文件都可以定义一个或多个初始化函数，但强烈建议只定义一个。</li>
<li>编译器不保证多个初始化函数执行次序。</li>
<li>初始化函数在单一线程被用，仅执行一次。</li>
<li>初始化函数在包所有全局变量初始化后执行。</li>
<li>在所有初始化函数结束后才执行 main.main。</li>
<li>init() 函数不能被其他函数调用。</li>
</ul>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/init%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="init执行过程"></p>
<p>&ensp;&ensp;&ensp;&ensp; 所以简而言之，你只需要记住这三点就可以了：</p>
<ul>
<li>依赖包按“深度优先”的次序进行初始化；</li>
<li>每个包内按以“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化；</li>
<li>包内的多个 init 函数按出现次序进行自动调用；</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 重点关注 init 函数具备的几种行为特征：</p>
<ul>
<li>执行顺位排在包内其他语法元素常量、变量的后面；</li>
<li>每个 init 函数在整个 Go 程序生命周期内仅会被执行一次；</li>
<li>init 函数是顺序执行的，只有当一个 init 函数执行完毕后，才会去执行下一个 init 函数。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 这里举出《Go并发编程实战》中的例子，帮助理解上面的包初始化，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 命令源码文件必须在这里声明自己属于main包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ( <span class="comment">// 引入了代码包fmt和runtime</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">// 包初始化函数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Map: %v\n&quot;</span>, m) <span class="comment">// 先格式化再打印</span></span><br><span class="line">    <span class="comment">// 通过调用runtime包的代码获取当前机器所运行的操作系统以及计算架构</span></span><br><span class="line">    <span class="comment">// 而后通过fmt包的Sprintf方法进行字符串格式化并赋值给变量info</span></span><br><span class="line">    info = fmt.Sprintf(<span class="string">&quot;OS: %s, Arch: %s&quot;</span>, runtime.GOOS, runtime.GOARCH)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非局部变量，map类型，且已初始化</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;A&quot;</span>, <span class="number">2</span>: <span class="string">&quot;B&quot;</span>, <span class="number">3</span>: <span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> info <span class="type">string</span> <span class="comment">// 非局部变量，string类型，未被初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 命令源码文件必须有的入口函数</span></span><br><span class="line">    fmt.Println(info) <span class="comment">// 打印变量info</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Map: <span class="keyword">map</span>[<span class="number">1</span>:A <span class="number">2</span>:B <span class="number">3</span>:C]</span><br><span class="line">OS: windows, Arch: amd64</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 在同一个代码包中，可以存在多个代码包初始化函数，甚至代码包内的每一个源码文件都可以定义多个代码包初始化函数。Go 语言编译器不能保证同一个代码包中的多个代码包初始化函数的执行顺序。如果要求按特定顺序执行的话，可以考虑使用 Channel 。</p>
<h4 id="8、编译速度"><a href="#8、编译速度" class="headerlink" title="8、编译速度"></a><strong>8、编译速度</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建， Go 语言编译器的编译速度也明显快于其它编译语言。 Go 语言的闪电般的编译速度主要得益于三个语言特性。</p>
<ul>
<li>所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>
<li>禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li>
<li>编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。</li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM参数概览(JDK8)</title>
    <url>/2023/11/03/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88(JDK8)/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88(JDK8).png" alt="JVM参数概览(JDK8)"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>虚拟机参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能工具</title>
    <url>/2023/10/25/Linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="性能工具谱图"><a href="#性能工具谱图" class="headerlink" title="性能工具谱图"></a><strong>性能工具谱图</strong></h4><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88.png" alt="性能工具谱图"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP报文结构和功能简析</title>
    <url>/2023/09/15/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a><strong>1、简介</strong></h2><p>&ensp;&ensp;&ensp;&ensp; TCP：传输、控制、协议。</p>
<p>&ensp;&ensp;&ensp;&ensp; TCP 与UDP 最大却别就在那个C上面，它充分实现了数据传输时各种控制功能。可以进行丢包重发控制，还可以对次序乱掉的数据包进行顺序控制，还能控制传输流量，这些是UDP中没有的。即 TCP 提供一种面向连接的、可靠的字节流服务。TCP 是一中面向有链接的协议，只有在确认对端存在的时候，才会发送分数据，从而也可以控制通信流量的浪费。</p>
<p>&ensp;&ensp;&ensp;&ensp; 什么是可靠的传输：不丢包、不损坏、不乱序、不重复。TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制来实现可靠传输。接收端查询就收数据 TCP 首部中的序号和数据长度。将自己下一步应该接受的序列号作为确认应答返送回去。就这样，通过序列号和确认应答，TCP 实现可靠传输。一般使用 TCP 首部用于控制的字段来管理连接。一个连接的建立和断开，正常过程中，至少需要来回共 7 个包才能完成。</p>
<h2 id="2、TCP首部"><a href="#2、TCP首部" class="headerlink" title="2、TCP首部"></a><strong>2、TCP首部</strong></h2><p>&ensp;&ensp;&ensp;&ensp; TCP首部的数据结构如图所示：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/TCP%E9%A6%96%E9%83%A8.webp" alt="TCP首部"></p>
<p>&ensp;&ensp;&ensp;&ensp; 为了便于理解，忽略选项部分，固定首部通常为20个字节，将按作用分类分析。</p>
<h4 id="2-1、端口号-port"><a href="#2-1、端口号-port" class="headerlink" title="2.1、端口号(port)"></a><strong>2.1、端口号(port)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 前 4 个字节来标识了发送方的端口号和接收方的端口号，即该数据包由谁发送，由谁接收。前 2 个字节标识源端口号，紧接着 2 个字节标识目的端口号。</p>
<p>&ensp;&ensp;&ensp;&ensp; 即发送方：(11111111,1111111)2 &#x3D; (65535)10，除去0~1023。</p>
<p>&ensp;&ensp;&ensp;&ensp; 即接收方：(11111111,1111111)2 &#x3D; (65535)10，除去0~1023。</p>
<h4 id="2-2、序号-seq"><a href="#2-2、序号-seq" class="headerlink" title="2.2、序号(seq)"></a><strong>2.2、序号(seq)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。长度为 4 字节，序号是 32bit 的无符号数,序号到达 2(32次方) - 1 后又从 0 开始。</p>
<h4 id="2-3、确认号-ack"><a href="#2-3、确认号-ack" class="headerlink" title="2.3、确认号(ack)"></a><strong>2.3、确认号(ack)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; ack：确认序号，即确认字节的序号，更确切地说，是发送确认的一端所期望收到的下一个序号。所谓的发送确认的一端就是将确认信息发出的一端。比如第二次握手的S端就是发送确认的一端。确认序号为上次接收的最后一个字节序号加1.只有确认标志位(ACK)为1的时候，确认序号才有效。</p>
<h4 id="2-4、数据偏移"><a href="#2-4、数据偏移" class="headerlink" title="2.4、数据偏移"></a><strong>2.4、数据偏移</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 也叫首部长度，占4个bit,它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB.webp" alt="TCP首部"></p>
<p>&ensp;&ensp;&ensp;&ensp; 由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。“首部长度”是 4 位二进制数，单位是32位字，能表示的最大十进制数字是 15。(1111)2&#x3D;(15)10,即是 15 个 32 位，一个 32 位是 4 个字节，因此数据偏移的最大值是 15x4&#x3D;60 个字节，这也是 TCP 首部的最大字节。因为固定首部的存在，数据偏移的值最小为20个字节，因此选项长度不能超过40字节*（减去20个字节的固定首部）。</p>
<h4 id="2-5、保留-reserve"><a href="#2-5、保留-reserve" class="headerlink" title="2.5、保留(reserve)"></a><strong>2.5、保留(reserve)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占 6 位，保留为今后使用，但目前应置为 0。</p>
<h4 id="2-6、紧急URG（urgent）"><a href="#2-6、紧急URG（urgent）" class="headerlink" title="2.6、紧急URG（urgent）"></a><strong>2.6、紧急URG（urgent）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当 URG&#x3D;1 时，表明紧急指针字段有效。</p>
<p>&ensp;&ensp;&ensp;&ensp; 它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。</p>
<p>&ensp;&ensp;&ensp;&ensp; 例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。</p>
<p>&ensp;&ensp;&ensp;&ensp; 当 URG 置为 1 时，应用进程就告诉 TCP 有紧急数据要传送。于是 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p>
<h4 id="2-7、确认ACK（acknowledgment）"><a href="#2-7、确认ACK（acknowledgment）" class="headerlink" title="2.7、确认ACK（acknowledgment）"></a><strong>2.7、确认ACK（acknowledgment）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 仅当ACK &#x3D; 1时确认号字段才有效，当ACK &#x3D; 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
<h4 id="2-8、推送-PSH（push）"><a href="#2-8、推送-PSH（push）" class="headerlink" title="2.8、推送 PSH（push）"></a><strong>2.8、推送 PSH（push）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p>
<h4 id="2-9、复位RST（reset）"><a href="#2-9、复位RST（reset）" class="headerlink" title="2.9、复位RST（reset）"></a><strong>2.9、复位RST（reset）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当RST&#x3D;1时，表明TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
<h4 id="2-10、同步SYN（synchronization）"><a href="#2-10、同步SYN（synchronization）" class="headerlink" title="2.10、同步SYN（synchronization）"></a><strong>2.10、同步SYN（synchronization）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1。</p>
<p>&ensp;&ensp;&ensp;&ensp; 因此SYN&#x3D;1就表示这是一个连接请求或连接接受报文。</p>
<h4 id="2-11、终止FIN（finis，意思是“完”“终”）"><a href="#2-11、终止FIN（finis，意思是“完”“终”）" class="headerlink" title="2.11、终止FIN（finis，意思是“完”“终”）"></a><strong>2.11、终止FIN（finis，意思是“完”“终”）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
<h4 id="2-12、窗口"><a href="#2-12、窗口" class="headerlink" title="2.12、窗口"></a><strong>2.12、窗口</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占2字节。窗口值是(0，216 -1)之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）,窗口大小是给对方用的。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方一次发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<p>&ensp;&ensp;&ensp;&ensp; 总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<p>&ensp;&ensp;&ensp;&ensp; 例如，A发送了一个报文段，其确认号是3000，窗口字段是1000.这就是告诉对方B：“从3000算起，A接收缓存空间还可接受1000个字节数据，字节序号是3000-3999”，可以想象到河道的阀门。</p>
<p>&ensp;&ensp;&ensp;&ensp; 总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p>
<h4 id="2-13、检验和"><a href="#2-13、检验和" class="headerlink" title="2.13、检验和"></a><strong>2.13、检验和</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。</p>
<h4 id="2-14、紧急指针"><a href="#2-14、紧急指针" class="headerlink" title="2.14、紧急指针"></a><strong>2.14、紧急指针</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p>
<h4 id="2-15、选项"><a href="#2-15、选项" class="headerlink" title="2.15、选项"></a><strong>2.15、选项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 长度可变，最长可达40个字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<h4 id="2-16、最大报文段长度"><a href="#2-16、最大报文段长度" class="headerlink" title="2.16、最大报文段长度"></a><strong>2.16、最大报文段长度</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 最大报文段长度(MSS:Maximum Segment Size)表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。</p>
<p>&ensp;&ensp;&ensp;&ensp; 当建立一个连接时，每一方都有用于通告它期望接收的MSS选项(MSS选项只能出现在SYN报文段中),如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节(这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报) 。</p>
<p>&ensp;&ensp;&ensp;&ensp; 为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1&#x2F;41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。<br>&ensp;&ensp;&ensp;&ensp; 因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。</p>
<p>&ensp;&ensp;&ensp;&ensp; 由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）&#x3D;556字节。</p>
<p>&ensp;&ensp;&ensp;&ensp; 后来又增加了几个选项如窗口扩大选项、时间戳选项等。</p>
<h4 id="2-17、窗口扩大选项"><a href="#2-17、窗口扩大选项" class="headerlink" title="2.17、窗口扩大选项"></a><strong>2.17、窗口扩大选项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 窗口扩大选项是为了扩大窗口。</p>
<p>&ensp;&ensp;&ensp;&ensp; 我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。</p>
<p>&ensp;&ensp;&ensp;&ensp; 窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2（16+14）-1&#x3D;230-1。</p>
<p>&ensp;&ensp;&ensp;&ensp; 窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S&#x3D;0选项，使窗口大小回到16。</p>
<h4 id="2-18、时间戳选项"><a href="#2-18、时间戳选项" class="headerlink" title="2.18、时间戳选项"></a><strong>2.18、时间戳选项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：</p>
<p>&ensp;&ensp;&ensp;&ensp; 第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。</p>
<p>&ensp;&ensp;&ensp;&ensp; 第二、 用于处理TCP序号超过232 的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加232 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit&#x2F;s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit&#x2F;s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>IP数据报</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2023/09/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a><strong>1、概述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 数据链路层是TCP&#x2F;IP协议栈的第二层！数据链路层的传输单元：帧（也就是传输单位）。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.webp" alt="数据链路层"></p>
<p>&ensp;&ensp;&ensp;&ensp; 帧的结构如下：</p>
<ul>
<li>帧结构的构成：MAC子层 + 上三层数据 + FCS</li>
</ul>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="帧结构"></p>
<ul>
<li>比喻：一个帧我们可以理解为一辆火车，MAC子层是火车头，上三层数据为乘客，FCS为火车尾巴</li>
<li>MAC子层头部包含（也叫帧头）：目标MAC地址（6字节） 源MAC地址（6字节） 类型（2字节）</li>
<li>MAC地址：也称为物理地址，是被固化到网卡的全球唯一标识，如下图：</li>
</ul>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/mac%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="Mac 地址结构"></p>
<p>&ensp;&ensp;&ensp;&ensp; <em>注释：MAC地址&#x3D;厂家标识+内部编号&#x3D;&#x3D;&#x3D;&#x3D;实现了全球唯一！怎么查看自己的MAC地址？开始运行–cmd–ipconfig &#x2F;all</em></p>
<ul>
<li>类型字段的作用：区分上层协议，0806代表上层协议是ARP协议，0800代表上层是IP协议</li>
<li>上三层数据：也就是3层包头+4层包头+5层数据。其中一个帧是有最大承载能力限制的。也就是一个帧中的上三层数据就是乘客，而一辆火车中的乘客是又上限的，一个帧的最大承受能力叫MTU值，目前国际标准为1500字节</li>
<li>MTU:（最大传输单元）1500字节</li>
<li>帧尾：FCS&#x3D;帧校验，长度4个字节，作用是校验整个帧在传输过程中是否发生传输错误。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 帧结构最终效果图如下：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E7%BB%93%E6%9E%84%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="帧结构效果图"></p>
<p>&ensp;&ensp;&ensp;&ensp; <em>经典问题：请描述一下帧结构?</em></p>
<p>&ensp;&ensp;&ensp;&ensp; <em>答：帧是由帧头+上三层数据+帧尾，帧头包含目MAC，源MAC，类型，帧尾是FCS，MTU：1500</em></p>
<h4 id="2、本层设备"><a href="#2、本层设备" class="headerlink" title="2、本层设备"></a><strong>2、本层设备</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 工作在2层的设备：交换机&#x2F;网桥</p>
<h4 id="3、交换机的工作原理"><a href="#3、交换机的工作原理" class="headerlink" title="3、交换机的工作原理"></a><strong>3、交换机的工作原理</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 经典问题：请描述一下交换机的工作原理。</p>
<p>&ensp;&ensp;&ensp;&ensp; 答：</p>
<p>&ensp;&ensp;&ensp;&ensp; 1）当收到一个帧，首先学习帧中的MAC地址来形成自己的MAC地址表！</p>
<p>&ensp;&ensp;&ensp;&ensp; 2）然后检查帧中的目标MAC地址，并匹配MAC地址表。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 如表中匹配成功，则单播转发！</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 如表中无匹配项，则广播转发！</p>
<p>&ensp;&ensp;&ensp;&ensp; 3）MAC地址表的老化时间是？300秒！</p>
<p>&ensp;&ensp;&ensp;&ensp; 效果图如下：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="交换机的工作原理"></p>
<h4 id="4、如何配置交换机"><a href="#4、如何配置交换机" class="headerlink" title="4、如何配置交换机"></a><strong>4、如何配置交换机</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 傻瓜式交换机一般是不支持管理和配置的！企业级交换机支持配置高级功能及高级配置，价格要高，一般称为管理型交换机！如购买一台华为或者思科交换机，看下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA.webp" alt="交换机"></p>
<p>&ensp;&ensp;&ensp;&ensp; 一般会自带一根console线！看下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/console%E7%BA%BF.webp" alt="console线"></p>
<p>&ensp;&ensp;&ensp;&ensp; 建议再买一根com口转USB线，看下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/com%E5%8F%A3%E8%BD%ACUSB%E7%BA%BF.webp" alt="com口转USB线"></p>
<p>&ensp;&ensp;&ensp;&ensp; 使用console线+转换usb线，来连接交换机的console口与电脑的USB接口，如下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E7%BA%BF.webp" alt="交换机接线"></p>
<p>&ensp;&ensp;&ensp;&ensp; 然后再电脑上打开超级终端（xp上自带，win7另行下载即可），即可看到配置界面。当然我们可以使用思科的模拟软件来做实验，如cisco packettracer</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈云原生</title>
    <url>/2023/09/13/%E8%B0%88%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 之前关于云计算技术底座的部门会谈，我本着程序员实事求是的态度，表示自己其实并不懂云原生。前段时间云技术底座的模型验证，遇到一个测试案例叫做“白屏纳管”，意思是指 CAAS 平台能够对包括云下硬件负载 F5、A10，云上 SLB 等设备进行管理。云原生技术有着太多的这种花里胡哨的名词，将本来很简单的一件事情包装出个能吓住人的词，来提高理解的门槛。作为一个一线开发，我有一种很深切的感受：很多优秀的设计，都是有着简洁优雅的设计原理或者说思想蕴含其中。这种没什么太多内涵的毫无意义的造词运动，对于工程实践，没有任何好处。我们不应该人云亦云盲目从众，也不应该以偏概全一叶障目。</p>
<p>&ensp;&ensp;&ensp;&ensp; 以下是阿里云公众号某产品经理关于云原生的解释，我截了图如下：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E5%8E%9F%E7%94%9F/%E8%B0%88%E8%B0%88%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9F%90%E6%96%87%E7%AB%A0.jpg" alt="阿里云云原生公众号某文章"></p>
<p>&ensp;&ensp;&ensp;&ensp; 这段话讲得没有问题，但是似乎又什么都没讲，对于云原生的定义，这种似是而非的说法显然不是一线开发人员想要的答案。</p>
<p>&ensp;&ensp;&ensp;&ensp; 我们在说云原生的时候，其实是在说“云原生计算”，云原生这个词其实可以拆为“云”和”原生“两个词，这其中其实隐藏了一个词——“云计算”。<strong>云原生一定是云计算，</strong> 这就要求我们事先已经对云计算的发展历史有所了解。云原生与云计算的区别便在“原生”二字上，那么理解云原生，重点就在理解其为何为“原生”。我这里用一句话来总结云原生：云原生是为了发挥出云计算所有优势的最短路径（这句精辟的提炼摘自《阿里云云原生架构实践》一书）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 这些想法和做法归纳为三个方面：应用架构、计算模型、代表技术。</p>
<ul>
<li><p><strong>代表技术</strong> 是最容易理解的。代表技术可以是一些狭义上的云原生基础设施，包含了相关的软件或硬件技术，例如裸金属、docker、K8S；也可以是泛化的一些工程技术体系，比如 Spring Cloud，DevOps，DDD ——它们与云基础设施不一样，很多并非为了云原生而生的，但是在云上环境表现活跃，也可以归纳到云原生代表技术中来。有些人说，使用了容器技术，就是云原生，这肯定是不准确的。容器其实只是改变了我们应用的部署方式，应用运行时的形态，以此来定义云原生是非常片面的。</p>
</li>
<li><p><strong>计算模型，</strong> 既然这个行业这么喜欢遣词造句，那我也造几个词（切，谁还不会啊！！！）。计算模型可以从两个方面来看：</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; <strong>计算的服务模型：</strong> 计算的服务模型是从商业的角度看的。我们从传统的购买硬件送软件，到购买软件和维护再到如今购买云服务，云计算平台将计算、存储、网络像煤电一样卖给我们。需要指出，计算资源的这种服务模型并不是在云原生中才强调的，而是从云计算提出的时候，就已经强调了的。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>服务的计算模型：</strong> 这个语境中，“服务”不再是商业上的“服务”，而是指“应用服务”。应用服务的计算模型，强调了应用程序的可伸缩性、弹性、自动化和可维护性，以适应现代云环境中的需求。当然，应用的可伸缩、弹性自动化运维这些并不是应用自身具备的能力，而是在云上环境被赋予的，但是需要从应用侧做一定的改造工作，“以适应现代云环境中的需求”，比如下面要说的——应用架构。</p>
<ul>
<li><strong>应用架构</strong> 为了最大化发挥云原生的计算优势，应用侧应该也要做架构升级——例如微服务化，在弹性扩缩的时候以更细的粒度进行算力分配，更精确的分配云计算底座资源（计算、存储、网络）——当然，这只是我简单作示意的一种说法。这种说法换个侧面来看，单体应用就不能上云计算么？当然可以，但是那就不叫云原生了，因为单体无法发挥出云计算的最大优势。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 所以从我自己目前的工作经历总结如下： <strong>云原生一定是云计算，特别的，云原生是有效发挥出云计算所有优势的最短路径。理解云原生，可以从代表技术、云原生计算模型、云原生应用架构三方面着手理解。</strong></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算领域</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>一种git分支模型</title>
    <url>/2023/09/10/%E4%B8%80%E7%A7%8Dgit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E5%B7%A5%E5%85%B7/git/%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B.png" alt="git 分支模型"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>分支模型</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之模板方法模式和策略模式</title>
    <url>/2023/09/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 这篇博客的设计模式应用案例来自于这个仓库，完整代码可以参考本仓库：</p>
<p>&ensp;&ensp;&ensp;&ensp; <a href="https://github.com/3546514206/WxChatGPT">微信大模型接入</a></p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E4%BB%93%E5%BA%93.png" alt="仓库主页"></p>
<p>&ensp;&ensp;&ensp;&ensp; 简单介绍一下这个仓库：1）实现了微信接入；2）实现了大模型接入；3）将微信的提问发给大模型，将大模型的回答返回给微信（欢迎给个 star）。</p>
<h4 id="1、背景分析"><a href="#1、背景分析" class="headerlink" title="1、背景分析"></a><strong>1、背景分析</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 1）我们预期接入的大模型肯定不止一种，现在市面上除了最牛的 GhatGPT，国内也陆续退出了豆包、文心一言、星火大模型等。为了获得良好的扩展性，我们可以基于策略模式对模型通讯模块进行封装，将不同的模型定义为一种通讯策略，程序中可以通过参数指定不同的模型工作；</p>
<p>&ensp;&ensp;&ensp;&ensp; 2）通讯的过程无非就是三个阶段：通信前参数组装、进行通讯、通讯完成处理结果，这里显然是可以通过模板方法进行封装的。结合策略模式，我们可以规定将来接入新模型的时候，有统一的代码组织形式和良好的扩展接口。</p>
<h4 id="2、知识补充"><a href="#2、知识补充" class="headerlink" title="2、知识补充"></a><strong>2、知识补充</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 我们这里不再对设计模式本身进行专门的讲解。</p>
<p>&ensp;&ensp;&ensp;&ensp; <a href="https://www.runoob.com/design-pattern/strategy-pattern.html">策略模式</a></p>
<p>&ensp;&ensp;&ensp;&ensp; <a href="https://www.runoob.com/design-pattern/template-pattern.html">模板方法模式</a></p>
<h4 id="3、代码分析"><a href="#3、代码分析" class="headerlink" title="3、代码分析"></a><strong>3、代码分析</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 如下图所示，DefaultHandler 是程序写给微信接入模块的一个回调（实现了消息处理接口 IMsgHandlerFace），当微信接入模块接收到微信消息，便会触发此回调，执行用户预定义行为。也就是在这个地方，我们接入了大模型，并将模型的问答结果返回给微信。 </p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E7%9A%84%E5%9C%B0%E6%96%B9.png" alt="模型接入的地方"></p>
<p>&ensp;&ensp;&ensp;&ensp; 一下三行代码的作用分别是：获取聊天模型的策略上下文（请参考上文中菜鸟教程——策略模式），返回的策略上下文会包含具体的执行策略，执行策略的选择是程序参数定义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 聊天模型策略</span></span><br><span class="line"><span class="type">StrategyContext</span> <span class="variable">context</span> <span class="operator">=</span> getStrategyContext();</span><br><span class="line"><span class="comment">// 构建聊天请求</span></span><br><span class="line"><span class="type">ChatRequest</span> <span class="variable">request</span> <span class="operator">=</span> buildChatRequest(msg);</span><br><span class="line"><span class="comment">// 进行聊天</span></span><br><span class="line"><span class="type">ChatResponse</span> <span class="variable">response</span> <span class="operator">=</span> context.executeStrategy(request);</span><br></pre></td></tr></table></figure>

<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B.png" alt="程序参数指定执行策略"></p>
<h4 id="3、策略模式实现"><a href="#3、策略模式实现" class="headerlink" title="3、策略模式实现"></a><strong>3、策略模式实现</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 首先，定义策略接口，策略接口中的 exec 方法是所有具体的策略类都需要实现的。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3.png" alt="策略接口"></p>
<p>&ensp;&ensp;&ensp;&ensp; 定义策略上下文，上下文是统一交给用户侧的一个”句柄”（可以参考上文 DefaultHandler 的代码，用户侧通过获取策略上下文来执行具体的策略实现的），用于持有具体的策略实现。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="策略上下文"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我们这里的策略实现类稍有不同，没有直接实现 exec 方法，也没有直接实现 IStrategy 接口。这涉及到另外一个设计模式——模板方法模式。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E7%B1%BB.png" alt="策略实现类"></p>
<h4 id="4、-模板方法模式"><a href="#4、-模板方法模式" class="headerlink" title="4、 模板方法模式"></a><strong>4、</strong> 模板方法模式</h4><p>&ensp;&ensp;&ensp;&ensp; 抽象策略类定义了一个算法模板方法，这个模板方法规定了 exec 方法执行时发生的三个算法步骤：postChatRequest (执行前的参数处理)、doExec (执行通讯请求)、postChatResponse(通讯完成之后的响应报文处理)。但是我并没有对这三个步骤进行实现，他们都是抽象的，延迟到了将来的策略实现类去实现。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E7%AD%96%E7%95%A5%E7%B1%BB.jpg" alt="抽象策略类"></p>
<p>&ensp;&ensp;&ensp;&ensp; 所有的策略实现类，实现的不是策略接口 IStrategy，而是继承抽象策略类 AbstractStrategy，也不再去实现 exec 方法，而是实现抽象类中算法模板规定的三个算法步骤。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%88%B6%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.jpg" alt="实现抽象策略类中规定的三个既定步骤"></p>
<h4 id="5、-其他一些想法"><a href="#5、-其他一些想法" class="headerlink" title="5、 其他一些想法"></a><strong>5、</strong> 其他一些想法</h4><p>&ensp;&ensp;&ensp;&ensp; 面向对象语言最重要的三个基本特性：封装、多态、继承，是软件工程七大原则开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特原则和合成复用原则的重要支撑点，设计模式是一种如何最大化发挥三个基本特性，从而能够遵循七大原则的一种编码层级上的技术，这也是 Java、C++ 等完美支持 OOP 编程范式语言，在面临庞大复杂工程时，总能将源代码组织得很好的原因之一吧。从这个角度出发，Go 语言在多态、继承的表现力上不足，也许是因为我还比较缺乏 Go 开发的实战经验，所以我不确定在面临复杂的建模场景的时候，Go 语言的编程方式还能不能进行有效表达。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础语法宝典</title>
    <url>/2023/09/04/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9D%E5%85%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言设计的关键字，了解这些关键字有助于命名变量的冲突避免</p>
<h3 id="go的二十五个关键字"><a href="#go的二十五个关键字" class="headerlink" title="go的二十五个关键字"></a>go的二十五个关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p><code>var</code>和<code>const</code> 是 Go语言基础里面的变量和常量申明</p>
</li>
<li><p><code>package</code>和<code>import</code> 用于分包和导入</p>
</li>
<li><p><code>func</code> 用于定义函数和方法</p>
</li>
<li><p><code>return</code> 用于从函数返回</p>
</li>
<li><p><code>defer</code> 用于类似析构函数</p>
</li>
<li><p><code>go</code> 用于并发</p>
</li>
<li><p><code>select</code> 用于选择不同类型的通讯</p>
</li>
<li><p><code>interface</code> 用于定义接口</p>
</li>
<li><p><code>struct</code> 用于定义抽象数据类型</p>
</li>
<li><p><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 用于流程控制</p>
</li>
<li><p><code>chan</code>用于channel通讯</p>
</li>
<li><p><code>type</code>用于声明自定义类型</p>
</li>
<li><p><code>map</code>用于声明map类型数据</p>
</li>
<li><p><code>range</code>用于读取slice、map、channel数据</p>
</li>
</ul>
<h1 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Go语言里面定义变量有多种方式。</p>
<p>使用<code>var</code>关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义三个类型都是“type”的变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义变量并初始化值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>

<p>同时初始化多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span>= v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>是不是觉得上面这样的定义有点繁琐？有一种写法可以让它变得简单一点。可以直接忽略类型声明，那么上面的代码变成这样了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    然后Go会根据其相应值的类型来初始化它们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>觉得上面的还是有些繁琐，继续简化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    编译器会根据初始化的值自动推导出相应的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>现在是不是看上去非常简洁了？<code>:=</code>这个符号直接取代了<code>var</code>和<code>type</code>,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用<code>var</code>方式来定义全局变量。</p>
<p><code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，将值<code>35</code>赋予<code>b</code>，并同时丢弃<code>34</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了<code>i</code>但未使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<p>它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>下面是一些常量声明的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> MaxThread = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;astaxie_&quot;</span></span><br></pre></td></tr></table></figure>

<p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给<code>float32</code>自动缩短为<code>32bit</code>，指定给<code>float64</code>自动缩短为<code>64bit</code>，详情参考 <code>http://golang.org/ref/spec#Constants</code> (需科学上网)</p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="type">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="type">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。</p>
<p>如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)</p>
<p>var a int8</p>
<p>var b int32</p>
<p>c:&#x3D;a + b</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p>
<p>Go还支持复数。它的默认类型是<code>complex128</code>（64位实数+64位虚数）。如果需要小一些的，也有<code>complex64</code>(32位实数+32位虚数)。复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。下面是一个使用复数的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="type">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code> </code>）括起来定义，它的类型是<code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="type">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="type">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">    frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但如果真的想要修改怎么办呢？下面的代码可以实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br></pre></td></tr></table></figure>

<p>Go中可以使用<code>+</code>操作符来连接两个字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure>

<p>修改字符串也可写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>

<p>如果要声明一个多行的字符串怎么办？可以通过&#96;&#96;&#96;来声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">    world`</span></span><br></pre></td></tr></table></figure>

<p>`&#96;&#96; 括起的字符串为<code>Raw</code>字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure>

<h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h2><p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。</p>
<p>例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> prefix <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>可以分组写成如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    pi <span class="type">float32</span></span><br><span class="line">    prefix <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h2><p>Go里面有一个关键字<code>iota</code>，这个关键字用来声明<code>enum</code>的时候采用，它默认开始值是0，const中每增加一行加1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">    y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">    z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">    w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">    b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">    c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">    d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">    g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p>
<h2 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h2><p>Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
<li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数。</li>
</ul>
<h2 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a><code>array</code>、<code>slice</code>、<code>map</code></h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h3><p><code>array</code>就是数组，它的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">//返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure>

<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组可以使用另一种<code>:=</code>来声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line">b := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure>

<p>Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p>在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和声明array一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>接下来可以声明一个<code>slice</code>，并初始化数据，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="type">byte</span></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"><span class="comment">// b是数组ar的另一个slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure>

<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
<h4 id="slice有一些简便的操作"><a href="#slice有一些简便的操作" class="headerlink" title="slice有一些简便的操作"></a><code>slice</code>有一些简便的操作</h4><ul>
<li><p><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></p>
</li>
<li><p><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></p>
</li>
<li><p>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></p>
</li>
</ul>
<p>下面这个例子展示了更多关于<code>slice</code>的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="type">byte</span></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:]  <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>]  <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>]  <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:]   <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>aSlice</code>中元素的值，那么<code>bSlice</code>相对应的值也会改变。</p>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li><p>一个指针，指向数组中<code>slice</code>指定的开始位置</p>
</li>
<li><p>长度，即<code>slice</code>的长度</p>
</li>
<li><p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Array_a := [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line">    Slice_a := Array_a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="slice有几个有用的内置函数"><a href="#slice有几个有用的内置函数" class="headerlink" title="slice有几个有用的内置函数"></a><code>slice</code>有几个有用的内置函数</h4><ul>
<li><p><code>len</code> 获取<code>slice</code>的长度</p>
</li>
<li><p><code>cap</code> 获取<code>slice</code>的最大容量</p>
</li>
<li><p><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></p>
</li>
<li><p><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</p>
</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。</p>
<p>但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<p>从Go1.2开始<code>slice</code>支持了三个参数的<code>slice</code>，之前一直采用这种方式在<code>slice</code>或者<code>array</code>基础上来获取一个<code>slice</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>上面这个的容量就是<code>7-2</code>，即5。这样这个产生的新的<code>slice</code>就没办法访问最后的三个元素。</p>
<p>如果<code>slice</code>是这样的形式<code>array[:i:j]</code>，即第一个参数为空，默认值就是0。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span><span class="string">`也就是Python中字典的概念，它的格式为`</span><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure>

<p>看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是｀int｀类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure>

<p>这个<code>map</code>就像平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用<code>map</code>过程中需要注意的几点：</p>
<ul>
<li><p><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</p>
</li>
<li><p><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</p>
</li>
<li><p>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</p>
</li>
<li><p><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></p>
</li>
<li><p><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p>
</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure>

<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Bonjour&quot;</span></span><br><span class="line">m1 := m</span><br><span class="line">m1[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Salut&quot;</span>  <span class="comment">// 现在m[&quot;hello&quot;]的值已经是Salut了</span></span><br></pre></td></tr></table></figure>

<h2 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a><code>make</code>、<code>new</code>操作</h2><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<p>内建函数<code>new</code>本质上说跟其它语言中的同名函数功能一样：<code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。有一点非常重要：</p>
<p><code>new</code>返回指针。</p>
<p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个<code>slice</code>，是一个包含指向数据（内部<code>array</code>）的指针、长度和容量的三项描述符；在这些项目被初始化之前，<code>slice</code>为<code>nil</code>。对于<code>slice</code>、<code>map</code>和<code>channel</code>来说，<code>make</code>初始化了内部的数据结构，填充适当的值。</p>
<p><code>make</code>返回初始化后的（非零）值。</p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。</p>
<p>此处罗列 部分类型 的 “零值”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>     <span class="number">0</span></span><br><span class="line"><span class="type">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="type">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="type">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="type">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="type">rune</span>    <span class="number">0</span> <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="type">byte</span>    <span class="number">0x0</span> <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="type">float32</span> <span class="number">0</span> <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="type">float64</span> <span class="number">0</span> <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="type">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="type">string</span>  <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的<code>if</code>还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>多个条件的时候如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Go有<code>goto</code>语句——请明智地使用它。用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">Here:   <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">goto</span> Here   <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签名是大小写敏感的。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go里面最强大的一个控制逻辑就是<code>for</code>，它既可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，看看下面的例子吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure>

<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果忽略<code>expression1</code>和<code>expression3</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，这就是<code>while</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code>   ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure>

<p><code>break</code>和<code>continue</code>还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值</p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>有些时候需要写很多的<code>if-else</code>来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候<code>switch</code>就能很好的解决这个问题。它的语法如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的类型必须一致。Go的<code>switch</code>非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果<code>switch</code>没有表达式，它会匹配<code>true</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第5行中，把很多值聚合在了一个<code>case</code>里面，同时，Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以使用<code>fallthrough</code>强制执行后面的case代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是Go里面的核心设计，它通过关键字<code>func</code>来声明，它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line">    <span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">    <span class="comment">//返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出</p>
<ul>
<li><p>关键字<code>func</code>用来声明一个函数<code>funcName</code></p>
</li>
<li><p>函数可以有一个或者多个参数，每个参数后面带有类型，通过<code>,</code>分隔</p>
</li>
<li><p>函数可以返回多个值</p>
</li>
<li><p>上面返回值声明了两个变量<code>output1</code>和<code>output2</code>，如果不想声明也可以，直接就两个类型</p>
</li>
<li><p>如果只有一个返回值且不声明返回值变量，那么可以省略 包括返回值的括号</p>
</li>
<li><p>如果没有返回值，那么就直接省略最后的返回信息</p>
</li>
<li><p>如果有返回值， 那么必须在函数的外层添加return语句</p>
</li>
</ul>
<p>下面来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line">    max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个里面可以看到<code>max</code>函数有两个参数，它们的类型都是<code>int</code>，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<p>直接看例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子可以看到直接返回了两个参数，当然也可以命名返回参数的变量，这个例子里面只是用了两个类型，也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">    add = A+B</span><br><span class="line">    Multiplied = A*B</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p>
<p>为了验证上面的说法，来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a = a+<span class="number">1</span> <span class="comment">// 改变了a的值</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">//返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(x)  <span class="comment">//调用add1(x)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出&quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出&quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然调用了<code>add1</code>函数，并且在<code>add1</code>中执行<code>a = a+1</code>操作，但是上面例子中<code>x</code>变量的值没有发生变化</p>
<p>理由很简单：因为当调用<code>add1</code>的时候，<code>add1</code>接收的参数其实是<code>x</code>的copy，而不是<code>x</code>本身。</p>
<p>如果真的需要传这个<code>x</code>本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p>
<ul>
<li><p>传指针使得多个函数能操作同一个对象。</p>
</li>
<li><p>传指针比较轻量级 (8bytes),只是传内存地址，可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。</p>
</li>
<li><p>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</p>
</li>
</ul>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言中有种不错的设计，即延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有很多重复的代码，Go的<code>defer</code>有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在<code>defer</code>后指定的函数会在函数退出前调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，defer会用在释放数据库连接，关闭文件等需要在函数结束时处理的操作。</p>
<h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在Go中函数也是一种变量，可以通过<code>type</code>来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 inputType1 , input2 inputType2 [, ...])</span></span> (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure>

<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">bool</span> <span class="comment">// 声明了一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="type">int</span>, f testInt)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数当做值和类型在写一些通用接口的时候非常有用，通过上面例子看到<code>testInt</code>这个类型是一个函数类型，然后两个<code>filter</code>函数的参数和返回值与<code>testInt</code>类型是一样的，但是可以实现很多种的逻辑，这样使得程序变得非常的灵活。</p>
<h2 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h2><p>Go没有像Java那样的异常机制，它不能抛出异常，而是使用了<code>panic</code>和<code>recover</code>机制。一定要记住，应当把它作为最后的手段来使用，也就是说，代码中应当没有，或者很少有<code>panic</code>的东西。这是个强大的工具，请明智地使用它。</p>
<p>Panic</p>
<p>是一个内建函数，可以中断原有的控制流程，进入一个<code>panic</code>状态中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。<code>panic</code>可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p>
<p>Recover</p>
<p>是一个内建的函数，可以让进入<code>panic</code>状态的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p>
<p>下面这个函数演示了如何在过程中使用<code>panic</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span></span>) (b <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>defer</code>必须在<code>panic</code>语句之前。</p>
<p><code>recover</code>必须配合<code>defer</code>使用。</p>
<h2 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h2><p>Go里面有两个保留的函数：<code>init</code>函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p>
<p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p>
<p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在写Go代码的时候经常用到import这个命令用来导入包文件，经常看到的方式参考如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后代码里面可以通过如下的方式调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<h3 id="1、相对路径"><a href="#1、相对路径" class="headerlink" title="1、相对路径"></a>1、相对路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./model&quot;</span> <span class="comment">//当前文件同一目录的model目录，但是不建议这种方式来import</span></span><br></pre></td></tr></table></figure>

<h3 id="2、绝对路径"><a href="#2、绝对路径" class="headerlink" title="2、绝对路径"></a>2、绝对路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;shorturl/model&quot;</span> <span class="comment">//加载gopath/src/shorturl/model模块</span></span><br></pre></td></tr></table></figure>

<p>上面展示了一些import常用的几种方式，但是还有一些</p>
<h3 id="特殊的import"><a href="#特殊的import" class="headerlink" title="特殊的import"></a>特殊的import</h3><h4 id="1、点操作"><a href="#1、点操作" class="headerlink" title="1、点操作"></a>1、点操作</h4><p>有时候会看到如下的方式导入包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个点操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名，也就是前面调用的fmt.Println(“hello world”)可以省略的写成<code>Println(&quot;hello world&quot;)</code></p>
<h4 id="2、别名操作"><a href="#2、别名操作" class="headerlink" title="2、别名操作"></a>2、别名操作</h4><p>别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">        f <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>别名操作的话调用包函数时前缀变成了前缀，即<code>f.Println(&quot;hello world&quot;)</code></p>
<h4 id="3、-操作"><a href="#3、-操作" class="headerlink" title="3、_操作"></a>3、_操作</h4><p>这个操作经常是让很多人费解的一个操作符，请看下面这个<code>import</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/ziutek/mymysql/godrv&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>_</code>操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的<code>init函数</code>。</p>
<h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct类型的声明"><a href="#struct类型的声明" class="headerlink" title="struct类型的声明"></a>struct类型的声明</h2><p>Go语言中，也和C或者其他语言一样，可以声明新的类型，作为其它类型的属性或字段的容器。例如，可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型称之<code>struct</code>。如下代码所示:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>struct</code>如此简单，上面的类型包含有两个字段</p>
<ul>
<li>一个<code>string</code>类型的字段name，用来保存用户名称这个属性</li>
<li>一个<code>int</code>类型的字段age，用来保存用户年龄这个属性</li>
</ul>
<p>使用<code>struct</code>看下面的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值&quot;Astaxie&quot;给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值&quot;25&quot;给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure>

<p>除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p>
<ol>
<li><p>按照顺序提供初始化值<br><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p>
</li>
<li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序<br><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p>
</li>
<li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code><br><code>P := new(person)</code></p>
</li>
</ol>
<p>看一个完整的使用<code>struct</code>的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span></span> (person, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> p1.age&gt;p2.age &#123;  <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tom person</span><br><span class="line">    <span class="comment">// 赋值初始化</span></span><br><span class="line">    tom.name, tom.age = <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span></span><br><span class="line">    <span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">    bob := person&#123;age:<span class="number">25</span>, name:<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">    paul := person&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">43</span>&#125;</span><br><span class="line">    tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">    tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">    bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a><code>struct</code>的匿名字段</h2><p>定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
<p>当匿名字段是一个<code>struct</code>的时候，那么这个<code>struct</code>所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p>
<p>看一个例子，让上面说的这些更具体化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，匿名字段就是这样，能够实现字段的继承。student还能访问Human这个字段作为字段名。请看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mark.Human = Human&#123;<span class="string">&quot;Marcus&quot;</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过匿名访问和修改字段相当的有用，但是不仅仅是<code>struct</code>字段，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">    Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">    <span class="type">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化学生Jane</span></span><br><span class="line">    jane := Student&#123;Human:Human&#123;<span class="string">&quot;Jane&quot;</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">&quot;Biology&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 现在访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her name is &quot;</span>, jane.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her age is &quot;</span>, jane.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her weight is &quot;</span>, jane.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her speciality is &quot;</span>, jane.speciality)</span><br><span class="line">    <span class="comment">// 修改他的skill技能字段</span></span><br><span class="line">    jane.Skills = []<span class="type">string</span>&#123;<span class="string">&quot;anatomy&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills are &quot;</span>, jane.Skills)</span><br><span class="line">    fmt.Println(<span class="string">&quot;She acquired two new ones &quot;</span>)</span><br><span class="line">    jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">&quot;physics&quot;</span>, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills now are &quot;</span>, jane.Skills)</span><br><span class="line">    <span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">    jane.<span class="type">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her preferred number is&quot;</span>, jane.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面例子看出来<code>struct</code>不仅仅能够将<code>struct</code>作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p>
<p>这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p>
<p>Go里面很简单的解决了这个问题，最外层的优先访问，也就是当通过<code>student.phone</code>访问的时候，是访问student里面的字段，而不是human里面的字段。</p>
<p>这样就允许去重载通过匿名字段继承的一些字段，当然如果想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// Human类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段Human</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// 雇员的phone字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">    <span class="comment">// 如果要访问Human的phone字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>函数的另一种形态，带有接收者的函数，称为<code>method</code></p>
<h2 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，定义了一个struct叫做长方形，现在想要计算他的面积，那么按照一般的思路应该会用下面的方式来实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r Rectangle)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, area(r1))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p>
<p>这样实现当然没有问题，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，想计算他们的面积的时候怎么办？那就只能增加新的函数，但是函数名就必须要跟着换了，变成<code>area_rectangle, area_circle, area_triangle...</code></p>
<p> 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p>
<p>很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p>
<p>基于上面的原因所以就有了<code>method</code>的概念，<code>method</code>是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在<code>func</code>后面增加了一个receiver(也就是method所依从的主体)。</p>
<p>用上面提到的形状的例子来说，method <code>area()</code> 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p>
<p>更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p>
<p>用Rob Pike的话来说就是：</p>
<p>“A method is a function with an implicit first argument, called a receiver.”</p>
<p>method的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r ReceiverType)</span></span> funcName(parameters) (results)</span><br></pre></td></tr></table></figure>

<p>下面用最开始的例子用method来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用method的时候重要注意几点</p>
<ul>
<li><p>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</p>
</li>
<li><p>method里面可以访问接收者的字段</p>
</li>
<li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p>
</li>
</ul>
<p>在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle&#x2F;Circle 发出的。</p>
<p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p>
<p>那是不是method只能作用在struct上面呢？当然不是，他可以定义在任何自定义的类型、内置类型、struct等各种类型上面。什么叫自定义类型，自定义类型不就是struct，其实不是这样的，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type typeName typeLiteral</span><br></pre></td></tr></table></figure>

<p>请看下面这个申明自定义类型的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ages <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> money <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> months <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m := months &#123;</span><br><span class="line">    <span class="string">&quot;January&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;February&quot;</span>:<span class="number">28</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;December&quot;</span>:<span class="number">31</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int，回到<code>method</code> 可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让看一个复杂一点的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    WHITE = <span class="literal">iota</span></span><br><span class="line">    BLACK</span><br><span class="line">    BLUE</span><br><span class="line">    RED</span><br><span class="line">    YELLOW</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Color <span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height, depth <span class="type">float64</span></span><br><span class="line">    color Color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span></span> Volume() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">    b.color = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> BiggestColor() Color &#123;</span><br><span class="line">    v := <span class="number">0.00</span></span><br><span class="line">    k := Color(WHITE)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        <span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">            v = bv</span><br><span class="line">            k = b.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> PaintItBlack() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        bl[i].SetColor(BLACK)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    strings := []<span class="type">string</span> &#123;<span class="string">&quot;WHITE&quot;</span>, <span class="string">&quot;BLACK&quot;</span>, <span class="string">&quot;BLUE&quot;</span>, <span class="string">&quot;RED&quot;</span>, <span class="string">&quot;YELLOW&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boxes := BoxList &#123;</span><br><span class="line">        Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">        Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">        Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;We have %d boxes in our set\n&quot;</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">    fmt.Println(<span class="string">&quot;The volume of the first one is&quot;</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">&quot;cm³&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the last one is&quot;</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s paint them all black&quot;</span>)</span><br><span class="line">    boxes.PaintItBlack()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the second one is&quot;</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Obviously, now, the biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过const定义了一些常量，然后定义了一些自定义类型</p>
<ul>
<li><p>Color作为byte的别名</p>
</li>
<li><p>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</p>
</li>
<li><p>定义了一个slice:BoxList，含有Box</p>
</li>
</ul>
<p>然后以上面的自定义类型为接收者定义了一些method</p>
<ul>
<li><p>Volume()定义了接收者为Box，返回Box的容量</p>
</li>
<li><p>SetColor(c Color)，把Box的颜色改为c</p>
</li>
<li><p>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</p>
</li>
<li><p>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</p>
</li>
<li><p>String()定义在Color上面，返回Color的具体颜色(字符串格式)</p>
</li>
</ul>
<p>上面的代码通过文字描述出来之后是不是很简单？一般解决问题都是通过问题的描述，去写相应的代码实现。</p>
<h2 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h2><p>现在让回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，可以使用*Box。</p>
<p>定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以需要传入指针。</p>
<p>这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p>
<p>这里也许会问SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,需要读取到指针相应的值。</p>
<p>其实Go里面这两种方式都是正确的，当用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值。PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。这两种方式都可以，因为Go知道receiver是指针，他自动转了。</p>
<p>也就是说：</p>
<p>如果一个method的receiver是*T,可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p>
<p>类似的</p>
<p>如果一个method的receiver是T，可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method</p>
<p>所以不用担心是调用的指针的method还是不是指针的method，Go知道要做的一切，这对于有多年C&#x2F;C++编程经验的同学来说，真是解决了一个很大的痛苦。</p>
<h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>通过字段的继承的学习，发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。来看下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><p>上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些内容，可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>Go语言里面设计最精妙的应该算<code>interface</code>，它让面向对象，内容组织实现非常的方便</p>
<h2 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，<code>interface</code>是一组<code>method</code>签名的组合，通过<code>interface</code>来定义对象的一组行为。</p>
<p>前面例子中<code>Student</code>和<code>Employee</code>都能<code>SayHi</code>，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p>
<p>继续做更多的扩展，<code>Student</code>和<code>Employee</code>实现另一个方法<code>Sing</code>，然后<code>Student</code>实现方法<code>BorrowMoney</code>而<code>Employee</code>实现<code>SpendSalary</code>。</p>
<p>这样<code>Student</code>实现了三个方法：<code>SayHi</code>、<code>Sing</code>、<code>BorrowMoney</code>；而<code>Employee</code>实现了<code>SayHi</code>、<code>Sing</code>、<code>SpendSalary</code>。</p>
<p>上面这些方法的组合称为<code>interface</code>(被对象<code>Student</code>和<code>Employee</code>实现)。例如<code>Student</code>和<code>Employee</code>都实现了<code>interface</code>：<code>SayHi</code>和<code>Sing</code>，也就是这两个对象是该<code>interface</code>类型。而<code>Employee</code>没有实现这个<code>interface：SayHi、Sing</code>和<code>BorrowMoney</code>，因为<code>Employee</code>没有实现<code>BorrowMoney</code>这个方法。</p>
<h2 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h2><p><code>interface</code>类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，interface可以被任意的对象实现。看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p>最后，任意的类型都实现了空interface(这样定义：interface{})，也就是包含0个method的interface。</p>
<h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><p>那么interface里面到底能存什么值呢？如果定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p>因为m能够持有这三种类型的对象，所以可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和传统意义上面的slice有所不同。</p>
<p>来看一下下面这个例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">    <span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line">    <span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">    <span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">    <span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，发现<code>interface</code>就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了<code>duck-typing</code>:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure>

<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回<code>interface&#123;&#125;</code>,那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h2 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h2><p>interface的变量可以持有任意实现该interface类型的对象，这给编写函数(包括method)提供了一些额外的思考，是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println是常用的一个函数，是否注意到它可以接受任意类型的数据。打开fmt的源码文件，会看到这样一个定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，任何实现了String方法的类型都能作为参数被<code>fmt.Println</code>调用,来试一试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在再回顾一下前面的Box示例，发现Color结构也定义了一个<code>method：String</code>。其实这也是实现了<code>fmt.Stringer</code>这个<code>interface</code>，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现<code>Stringer</code>这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure>

<p>注：实现了<code>error</code>接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
<h2 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h2><p>interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<ul>
<li>Comma-ok断言</li>
</ul>
<p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok &#x3D; element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p>
<p>通过一个例子来更加深入的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="type">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否注意到了多个if里面，if里面允许初始化变量。断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。</p>
<ul>
<li>switch测试</li>
</ul>
<p>重写上面的这个实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要强调的是：<code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用<code>comma-ok</code>。</p>
<h2 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h2><p>Go里面真正吸引人的是它内置的逻辑语法，就像在学习Struct时学习的匿名字段，那么相同的逻辑引入到interface里面，更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p>
<p>可以看到源码包<code>container/heap</code>里面有这样的一个定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>sort.Interface</code>其实就是嵌入字段，把<code>sort.Interface</code>的所有<code>method</code>给隐式的包含进来了。也就是下面三个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子就是io包下面的 <code>io.ReadWriter</code> ，它包含了io包下面的<code>Reader</code>和<code>Writer</code>两个<code>interface</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。一般用到的包是<code>reflect</code>包。如何运用<code>reflect</code>包，官方的这篇文章详细的讲解了<code>reflect</code>包的实现原理，<code>laws of reflection</code> 链接地址为 <a href="http://golang.org/doc/articles/laws_of_reflection.html">http://golang.org/doc/articles/laws_of_reflection.html</a></p>
<p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了<code>空interface</code>)，首先需要把它转化成<code>reflect</code>对象(<code>reflect.Type</code>或者<code>reflect.Value</code>，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>

<p>转化为reflect对象之后就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>

<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>

<p>最后，反射的话，那么反射的字段必须是可修改的，前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<p>如果要修改相应的值，必须这样写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go从语言层面支持了并行。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><code>goroutine</code>是<code>Go</code>并行设计的核心。<code>goroutine</code>说到底其实就是协程，但是它比线程更小，十几个<code>goroutine</code>可能体现在底层就是五六个线程，Go语言内部实现了这些<code>goroutine</code>之间的内存共享。执行<code>goroutine</code>只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。<code>goroutine</code>比<code>thread</code>更易用、更高效、更轻便。</p>
<p><code>goroutine</code>是通过Go的<code>runtime</code>管理的一个线程管理器。<code>goroutine</code>通过<code>go</code>关键字实现了，其实就是一个普通的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure>

<p>通过关键字go就启动了一个<code>goroutine</code>。来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>可以看到go关键字很方便的就实现了并发编程。</p>
<p>上面的多个<code>goroutine</code>运行在同一个进程里面，共享内存数据，不过设计上要遵循：不要通过共享来通信，而要通过通信来共享。</p>
<p><code>runtime.Gosched()</code>表示让CPU把时间片让给别人,下次某个时候继续恢复执行该<code>goroutine</code>。</p>
<p>默认情况下，在Go 1.5将标识并发系统线程个数的<code>runtime.GOMAXPROCS</code>的初始值由1改为了<code>运行环境的CPU核数</code>。</p>
<p>但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要程序中显式调用 <code>runtime.GOMAXPROCS(n)</code> 告诉调度器同时使用多个线程。<code>GOMAXPROCS</code> 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果<code>n &lt; 1</code>，不会改变当前设置。</p>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p><code>goroutine</code>运行在相同的地址空间，因此访问共享内存必须做好同步。那么<code>goroutine</code>之间如何进行数据的通信呢，Go提供了一个很好的通信机制<code>channel</code>。<code>channel</code>可以与<code>Unix shell</code> 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：<code>channel类型</code>。定义一个<code>channel</code>时，也需要定义发送到<code>channel</code>的值的类型。注意，必须使用<code>make</code> 创建<code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><code>channel</code>通过操作符<code>&lt;-</code>来接收和发送数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure>

<p>把这些应用到例子中来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>channel</code>接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得<code>Goroutines</code>同步变的更加的简单，而不需要显式的<code>lock</code>。所谓阻塞，也就是如果读取（<code>value := &lt;-ch</code>）它将会被阻塞，直到有数据接收。其次，任何发送（<code>ch&lt;-5</code>）将会被阻塞，直到数据被读出。无缓冲<code>channel</code>是在多个<code>goroutine</code>之间同步很棒的工具。</p>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。<code>ch:= make(chan bool</code>, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure>

<p>当 <code>value = 0</code> 时，channel 是无缓冲阻塞读写的，当<code>value &gt; 0</code> 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p>
<p>看一下下面这个例子，可以在自己本机测试一下，修改相应的value值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改为1报如下的错误:</span></span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>

<h2 id="Range和Close"><a href="#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h2><p>上面这个例子中，需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for i := range c</code>能够不断的读取<code>channel</code>里面的数据，直到该<code>channel</code>被显式的关闭。上面代码看到可以显式的关闭<code>channel</code>，生产者通过内置函数<code>close</code>关闭<code>channel</code>。关闭<code>channel</code>之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试<code>channel</code>是否被关闭。如果ok返回false，那么说明<code>channel</code>已经没有任何数据并且已经被关闭。</p>
<p>记住应该在生产者的地方关闭<code>channel</code>，而不是消费的地方去关闭它，这样容易引起<code>panic</code></p>
<p>另外记住一点的就是<code>channel</code>不像文件之类的，不需要经常去关闭，只有确实没有任何发送数据了，或者想显式的结束<code>range</code>循环之类的</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>上面介绍的都是只有一个<code>channel</code>的情况，那么如果存在多个<code>channel</code>的时候，该如何操作呢，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听<code>channel</code>上的数据流动。</p>
<p><code>select</code>默认是阻塞的，只有当监听的<code>channel</code>中有发送或接收可以进行时才会运行，当多个<code>channel</code>都准备好的时候，<code>select</code>是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>select</code>里面还有<code>default</code>语法，<code>select</code>其实就是类似<code>switch</code>的功能，<code>default</code>就是当监听的<code>channel</code>都没有准备好的时候，默认执行的（<code>select</code>不再阻塞等待<code>channel</code>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现<code>goroutine</code>阻塞的情况，那么如何避免整个程序进入阻塞的情况呢？可以利用<code>select</code>来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p><code>runtime</code>包中有几个处理<code>goroutine</code>的函数：</p>
<ul>
<li><p><code>Goexit</code> : 退出当前执行的goroutine，但是defer函数还会继续调用</p>
</li>
<li><p><code>Gosched</code>: 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p><code>NumCPU</code> : 返回 CPU 核数量</p>
</li>
<li><p><code>NumGoroutine</code>: 返回正在执行和排队的任务总数</p>
</li>
<li><p><code>GOMAXPROCS</code> : 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言主要的设计准则是：简洁、明白，简洁是指语法和C类似，相当的简单，明白是指任何语句都是很明显的，不含有任何隐含的东西，在错误处理方案的设计中也贯彻了这一思想。</p>
<p>在C语言里面是通过返回<code>-1</code>或者<code>NULL</code>之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而<code>Go</code>定义了一个叫做<code>error</code>的类型，来显式表达错误。在使用时，通过把返回的<code>error</code>变量与<code>nil</code>的比较，来判定操作是否成功。例如<code>os.Open</code>函数在打开文件失败时将返回一个不为<code>nil</code>的<code>error</code>变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>下面这个例子通过调用<code>os.Open</code>打开一个文件，如果出现错误，那么就会调用<code>log.Fatal</code>来输出错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;filename.ext&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于<code>os.Open</code>函数，标准包中所有可能出错的API都会返回一个<code>error</code>变量，以方便错误处理，这个小节将详细地介绍<code>error</code>类型的设计，和讨论开发Web应用中如何更好地处理<code>error</code>。</p>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>error是一个内置的接口类型，可以在<code>/builtin/</code>包下面找到相应的定义。而在很多内部包里面用到的 <code>error</code>是<code>errors</code>包下面的实现的私有结构<code>errorString</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<code>errors.New</code>把一个字符串转化为<code>errorString</code>，以得到一个满足接口<code>error</code>的对象，其内部实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子演示了如何使用<code>errors.New</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，在调用Sqrt的时候传递的一个负数，然后就得到了<code>non-nil</code>的<code>error</code>对象，将此对象与<code>nil</code>比较，结果为<code>true</code>，所以<code>fmt.Println</code>(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := Sqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Error"><a href="#自定义Error" class="headerlink" title="自定义Error"></a>自定义Error</h2><p><code>error</code>是一个<code>interface</code>，所以在实现自己的包的时候，通过定义实现此接口的结构，就可以实现自己的错误定义，请看来自Json包的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="type">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="type">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>

<p><code>Offset</code>字段在调用<code>Error</code>的时候不会被打印，但可以通过类型断言获取错误类型，然后可以打印相应的错误信息，请看下面的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">        line, col := findLine(f, serr.Offset)</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s:%d:%d: %v&quot;</span>, f.Name(), line, col, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数返回自定义错误时，返回值推荐设置为<code>error</code>类型，而非自定义错误类型，特别需要注意的是不应预声明自定义错误类型的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">()</span></span> *SyntaxError &#123; <span class="comment">// 错误，将可能导致上层调用者err!=nil的判断永远为true。</span></span><br><span class="line">    <span class="keyword">var</span> err *SyntaxError     <span class="comment">// 预声明错误变量</span></span><br><span class="line">    <span class="keyword">if</span> 出错条件 &#123;</span><br><span class="line">        err = &amp;SyntaxError&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err               <span class="comment">// 错误，err永远等于非nil，导致上层调用者err!=nil的判断始终为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因见 <code>http://golang.org/doc/faq#nil_error</code> (需科学上网)</p>
<p>上面例子简单的演示了如何自定义Error类型。但是如果还需要更复杂的错误处理呢？此时，来参考一下net包采用的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的地方，通过类型断言<code>err</code>是不是<code>net.Error</code>,来细化错误的处理，例如下面的例子，如果一个网络发生临时性错误，那么将会sleep 1秒之后重试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go在错误处理上采用了与C类似的检查返回值的方式，而不是其他多数主流语言采用的异常方式，这造成了代码编写上的一个很大的缺点:错误处理代码的冗余，对于这种情况是通过复用检测函数来减少类似的代码。</p>
<p>请看下面这个例子代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/view&quot;</span>, viewRecord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中获取数据和模板展示调用时都有检测错误，当有错误发生时，调用了统一的处理函数<code>http.Error</code>，返回给客户端500错误码，并显示相应的错误数据。但是当越来越多的<code>HandleFunc</code>加入之后，这样的错误处理逻辑代码就会越来越多，其实可以通过自定义路由器来缩减代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fn(w, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了自定义的路由器，然后可以通过如下方式来注册函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/view&quot;</span>, appHandler(viewRecord))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求<code>/view</code>的时候逻辑处理可以变成如下代码，和第一种实现方式相比较已经简单了很多。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewTemplate.Execute(w, record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子错误处理的时候所有的错误返回给用户的都是500错误码，然后打印出来相应的错误代码，其实可以把这个错误信息定义的更加友好，调试的时候也方便定位问题，可以自定义返回的错误类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   <span class="type">error</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样自定义路由器可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> *appError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">&quot;%v&quot;</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改完自定义错误之后，逻辑处理可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> *appError &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在访问view的时候可以根据不同的情况获取不同的错误码和错误信息，虽然这个和第一个版本的代码量差不多，但是这个显示的错误更加明显，提示的错误信息更加友好，扩展性也比第一个更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在程序设计中，容错是相当重要的一部分工作，在Go中它是通过错误处理来实现的，error虽然只是一个接口，但是其变化却可以有很多，可以根据自己的需求来实现不同的处理。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang新手可能会踩的50个坑</title>
    <url>/2023/09/04/Golang%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%8450%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p>
<p>如果花时间学习官方 doc、wiki、<a href="https://groups.google.com/forum/#!forum/golang-nuts">讨论邮件列表</a>、 <a href="https://github.com/robpike">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p>
<h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-不能单独放一行"><a href="#1-左大括号-不能单独放一行" class="headerlink" title="1. 左大括号 { 不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;    <span class="comment">// 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.&#x2F;main.go: missing function body</p>
</blockquote>
<blockquote>
<p>.&#x2F;main.go: syntax error: unexpected semicolon or newline before {</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p>
<p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span>     <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span>     <span class="comment">// error: one declared and not used</span></span><br><span class="line">    two := <span class="number">2</span>    <span class="comment">// error: two declared and not used</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span>    <span class="comment">// error: three declared and not used</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">    _ = one</span><br><span class="line"></span><br><span class="line">    two := <span class="number">2</span></span><br><span class="line">    <span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">    one = three</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">    four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p>
<p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span>    <span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>    <span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = log.Println</span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>    <span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>, <span class="number">2</span>    <span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">    one, two = two, one    <span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span>    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p>
<p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 2    // 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Go 开发者常犯的错，而且不易被发现。</p>
<p>可使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; go tool vet -shadow main.go</span><br><span class="line">main.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5</span><br></pre></td></tr></table></figure>

<p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; $GOPATH/bin/<span class="keyword">go</span>-nyet main.<span class="keyword">go</span></span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">3</span>:Shadowing variable <span class="string">`x`</span></span><br></pre></td></tr></table></figure>

<h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>    <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11. string 类型的变量值不能为 nil"></a>11. string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;    <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span>    <span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p>
<p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)            <span class="comment">// [1 2 3]    // 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改参数数组：</p>
<ul>
<li>直接传递指向这个数组的指针类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v)    <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;    <span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p>
<p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p>
<p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p>
<ol>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</li>
<li>使用“独立”的切片分两步：</li>
</ol>
<ul>
<li><p>创建外部 slice</p>
</li>
<li><p>对每个内部 slice 进行内存分配<br>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用“共享底层数组”的切片</li>
</ol>
<ul>
<li><p>创建一个存放原始数据的容器 slice</p>
</li>
<li><p>创建其他的 slice</p>
</li>
<li><p>切割原始 slice 来初始化其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化原始 slice</span></span><br><span class="line">    fmt.Println(raw, &amp;raw[<span class="number">4</span>])    <span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">        table[i] = raw[i*w : i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])    <span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于多维数组的参考</p>
<p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p>
<p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p>
<h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; php -r &#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure>

<p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p>
<p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)    <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p>
<p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span>        <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>    <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="type">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">    x = <span class="type">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p>
<p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p>
<ul>
<li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li>
<li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li>
</ul>
<p>雾：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p>
<h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p>
<p>这种处理方式和其他语言一样，比如 PHP 中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span>    <span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;中文&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;�&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;中&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>])        <span class="comment">// 97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p>
<h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p>
<p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>然而在 Go 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内建函数 <code>len()</code> 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。</p>
<p>如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    char := &quot;é&quot;</span><br><span class="line">    fmt.Println(len(char))    // 3</span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    // 2</span><br><span class="line">    fmt.Println(&quot;cafe\u0301&quot;)    // café    // 法文的 cafe，实际上是两个 rune 的组合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.golang.org/normalization">normalization</a></p>
<h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">    z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p>
<h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p>
<h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p>
<p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079494-de9e6a55-0bd7-4d37-9cf8-4edc3c9ee978.png" alt="img"></p>
<h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p>
<p>也可以改写 case 为多条件判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code> 只作为运算符而非表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i            <span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">    fmt.Println(data[i++])    <span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(~<span class="number">2</span>)        <span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)        <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p>
<p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">10000010</span> [A]</span><br><span class="line"><span class="number">00000010</span> [B]</span><br><span class="line"><span class="number">11111101</span> (NOT B)</span><br><span class="line"><span class="number">00000010</span> ^ <span class="number">11111111</span> = <span class="number">11111101</span> [B XOR <span class="number">0xff</span>]</span><br><span class="line"><span class="number">10000010</span> ^ <span class="number">00000010</span> = <span class="number">10000000</span> [A XOR B]</span><br><span class="line"><span class="number">10000010</span> &amp; <span class="number">00000010</span> = <span class="number">00000010</span> [A AND B]</span><br><span class="line"><span class="number">10000010</span> &amp;^<span class="number">00000010</span> = <span class="number">10000000</span> [A <span class="string">&#x27;AND NOT&#x27;</span> B]</span><br><span class="line"><span class="number">10000010</span>&amp;(^<span class="number">00000010</span>)= <span class="number">10000000</span> [A AND (NOT B)]</span><br></pre></td></tr></table></figure>

<h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)    <span class="comment">// &amp; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)    <span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)    <span class="comment">// | 优先 ^</span></span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级列表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>

<h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)    <span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(encoded))    <span class="comment">// &#123;&quot;One&quot;:1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out)     <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079610-d9523090-8363-463a-b6f0-aa4e55a1b7ef.png" alt="img"></p>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079522-5d8f767c-aa6d-4960-bcd3-795aca54b1da.png" alt="img"></p>
<p>看起来好像 goroutine 都执行完了，然而报错：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p>
<p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-48ae068a-8fe5-49b8-ba79-6aecc941525a.png" alt="img"></p>
<h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079544-84c1140a-23ae-4858-80b7-b0adf759ee18.png" alt="img"></p>
<h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p>
<p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p>
<p>向已关闭的 channel 中发送数据会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)        <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)            <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)    <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-645d7d98-a284-417a-94d0-a0b810b6d032.png" alt="img"></p>
<p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079515-81889255-1ad8-424a-9b46-20de774153b4.png" alt="img"></p>
<h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil 的 channel"></a>34. 使用了值为 <code>nil</code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 死锁错误：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>goroutine 1 [chan receive (nil chan)]</p>
<p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inCh</span><br><span class="line">            <span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">                out = outCh</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inCh &lt;- <span class="number">1</span></span><br><span class="line">    inCh &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079586-ec05c601-40cf-4ae1-b8f6-c02b63226d74.png" alt="img"></p>
<h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="type">int</span></span><br><span class="line">    key   *<span class="type">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">    this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc()    <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()    <span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-aac01481-dec9-4479-b0be-d9f7165af772.png" alt="img"></p>
<h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<p>应该先检查HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Get <a href="https://api.ipify.org/?format=json">https://api.ipify.org?format=...</a>: x509: certificate signed by unknown authority</p>
<p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p>
<ul>
<li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li>
<li>手动调用 <code>defer</code> 来关闭响应体：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkError(err)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p>
<p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_, err = io.Copy(ioutil.Discard, resp.Body)    // 手动丢弃读取完毕的数据</span><br></pre></td></tr></table></figure>

<p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)</span><br></pre></td></tr></table></figure>

<h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p>
<ul>
<li>直接设置请求变量的 <code>Close</code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li>
<li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)    // 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)    <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需求选择使用场景：</p>
<ul>
<li>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</li>
<li>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</li>
</ul>
<h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])    <span class="comment">// float64</span></span><br><span class="line">    <span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)    <span class="comment">// 类型断言错误</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: interface conversion: interface {} is float64, not int</p>
<p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p>
<ul>
<li>将 int 值转为 float 统一使用</li>
<li>将 decode 后需要的 float 值转为 int 使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">    decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">      decoder.UseNumber()</span><br><span class="line">      <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">      err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">    checkError(err)</span><br><span class="line">       fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">          Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">      checkError(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型<br>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">            StatusCode <span class="type">uint64</span></span><br><span class="line">            StatusName <span class="type">string</span></span><br><span class="line">            Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">            Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">        checkError(err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusName = name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusCode = code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="type">int</span></span><br><span class="line">    fp      <span class="type">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">    str     <span class="type">string</span></span><br><span class="line">    char    <span class="type">rune</span></span><br><span class="line">    yes     <span class="type">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="type">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="type">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>    <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="type">byte</span>            <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared)</p>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">       <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>DeepEqual()</code> 并不总适合于比较 slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code> 和 <code>strings.EqualFold()</code></p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto&#x2F;subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p>
<ul>
<li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 &#x2F; 中断 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 什么都不会捕捉</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)    <span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recobered:  panic: not good</p>
<h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span>    <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])    <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]    <span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p>
<p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAA</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/uffixBBBB    // 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改</p>
<p>解决方法：</p>
<ul>
<li>重新分配新的 slice 并拷贝你需要的数据</li>
<li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]        <span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p>
<h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)    <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)    <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)    <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p>
<p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 类型声明也保留它的方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line">            <span class="comment">//break    // 死循环，一直打印 breaking out...</span></span><br><span class="line">            <span class="keyword">break</span> loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p>
<h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vCopy := v</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vCopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下边这个稍复杂的 3 个示例区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;    <span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>result: 2</p>
<h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)    <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()    <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建 10000 个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> n in &#123;<span class="number">1.</span><span class="number">.10000</span>&#125;; do</span><br><span class="line">    echo content &gt; <span class="string">&quot;file$&#123;n&#125;.txt&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079519-ec32c68a-4892-4e5c-bced-cd3d864c960f.png" alt="img"></p>
<p>解决办法：defer 延迟执行的函数写入匿名函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p>
<h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p>
<p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p>
<p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p>
<p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p>
<ul>
<li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel <code>default</code> 语句：<br><code>default</code> 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p>
<h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>()    <span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    in.<span class="built_in">print</span>()    <span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()    <span class="comment">// m[&quot;x&quot;] 是不可寻址的    // 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot use data literal (type data) as type printer in assignment:</p>
<p>data does not implement printer (print method has pointer receiver)</p>
<p>cannot call pointer method on m[“x”]</p>
<p>cannot take the address of m[“x”]</p>
<h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot assign to struct field m[“x”].name in map</p>
<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p>
<p>更新 map 中 struct 元素的字段值，有 2 个方法：</p>
<ul>
<li>使用局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">    r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">    fmt.Println(m)    <span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指向元素的 map 指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span>    <span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])    <span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; false    // data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)    <span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)            <span class="comment">// *struct &#123;&#125;    // res 不是 nil，它的值为 nil</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)            <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>    <span class="comment">// 明确指明返回 nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)    <span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p>
<p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。</p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置：</p>
<p> <img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079583-c6b22446-874e-41ce-8898-39d36c0881b5.png" alt="img"></p>
<h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p>
<p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p>
<p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/">文档</a></p>
<p><code>GOMAXPROCS</code> 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())    <span class="comment">// 4</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> u1()    <span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-1ec1022c-6083-4b1a-93fd-982ef37ae959.png" alt="img"></p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p>
<h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)    <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079553-0bfc962d-ba49-426c-b720-43d42581d3af.png" alt="img"></p>
<p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079699-1d179d4e-3e72-4be3-8595-67d600aa223e.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢原作者 <a href="https://twitter.com/kcqon">kcqon</a> 总结的这篇博客，让我受益匪浅。</p>
<p>由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang精编100题</title>
    <url>/2023/09/04/Golang%E7%B2%BE%E7%BC%96100%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="能力模型"><a href="#能力模型" class="headerlink" title="能力模型"></a>能力模型</h2><table>
<thead>
<tr>
<th>级别</th>
<th>模型</th>
</tr>
</thead>
<tbody><tr>
<td>初级</td>
<td></td>
</tr>
<tr>
<td>primary</td>
<td>熟悉基本语法，能够看懂代码的意图；</td>
</tr>
<tr>
<td>在他人指导下能够完成用户故事的开发，编写的代码符合CleanCode规范；</td>
<td></td>
</tr>
<tr>
<td>中级</td>
<td></td>
</tr>
<tr>
<td>intermediate</td>
<td>能够独立完成用户故事的开发和测试；</td>
</tr>
<tr>
<td>能够嗅出代码的坏味道，并知道如何重构达成目标；</td>
<td></td>
</tr>
<tr>
<td>高级</td>
<td></td>
</tr>
<tr>
<td>senior</td>
<td>能够开发出高质量高性能的代码；</td>
</tr>
<tr>
<td>能够熟练使用高级特性，开发编程框架或测试框架；</td>
<td></td>
</tr>
</tbody></table>
<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="1、-primary-下面属于关键字的是（）"><a href="#1、-primary-下面属于关键字的是（）" class="headerlink" title="1、**[primary]** 下面属于关键字的是（）"></a>1、**[primary]** 下面属于关键字的是（）</h3><p>A. func</p>
<p>B. def</p>
<p>C. struct</p>
<p>D. class</p>
<p>参考答案：AC</p>
<h3 id="2、-primary-定义一个包内全局字符串变量，下面语法正确的是-（）"><a href="#2、-primary-定义一个包内全局字符串变量，下面语法正确的是-（）" class="headerlink" title="2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）"></a>2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）</h3><p>A. var str string</p>
<p>B. str :&#x3D; “”</p>
<p>C. str &#x3D; “”</p>
<p>D. var str &#x3D; “”</p>
<p>参考答案：AD</p>
<h3 id="3、-primary-通过指针变量-p-访问其成员变量-name，下面语法正确的是（）"><a href="#3、-primary-通过指针变量-p-访问其成员变量-name，下面语法正确的是（）" class="headerlink" title="3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）"></a>3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）</h3><p>A. p.name</p>
<p>B. (*p).name</p>
<p>C. (&amp;p).name</p>
<p>D. p-&gt;name</p>
<p>参考答案：AB</p>
<h3 id="4、-primary-关于接口和类的说法，下面说法正确的是（）"><a href="#4、-primary-关于接口和类的说法，下面说法正确的是（）" class="headerlink" title="4、**[primary]** 关于接口和类的说法，下面说法正确的是（）"></a>4、**[primary]** 关于接口和类的说法，下面说法正确的是（）</h3><p>A. 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口</p>
<p>B. 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理</p>
<p>C. 类实现接口时，需要导入接口所在的包</p>
<p>D. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p>
<p>参考答案：ABD</p>
<h3 id="5、-primary-关于字符串连接，下面语法正确的是（）"><a href="#5、-primary-关于字符串连接，下面语法正确的是（）" class="headerlink" title="5、**[primary]** 关于字符串连接，下面语法正确的是（）"></a>5、**[primary]** 关于字符串连接，下面语法正确的是（）</h3><p>A. str :&#x3D; ‘abc’ + ‘123’</p>
<p>B. str :&#x3D; “abc” + “123”</p>
<p>C. str ：&#x3D; ‘123’ + “abc”</p>
<p>D. fmt.Sprintf(“abc%d”, 123)</p>
<p>参考答案：BD</p>
<h3 id="6、-primary-关于协程，下面说法正确是（）"><a href="#6、-primary-关于协程，下面说法正确是（）" class="headerlink" title="6、**[primary]** 关于协程，下面说法正确是（）"></a>6、**[primary]** 关于协程，下面说法正确是（）</h3><p>A. 协程和线程都可以实现程序的并发执行</p>
<p>B. 线程比协程更轻量级</p>
<p>C. 协程不存在死锁问题</p>
<p>D. 通过channel来进行协程间的通信</p>
<p>参考答案：AD</p>
<h3 id="7、-intermediate-关于init函数，下面说法正确的是（）"><a href="#7、-intermediate-关于init函数，下面说法正确的是（）" class="headerlink" title="7、**[intermediate]** 关于init函数，下面说法正确的是（）"></a>7、**[intermediate]** 关于init函数，下面说法正确的是（）</h3><p>A. 一个包中，可以包含多个init函数</p>
<p>B. 程序编译时，先执行导入包的init函数，再执行本包内的init函数</p>
<p>C. main包中，不能有init函数</p>
<p>D. init函数可以被其他函数调用</p>
<p>参考答案：AB</p>
<h3 id="8、-primary-关于循环语句，下面说法正确的有（）"><a href="#8、-primary-关于循环语句，下面说法正确的有（）" class="headerlink" title="8、**[primary]** 关于循环语句，下面说法正确的有（）"></a>8、**[primary]** 关于循环语句，下面说法正确的有（）</h3><p>A. 循环语句既支持for关键字，也支持while和do-while</p>
<p>B. 关键字for的基本使用方法与C&#x2F;C++中没有任何差异</p>
<p>C. for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环</p>
<p>D. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</p>
<p>参考答案：CD</p>
<h3 id="9、-intermediate-对于函数定义："><a href="#9、-intermediate-对于函数定义：" class="headerlink" title="9、**[intermediate]** 对于函数定义："></a>9、**[intermediate]** 对于函数定义：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">            sum += arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">下面对add函数调用正确的是（）</span><br><span class="line">A. add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">B. add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">C. add([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">D. add([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;...)</span><br></pre></td></tr></table></figure>

<p>参考答案：ABD</p>
<h3 id="10、-primary-关于类型转化，下面语法正确的是（）"><a href="#10、-primary-关于类型转化，下面语法正确的是（）" class="headerlink" title="10、**[primary]** 关于类型转化，下面语法正确的是（）"></a>10、**[primary]** 关于类型转化，下面语法正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = i</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = (MyInt)i</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = MyInt(i)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = i.(MyInt)</span><br></pre></td></tr></table></figure>

<p>参考答案：C</p>
<h3 id="11、-primary-关于局部变量的初始化，下面正确的使用方式是（）"><a href="#11、-primary-关于局部变量的初始化，下面正确的使用方式是（）" class="headerlink" title="11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）"></a>11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）</h3><p>A. var i int &#x3D; 10</p>
<p>B. var i &#x3D; 10</p>
<p>C. i :&#x3D; 10</p>
<p>D. i &#x3D; 10</p>
<p>参考答案：ABC</p>
<h3 id="12、-primary-关于const常量定义，下面正确的使用方式是（）"><a href="#12、-primary-关于const常量定义，下面正确的使用方式是（）" class="headerlink" title="12、**[primary]** 关于const常量定义，下面正确的使用方式是（）"></a>12、**[primary]** 关于const常量定义，下面正确的使用方式是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">        eof = <span class="number">-1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        ERR_ELEM_EXIST <span class="type">error</span> = errors.New(<span class="string">&quot;element already exists&quot;</span>)</span><br><span class="line">        ERR_ELEM_NT_EXIST <span class="type">error</span> = errors.New(<span class="string">&quot;element not exists&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考答案：ABD</p>
<h3 id="13、-primary-关于布尔变量b的赋值，下面错误的用法是（）"><a href="#13、-primary-关于布尔变量b的赋值，下面错误的用法是（）" class="headerlink" title="13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）"></a>13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）</h3><p>A. b &#x3D; true</p>
<p>B. b &#x3D; 1</p>
<p>C. b &#x3D; bool(1)</p>
<p>D. b &#x3D; (1 &#x3D;&#x3D; 2)</p>
<p>参考答案：BC</p>
<h3 id="14、-intermediate-下面的程序的运行结果是（）"><a href="#14、-intermediate-下面的程序的运行结果是（）" class="headerlink" title="14、**[intermediate]** 下面的程序的运行结果是（）"></a>14、**[intermediate]** 下面的程序的运行结果是（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A. 321</p>
<p>B. 32</p>
<p>C. 31</p>
<p>D. 13</p>
<p>参考答案：C</p>
<h3 id="15、-primary-关于switch语句，下面说法正确的有（）"><a href="#15、-primary-关于switch语句，下面说法正确的有（）" class="headerlink" title="15、**[primary]** 关于switch语句，下面说法正确的有（）"></a>15、**[primary]** 关于switch语句，下面说法正确的有（）</h3><p>A. 条件表达式必须为常量或者整数</p>
<p>B. 单个case中，可以出现多个结果选项</p>
<p>C. 需要用break来明确退出一个case</p>
<p>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case</p>
<p>参考答案：BD</p>
<h3 id="16、-intermediate-golang中没有隐藏的this指针，这句话的含义是（）"><a href="#16、-intermediate-golang中没有隐藏的this指针，这句话的含义是（）" class="headerlink" title="16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）"></a>16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）</h3><p>A. 方法施加的对象显式传递，没有被隐藏起来</p>
<p>B. golang沿袭了传统面向对象编程中的诸多概念，比如继承、虚函数和构造函数</p>
<p>C. golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达</p>
<p>D. 方法施加的对象不需要非得是指针，也不用非得叫this</p>
<p>参考答案：ACD</p>
<h3 id="17、-intermediate-golang中的引用类型包括（）"><a href="#17、-intermediate-golang中的引用类型包括（）" class="headerlink" title="17、**[intermediate]** golang中的引用类型包括（）"></a>17、**[intermediate]** golang中的引用类型包括（）</h3><p>A. 数组切片</p>
<p>B. map</p>
<p>C. channel</p>
<p>D. interface</p>
<p>参考答案：ABCD</p>
<h3 id="18、-intermediate-golang中的指针运算包括（）"><a href="#18、-intermediate-golang中的指针运算包括（）" class="headerlink" title="18、**[intermediate]** golang中的指针运算包括（）"></a>18、**[intermediate]** golang中的指针运算包括（）</h3><p>A. 可以对指针进行自增或自减运算</p>
<p>B. 可以通过“&amp;”取指针的地址</p>
<p>C. 可以通过“*”取指针指向的数据</p>
<p>D. 可以对指针进行下标运算</p>
<p>参考答案：BC</p>
<h3 id="19、-primary-关于main函数（可执行程序的执行起点），下面说法正确的是（）"><a href="#19、-primary-关于main函数（可执行程序的执行起点），下面说法正确的是（）" class="headerlink" title="19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）"></a>19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）</h3><p>A. main函数不能带参数</p>
<p>B. main函数不能定义返回值</p>
<p>C. main函数所在的包必须为main包</p>
<p>D. main函数中可以使用flag包来获取和解析命令行参数</p>
<p>参考答案：ABCD</p>
<h3 id="20、-intermediate-下面赋值正确的是（）"><a href="#20、-intermediate-下面赋值正确的是（）" class="headerlink" title="20、**[intermediate]** 下面赋值正确的是（）"></a>20、**[intermediate]** 下面赋值正确的是（）</h3><p>A. var x &#x3D; nil</p>
<p>B. var x interface{} &#x3D; nil</p>
<p>C. var x string &#x3D; nil</p>
<p>D. var x error &#x3D; nil</p>
<p>参考答案：BD</p>
<h3 id="21、-intermediate-关于整型切片的初始化，下面正确的是（）"><a href="#21、-intermediate-关于整型切片的初始化，下面正确的是（）" class="headerlink" title="21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）"></a>21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）</h3><p>A. s :&#x3D; make([]int)</p>
<p>B. s :&#x3D; make([]int, 0)</p>
<p>C. s :&#x3D; make([]int, 5, 10)</p>
<p>D. s :&#x3D; []int{1, 2, 3, 4, 5}</p>
<p>参考答案：BCD</p>
<h3 id="22、-intermediate-从切片中删除一个元素，下面的算法实现正确的是（）"><a href="#22、-intermediate-从切片中删除一个元素，下面的算法实现正确的是（）" class="headerlink" title="22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）"></a>22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                <span class="keyword">if</span> i== <span class="built_in">len</span>(*s) - <span class="number">1</span> &#123;</span><br><span class="line">                    *s = (*s)[:i]</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">2</span>:]...)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                <span class="built_in">delete</span>(*s, v)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">1</span>:]...)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：D</p>
<h3 id="23、-primary-对于局部变量整型切片x的赋值，下面定义正确的是（）"><a href="#23、-primary-对于局部变量整型切片x的赋值，下面定义正确的是（）" class="headerlink" title="23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）"></a>23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：ACD</p>
<h3 id="24、-primary-关于变量的自增和自减操作，下面语句正确的是（）"><a href="#24、-primary-关于变量的自增和自减操作，下面语句正确的是（）" class="headerlink" title="24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）"></a>24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">i++</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">j = i++</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">++i</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">i--</span><br></pre></td></tr></table></figure>



<p>参考答案：AD</p>
<h3 id="25、-intermediate-关于函数声明，下面语法错误的是（）"><a href="#25、-intermediate-关于函数声明，下面语法错误的是（）" class="headerlink" title="25、**[intermediate]** 关于函数声明，下面语法错误的是（）"></a>25、**[intermediate]** 关于函数声明，下面语法错误的是（）</h3><p>A. func f(a, b int) (value int, err error)</p>
<p>B. func f(a int, b int) (value int, err error)</p>
<p>C. func f(a, b int) (value int, error)</p>
<p>D. func f(a int, b int) (int, int, error)</p>
<p>参考答案：C</p>
<h3 id="26、-intermediate-如果Add函数的调用代码为："><a href="#26、-intermediate-如果Add函数的调用代码为：" class="headerlink" title="26、**[intermediate]** 如果Add函数的调用代码为："></a>26、**[intermediate]** 如果Add函数的调用代码为：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = &amp;a</span><br><span class="line">        sum := i.(*Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27、则Add函数定义正确的是（）"><a href="#27、则Add函数定义正确的是（）" class="headerlink" title="27、则Add函数定义正确的是（）"></a>27、则Add函数定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：AC</p>
<h3 id="28、-intermediate-如果Add函数的调用代码为："><a href="#28、-intermediate-如果Add函数的调用代码为：" class="headerlink" title="28、**[intermediate]** 如果Add函数的调用代码为："></a>28、**[intermediate]** 如果Add函数的调用代码为：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line">        sum := i.(Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="29、则Add函数定义正确的是（）"><a href="#29、则Add函数定义正确的是（）" class="headerlink" title="29、则Add函数定义正确的是（）"></a>29、则Add函数定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：A</p>
<h3 id="30、-intermediate-关于GetPodAction定义，下面赋值正确的是（）"><a href="#30、-intermediate-关于GetPodAction定义，下面赋值正确的是（）" class="headerlink" title="30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）"></a>30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fragment <span class="keyword">interface</span> &#123;</span><br><span class="line">        Exec(transInfo *TransInfo) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetPodAction <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GetPodAction)</span></span> Exec(transInfo *TransInfo) <span class="type">error</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>A. var fragment Fragment &#x3D; new(GetPodAction)</p>
<p>B. var fragment Fragment &#x3D; GetPodAction</p>
<p>C. var fragment Fragment &#x3D; &amp;GetPodAction{}</p>
<p>D. var fragment Fragment &#x3D; GetPodAction{}</p>
<p>参考答案：ACD</p>
<h3 id="31、-intermediate-关于GoMock，下面说法正确的是（）"><a href="#31、-intermediate-关于GoMock，下面说法正确的是（）" class="headerlink" title="31、**[intermediate]** 关于GoMock，下面说法正确的是（）"></a>31、**[intermediate]** 关于GoMock，下面说法正确的是（）</h3><p>A. GoMock可以对interface打桩</p>
<p>B. GoMock可以对类的成员函数打桩</p>
<p>C. GoMock可以对函数打桩</p>
<p>D. GoMock打桩后的依赖注入可以通过GoStub完成</p>
<p>参考答案：AD</p>
<h3 id="32、-intermediate-关于接口，下面说法正确的是（）"><a href="#32、-intermediate-关于接口，下面说法正确的是（）" class="headerlink" title="32、**[intermediate]** 关于接口，下面说法正确的是（）"></a>32、**[intermediate]** 关于接口，下面说法正确的是（）</h3><p>A. 只要两个接口拥有相同的方法列表（次序不同不要紧），那么它们就是等价的，可以相互赋值</p>
<p>B. 如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A</p>
<p>C. 接口查询是否成功，要在运行期才能够确定</p>
<p>D. 接口赋值是否可行，要在运行期才能够确定</p>
<p>参考答案：ABC</p>
<h3 id="33、-primary-关于channel，下面语法正确的是（）"><a href="#33、-primary-关于channel，下面语法正确的是（）" class="headerlink" title="33、**[primary]** 关于channel，下面语法正确的是（）"></a>33、**[primary]** 关于channel，下面语法正确的是（）</h3><p>A. var ch chan int</p>
<p>B. ch :&#x3D; make(chan int)</p>
<p>C. &lt;- ch</p>
<p>D. ch &lt;-</p>
<p>参考答案：ABC</p>
<h3 id="34、-primary-关于同步锁，下面说法正确的是（）"><a href="#34、-primary-关于同步锁，下面说法正确的是（）" class="headerlink" title="34、**[primary]** 关于同步锁，下面说法正确的是（）"></a>34、**[primary]** 关于同步锁，下面说法正确的是（）</h3><p>A. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex</p>
<p>B. RWMutex在读锁占用的情况下，会阻止写，但不阻止读</p>
<p>C. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占</p>
<p>D. Lock()操作需要保证有Unlock()或RUnlock()调用与之对应</p>
<p>参考答案：ABC</p>
<h3 id="35、-intermediate-golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）"><a href="#35、-intermediate-golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）" class="headerlink" title="35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）"></a>35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）</h3><p>A. 指针</p>
<p>B. channel</p>
<p>C. complex</p>
<p>D. 函数</p>
<p>参考答案：BCD</p>
<h3 id="36、-intermediate-关于go-vendor，下面说法正确的是（）"><a href="#36、-intermediate-关于go-vendor，下面说法正确的是（）" class="headerlink" title="36、**[intermediate]** 关于go vendor，下面说法正确的是（）"></a>36、**[intermediate]** 关于go vendor，下面说法正确的是（）</h3><p>A. 基本思路是将引用的外部包的源代码放在当前工程的vendor目录下面</p>
<p>B. 编译go代码会优先从vendor目录先寻找依赖包</p>
<p>C. 可以指定引用某个特定版本的外部包</p>
<p>D. 有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH&#x2F;src下都可以通过编译</p>
<p>参考答案：ABD</p>
<h3 id="37、-primary-flag是bool型变量，下面if表达式符合编码规范的是（）"><a href="#37、-primary-flag是bool型变量，下面if表达式符合编码规范的是（）" class="headerlink" title="37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）"></a>37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）</h3><p>A. if flag &#x3D;&#x3D; 1</p>
<p>B. if flag</p>
<p>C. if flag &#x3D;&#x3D; false</p>
<p>D. if !flag</p>
<p>参考答案：BD</p>
<h3 id="38、-primary-value是整型变量，下面if表达式符合编码规范的是（）"><a href="#38、-primary-value是整型变量，下面if表达式符合编码规范的是（）" class="headerlink" title="38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）"></a>38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）</h3><p>A. if value &#x3D;&#x3D; 0</p>
<p>B. if value</p>
<p>C. if value !&#x3D; 0</p>
<p>D. if !value</p>
<p>参考答案：AC</p>
<h3 id="39、-intermediate-关于函数返回值的错误设计，下面说法正确的是（）"><a href="#39、-intermediate-关于函数返回值的错误设计，下面说法正确的是（）" class="headerlink" title="39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）"></a>39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）</h3><p>A. 如果失败原因只有一个，则返回bool</p>
<p>B. 如果失败原因超过一个，则返回error</p>
<p>C. 如果没有失败原因，则不返回bool或error</p>
<p>D. 如果重试几次可以避免失败，则不要立即返回bool或error</p>
<p>参考答案：ABCD</p>
<h3 id="40、-intermediate-关于异常设计，下面说法正确的是（）"><a href="#40、-intermediate-关于异常设计，下面说法正确的是（）" class="headerlink" title="40、**[intermediate]** 关于异常设计，下面说法正确的是（）"></a>40、**[intermediate]** 关于异常设计，下面说法正确的是（）</h3><p>A. 在程序开发阶段，坚持速错，让程序异常崩溃</p>
<p>B. 在程序部署后，应恢复异常避免程序终止</p>
<p>C. 一切皆错误，不用进行异常设计</p>
<p>D. 对于不应该出现的分支，使用异常处理</p>
<p>参考答案：ABD</p>
<h3 id="41、-intermediate-关于slice或map操作，下面正确的是（）"><a href="#41、-intermediate-关于slice或map操作，下面正确的是（）" class="headerlink" title="41、**[intermediate]** 关于slice或map操作，下面正确的是（）"></a>41、**[intermediate]** 关于slice或map操作，下面正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>参考答案：ACD</p>
<h3 id="42、-intermediate-关于channel的特性，下面说法正确的是（）"><a href="#42、-intermediate-关于channel的特性，下面说法正确的是（）" class="headerlink" title="42、**[intermediate]** 关于channel的特性，下面说法正确的是（）"></a>42、**[intermediate]** 关于channel的特性，下面说法正确的是（）</h3><p>A. 给一个 nil channel 发送数据，造成永远阻塞</p>
<p>B. 从一个 nil channel 接收数据，造成永远阻塞</p>
<p>C. 给一个已经关闭的 channel 发送数据，引起 panic</p>
<p>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</p>
<p>参考答案：ABCD</p>
<h3 id="43、-intermediate-关于无缓冲和有冲突的channel，下面说法正确的是（）"><a href="#43、-intermediate-关于无缓冲和有冲突的channel，下面说法正确的是（）" class="headerlink" title="43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）"></a>43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）</h3><p>A. 无缓冲的channel是默认的缓冲为1的channel</p>
<p>B. 无缓冲的channel和有缓冲的channel都是同步的</p>
<p>C. 无缓冲的channel和有缓冲的channel都是非同步的</p>
<p>D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的</p>
<p>参考答案：D</p>
<h3 id="44、-intermediate-关于异常的触发，下面说法正确的是（）"><a href="#44、-intermediate-关于异常的触发，下面说法正确的是（）" class="headerlink" title="44、**[intermediate]** 关于异常的触发，下面说法正确的是（）"></a>44、**[intermediate]** 关于异常的触发，下面说法正确的是（）</h3><p>A. 空指针解析</p>
<p>B. 下标越界</p>
<p>C. 除数为0</p>
<p>D. 调用panic函数</p>
<p>参考答案：ABCD</p>
<h3 id="45、-intermediate-关于cap函数的适用类型，下面说法正确的是（）"><a href="#45、-intermediate-关于cap函数的适用类型，下面说法正确的是（）" class="headerlink" title="45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）"></a>45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）</h3><p>A. array</p>
<p>B. slice</p>
<p>C. map</p>
<p>D. channel</p>
<p>参考答案：ABD</p>
<h3 id="46、-intermediate-关于beego框架，下面说法正确的是（）"><a href="#46、-intermediate-关于beego框架，下面说法正确的是（）" class="headerlink" title="46、**[intermediate]** 关于beego框架，下面说法正确的是（）"></a>46、**[intermediate]** 关于beego框架，下面说法正确的是（）</h3><p>A. beego是一个golang实现的轻量级HTTP框架</p>
<p>B. beego可以通过注释路由、正则路由等多种方式完成url路由注入</p>
<p>C. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译</p>
<p>D. beego框架只提供了对url路由的处理， 而对于MVC架构中的数据库部分未提供框架支持</p>
<p>参考答案：ABC</p>
<h3 id="47、-intermediate-关于goconvey，下面说法正确的是（）"><a href="#47、-intermediate-关于goconvey，下面说法正确的是（）" class="headerlink" title="47、**[intermediate]** 关于goconvey，下面说法正确的是（）"></a>47、**[intermediate]** 关于goconvey，下面说法正确的是（）</h3><p>A. goconvey是一个支持golang的单元测试框架</p>
<p>B. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面</p>
<p>C. goconvey提供了丰富的断言简化测试用例的编写</p>
<p>D. goconvey无法与go test集成</p>
<p>参考答案：ABC</p>
<h3 id="48、-intermediate-关于go-vet，下面说法正确的是（）"><a href="#48、-intermediate-关于go-vet，下面说法正确的是（）" class="headerlink" title="48、**[intermediate]** 关于go vet，下面说法正确的是（）"></a>48、**[intermediate]** 关于go vet，下面说法正确的是（）</h3><p>A. go vet是golang自带工具go tool vet的封装</p>
<p>B. 当执行go vet database时，可以对database所在目录下的所有子文件夹进行递归检测</p>
<p>C. go vet可以使用绝对路径、相对路径或相对GOPATH的路径指定待检测的包</p>
<p>D. go vet可以检测出死代码</p>
<p>参考答案：ACD</p>
<h3 id="49、-intermediate-关于map，下面说法正确的是（）"><a href="#49、-intermediate-关于map，下面说法正确的是（）" class="headerlink" title="49、**[intermediate]** 关于map，下面说法正确的是（）"></a>49、**[intermediate]** 关于map，下面说法正确的是（）</h3><p>A. map反序列化时json.unmarshal的入参必须为map的地址</p>
<p>B. 在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改</p>
<p>C. 在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改</p>
<p>D. 不能使用内置函数delete删除map的元素</p>
<p>参考答案：A</p>
<h3 id="50、-intermediate-关于GoStub，下面说法正确的是（）"><a href="#50、-intermediate-关于GoStub，下面说法正确的是（）" class="headerlink" title="50、**[intermediate]** 关于GoStub，下面说法正确的是（）"></a>50、**[intermediate]** 关于GoStub，下面说法正确的是（）</h3><p>A. GoStub可以对全局变量打桩</p>
<p>B. GoStub可以对函数打桩</p>
<p>C. GoStub可以对类的成员方法打桩</p>
<p>D. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为</p>
<p>参考答案：ABD</p>
<h3 id="51、-primary-关于select机制，下面说法正确的是（）"><a href="#51、-primary-关于select机制，下面说法正确的是（）" class="headerlink" title="51、**[primary]** 关于select机制，下面说法正确的是（）"></a>51、**[primary]** 关于select机制，下面说法正确的是（）</h3><p>A. select机制用来处理异步IO问题</p>
<p>B. select机制最大的一条限制就是每个case语句里必须是一个IO操作</p>
<p>C. golang在语言级别支持select关键字</p>
<p>D. select关键字的用法与switch语句非常类似，后面要带判断条件</p>
<p>参考答案：ABC</p>
<h3 id="52、-primary-关于内存泄露，下面说法正确的是（）"><a href="#52、-primary-关于内存泄露，下面说法正确的是（）" class="headerlink" title="52、**[primary]** 关于内存泄露，下面说法正确的是（）"></a>52、**[primary]** 关于内存泄露，下面说法正确的是（）</h3><p>A. golang有自动垃圾回收，不存在内存泄露</p>
<p>B. golang中检测内存泄露主要依靠的是pprof包</p>
<p>C. 内存泄露可以在编译阶段发现</p>
<p>D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题</p>
<p>参考答案：BD</p>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="1、-primary-声明一个整型变量i"><a href="#1、-primary-声明一个整型变量i" class="headerlink" title="1、**[primary]** 声明一个整型变量i__________"></a>1、**[primary]** 声明一个整型变量i__________</h3><p>参考答案：var i int</p>
<h3 id="2、-primary-声明一个含有10个元素的整型数组a"><a href="#2、-primary-声明一个含有10个元素的整型数组a" class="headerlink" title="2、**[primary]** 声明一个含有10个元素的整型数组a__________"></a>2、**[primary]** 声明一个含有10个元素的整型数组a__________</h3><p>参考答案：var a [10]int</p>
<h3 id="3、-primary-声明一个整型数组切片s"><a href="#3、-primary-声明一个整型数组切片s" class="headerlink" title="3、**[primary]** 声明一个整型数组切片s__________"></a>3、**[primary]** 声明一个整型数组切片s__________</h3><p>参考答案：var s []int</p>
<h3 id="4、-primary-声明一个整型指针变量p"><a href="#4、-primary-声明一个整型指针变量p" class="headerlink" title="4、**[primary]** 声明一个整型指针变量p__________"></a>4、**[primary]** 声明一个整型指针变量p__________</h3><p>参考答案：var p *int</p>
<h3 id="5、-primary-声明一个key为字符串型value为整型的map变量m"><a href="#5、-primary-声明一个key为字符串型value为整型的map变量m" class="headerlink" title="5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________"></a>5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________</h3><p>参考答案：var m map[string]int</p>
<h3 id="6、-primary-声明一个入参和返回值均为整型的函数变量f"><a href="#6、-primary-声明一个入参和返回值均为整型的函数变量f" class="headerlink" title="6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________"></a>6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________</h3><p>参考答案：var f func(a int) int</p>
<h3 id="7、-primary-声明一个只用于读取int数据的单向channel变量ch"><a href="#7、-primary-声明一个只用于读取int数据的单向channel变量ch" class="headerlink" title="7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________"></a>7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________</h3><p>参考答案：var ch &lt;-chan int</p>
<h3 id="8、-primary-假设源文件的命名为slice-go，则测试文件的命名为"><a href="#8、-primary-假设源文件的命名为slice-go，则测试文件的命名为" class="headerlink" title="8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________"></a>8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________</h3><p>参考答案：slice_test.go</p>
<h3 id="9、-primary-go-test要求测试函数的前缀必须命名为"><a href="#9、-primary-go-test要求测试函数的前缀必须命名为" class="headerlink" title="9、**[primary]** go test要求测试函数的前缀必须命名为__________"></a>9、**[primary]** go test要求测试函数的前缀必须命名为__________</h3><p>参考答案：Test</p>
<h3 id="10、-intermediate-下面的程序的运行结果是"><a href="#10、-intermediate-下面的程序的运行结果是" class="headerlink" title="10、**[intermediate]** 下面的程序的运行结果是__________"></a>10、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：4 3 2 1 0</p>
<h3 id="11、-intermediate-下面的程序的运行结果是"><a href="#11、-intermediate-下面的程序的运行结果是" class="headerlink" title="11、**[intermediate]** 下面的程序的运行结果是__________"></a>11、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            x := <span class="number">2</span></span><br><span class="line">            fmt.Print(x)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：21</p>
<h3 id="12、-intermediate-下面的程序的运行结果是"><a href="#12、-intermediate-下面的程序的运行结果是" class="headerlink" title="12、**[intermediate]** 下面的程序的运行结果是__________"></a>12、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        strs := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%s &quot;</span>, s)</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：three three three</p>
<h3 id="13、-intermediate-下面的程序的运行结果是"><a href="#13、-intermediate-下面的程序的运行结果是" class="headerlink" title="13、**[intermediate]** 下面的程序的运行结果是__________"></a>13、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">            fmt.Print(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：012</p>
<h3 id="14、-intermediate-下面的程序的运行结果是"><a href="#14、-intermediate-下面的程序的运行结果是" class="headerlink" title="14、**[intermediate]** 下面的程序的运行结果是__________"></a>14、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">            fmt.Print(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：abc</p>
<h3 id="15、-primary-下面的程序的运行结果是"><a href="#15、-primary-下面的程序的运行结果是" class="headerlink" title="15、**[primary]** 下面的程序的运行结果是__________"></a>15、**[primary]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">       i := <span class="number">1</span></span><br><span class="line">       j := <span class="number">2</span></span><br><span class="line">       i, j = j, i</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%d%d\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：21</p>
<h3 id="16、-primary-下面的程序的运行结果是"><a href="#16、-primary-下面的程序的运行结果是" class="headerlink" title="16、**[primary]** 下面的程序的运行结果是__________"></a>16、**[primary]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        *p++</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        v := <span class="number">1</span></span><br><span class="line">        incr(&amp;v)</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：2</p>
<h3 id="17、-primary-启动一个goroutine的关键字是"><a href="#17、-primary-启动一个goroutine的关键字是" class="headerlink" title="17、**[primary]** 启动一个goroutine的关键字是__________"></a>17、**[primary]** 启动一个goroutine的关键字是__________</h3><p>参考答案：go</p>
<h3 id="18、-intermediate-下面的程序的运行结果是"><a href="#18、-intermediate-下面的程序的运行结果是" class="headerlink" title="18、**[intermediate]** 下面的程序的运行结果是__________"></a>18、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">()</span></span> Slice &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">make</span>(Slice, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s* Slice)</span></span> Add(elem <span class="type">int</span>) *Slice &#123;</span><br><span class="line">         *s = <span class="built_in">append</span>(*s, elem)</span><br><span class="line">         fmt.Print(elem)</span><br><span class="line">         <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">         s := NewSlice()</span><br><span class="line">         <span class="keyword">defer</span> s.Add(<span class="number">1</span>).Add(<span class="number">2</span>)</span><br><span class="line">         s.Add(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：132</p>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><h3 id="1、-primary-数组是一个值类型（）"><a href="#1、-primary-数组是一个值类型（）" class="headerlink" title="1、**[primary]** 数组是一个值类型（）"></a>1、**[primary]** 数组是一个值类型（）</h3><p>参考答案：T</p>
<h3 id="2、-primary-使用map不需要引入任何库（）"><a href="#2、-primary-使用map不需要引入任何库（）" class="headerlink" title="2、**[primary]** 使用map不需要引入任何库（）"></a>2、**[primary]** 使用map不需要引入任何库（）</h3><p>参考答案：T</p>
<h3 id="3、-intermediate-内置函数delete可以删除数组切片内的元素（）"><a href="#3、-intermediate-内置函数delete可以删除数组切片内的元素（）" class="headerlink" title="3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）"></a>3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）</h3><p>参考答案：F</p>
<h3 id="4、-primary-指针是基础类型（）"><a href="#4、-primary-指针是基础类型（）" class="headerlink" title="4、**[primary]** 指针是基础类型（）"></a>4、**[primary]** 指针是基础类型（）</h3><p>参考答案：F</p>
<h3 id="5、-primary-interface-是可以指向任意对象的Any类型（）"><a href="#5、-primary-interface-是可以指向任意对象的Any类型（）" class="headerlink" title="5、**[primary]** interface{}是可以指向任意对象的Any类型（）"></a>5、**[primary]** interface{}是可以指向任意对象的Any类型（）</h3><p>参考答案：T</p>
<h3 id="6、-intermediate-下面关于文件操作的代码可能触发异常（）"><a href="#6、-intermediate-下面关于文件操作的代码可能触发异常（）" class="headerlink" title="6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）"></a>6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;open file failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>参考答案：T</p>
<h3 id="7、-primary-Golang不支持自动垃圾回收（）"><a href="#7、-primary-Golang不支持自动垃圾回收（）" class="headerlink" title="7、**[primary]** Golang不支持自动垃圾回收（）"></a>7、**[primary]** Golang不支持自动垃圾回收（）</h3><p>参考答案：F</p>
<h3 id="8、-primary-Golang支持反射，反射最常见的使用场景是做对象的序列化（）"><a href="#8、-primary-Golang支持反射，反射最常见的使用场景是做对象的序列化（）" class="headerlink" title="8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）"></a>8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）</h3><p>参考答案：T</p>
<h3 id="9、-primary-Golang可以复用C-C-的模块，这个功能叫Cgo（）"><a href="#9、-primary-Golang可以复用C-C-的模块，这个功能叫Cgo（）" class="headerlink" title="9、**[primary]** Golang可以复用C&#x2F;C++的模块，这个功能叫Cgo（）"></a>9、**[primary]** Golang可以复用C&#x2F;C++的模块，这个功能叫Cgo（）</h3><p>参考答案：F</p>
<h3 id="10、-primary-下面代码中两个斜点之间的代码，比如json-x-，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）"><a href="#10、-primary-下面代码中两个斜点之间的代码，比如json-x-，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）" class="headerlink" title="10、**[primary]** 下面代码中两个斜点之间的代码，比如json:&quot;x&quot;，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）"></a>10、**[primary]** 下面代码中两个斜点之间的代码，比如<code>json:&quot;x&quot;</code>，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;</span><br><span class="line">        X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">        Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">        Z <span class="type">int</span> <span class="string">`json:&quot;z&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：T</p>
<h3 id="11、-primary-通过成员变量或函数首字母的大小写来决定其作用域（）"><a href="#11、-primary-通过成员变量或函数首字母的大小写来决定其作用域（）" class="headerlink" title="11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）"></a>11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）</h3><p>参考答案：T</p>
<h3 id="12、-primary-对于常量定义zero-const-zero-0-0-，zero是浮点型常量（）"><a href="#12、-primary-对于常量定义zero-const-zero-0-0-，zero是浮点型常量（）" class="headerlink" title="12、**[primary]** 对于常量定义zero(const zero &#x3D; 0.0)，zero是浮点型常量（）"></a>12、**[primary]** 对于常量定义zero(const zero &#x3D; 0.0)，zero是浮点型常量（）</h3><p>参考答案：F</p>
<h3 id="13、-primary-对变量x的取反操作是-x（）"><a href="#13、-primary-对变量x的取反操作是-x（）" class="headerlink" title="13、**[primary]** 对变量x的取反操作是~x（）"></a>13、**[primary]** 对变量x的取反操作是~x（）</h3><p>参考答案：F</p>
<h3 id="14、-primary-下面的程序的运行结果是xello（）"><a href="#14、-primary-下面的程序的运行结果是xello（）" class="headerlink" title="14、**[primary]** 下面的程序的运行结果是xello（）"></a>14、**[primary]** 下面的程序的运行结果是xello（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">        fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="15、-primary-golang支持goto语句（）"><a href="#15、-primary-golang支持goto语句（）" class="headerlink" title="15、**[primary]** golang支持goto语句（）"></a>15、**[primary]** golang支持goto语句（）</h3><p>参考答案：T</p>
<h3 id="16、-primary-下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）"><a href="#16、-primary-下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）" class="headerlink" title="16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）"></a>16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TimesMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">        base <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimesMatcher</span><span class="params">(base <span class="type">int</span>)</span></span> *TimesMatcher&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TimesMatcher&#123;base:base&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p := NewTimesMatcher(<span class="number">3</span>)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="17、-primary-匿名函数可以直接赋值给一个变量或者直接执行（）"><a href="#17、-primary-匿名函数可以直接赋值给一个变量或者直接执行（）" class="headerlink" title="17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）"></a>17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）</h3><p>参考答案：T</p>
<h3 id="18、-primary-如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“-”来跳过这个返回值，该下划线对应的变量叫匿名变量（）"><a href="#18、-primary-如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“-”来跳过这个返回值，该下划线对应的变量叫匿名变量（）" class="headerlink" title="18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）"></a>18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）</h3><p>参考答案：T</p>
<h3 id="19、-primary-在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）"><a href="#19、-primary-在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）" class="headerlink" title="19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）"></a>19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）</h3><p>参考答案：T</p>
<h3 id="20、-primary-错误是业务过程的一部分，而异常不是（）"><a href="#20、-primary-错误是业务过程的一部分，而异常不是（）" class="headerlink" title="20、**[primary]** 错误是业务过程的一部分，而异常不是（）"></a>20、**[primary]** 错误是业务过程的一部分，而异常不是（）</h3><p>参考答案：T</p>
<h3 id="21、-primary-函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）"><a href="#21、-primary-函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）" class="headerlink" title="21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）"></a>21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）</h3><p>参考答案：F</p>
<h3 id="22、-intermediate-当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）"><a href="#22、-intermediate-当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）" class="headerlink" title="22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）"></a>22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）</h3><p>参考答案：F</p>
<h3 id="23、-primary-同级文件的包名不允许有多个（）"><a href="#23、-primary-同级文件的包名不允许有多个（）" class="headerlink" title="23、**[primary]** 同级文件的包名不允许有多个（）"></a>23、**[primary]** 同级文件的包名不允许有多个（）</h3><p>参考答案：T</p>
<h3 id="24、-intermediate-可以给任意类型添加相应的方法（）"><a href="#24、-intermediate-可以给任意类型添加相应的方法（）" class="headerlink" title="24、**[intermediate]** 可以给任意类型添加相应的方法（）"></a>24、**[intermediate]** 可以给任意类型添加相应的方法（）</h3><p>参考答案：F</p>
<h3 id="25、-primary-golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）"><a href="#25、-primary-golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）" class="headerlink" title="25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）"></a>25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）</h3><p>参考答案：T</p>
<h3 id="26、-primary-使用for-range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）"><a href="#26、-primary-使用for-range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）" class="headerlink" title="26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）"></a>26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）</h3><p>参考答案：T</p>
<h3 id="27、-primary-switch后面可以不跟表达式（）"><a href="#27、-primary-switch后面可以不跟表达式（）" class="headerlink" title="27、**[primary]** switch后面可以不跟表达式（）"></a>27、**[primary]** switch后面可以不跟表达式（）</h3><p>参考答案：T</p>
<h3 id="28、-intermediate-结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）"><a href="#28、-intermediate-结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）" class="headerlink" title="28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）"></a>28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）</h3><p>参考答案：T</p>
<h3 id="29、-primary-golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）"><a href="#29、-primary-golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）" class="headerlink" title="29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）"></a>29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）</h3><p>参考答案：T</p>
<h3 id="30、-intermediate-当函数deferDemo返回失败时，并不能destroy已create成功的资源（）"><a href="#30、-intermediate-当函数deferDemo返回失败时，并不能destroy已create成功的资源（）" class="headerlink" title="30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）"></a>30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        err := createResource1()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                destroyResource1()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        err = createResource2()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                destroyResource2()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        err = createResource3()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="31、-intermediate-channel本身必然是同时支持读写的，所以不存在单向channel（）"><a href="#31、-intermediate-channel本身必然是同时支持读写的，所以不存在单向channel（）" class="headerlink" title="31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）"></a>31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）</h3><p>参考答案：F</p>
<h3 id="32、-primary-import后面的最后一个元素是包名（）"><a href="#32、-primary-import后面的最后一个元素是包名（）" class="headerlink" title="32、**[primary]** import后面的最后一个元素是包名（）"></a>32、**[primary]** import后面的最后一个元素是包名（）</h3><p>参考答案：F</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>UberGo语言编码规范中文版</title>
    <url>/2023/09/04/UberGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%AD%E6%96%87%E7%89%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!--

Editing this document:

- Discuss all changes in GitHub issues first.
- Update the table of contents as new sections are added or removed.
- Use tables for side-by-side code samples. See below.

Code Samples:

Use 2 spaces to indent. Horizontal real estate is important in side-by-side
samples.

For side-by-side code samples, use the following snippet.

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bad&lt;/th&gt;&lt;th&gt;Good&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">BAD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">GOOD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>(You need the empty lines between the <td> and code samples for it to be<br>treated as Markdown.)</p>
<p>If you need to add labels or descriptions below the code samples, add another<br>row before the </tbody></table> line.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;DESCRIBE BAD CODE&lt;/td&gt;</span><br><span class="line">&lt;td&gt;DESCRIBE GOOD CODE&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>



<p>–&gt;</p>
<!--
change.md

# 2019-12-17
- 函数选项：推荐 “Option” 接口的结构实现
- 而不是用闭包捕获值。

# 2019-11-26
- 添加针对全局变量变异的指导。

# 2020-01-11
- 为`open（..）`调用添加缺少的参数。

# 2020-02-03
- 使用 `"time"` 处理时间的建议
- 添加有关在公共结构中嵌入类型的指导。

# 2020-02-25
- 添加有关接口验证是否符合编译时检查的指导。

# 2020-06-05
- 添加避免使用内置名称的指导意见

# 2020-06-10
- 添加 init() 指导意见

# 2020-06-16
- 追加时优先指定切片容量
- 添加有关指针接收器可调用性的说明

# 2020-06-17
- map和切片的联合指导

# 2020-09-15
- Remove main panic

# 2021-03-17
- 结构体初始化

# 2021-04-19
- 程序只能在`main()`中退出，最好最多退出一次

-->

<h2 id="forked-from-uber-go-guide-cn"><a href="#forked-from-uber-go-guide-cn" class="headerlink" title="forked from uber_go_guide_cn"></a>forked from <a href="https://github.com/xxjwxc/uber_go_guide_cn">uber_go_guide_cn</a></h2><h2 id="uber-go-guide-的中文翻译"><a href="#uber-go-guide-的中文翻译" class="headerlink" title="uber-go&#x2F;guide 的中文翻译"></a><a href="https://github.com/uber-go/guide">uber-go&#x2F;guide</a> 的中文翻译</h2><h2 id="English"><a href="#English" class="headerlink" title="English"></a><a href="https://github.com/uber-go/guide/blob/master/style.md">English</a></h2><h2 id="Uber-Go-语言编码规范"><a href="#Uber-Go-语言编码规范" class="headerlink" title="Uber Go 语言编码规范"></a>Uber Go 语言编码规范</h2><p> <a href="https://www.uber.com/">Uber</a> 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 <a href="https://github.com/uber-go/zap">zap</a>、<a href="https://github.com/jaegertracing/jaeger">jaeger</a> 等。2018 年年末 Uber 将内部的 <a href="https://github.com/uber-go/guide">Go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>当前更新版本：2021-07-09 版本地址：<a href="https://github.com/uber-go/guide/commit/b8745282405323881e13cd122d5222316a815349">commit:#130</a></li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#uber-goguide-%E7%9A%84%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91">uber-go&#x2F;guide 的中文翻译</a></li>
<li><a href="#english">English</a></li>
<li><a href="#uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">Uber Go 语言编码规范</a></li>
<li><a href="#%E7%89%88%E6%9C%AC">版本</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">指导原则</a><ul>
<li><a href="#%E6%8C%87%E5%90%91-interface-%E7%9A%84%E6%8C%87%E9%92%88">指向 interface 的指针</a></li>
<li><a href="#interface-%E5%90%88%E7%90%86%E6%80%A7%E9%AA%8C%E8%AF%81">Interface 合理性验证</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E5%99%A8-receiver-%E4%B8%8E%E6%8E%A5%E5%8F%A3">接收器 (receiver) 与接口</a></li>
<li><a href="#%E9%9B%B6%E5%80%BC-mutex-%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84">零值 Mutex 是有效的</a></li>
<li><a href="#%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%8B%B7%E8%B4%9D-slices-%E5%92%8C-maps">在边界处拷贝 Slices 和 Maps</a><ul>
<li><a href="#%E6%8E%A5%E6%94%B6-slices-%E5%92%8C-maps">接收 Slices 和 Maps</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E-slices-%E6%88%96-maps">返回 slices 或 maps</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8-defer-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90">使用 defer 释放资源</a></li>
<li><a href="#channel-%E7%9A%84-size-%E8%A6%81%E4%B9%88%E6%98%AF-1%E8%A6%81%E4%B9%88%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84">Channel 的 size 要么是 1，要么是无缓冲的</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E4%BB%8E-1-%E5%BC%80%E5%A7%8B">枚举从 1 开始</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-time-%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4">使用 time 处理时间</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8-timetime-%E8%A1%A8%E8%BE%BE%E7%9E%AC%E6%97%B6%E6%97%B6%E9%97%B4">使用 <code>time.Time</code> 表达瞬时时间</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-timeduration-%E8%A1%A8%E8%BE%BE%E6%97%B6%E9%97%B4%E6%AE%B5">使用 <code>time.Duration</code> 表达时间段</a></li>
<li><a href="#%E5%AF%B9%E5%A4%96%E9%83%A8%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8-timetime-%E5%92%8C-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">错误类型</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85-error-wrapping">错误包装 (Error Wrapping)</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5">处理类型断言失败</a></li>
<li><a href="#%E4%B8%8D%E8%A6%81-panic">不要 panic</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-gouberorgatomic">使用 go.uber.org&#x2F;atomic</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%8F%AF%E5%8F%98%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">避免可变全局变量</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B">避免在公共结构中嵌入类型</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%90%8D%E7%A7%B0">避免使用内置名称</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-init">避免使用 <code>init()</code></a></li>
<li><a href="#%E8%BF%BD%E5%8A%A0%E6%97%B6%E4%BC%98%E5%85%88%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F">追加时优先指定切片容量</a></li>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8Fexit">主函数退出方式(Exit)</a><ul>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%80%E5%87%BA">一次性退出</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD">性能</a><ul>
<li><a href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-strconv-%E8%80%8C%E4%B8%8D%E6%98%AF-fmt">优先使用 strconv 而不是 fmt</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E5%AD%97%E8%8A%82%E7%9A%84%E8%BD%AC%E6%8D%A2">避免字符串到字节的转换</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%AE%B9%E9%87%8F">指定容器容量</a><ul>
<li><a href="#%E6%8C%87%E5%AE%9Amap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F">指定切片容量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A7%84%E8%8C%83">规范</a><ul>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li>
<li><a href="#%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%A3%B0%E6%98%8E%E6%94%BE%E5%9C%A8%E4%B8%80%E7%BB%84">相似的声明放在一组</a></li>
<li><a href="#import-%E5%88%86%E7%BB%84">import 分组</a></li>
<li><a href="#%E5%8C%85%E5%90%8D">包名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%90%8D">函数名</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E5%88%AB%E5%90%8D">导入别名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%86%E7%BB%84%E4%B8%8E%E9%A1%BA%E5%BA%8F">函数分组与顺序</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a></li>
<li><a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-else">不必要的 else</a></li>
<li><a href="#%E9%A1%B6%E5%B1%82%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">顶层变量声明</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AA%E5%AF%BC%E5%87%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80">对于未导出的顶层常量和变量，使用_作为前缀</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%85%A5">结构体中的嵌入</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">使用字段名初始化结构体</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">本地变量声明</a></li>
<li><a href="#nil-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E7%9A%84-slice">nil 是一个有效的 slice</a></li>
<li><a href="#%E7%BC%A9%E5%B0%8F%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">缩小变量作用域</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%8F%82%E6%95%B0%E8%AF%AD%E4%B9%89%E4%B8%8D%E6%98%8E%E7%A1%AEavoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E9%81%BF%E5%85%8D%E8%BD%AC%E4%B9%89">使用原始字符串字面值，避免转义</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">初始化结构体</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84">使用字段名初始化结构</a></li>
<li><a href="#%E7%9C%81%E7%95%A5%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC%E5%AD%97%E6%AE%B5">省略结构中的零值字段</a></li>
<li><a href="#%E5%AF%B9%E9%9B%B6%E5%80%BC%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8-var">对零值结构使用 <code>var</code></a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-struct-%E5%BC%95%E7%94%A8">初始化 Struct 引用</a></li>
</ul>
</li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-maps">初始化 Maps</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-string-format">字符串 string format</a></li>
<li><a href="#%E5%91%BD%E5%90%8D-printf-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0">命名 Printf 样式的函数</a></li>
</ul>
</li>
<li><a href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">编程模式</a><ul>
<li><a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a></li>
<li><a href="#%E5%8A%9F%E8%83%BD%E9%80%89%E9%A1%B9">功能选项</a></li>
</ul>
</li>
<li><a href="#linting">Linting</a><ul>
<li><a href="#lint-runners">Lint Runners</a></li>
</ul>
</li>
<li><a href="#stargazers-over-time">Stargazers over time</a></li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。</p>
<p>本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。</p>
<p>该指南最初由 <a href="https://github.com/prashantv">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52">Simon Newton</a> 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。</p>
<p>本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p>
<ol>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CommonMistakes">Go Common Mistakes</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a></li>
</ol>
<p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p>
<ul>
<li>保存时运行 <code>goimports</code></li>
<li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li>
</ul>
<p>您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：<br><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p>
<h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><h3 id="指向-interface-的指针"><a href="#指向-interface-的指针" class="headerlink" title="指向 interface 的指针"></a>指向 interface 的指针</h3><p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ol>
<li>一个指向某些特定类型信息的指针。您可以将其视为”type”。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ol>
<p>如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1.f()无法修改底层数据</span></span><br><span class="line"><span class="comment">// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针</span></span><br><span class="line"><span class="keyword">var</span> f1 F = S1&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f2 F = &amp;S2&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Interface-合理性验证"><a href="#Interface-合理性验证" class="headerlink" title="Interface 合理性验证"></a>Interface 合理性验证</h3><p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口API 的一部分进行检查</li>
<li>实现同一接口的(导出和非导出)类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景,都会终止编译,并通知给用户</li>
</ul>
<p>补充:上面3条是编译器对接口的检查机制,<br>大体意思是错误使用接口会在编译期报错.<br>所以可以利用这个机制让部分问题在编译期暴露.</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果Handler没有实现http.Handler,会在运行时报错</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于触发编译期的接口的合理性检查机制</span></span><br><span class="line"><span class="comment">// 如果Handler没有实现http.Handler,会在编译期报错</span></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配,<br>那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过.</p>
<p>赋值的右边应该是断言类型的零值。<br>对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；<br>对于结构类型，这是空结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h LogHandler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收器-receiver-与接口"><a href="#接收器-receiver-与接口" class="headerlink" title="接收器 (receiver) 与接口"></a>接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values">addressable values</a>调用.</p>
<p>例如，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> Read() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span></span> Write(str <span class="type">string</span>) &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="type">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">&quot;A&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你只能通过值调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不能编译通过：</span></span><br><span class="line"><span class="comment">//  sVals[1].Write(&quot;test&quot;)</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="type">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">&quot;A&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure>

<p><a href="https://golang.org/doc/effective_go.html">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values">pointers vs. values</a> 的精彩讲解。</p>
<p>补充:</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集<ul>
<li>值接收器方法集是指针接收器方法集的子集,反之不是</li>
</ul>
</li>
<li>规则<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
<li>接口的匹配(或者叫实现)<ul>
<li>类型实现了接口的所有方法,叫匹配</li>
<li>具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口</li>
</ul>
</li>
</ul>
<p>具体的匹配分两种:</p>
<ul>
<li>值方法集和接口匹配<ul>
<li>给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集</li>
</ul>
</li>
<li>指针方法集和接口匹配<ul>
<li>只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配</li>
<li>如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)</li>
</ul>
</li>
</ul>
<p>为啥 i &#x3D; s2Val 会报错,因为值方法集和接口不匹配.</p>
<h3 id="零值-Mutex-是有效的"><a href="#零值-Mutex-是有效的" class="headerlink" title="零值 Mutex 是有效的"></a>零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果你使用结构体指针，mutex 应该作为结构体的非指针字段。即使该结构体不被导出，也不要直接把 mutex 嵌入到结构体中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p><code>Mutex</code> 字段， <code>Lock</code> 和 <code>Unlock</code> 方法是 <code>SMap</code> 导出的 API 中不刻意说明的一部分。</p>
 </td><td>

<p>mutex 及其方法是 <code>SMap</code> 的实现细节，对其调用者不可见。</p>
 </td></tr>
 </tbody></table>

<h3 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<h4 id="接收-Slices-和-Maps"><a href="#接收-Slices-和-Maps" class="headerlink" title="接收 Slices 和 Maps"></a>接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<table>
<thead><tr><th>Bad</th> <th>Good</th></tr></thead>
<tbody>
<tr>
<td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你是要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure>

</td>
<td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure>

</td>
</tr>

</tbody>
</table>

<h4 id="返回-slices-或-maps"><a href="#返回-slices-或-maps" class="headerlink" title="返回 slices 或 maps"></a>返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="使用-defer-释放资源"><a href="#使用-defer-释放资源" class="headerlink" title="使用 defer 释放资源"></a>使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p>
<h3 id="Channel-的-size-要么是-1，要么是无缓冲的"><a href="#Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="Channel 的 size 要么是 1，要么是无缓冲的"></a>Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应该足以满足任何情况！</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="枚举从-1-开始"><a href="#枚举从-1-开始" class="headerlink" title="枚举从 1 开始"></a>枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-time-处理时间"><a href="#使用-time-处理时间" class="headerlink" title="使用 time 处理时间"></a>使用 time 处理时间</h3><p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p>
<ol>
<li>一天有 24 小时</li>
<li>一小时有 60 分钟</li>
<li>一周有七天</li>
<li>一年 365 天</li>
<li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">还有更多</a></li>
</ol>
<p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<h4 id="使用-time-Time-表达瞬时时间"><a href="#使用-time-Time-表达瞬时时间" class="headerlink" title="使用 time.Time 表达瞬时时间"></a>使用 <code>time.Time</code> 表达瞬时时间</h4><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h4 id="使用-time-Duration-表达时间段"><a href="#使用-time-Duration-表达时间段" class="headerlink" title="使用 time.Duration 表达时间段"></a>使用 <code>time.Duration</code> 表达时间段</h4><p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration"><code>time.Duration</code></a> .</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒?</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate"><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 <a href="https://golang.org/pkg/time/#Time.Add"><code>Time.Add</code></a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">0</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>)</span><br><span class="line">maybeNewDay := t.Add(<span class="number">24</span> * time.Hour)</span><br></pre></td></tr></table></figure>

<h4 id="对外部系统使用-time-Time-和-time-Duration"><a href="#对外部系统使用-time-Time-和-time-Duration" class="headerlink" title="对外部系统使用 time.Time 和 time.Duration"></a>对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p>
<ul>
<li><p>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p>
</li>
<li><p>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</p>
</li>
<li><p>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p>
</li>
<li><p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p>
</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&quot;interval&quot;: 2&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interval <span class="type">int</span> <span class="string">`json:&quot;interval&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&quot;intervalMillis&quot;: 2000&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  IntervalMillis <span class="type">int</span> <span class="string">`json:&quot;intervalMillis&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p>
<p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190">15190</a>）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<!-- TODO: section on String methods for enums -->

<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>Go 中有多种声明错误（Error) 的选项：</p>
<ul>
<li><a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 对于简单静态字符串的错误</li>
<li><a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li>
<li>实现 <code>Error()</code> 方法的自定义类型</li>
<li>用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li>
</ul>
<p>返回错误时，请考虑以下因素以确定最佳选择：</p>
<ul>
<li><p>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 足够了。</p>
</li>
<li><p>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</li>
<li><p>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85" title="Error-Wrapping">section on error wrapping</a> 部分的内容。</p>
</li>
<li><p>否则 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 就可以了。</p>
</li>
</ul>
<p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a>，请使用一个错误变量。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">&quot;could not open&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;file %q not found&quot;</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">&quot;testfile.txt&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;not found&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;file %q not found&quot;</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">&quot;testfile.txt&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;file %q not found&quot;</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">&quot;foo&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- TODO: Exposing the information to callers with accessor functions. -->

<h3 id="错误包装-Error-Wrapping"><a href="#错误包装-Error-Wrapping" class="headerlink" title="错误包装 (Error Wrapping)"></a>错误包装 (Error Wrapping)</h3><p>一个（函数&#x2F;方法）调用失败时，有三种主要的错误传播方式：</p>
<ul>
<li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li>
<li>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</li>
<li>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>。</li>
</ul>
<p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p>
<p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">&quot;failed to create new store: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">&quot;new store: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x: y: new store: the error</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p>
<p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p>
<h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := i.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, ok := i.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<!-- TODO: There are a few situations where the single assignment form is
fine. -->

<h3 id="不要-panic"><a href="#不要-panic" class="headerlink" title="不要 panic"></a>不要 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure">cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;an argument is required&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;an argument is required&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>panic&#x2F;recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">&quot;name&quot;</span>).Parse(<span class="string">&quot;_statusHTML&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;failed to set up test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">&quot;failed to set up test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<!-- TODO: Explain how to use _test packages. -->

<h3 id="使用-go-uber-org-atomic"><a href="#使用-go-uber-org-atomic" class="headerlink" title="使用 go.uber.org&#x2F;atomic"></a>使用 go.uber.org&#x2F;atomic</h3><p>使用 <a href="https://golang.org/pkg/sync/atomic/">sync&#x2F;atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a href="https://godoc.org/go.uber.org/atomic">go.uber.org&#x2F;atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="type">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span></span> start() &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span></span> isRunning() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span></span> start() &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span></span> isRunning() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="避免可变全局变量"><a href="#避免可变全局变量" class="headerlink" title="避免可变全局变量"></a>避免可变全局变量</h3><p>使用选择依赖注入方式避免改变全局变量。<br>既适用于函数指针又适用于其他值类型</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span></span> *signer &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span></span> Sign(msg <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="避免在公共结构中嵌入类型"><a href="#避免在公共结构中嵌入类型" class="headerlink" title="避免在公共结构中嵌入类型"></a>避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。<br>相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(e Entity) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(e Entity) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding">类型嵌入</a> 作为继承和组合之间的折衷。<br>外部类型获取嵌入类型的方法的隐式副本。<br>默认情况下，这些方法委托给嵌入实例的同一方法。</p>
<p>结构还获得与类型同名的字段。<br>所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<p>很少需要嵌入类型。<br>这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractList 是各种实体列表的通用实现。</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p>
<ul>
<li>向嵌入式接口添加方法是一个破坏性的改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<h3 id="避免使用内置名称"><a href="#避免使用内置名称" class="headerlink" title="避免使用内置名称"></a>避免使用内置名称</h3><p>Go语言规范<a href="https://golang.org/ref/spec">language specification</a> 概述了几个内置的，<br>不应在Go项目中使用的名称标识<a href="https://golang.org/ref/spec#Predeclared_identifiers">predeclared identifiers</a>。</p>
<p>根据上下文的不同，将这些标识符作为名称重复使用，<br>将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。<br>在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">error</span> <span class="type">string</span></span><br><span class="line"><span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(<span class="type">error</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="type">string</span></span><br><span class="line"><span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。</span></span><br><span class="line">    <span class="type">error</span>  <span class="type">error</span></span><br><span class="line">    <span class="type">string</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Error() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// `error` 和 `f.error` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// `string` and `f.string` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `string` 现在是明确的。</span></span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Error() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
</tbody></table>

<p>注意，编译器在使用预先分隔的标识符时不会生成错误，<br>但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<h3 id="避免使用-init"><a href="#避免使用-init" class="headerlink" title="避免使用 init()"></a>避免使用 <code>init()</code></h3><p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，<br>因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数&#x2F;输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方），<br>或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，<br>而不是执行“init magic”</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _defaultFoo Foo</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _defaultFoo = Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _defaultFoo = Foo&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or, 为了更好的可测试性:</span></span><br><span class="line"><span class="keyword">var</span> _defaultFoo = defaultFoo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFoo</span><span class="params">()</span></span> Foo &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _config Config</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 基于当前目录</span></span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line">    <span class="comment">// Bad: I/O</span></span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;config.yaml&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> Config &#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;config.yaml&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li><p>不能表示为单个赋值的复杂表达式。</p>
</li>
<li><p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p>
</li>
<li><p>对<a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations">Google Cloud Functions</a>和其他形式的确定性预计算的优化。</p>
</li>
</ul>
<h3 id="追加时优先指定切片容量"><a href="#追加时优先指定切片容量" class="headerlink" title="追加时优先指定切片容量"></a>追加时优先指定切片容量</h3><p>追加时优先指定切片容量</p>
<p>在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="主函数退出方式-Exit"><a href="#主函数退出方式-Exit" class="headerlink" title="主函数退出方式(Exit)"></a>主函数退出方式(Exit)</h3><p>Go程序使用<a href="https://golang.org/pkg/os/#Exit"><code>os.Exit</code></a> 或者 <a href="https://golang.org/pkg/log/#Fatal"><code>log.Fatal*</code></a> 立即退出 (使用<code>panic</code>不是退出程序的好方法，请 <a href="#%E4%B8%8D%E8%A6%81-panic">don’t panic</a>.)</p>
<p>**仅在<code>main（）</code>**中调用其中一个 <code>os.Exit</code> 或者 <code>log.Fatal*</code>。所有其他函数应将错误返回到信号失败中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body := readFile(path)</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body, err := readFile(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>原则上：退出的具有多种功能的程序存在一些问题：</p>
<ul>
<li>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</li>
<li>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 <code>go test</code> 尚未运行的其他测试的风险。</li>
<li>跳过清理：当函数退出程序时，会跳过已经进入<code>defer</code>队列里的函数调用。这增加了跳过重要清理任务的风险。</li>
</ul>
<h4 id="一次性退出"><a href="#一次性退出" class="headerlink" title="一次性退出"></a>一次性退出</h4><p>如果可能的话，你的<code>main（）</code>函数中<strong>最多一次</strong> 调用 <code>os.Exit</code>或者<code>log.Fatal</code>。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。<br>这会缩短 <code>main()</code>函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;missing file&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  <span class="comment">// 如果我们调用log.Fatal 在这条线之后</span></span><br><span class="line">  <span class="comment">// f.Close 将会被执行.</span></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;missing file&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能方面的特定准则只适用于高频场景。</p>
<h3 id="优先使用-strconv-而不是-fmt"><a href="#优先使用-strconv-而不是-fmt" class="headerlink" title="优先使用 strconv 而不是 fmt"></a>优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkFmtSprint-4    143 ns/op    2 allocs/op</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>



<h3 id="避免字符串到字节的转换"><a href="#避免字符串到字节的转换" class="headerlink" title="避免字符串到字节的转换"></a>避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns/op</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns/op</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="指定容器容量"><a href="#指定容器容量" class="headerlink" title="指定容器容量"></a>指定容器容量</h3><p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<h4 id="指定Map容量提示"><a href="#指定Map容量提示" class="headerlink" title="指定Map容量提示"></a>指定Map容量提示</h4><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure>

<p>向<code>make()</code>提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。</p>
<p>注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。<br>因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p>
</td><td>

<p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p>
</td></tr>
</tbody></table>

<h4 id="指定切片容量"><a href="#指定切片容量" class="headerlink" title="指定切片容量"></a>指定切片容量</h4><p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>

<p>与maps不同，slice capacity不是一个提示：编译器将为提供给<code>make()</code>的slice的容量分配足够的内存，<br>这意味着后续的append()&#96;操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p>
<p>但是最重要的是，<strong>保持一致</strong>.</p>
<p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<h3 id="相似的声明放在一组"><a href="#相似的声明放在一组" class="headerlink" title="相似的声明放在一组"></a>相似的声明放在一组</h3><p>Go 语言支持将相似的声明放在一个组内。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="string">&quot;b&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>这同样适用于常量、变量和类型声明：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="type">float64</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="type">float64</span></span><br><span class="line">  Volume <span class="type">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  EnvVar = <span class="string">&quot;MY_ENV&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnvVar = <span class="string">&quot;MY_ENV&quot;</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> red = color.New(<span class="number">0xff0000</span>)</span><br><span class="line">  <span class="keyword">var</span> green = color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">  <span class="keyword">var</span> blue = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff0000</span>)</span><br><span class="line">    green = color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="import-分组"><a href="#import-分组" class="headerlink" title="import 分组"></a>import 分组</h3><p>导入应该分为两组：</p>
<ul>
<li>标准库</li>
<li>其他库</li>
</ul>
<p>默认情况下，这是 goimports 应用的分组。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;go.uber.org/atomic&quot;</span></span><br><span class="line">  <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.uber.org/atomic&quot;</span></span><br><span class="line">  <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>当命名包时，请按下面规则选择一个名称：</p>
<ul>
<li>全部小写。没有大写或下划线。</li>
<li>大多数使用命名导入的情况下，不需要重命名。</li>
<li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li>
<li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li>
<li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li>
</ul>
<p>另请参阅 <a href="https://blog.golang.org/package-names">Package Names</a> 和 <a href="https://rakyll.org/style-packages/">Go 包样式指南</a>.</p>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p>
<h3 id="导入别名"><a href="#导入别名" class="headerlink" title="导入别名"></a>导入别名</h3><p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">&quot;example.com/client-go&quot;</span></span><br><span class="line">  trace <span class="string">&quot;example.com/trace/v2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">&quot;golang.net/x/trace&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">&quot;golang.net/x/trace&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="函数分组与顺序"><a href="#函数分组与顺序" class="headerlink" title="函数分组与顺序"></a>函数分组与顺序</h3><ul>
<li>函数应按粗略的调用顺序排序。</li>
<li>同一文件中的函数应按接收者分组。</li>
</ul>
<p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>&#x2F;<code>NewXYZ()</code> </p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Cost() &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Stop() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span></span> *something &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span></span> *something &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Cost() &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Stop() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>代码应通过尽可能先处理错误情况&#x2F;特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="type">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span></span><br><span class="line"><span class="comment">// 还是那种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> myError &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e <span class="type">error</span> = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="对于未导出的顶层常量和变量，使用-作为前缀"><a href="#对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="对于未导出的顶层常量和变量，使用_作为前缀"></a>对于未导出的顶层常量和变量，使用_作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以<code>err</code>开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">&quot;user&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">&quot;Default port&quot;</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">&quot;user&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="结构体中的嵌入"><a href="#结构体中的嵌入" class="headerlink" title="结构体中的嵌入"></a>结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="type">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。<br>它应该在对用户不利影响的情况下完成这项工作（另请参见：<code>避免在公共结构中嵌入类型</code><a href="#avoid-embedding-types-in-public-structs">Avoid Embedding Types in Public Structs</a>）。</p>
<p>嵌入 <strong>不应该</strong>:</p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的API或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p>简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，<br>“是否所有这些导出的内部方法&#x2F;字段都将直接添加到外部类型”<br>如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型-而是使用字段。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: A.Lock() and A.Unlock() 现在可用</span></span><br><span class="line">    <span class="comment">// 不提供任何功能性好处，并允许用户控制有关A的内部细节。</span></span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> countingWriteCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: Write() 在外层提供用于特定目的，</span></span><br><span class="line">    <span class="comment">// 并且委托工作到内部类型的Write()中。</span></span><br><span class="line">    io.WriteCloser</span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *countingWriteCloser)</span></span> Write(bs []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    w.count += <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">return</span> w.WriteCloser.Write(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 指针更改零值的有用性</span></span><br><span class="line">    io.ReadWriter</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.String()   <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.Write(...) <span class="comment">// panic: nil pointer</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: 有用的零值</span></span><br><span class="line">    bytes.Buffer</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// ok</span></span><br><span class="line">b.String()   <span class="comment">// ok</span></span><br><span class="line">b.Write(...) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    buf bytes.Buffer</span><br><span class="line">    url url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h3><p>初始化结构体时，应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> 强制执行。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">&quot;add&quot;</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">&quot;subtract&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="本地变量声明"><a href="#本地变量声明" class="headerlink" title="本地变量声明"></a>本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="nil-是一个有效的-slice"><a href="#nil-是一个有效的-slice" class="headerlink" title="nil 是一个有效的 slice"></a>nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p>
<ul>
<li><p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>
</li>
<li><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>
</li>
<li><p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table></li>
</ul>
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
<h3 id="缩小变量作用域"><a href="#缩小变量作用域" class="headerlink" title="缩小变量作用域"></a>缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="避免参数语义不明确-Avoid-Naked-Parameters"><a href="#避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="避免参数语义不明确(Avoid Naked Parameters)"></a>避免参数语义不明确(Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true&#x2F;false）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="type">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用原始字符串字面值，避免转义"><a href="#使用原始字符串字面值，避免转义" class="headerlink" title="使用原始字符串字面值，避免转义"></a>使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit">原始字符串字面值</a>，也就是 “ &#96; “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wantError := <span class="string">&quot;unknown name:\&quot;test\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:&quot;test&quot;`</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h3><h4 id="使用字段名初始化结构"><a href="#使用字段名初始化结构" class="headerlink" title="使用字段名初始化结构"></a>使用字段名初始化结构</h4><p>初始化结构时，几乎应该始终指定字段名。目前由<a href="https://golang.org/cmd/vet/"><code>go vet</code></a>强制执行。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>例外：当有3个或更少的字段时，测试表中的字段名<em>may</em>可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">&quot;add&quot;</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">&quot;subtract&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="省略结构中的零值字段"><a href="#省略结构中的零值字段" class="headerlink" title="省略结构中的零值字段"></a>省略结构中的零值字段</h4><p>初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。<br>也就是，让我们自动将这些设置为零值</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  MiddleName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  Admin: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。</p>
<p>在字段名提供有意义上下文的地方包含零值。例如，<a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a> 中的测试用例可以受益于字段的名称，即使它们是零值的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="type">string</span></span><br><span class="line">  want <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;give: <span class="string">&quot;0&quot;</span>, want: <span class="number">0</span>&#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对零值结构使用-var"><a href="#对零值结构使用-var" class="headerlink" title="对零值结构使用 var"></a>对零值结构使用 <code>var</code></h4><p>如果在声明中省略了结构的所有字段，请使用 <code>var</code> 声明结构。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>这将零值结构与那些具有类似于为[初始化 Maps]创建的,区别于非零值字段的结构区分开来，<br>并与我们更喜欢的<a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices">declare empty slices</a>方式相匹配。</p>
<h4 id="初始化-Struct-引用"><a href="#初始化-Struct-引用" class="headerlink" title="初始化 Struct 引用"></a>初始化 Struct 引用</h4><p>在初始化结构引用时，请使用<code>&amp;T&#123;&#125;</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">&quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">&quot;bar&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="初始化-Maps"><a href="#初始化-Maps" class="headerlink" title="初始化 Maps"></a>初始化 Maps</h3><p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。<br>这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p>声明和初始化看起来非常相似的。</p>
</td><td>

<p>声明和初始化看起来差别非常大。</p>
</td></tr>
</tbody></table>

<p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#%E6%8C%87%E5%AE%9AMap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a>。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p>
<h3 id="字符串-string-format"><a href="#字符串-string-format" class="headerlink" title="字符串 string format"></a>字符串 string format</h3><p>如果你在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。</p>
<p>这有助于<code>go vet</code>对格式字符串执行静态分析。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := <span class="string">&quot;unexpected values %v, %v\n&quot;</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">&quot;unexpected values %v, %v\n&quot;</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="命名-Printf-样式的函数"><a href="#命名-Printf-样式的函数" class="headerlink" title="命名 Printf 样式的函数"></a>命名 Printf 样式的函数</h3><p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p>
<p>这意味着您应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family">Printf 系列</a>。</p>
<p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure>

<p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/">go vet: Printf family check</a>.</p>
<h2 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h2><h3 id="表驱动测试"><a href="#表驱动测试" class="headerlink" title="表驱动测试"></a>表驱动测试</h3><p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">&quot;192.0.2.0:8000&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">&quot;192.0.2.0:http&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;http&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">&quot;1:8&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;1&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;8&quot;</span>, port)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="type">string</span></span><br><span class="line">  wantHost <span class="type">string</span></span><br><span class="line">  wantPort <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;192.0.2.0:8000&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;8000&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;192.0.2.0:http&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;:8000&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;8000&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;1:8&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p>
<p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="type">string</span></span><br><span class="line">  wantHost <span class="type">string</span></span><br><span class="line">  wantPort <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h3><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  addr <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cache <span class="type">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  logger *zap.Logger</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*Connection, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  addr <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  opts ...Option,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*Connection, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Open(addr, db.DefaultCache, zap.NewNop())</span><br><span class="line">db.Open(addr, db.DefaultCache, log)</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br></pre></td></tr></table></figure>

</td><td>

<p>只有在需要时才提供选项。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Open(addr)</span><br><span class="line">db.Open(addr, db.WithLogger(log))</span><br><span class="line">db.Open(addr, db.WithCache(<span class="literal">false</span>))</span><br><span class="line">db.Open(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCache(<span class="literal">false</span>),</span><br><span class="line">  db.WithLogger(log),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>Our suggested way of implementing this pattern is with an <code>Option</code> interface<br>that holds an unexported method, recording options on an unexported <code>options</code><br>struct.</p>
<p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  cache  <span class="type">bool</span></span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span></span> apply(opts *options) &#123;</span><br><span class="line">  opts.cache = <span class="type">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span></span> apply(opts *options) &#123;</span><br><span class="line">  opts.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  addr <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  opts ...Option,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*Connection, <span class="type">error</span>) &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p>
<p>还可以参考下面资料：</p>
<ul>
<li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Self-referential functions and the design of options</a></p>
</li>
<li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional options for friendly APIs</a></p>
</li>
</ul>
<!-- TODO: replace this with parameter structs and functional options, when to
use one vs other -->

<h2 id="Linting"><a href="#Linting" class="headerlink" title="Linting"></a>Linting</h2><p>比任何 “blessed” linter 集更重要的是，lint在一个代码库中始终保持一致。</p>
<p>我们建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p>
<ul>
<li><p><a href="https://github.com/kisielk/errcheck">errcheck</a> 以确保错误得到处理</p>
</li>
<li><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a> 格式化代码和管理 imports</p>
</li>
<li><p><a href="https://github.com/golang/lint">golint</a> 指出常见的文体错误</p>
</li>
<li><p><a href="https://golang.org/cmd/vet/">govet</a> 分析代码中的常见错误</p>
</li>
<li><p><a href="https://staticcheck.io/">staticcheck</a> 各种静态分析检查</p>
</li>
</ul>
<h3 id="Lint-Runners"><a href="#Lint-Runners" class="headerlink" title="Lint Runners"></a>Lint Runners</h3><p>我们推荐 <a href="https://github.com/golangci/golangci-lint">golangci-lint</a> 作为go-to lint的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个repo有一个示例配置文件<a href="https://github.com/uber-go/guide/blob/master/.golangci.yml">.golangci.yml</a>和推荐的linter设置。</p>
<p>golangci-lint 有<a href="https://golangci-lint.run/usage/linters/">various-linters</a>可供使用。建议将上述linters作为基本set，我们鼓励团队添加对他们的项目有意义的任何附加linters。</p>
<h2 id="Stargazers-over-time"><a href="#Stargazers-over-time" class="headerlink" title="Stargazers over time"></a>Stargazers over time</h2><p><a href="https://starchart.cc/xxjwxc/uber_go_guide_cn"><img src="https://starchart.cc/xxjwxc/uber_go_guide_cn.svg" alt="Stargazers over time"></a></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>RobPike谈GoogGo</title>
    <url>/2023/09/04/RobPike%E8%B0%88GoogGo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Rob，你创建了Google-Go这门语言。什么是Google-Go？能简明扼要的介绍一下Google-Go吗？"><a href="#1-Rob，你创建了Google-Go这门语言。什么是Google-Go？能简明扼要的介绍一下Google-Go吗？" class="headerlink" title="1. Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？"></a>1. Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？</h2><p>我还是讲讲为什么要创建这门语言吧，和你的问题稍有些不同。我在Google做了一个有关编程语言的系列讲座，在Youtube上有，谈及了我早期所写的一个语言，叫做Newsqueak，那是八十年代的事，非常早。在做讲座期间，我开始思考为什么Newsqueak中的一些想法在我现在以C++为主的工作环境中无法使用。而且在Google我们经常要构建非常大的程序，光构建就要花很多时间，对依赖的管理也有问题，由于链接了本来并不需要的东西，二进制程序包变得很大，链接时间很长，编译时间也很长，而且C++的工作方式有点古老，其底层实际上C，C++已经有三十年的历史了，而C则更是有四十年了。用现今的硬件做计算，有很多新东西需要考虑：多核机器、网络化、分布式系统、云计算等等。</p>
<h2 id="2-Go的主要特点是什么？有什么重要功能？"><a href="#2-Go的主要特点是什么？有什么重要功能？" class="headerlink" title="2. Go的主要特点是什么？有什么重要功能？"></a>2. Go的主要特点是什么？有什么重要功能？</h2><p>对于大多数人来说，他们对Go的第一印象是该语言将并发性作为语言原语，这对我们处理分布式计算和多核这类东西来说非常好、也非常重要。我猜许多人会认为Go是一门简单无趣的语言，没有什么特别的东西，因为其构想看起来一目了然。但实际上不能用第一印象来判断Go。很多用过Go的人会发现它是一门非常高产而且有表现力的语言，能够解决我们编写这门语言时期望其所能解决的所有问题。</p>
<p>Go的编译过程很快，二进制程序包又比较小，它管理依赖的方式如同管理语言本身的东西一样。这里还有一个故事呢，但是在这里就不再展开讨论了，但是这门语言的并发性使其能够以非常简单的模式来处理非常复杂的操作及分布式计算环境。我想最重要的功能可能就是并发性了，后面我们可以谈谈该语言的类型系统，其与C++、Java这类传统面向对象类型系统的差异很大。</p>
<h2 id="3-在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？"><a href="#3-在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？" class="headerlink" title="3. 在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？"></a>3. 在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？</h2><p>它之所以快，有两个原因。首先Go有两个编译器——两个单独的实现。一个是按照Plan 9（<a href="http://plan9.bell-labs.com/wiki/plan9/1/%EF%BC%89">http://plan9.bell-labs.com/wiki/plan9/1/）</a> 风格新写的编译器，它有自己独特的工作方式，是个全新的编译器。另一个编译器叫做GCC Go，它拥有GCC前端，这个编译器是Ian Taylor后来写的。所以Go有两个编译器，速度快是二者的共同特点，但是Plan 9风格编译器的速度是GCC Go的5倍，因为它从头到脚都是全新的，没有GCC后端，那些东西会花很多时间来产生真正的好代码。</p>
<p>GCC Go编译器要产生更好的代码，所以速度慢些。不过真正重要的一点是Go编译器的依赖管理特性才是其编译速度快的真正原因。如果你去看一个C或C++程序，便会发现其头文件描述了函数库、对象代码等等东西。语言本身并不强制检查依赖，每一次你都必须分析代码以便清楚你的函数是怎样的。如果你编译过程中想用另一个类的C++程序，你必须先编译它所依赖的类和头文件等等等等。如果你所编译的C++程序有许多类，并且内部相关，你可能会把同一个头文件编译数百次甚至上千次。当然，你可以用预编译头文件及其他技巧来回避之一问题。</p>
<p>但是语言本身并不能帮上你的忙，工具可能会让这一问题得到改善，可是最大的问题是并没有什么能保证你所编译的东西就是程序真正需要的东西。有可能你的程序包含了一个并不真正需要的头文件，但是你没办法知道，因为语言并没有强制检查。而Go有一个更加严格的依赖模型，它有一些叫做包（packages）的东西，你可以把它想象成Java类文件或着类似的东西，或者函数库什么的，虽然他们并不相同，但基本思路是一样的。关键问题是，如果这个东西依赖那个东西，而那个东西又依赖另外一个东西，比如A依赖于B，B又依赖于C，那么你必须首先编译最内层的依赖：即，你先编译C，然后编译B，最后编译A。</p>
<p>但是如果A依赖B，但是A并不直接依赖于C，而是存在依赖传递，那么该怎么办呢？这时所有B需要从C拿到的信息都会被放在B的对象代码里。这样，当我编译A的时候，我不需要再管C了。于是事情就非常简单了：在你编译程序时，你只需将类型信息沿着依赖关系树向上遍历即可，如果你到达树的顶端，则只需编译紧邻的依赖，而不用管其它层级的依赖了。如果你要做算术运算，你会发现在Objective-C或C++或类似的语言里，虽然只包含了一个简单的头文件，但由于依赖传递的存在，你可能会编译数十万行程序。然而在Go中，你打开一个文件，里面或许只有20行，因为其中只描述了公共接口。</p>
<p>如果一个依赖链里只有三个文件，Go的优势可能并不明显，但是如果你有成千上万个文件的时候，Go的速度优势会成指数增长。我们相信，如果用Go的话，我们应该能够在数秒内就编译完数百万行代码。然而如果是等量的用C++编写的程序，由于依赖管理问题，编译的开销会大得多，编译的时间将会长达若干分钟。因此，Go速度快的根源主要归功于对依赖的管理。</p>
<h2 id="4-让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）-那么Go里的类型是什么？"><a href="#4-让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）-那么Go里的类型是什么？" class="headerlink" title="4. 让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）,那么Go里的类型是什么？"></a>4. 让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）,那么Go里的类型是什么？</h2><p>Go里的类型与其它传统编程语言里的类型是类似的。Go里的类型有整数、字符串、struct数据结构、以及数组（array），我们称之为切片（slice），它们类似于C的数组，但更易于使用，更加固定一些。你可以声明本地类型并予以命名，然后按照通常的方式来使用。Go和面向对象方式的不同之处在于，类型只是书写数据的一种方式，方法则是一个完全独立的概念。你可以把方法放在struct上，在Go里没有类的概念，取而代之的是结构，以及为此结构声明的一些方法。</p>
<p>结构不能与类混为一谈。但是你也可以把方法放在数组、整数、浮点数或字符串上，实际上任何类型都可以有方法。因此，这里方法的概念比Java的方法更加泛化，在Java里方法是类的一部分，仅此而已。例如，你的整数上可以有方法，听上去似乎没什么用，但是如果你想在一个叫做Tuesday的整数常量上附加上to_string方法来打印出漂亮的星期格式；或者，你想重新格式化字符串使其能够以不同的方式打印出自己，这时你就会意识到它的作用。为什么非要把所有方法或者其它好东西都塞进类里面呢，为什么不让它们提供更广泛的服务呢？</p>
<h2 id="5-那么这些方法只是在包内部可见喽？"><a href="#5-那么这些方法只是在包内部可见喽？" class="headerlink" title="5. 那么这些方法只是在包内部可见喽？"></a>5. 那么这些方法只是在包内部可见喽？</h2><p>非也，实际上是这样，Go只允许你在包内为你所实现的类型定义方法。我不能引入你的类型然后直接把我的方法增加进去，但是我可以使用匿名属性（anonymous field）将其包裹起来，方法可不是你想加到哪就加到哪的，你要定义类型，然后才能把方法放在上面。正因为如此，我们在包里提供了另一种封装——接口（interface），但是如果你不明白谁能为对象增加方法的严格界限，就很难理解接口。</p>
<h2 id="6-你的意思是，我可以给int增加方法，但是必须先使用typedef吗？"><a href="#6-你的意思是，我可以给int增加方法，但是必须先使用typedef吗？" class="headerlink" title="6. 你的意思是，我可以给int增加方法，但是必须先使用typedef吗？"></a>6. 你的意思是，我可以给int增加方法，但是必须先使用typedef吗？</h2><p>你要typedef一个整数类型，起个名字，如果你正在处理一星期中的七天，可以就叫它“Day”，你可以给你所声明的类型——Day增加方法，但是你不能直接给int增加方法。因为整数类型不是你定义的，不在你的包里，它是引入的但并不在你的包中定义，这就意味着你不能给其增加方法。你不能给不在你包里定义的类型增加方法。</p>
<h2 id="7-你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。"><a href="#7-你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。" class="headerlink" title="7. 你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。"></a>7. 你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。</h2><p>它是安全可控的，而且很容易理解。最初我们觉得类型用起来可能不太方便，我们也希望像Ruby那样添加方法，但这又让接口比较难以理解。所以，我们只把方法取出来，而不是放进去，我们想不出有什么更好的办法，于是限制方法只能在本地类型上，不过这种思路确实很容易理解和使用。</p>
<h2 id="8-你还提到了typedef，是叫typedef吧？"><a href="#8-你还提到了typedef，是叫typedef吧？" class="headerlink" title="8. 你还提到了typedef，是叫typedef吧？"></a>8. 你还提到了typedef，是叫typedef吧？</h2><p>应该叫“type”，你所说的类型——Day的定义方式是这样“type Day int”，这样你就有一个新类型了，你可以在其上增加方法、声明变量，但这个类型不同于int，不像C那样，只是同一事物另起了个名字而已，在Go里实际上你创建了一个不同于int的新类型，叫做“Day”，它拥有int的结构特性，但却有自己的方法集。</p>
<h3 id="9-Typedef在C里是一种预处理指令吗？【编辑注-免责申明：C语言里的typedef与预处理无关】"><a href="#9-Typedef在C里是一种预处理指令吗？【编辑注-免责申明：C语言里的typedef与预处理无关】" class="headerlink" title="9. Typedef在C里是一种预处理指令吗？【编辑注&#x2F;免责申明：C语言里的typedef与预处理无关】"></a>9. Typedef在C里是一种预处理指令吗？【编辑注&#x2F;免责申明：C语言里的typedef与预处理无关】</h3><p>那实际上就是个别名，但在Go里不是别名，是新类型。</p>
<h2 id="10-我们从底层说起吧，在Go里最小的类型是什么？"><a href="#10-我们从底层说起吧，在Go里最小的类型是什么？" class="headerlink" title="10. 我们从底层说起吧，在Go里最小的类型是什么？"></a>10. 我们从底层说起吧，在Go里最小的类型是什么？</h2><p>最小的类型应该是布尔类型（bool）吧。bool、int和float，然后是int32、float64之类有尺寸的类型、字符串、复杂类型，可能有遗漏，但这就是基本类型集了。你可以由这些类型构建结构、数组、映射（map），映射在Go里是内建类型不是函数库。然后我想就该是接口了，到了接口，有趣的东西才真正开始。</p>
<h2 id="11-但是，int这样的类型是值类型对吧"><a href="#11-但是，int这样的类型是值类型对吧" class="headerlink" title="11. 但是，int这样的类型是值类型对吧."></a>11. 但是，int这样的类型是值类型对吧.</h2><p>Int是值类型。在Go里，任何类型都是值类型，和C一样，所有东西都是按值调用，但是你也可以用指针。如果你想引用某样东西，可以获取其地址，这样你就有了一个指针。Go也有指针但是比C指针有更多限制，Go里的指针是安全的，因为他们是类型安全的，所以你没法欺骗编译器，而且也没有指针运算，因此，如果你有个指向某物的指针，你无法将其移到对象外，也无法欺骗编译器。</p>
<h2 id="12-它们类似C-的引用吗？"><a href="#12-它们类似C-的引用吗？" class="headerlink" title="12. 它们类似C++的引用吗？"></a>12. 它们类似C++的引用吗？</h2><p>是的，很像引用，但是你可以按照你预期的方式对它们进行写操作。而且你可以使用结构内部（如缓冲区）中间的某个地址，它和Java的引用不一样。在Java中，你必须在旁边分配一个缓冲区，这是额外的开销。在Go中，你实际上把该对象分配为结构的一部分，在同一内存块中，这对性能是非常重要的。</p>
<h2 id="13-它是结构内部一个复合对象。"><a href="#13-它是结构内部一个复合对象。" class="headerlink" title="13. 它是结构内部一个复合对象。"></a>13. 它是结构内部一个复合对象。</h2><p>是的，如果它是值而不是指针的话，是这样。当然你也可以把指针放在结构内部和外部，但是如果你有struct A，而把struct B放在struct A里，那么stuct B就是一块内存，而不像Java那样，这也是Java性能问题的原因之一。</p>
<h2 id="14-你提到过接口比较有趣，那下面咱们就谈谈这一部分。"><a href="#14-你提到过接口比较有趣，那下面咱们就谈谈这一部分。" class="headerlink" title="14. 你提到过接口比较有趣，那下面咱们就谈谈这一部分。"></a>14. 你提到过接口比较有趣，那下面咱们就谈谈这一部分。</h2><p>Go里的接口真的非常、非常地简单。接口指明了两个不同事情：其一，它表明了类型的构思，接口类型是一个罗列了一组方法的类型，因此如果你要抽象一组方法来定义一个行为，那么就定义一个接口并声明这些方法。现在你就有了一个类型，我们就叫它接口类型吧，那么从现在起所有实现了接口中这些方法的类型——包括基本类型、结构、映射（map）或其它什么类型，都隐含符合该接口要求。其二，也是真正有意思的是，和大多数语言中的接口不同的是，Go里面没有“implements”声明。</p>
<p>你无须说明“我的对象实现了这个接口”，只要你定义了接口中的那些方法，它就自动实现了该接口。有些人对此感到非常担忧，依我看他们想说的是：知道自己实现（Implement）了什么接口真的很重要。如果你真想确定自己实现了什么接口，还是有技巧可以做到这一点的。但是我们的想法与此截然不同，我们的想法是你不应该考虑实现什么接口，而是应该写下要做的东西，因为你不必事前就决定要实现哪个接口。可能后来你实际上实现了某个现在你尚不知晓的接口，因为该接口还未设计出来，但是现在你已经在实现它。</p>
<p>后来你可能发现两个原先未曾考虑过相关性的类具有了相关性——我又用了类这个词，我思考Java太多了——两个structs都实现了一些非常有用的小子集中的相关方法，这时有办法能够操作这两个structs中的任意一个就显得非常有用了。这样你就可以声明一个接口，然后什么都不用管了，即使这些方法是在别人的代码中实现的也没问题，虽然你不能编辑这些代码。如果是Java，这些代码必须要声明实现你的接口，在某种意义上，实现是单向的。然而在Go里，实现是双向的。对于接口实际上有不少漂亮而简单的例子。</p>
<p>我最爱用的一个真实例子就是“Reader”，Go里有个包叫做IO，IO包里有个Reader接口，它只有一个方法，该方法是read方法的标准声明，比如从操作系统或文件中读取内容。这个接口可以被系统中任何做read系统调用的东西所实现。显然，文件、网络、缓存、解压器、解密机、管道，甚至任何想访问数据的东西，都可以给其数据提供一个Reader接口，然后想从这些资源中读取数据的任何程序都可以通过该接口达到目的。这有点像我们前面说过的Plan 9，但是用不同的方式泛化的。</p>
<p>与之类似，Writer也是比较好理解的另一个例子，Writer 由那些要做写操作的人来实现。那么在做格式化打印时，fpringf的第一参数不是file了，而是Writer。这样，fprintf可以给任何实现了write方法的东西做IO格式化的工作。有很多很好的例子：比如HTTP，如果你正在实现一个HTTP服务器，你仅须对connection做fprintf，便可将数据传递到客户端，不需要任何花哨的操作。你可以通过压缩器来进行写操作，你可以通过我所提到的任何东西来进行写操作：压缩器、加密机、缓存、网络连接、管道、文件，你都可以通过fprintf直接操作，因为它们都实现了write方法，因此，隐含都隐含符合writer接口要求。</p>
<h2 id="15-某种程度上有点类似结构化类型系统（structural-typing"><a href="#15-某种程度上有点类似结构化类型系统（structural-typing" class="headerlink" title="15. 某种程度上有点类似结构化类型系统（structural typing)"></a>15. 某种程度上有点类似结构化类型系统（structural typing)</h2><p>不考虑它的行为的话，它是有点像结构化类型系统。不过它是完全抽象的，其意并不在拥有什么，而是能做什么。有了结构（struct）之后，就规定了其内存的样子，然后方法说明了结构的行为，再之后，接口则抽象了该结构及其它实现了相同方法的其他结构中的这些方法。这是一种鸭子类型系统（duck typing，一种动态类型系统，<a href="http://en.wikipedia.org/wiki/Duck_typing%EF%BC%89%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%82">http://en.wikipedia.org/wiki/Duck_typing），而不是结构化类型系统。</a></p>
<h2 id="16-你提到过类，但Go没有类，对吧。"><a href="#16-你提到过类，但Go没有类，对吧。" class="headerlink" title="16. 你提到过类，但Go没有类，对吧。"></a>16. 你提到过类，但Go没有类，对吧。</h2><p>Go没有类。</p>
<h2 id="17-但是没有类怎么去写代码？"><a href="#17-但是没有类怎么去写代码？" class="headerlink" title="17. 但是没有类怎么去写代码？"></a>17. 但是没有类怎么去写代码？</h2><p>带方法的结构（stuct）很像是类。比较有意思的不同之处是，Go没有子类型继承，你必须学习Go的另类写法，Go有更强大、更有表现力的东西。不过Java程序员和C++程序员刚开始使用Go的时候会感到意外，因为他们实际上在用Go去编写Java程序或C++程序，这样的代码工作得并不好，你可以这样做，但这样就略显笨拙了。但是如果你退一步，对自己说“我该怎样用Go去编写这些东西呢？”，你会发现模式其实是不同的，用Go你可以用更短的程序来表达类似的想法，因为你不需要在所有子类里重复实现行为。这是个非常不同的环境，比你第一眼看上去的还要不同。</p>
<h2 id="18-如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？"><a href="#18-如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？" class="headerlink" title="18. 如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？"></a>18. 如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？</h2><p>有一个叫做匿名域的概念，也就是所谓的嵌入。其工作方式是这样：如果你有一个结构（struct），而又有一些其它东西实现了你想要的行为，你可以把这些东西嵌入到你的结构（struct）里，这样，这个结构（struct）不仅仅可以获得被嵌入者的数据还可以获得它的方法。如果你有一些公共行为，比如某些类型里都有一个name方法，在Java里的话你会认为这是一组子类（继承来的方法），在Go里，你只需拿到一个拥有name方法的类型，放在所有你要实现这个方法的结构里，它们就会自动获得name方法，而不用在每个结构里都去写这个方法。这是个很简单的例子，但有不少有趣的结构化的东西使用到了嵌入。</p>
<p>而且，你还可以把多个东西嵌入到一个单一结构中，你可以把它想象成多重继承，不过这会让人更加迷惑，实际在Go里它是很简单的，它只是一个集合，你可以放任何东西在里面，基本上联合了所有的方法，对每个方法集合，你只需写一行代码就可以拥有其所有行为。</p>
<h2 id="19-如果有多重继承命名冲突的问题该怎么办？"><a href="#19-如果有多重继承命名冲突的问题该怎么办？" class="headerlink" title="19. 如果有多重继承命名冲突的问题该怎么办？"></a>19. 如果有多重继承命名冲突的问题该怎么办？</h2><p>命名冲突实际上并没什么，Go是静态处理这一问题的。其规则是，如果有多层嵌入，则最高层优先；如果同一层有两个相同的名字或相同的方法，Go会给出一个简单的静态错误。你不用自己检查，只需留意这个错误即可。命名冲突是静态检查的，而且规则非常简单，在实践中命名冲突发生的也并不多。</p>
<h2 id="20-因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？"><a href="#20-因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？" class="headerlink" title="20. 因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？"></a>20. 因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？</h2><p>接口一个有意思的地方是他们只是集合，方法的集合，那么就会有空集合，没有任何方法的接口，我们称之为空接口。系统中任何东西都符合空接口的要求。空接口有点类似于Java的Object，不同之处在于，int、float和string也符合空接口，Go并不需要一个实际的类，因为Go里没有类的概念，所有东西都是统一的，这有点像void<em>，只不过void</em>是针对指针而不是值。</p>
<p>但是一个空接口值可以代表系统中的任何东西，非常具有普遍性。所以，如果创建一个空接口数组，实际上你就有了一个多态性容器，如果你想再把它拿出来，Go里面有类型开关，你可以在解包的时候询问里面的类型，因此可以安全的进行解包操作。</p>
<h2 id="21-Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？"><a href="#21-Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？" class="headerlink" title="21. Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？"></a>21. Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？</h2><p>Coroutines和Goroutines是不同的，它们的名字反应了这一点。我们给它起了个新名，因为有太多术语了，进程（processes）、线程（threads）、轻量级线程、弦（chords），这些东西有数不清的名字，而Goroutines也并不新鲜，同样的概念在其它系统里已经都有了。但是这个概念和前面那些名字有很大不同，我希望我们自己起名字来命名它们。Goroutine背后的含义是：它是一个coroutine，但是它在阻塞之后会转移到其它coroutine，同一线程上的其它coroutines也会转移，因此它们不会阻塞。</p>
<p>因此，从根本上讲Goroutines是coroutines的一个分支，可在足够多的操作线程上获得多路特性，不会有Goroutines会被其他coroutine阻塞。如果它们只是协作的话，只需一个线程即可。但是如果有很多IO操作的话，就会有许多操作系统动作，也就会有许多许多线程。但是Goroutines还是非常廉价的，它们可以有数十万之众，总体运行良好并只占用合理数量的内存，它们创建起来很廉价并有垃圾回收功能，一切都非常简单。</p>
<h2 id="22-你提到你们使用了m-n线程模型，即m个coroutines映射到n个线程上？"><a href="#22-你提到你们使用了m-n线程模型，即m个coroutines映射到n个线程上？" class="headerlink" title="22. 你提到你们使用了m:n线程模型，即m个coroutines映射到n个线程上？"></a>22. 你提到你们使用了m:n线程模型，即m个coroutines映射到n个线程上？</h2><p>对的，但是coroutines的数量和线程的数量是按照程序所做工作动态决定的。</p>
<h2 id="23-Goroutines有用于通信的通道吗？"><a href="#23-Goroutines有用于通信的通道吗？" class="headerlink" title="23. Goroutines有用于通信的通道吗？"></a>23. Goroutines有用于通信的通道吗？</h2><p>是的，一旦有两个独立执行的功能，如果Goroutine们要相互协作它们就需要相互对话。所以就有了通道这个概念，它实际上是一个类型消息队列，你可以用它来发送值，如果你在Goroutine中持有通道的一端，那么你可以发送类型值给另外一端，那一端则会得到想要的东西。通道有同步和异步之分，我们尽可能使用同步通道，因为同步通道的构思非常好，你可以同时进行同步和通信，所有东西运行起来都步调一致。</p>
<p>但是有时由于效率原因或调度原因，对消息进行缓存也是有意义的。你可以向通道发送整型消息、字符串、结构、指向结构的指针等任何东西，非常有意思的事，你可以在通道上发送另一个通道。这样，我就能够把与他人的通信发送给你，这是非常有意思的概念。</p>
<h2 id="24-你提到你们有缓存的同步通道和异步通道。"><a href="#24-你提到你们有缓存的同步通道和异步通道。" class="headerlink" title="24. 你提到你们有缓存的同步通道和异步通道。"></a>24. 你提到你们有缓存的同步通道和异步通道。</h2><p>不对，同步是没有缓存的；异步和缓存是一个意思，因为有了缓存，我才能把值放在缓存的空间里进行保存。但是如果没有缓存，我必须等着别人把值拿走，因此无缓存和同步是一个意思。</p>
<h2 id="25-每个Goroutine就像是一个小的线程，可以这么给读者解释吧。"><a href="#25-每个Goroutine就像是一个小的线程，可以这么给读者解释吧。" class="headerlink" title="25. 每个Goroutine就像是一个小的线程，可以这么给读者解释吧。"></a>25. 每个Goroutine就像是一个小的线程，可以这么给读者解释吧。</h2><p>对，但是轻量级的。</p>
<h2 id="26-它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？"><a href="#26-它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？" class="headerlink" title="26. 它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？"></a>26. 它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？</h2><p>没错，Goroutines在被创建的时候，只有非常小的一个栈——4K，可能有点小吧，这个栈是在堆中的，当然，你知道如果在C语言里有这么一个小栈会发生什么，当你调用函数或分配数组之类的东西时，程序会马上溢出。在Go里则不会发生这样的事情，每个函数的开头都会有若干指令以检查栈指针是否达到其界限，如果到达界限，它会链接到其它块上，这种连接的栈叫做分段栈，如果你使用了比刚开始启动时更多的栈，你就有了这种栈块链接串，我们称之为分段栈。</p>
<p> 由于只有若干指令，这种机制非常廉价。当然，你可以分配多个栈块，但是Go编译器更倾向于将大的东西移到堆上，因此实际上典型的用法是，你必须在达到4K边界之前调用几个方法，虽然这并不经常发生。但是有一点很重要：它们创建起来很廉价，因为仅有一次内存分配，而且分配的内存非常小，在创建一个新的Goroutine时你不用指明栈的尺寸，这是很好的一种抽象，你根本不用担心栈的大小问题。之后，栈会随需求增长或缩小，你不用担心递归会有问题，你也不用担心大的缓存或任何对程序员完全不可见的东西，一切由Go语言来打理，这是一门语言的整体构思。</p>
<h2 id="27-我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？"><a href="#27-我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？" class="headerlink" title="27. 我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？"></a>27. 我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？</h2><p>我认为这是个非常难的问题，我们也还没有解决它，我们的垃圾回收器可以工作，但是有一些延迟问题，垃圾回收器可能会停顿，但是我们的看法是，我们相信尽管这是一个研究课题，虽还没解决但是我们正在努力。对于现今的并行机，通过把机器内核的一些碎片专门分给作为后台任务的垃圾回收来进行并行回收是可行的。在这一领域有很多工作要做，也取得了不少成功，但这是个很微妙的问题，我不认为而我们会把延迟降为0，但是我相信我们可以让延迟尽可能低，这样对于绝大多数系统软件来讲它不再是个问题。我不保证每个程序都不会有显著延迟，但是我想我们可以获得成功，而且这是Go语言中一个比较活跃的领域。</p>
<h2 id="28-有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。"><a href="#28-有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。" class="headerlink" title="28. 有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。"></a>28. 有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。</h2><p>Go可以让你深入到内存布局，你可以分配自己的空间，如果你想的话可以自己做内存管理。虽然没有alloc和free方法，但是你可以声明一个缓存把东西放进去，这个技巧可用来避免产生不必要的垃圾。就像在C语言一样，在C里，如果你老是malloc和free，代价很大。因此，你分配一个对象数组并把它们链接在一起，形成一个链表，管理你自己的空间，而且还不用malloc和free，那么速度会很快。你可以做与Go所做相同的事情，因为Go赋予你与底层事物安全打交道的能力，因此不用欺骗类型系统来达到目的，你实际上可以自己来做。</p>
<p> 前面我表达了这样的观点，在Java里，无论何时你在结构里嵌入其它东西，都是通过指针来实现的，但在Go里你可以把它放在一个单一结构中。因此如果你有一些需要若干缓存的数据结构，你可以把缓存放在结构的内存里，这不仅意味着高效（因为你不用间接得到缓存），而且还意味着单一结构可以在一步之内进行内存分配与垃圾回收。这样开销就会减少。因此，如果你考虑一下垃圾回收的实际情况，当你正在设计性能要求不高的东西时，你不应该总是考虑这个问题。但如果是高性能要求的，考虑到内存布局，尽管Go是具有真正垃圾回收特性的语言，它还是给了你工具，让你自己来控制有多少内存和产生了的垃圾。我想这是很多人容易忽略的。</p>
<h2 id="29-最后一个问题：Go是系统级语言还是应用级语言？"><a href="#29-最后一个问题：Go是系统级语言还是应用级语言？" class="headerlink" title="29. 最后一个问题：Go是系统级语言还是应用级语言？"></a>29. 最后一个问题：Go是系统级语言还是应用级语言？</h2><p>我们是把他设计为一种系统级语言，因为我们在Google所做的工作是系统级的，对吧？Web服务器和数据库系统、以及存储系统等，这些都是系统。但不是操作系统，我不知道Go是否能成为一个好的操作系统语言，但是也不能说它不会成为这样的语言。有趣的是由于我们设计语言时所采用的方法，Go最终成为了一个非常好的通用语言，这有点出乎我们意料。我想大多数用户并没有实际从系统观点来考虑过它，尽管很多人做过一点Web服务器或类似东西。</p>
<p>Go用来做很多应用类的东西也非常不错，它将会有更好的函数库，越来越多的工具以及一些Go更有用的东西，Go是一个非常好的通用语言，它是我用过的最高产的语言。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go自带库的使用说明</title>
    <url>/2023/09/04/Go%E8%87%AA%E5%B8%A6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-中的时间操作"><a href="#Go-中的时间操作" class="headerlink" title="Go 中的时间操作"></a>Go 中的时间操作</h1><p>Golang中与时间有关的操作，主要涉及到 time 包，核心数据结构是 <code>time.Time</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    wall <span class="type">uint64</span></span><br><span class="line">    ext  <span class="type">int64</span></span><br><span class="line">    loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、获取时间相关函数"><a href="#1、获取时间相关函数" class="headerlink" title="1、获取时间相关函数"></a>1、获取时间相关函数</h3><h4 id="1-1-获取当前时间"><a href="#1-1-获取当前时间" class="headerlink" title="1.1 获取当前时间"></a>1.1 获取当前时间</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间，注意此时返回的是 time.Time 类型</span></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 当前时间戳</span></span><br><span class="line">fmt.Println(now.Unix())</span><br><span class="line"><span class="comment">// 纳秒级时间戳</span></span><br><span class="line">fmt.Println(now.UnixNano())</span><br><span class="line"><span class="comment">// 时间戳小数部分 单位：纳秒</span></span><br><span class="line">fmt.Println(now.Nanosecond())</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">15.930562</span> +<span class="number">0800</span> CST m=+<span class="number">0.000124449</span></span><br><span class="line"><span class="number">1610261775</span></span><br><span class="line"><span class="number">1610261775930562000</span></span><br><span class="line"><span class="number">930562000</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-返回当前年月日时分秒、星期几、一年中的第几天等操作"><a href="#1-2-返回当前年月日时分秒、星期几、一年中的第几天等操作" class="headerlink" title="1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作"></a>1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 返回日期</span></span><br><span class="line">year, month, day := now.Date()</span><br><span class="line">fmt.Printf(<span class="string">&quot;year:%d, month:%d, day:%d\n&quot;</span>, year, month, day)</span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">fmt.Println(now.Year())</span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">fmt.Println(now.Month())</span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">fmt.Println(now.Day())</span><br><span class="line"><span class="comment">// 时分秒</span></span><br><span class="line">hour, minute, second := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;hour:%d, minute:%d, second:%d\n&quot;</span>, hour, minute, second)</span><br><span class="line"><span class="comment">// 时</span></span><br><span class="line">fmt.Println(now.Hour())</span><br><span class="line"><span class="comment">// 分</span></span><br><span class="line">fmt.Println(now.Minute())</span><br><span class="line"><span class="comment">// 秒</span></span><br><span class="line">fmt.Println(now.Second())</span><br><span class="line"><span class="comment">// 返回星期</span></span><br><span class="line">fmt.Println(now.Weekday())</span><br><span class="line"><span class="comment">//返回一年中对应的第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br><span class="line"><span class="comment">//返回时区</span></span><br><span class="line">fmt.Println(now.Location())</span><br><span class="line"><span class="comment">// 返回一年中第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br></pre></td></tr></table></figure>

<h4 id="1-3-格式化时间"><a href="#1-3-格式化时间" class="headerlink" title="1.3 格式化时间"></a>1.3 格式化时间</h4><p>Go 语言提供了时间类型格式化函数 <code>Format()</code>，需要注意的是 Go 语言格式化时间模板不是常见的 <code>Y-m-d H:i:s</code>，而是 2006-01-02 15:04:05，也很好记忆(2006 1 2 3 4 5)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2、时间戳与日期字符串相互转化"><a href="#2、时间戳与日期字符串相互转化" class="headerlink" title="2、时间戳与日期字符串相互转化"></a>2、时间戳与日期字符串相互转化</h3><p>时间戳转成日期格式，需要先转成将时间戳转成 <code>time.Time</code> 类型再格式化成日期格式。</p>
<h4 id="2-1-根据秒数、纳秒数返回-time-Time-类型"><a href="#2-1-根据秒数、纳秒数返回-time-Time-类型" class="headerlink" title="2.1 根据秒数、纳秒数返回 time.Time 类型"></a>2.1 根据秒数、纳秒数返回 <code>time.Time</code> 类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">t := time.Unix(now.Unix(),<span class="number">0</span>)    <span class="comment">// 参数分别是：秒数,纳秒数</span></span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<h4 id="2-2-根据指定时间返回-time-Time-类型，使用函数-time-Date"><a href="#2-2-根据指定时间返回-time-Time-类型，使用函数-time-Date" class="headerlink" title="2.2 根据指定时间返回 time.Time 类型，使用函数 time.Date()"></a>2.2 根据指定时间返回 <code>time.Time</code> 类型，使用函数 <code>time.Date()</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"><span class="comment">//根据指定时间返回 time.Time 类型</span></span><br><span class="line"><span class="comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span></span><br><span class="line">t := time.Date(<span class="number">2011</span>, time.Month(<span class="number">3</span>), <span class="number">12</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">0</span>, now.Location())</span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-日期字符串解析成-time-Time-类型"><a href="#2-3-日期字符串解析成-time-Time-类型" class="headerlink" title="2.3 日期字符串解析成 time.Time 类型"></a>2.3 日期字符串解析成 <code>time.Time</code> 类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>), time.Local)</span><br><span class="line">fmt.Println(t)  </span><br><span class="line"><span class="comment">// 输出 2021-01-10 17:28:50 +0800 CST</span></span><br><span class="line"><span class="comment">// time.Local 指定本地时间</span></span><br></pre></td></tr></table></figure>

<p>解析的时候需要特别注意时区的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(time.Now())</span><br><span class="line">fmt.Println(time.Now().Location())</span><br><span class="line">t, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2021-01-10 15:01:02&quot;</span>)</span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-10 17:22:10.951904 +0800 CST m=+0.000094166</span><br><span class="line">Local</span><br><span class="line">2021-01-10 15:01:02 +0000 UTC</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>time.Now()</code> 使用的 CST(中国标准时间)，而 <code>time.Parse()</code> 默认的是 UTC(零时区)，它们相差 8 小时。所以解析时常用 <code>time.ParseInLocation()</code>，可以指定时区。<img src="https://cdn.nlark.com/yuque/0/2021/gif/396745/1610587943191-e1905a90-4157-43d7-8623-c98b46969a36.gif" alt="img"></p>
<h3 id="3、计算、比较日期"><a href="#3、计算、比较日期" class="headerlink" title="3、计算、比较日期"></a>3、计算、比较日期</h3><p>讲到日期的计算就不得不提 time 包提供的一种新的类型 <code>Duration</code>，源码是这样定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="type">int64</span></span><br></pre></td></tr></table></figure>

<p>底层类型是 int64，表示一段时间间隔，单位是 纳秒。</p>
<h4 id="3-1-24小时之内的时间计算"><a href="#3-1-24小时之内的时间计算" class="headerlink" title="3.1 24小时之内的时间计算"></a>3.1 24小时之内的时间计算</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 1小时1分1s之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;1h1m1s&quot;</span>)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"><span class="comment">// 1小时1分1s之前</span></span><br><span class="line">t2, _ := time.ParseDuration(<span class="string">&quot;-1h1m1s&quot;</span>)</span><br><span class="line">m2 := now.Add(t2)</span><br><span class="line">fmt.Println(m2)</span><br><span class="line"><span class="comment">// 3小时之前</span></span><br><span class="line">t3, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">m3 := now.Add(t3 * <span class="number">3</span>)</span><br><span class="line">fmt.Println(m3)</span><br><span class="line"><span class="comment">// 10 分钟之后</span></span><br><span class="line">t4, _ := time.ParseDuration(<span class="string">&quot;10m&quot;</span>)</span><br><span class="line">m4 := now.Add(t4)</span><br><span class="line">fmt.Println(m4)</span><br><span class="line"><span class="comment">// Sub 计算两个时间差</span></span><br><span class="line">sub1 := now.Sub(m3)</span><br><span class="line">fmt.Println(sub1.Hours())   <span class="comment">// 相差小时数</span></span><br><span class="line">fmt.Println(sub1.Minutes()) <span class="comment">// 相差分钟数</span></span><br></pre></td></tr></table></figure>

<p>额外再介绍两个函数 <code>time.Since()</code>、<code>time.Until()</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间与 t 的时间差，返回值是 Duration</span></span><br><span class="line">time.Since(t Time) Duration</span><br><span class="line"><span class="comment">// 返回 t 与当前时间的时间差，返回值是 Duration</span></span><br><span class="line">time.Until(t Time) Duration</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line">fmt.Println(time.Since(m1))</span><br><span class="line">fmt.Println(time.Until(m1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-10 20:41:48.668232 +0800 CST m=+0.000095594</span><br><span class="line">2021-01-10 19:41:48.668232 +0800 CST m=-3599.999904406</span><br><span class="line">1h0m0.000199007s</span><br><span class="line">-1h0m0.000203035s</span><br></pre></td></tr></table></figure>

<h4 id="3-2-24小时之外的时间计算"><a href="#3-2-24小时之外的时间计算" class="headerlink" title="3.2 24小时之外的时间计算"></a>3.2 24小时之外的时间计算</h4><p>涉及到一天以外的时间计算，就需要用到 <code>time.AddDate()</code>，函数原型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> AddDate(years <span class="type">int</span>, months <span class="type">int</span>, days <span class="type">int</span>) Time</span><br></pre></td></tr></table></figure>

<p>比如想知道 一年一个月零一天 之后的时间，就可以这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></table></figure>

<p>再比如，想获得 2 天之前时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-2</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-日期比较"><a href="#3-3-日期比较" class="headerlink" title="3.3 日期比较"></a>3.3 日期比较</h4><p>日期的比较总共有三种：之前、之后和相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之后，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br><span class="line"><span class="comment">// 比较时间是否相等，相等返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 1小时之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;1h&quot;</span>)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line">fmt.Println(m1.After(now))</span><br><span class="line">fmt.Println(now.Before(m1))</span><br><span class="line">fmt.Println(now.Equal(m1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-10 21:00:44.409785 +0800 CST m=+0.000186800</span><br><span class="line">2021-01-10 22:00:44.409785 +0800 CST m=+3600.000186800</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="4、常见例子"><a href="#4、常见例子" class="headerlink" title="4、常见例子"></a>4、常见例子</h3><p>下面列举一些常见的例子和函数封装。</p>
<h4 id="4-1-日期格式-转-时间戳"><a href="#4-1-日期格式-转-时间戳" class="headerlink" title="4.1 日期格式 转 时间戳"></a>4.1 日期格式 转 时间戳</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeStr2Time</span><span class="params">(fmtStr,valueStr, locStr <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    loc := time.Local</span><br><span class="line">    <span class="keyword">if</span> locStr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        loc, _ = time.LoadLocation(locStr) <span class="comment">// 设置时区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    t, _ := time.ParseInLocation(fmtStr, valueStr, loc)</span><br><span class="line">    <span class="keyword">return</span> t.Unix()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-获取当前时间日期格式"><a href="#4-2-获取当前时间日期格式" class="headerlink" title="4.2 获取当前时间日期格式"></a>4.2 获取当前时间日期格式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentFormatStr</span><span class="params">(fmtStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Now().Format(fmtStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-时间戳-to-日期格式"><a href="#4-3-时间戳-to-日期格式" class="headerlink" title="4.3 时间戳 to 日期格式"></a>4.3 时间戳 to 日期格式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sec2TimeStr</span><span class="params">(sec <span class="type">int64</span>, fmtStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Unix(sec, <span class="number">0</span>).Format(fmtStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go-regexp正则"><a href="#Go-regexp正则" class="headerlink" title="Go-regexp正则"></a>Go-regexp正则</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;My email is ccmouse@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	compile := regexp.MustCompile(<span class="string">`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`</span>)</span><br><span class="line">	match := compile.FindString(text)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go存储基础-—-文件-IO-操作"><a href="#Go存储基础-—-文件-IO-操作" class="headerlink" title="Go存储基础 — 文件 IO 操作"></a>Go存储基础 — 文件 IO 操作</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059277-22fc4174-ea19-40a1-96a9-dc837804eaff.png" alt="img"></p>
<h2 id="两大-IO-分类"><a href="#两大-IO-分类" class="headerlink" title="两大 IO 分类"></a>两大 IO 分类</h2><p>计算的体系架构，CPU，内存，网络，IO。那么 IO 是什么呢？一般理解成 Input、Output 的缩写，通俗话就是输入输出的意思。</p>
<p>IO 分为网络和存储 IO 两种类型（<strong>其实网络 IO 和磁盘 IO 在 Go 里面有着根本性区别</strong>）。网络 IO 对应的是网络数据传输过程，网络是分布式系统的基石，通过网络把离散的物理节点连接起来，形成一个有机的系统。</p>
<p>存储 IO 对应的就是数据存储到物理介质的过程，通常物理介质对应的是磁盘，磁盘上一般会分个区，然后在上面格式化个文件系统出来，所以普通程序员最常看见的是文件 IO 的形式。</p>
<p>在 Golang 里可以归类出两种读写文件的方式：</p>
<ol>
<li>标准库封装：操作对象 <code>File</code>;</li>
<li>系统调用 ：操作对象 <code>fd</code>;</li>
</ol>
<h2 id="读写数据要素"><a href="#读写数据要素" class="headerlink" title="读写数据要素"></a>读写数据要素</h2><p>文件的读写最核心的要素是什么？</p>
<p>通俗来讲：读文件，就是把磁盘上的文件的<strong>特定位置</strong>的数据读到<strong>内存的 buffer</strong> 。写文件，就是把<strong>内存 buffer</strong> 的数据写到磁盘的文件的<strong>特定位置</strong>。</p>
<p>这里注意到两个关键词：</p>
<ol>
<li>特定位置；</li>
<li>内存 buffer；</li>
</ol>
<p><strong>特定位置怎么理解？怎么指定所谓的</strong><code>特定位置</code><strong>？</strong></p>
<p>很简单，用 <code>[ offset, length ]</code> 这两个参数就能标识一段位置。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059263-970193ad-ab90-4abd-8c62-bf040410e14d.png" alt="img"></p>
<p>也就是 IO 偏移和长度，Offset 和 Length。</p>
<p><strong>内存 buffer 怎么理解？</strong></p>
<p>归根结底，文件的数据和谁直接打交道？<strong>内存</strong>，写的时候是从内存写到磁盘文件的，读的时候是从磁盘文件读到内存的。</p>
<p>本质上，下面的 IO 函数都离不开 Offset，Length，buffer 这三个要素。</p>
<h2 id="标准库封装"><a href="#标准库封装" class="headerlink" title="标准库封装"></a>标准库封装</h2><p>Go 对文件进行读写非常简单，因为 Go 已经封装了一个非常便捷的使用接口，位于标准库 os 中。Go 标准库对文件 IO 的封装也就是 Go 推荐对文件进行 IO 时使用的操作方式。</p>
<h3 id="打开文件（Open）"><a href="#打开文件（Open）" class="headerlink" title="打开文件（Open）"></a>打开文件（Open）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>Open 文件之后，获取到一个句柄，也就是 <code>File</code> 结构，之后对文件的读写都是基于 <code>File</code> 结构之上进行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    *file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件读写只需要针对这个句柄结构体做操作即可。</p>
<p>另外有一点隐藏起来的知识点必须要提一下：<strong>偏移</strong>。也就是最开始强调的读写 3 要素之一的 Offset 。打开（<code>Open</code>）文件的时候，文件当前偏移量默认设置为 0，也就是说 IO 的起始位置就是文件的最开头。举个例子，如果这个时候，写 4K 的数据到文件，那么就是写 [0, 4K] 这个位置的数据，如果之前这上面已经有数据了，那么就会是覆盖写。</p>
<p>除非 <code>Open</code> 文件的时候指定 <code>O_APPEND</code> 选项，偏移量会设置为文件末尾，那么 IO 都是从文件末尾开始。</p>
<h3 id="文件写操作（Write）"><a href="#文件写操作（Write）" class="headerlink" title="文件写操作（Write）"></a>文件写操作（Write）</h3><p>文件 <code>File</code> 句柄对象有两个写方法：</p>
<p>第一种：写一个 buffer 到文件 ，使用文件当前偏移</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该写操作会导致文件偏移量的增加。</strong></p>
<p>第二种：从指定文件偏移，写入 buffer 到文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该写操作不会更新文件偏移量</strong></p>
<h3 id="文件读操作（Read）"><a href="#文件读操作（Read）" class="headerlink" title="文件读操作（Read）"></a>文件读操作（Read）</h3><p>和写对应，文件 <code>File</code> 句柄对象有两个读方法：</p>
<p>第一种：从文件当前偏移读一个 buffer 的数据上来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该读操作会导致文件偏移量的增加。</strong></p>
<p>第二种：从指定文件偏移，读一个 buffer 大小的数据上来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该读操作不会更新文件偏移量</strong></p>
<h3 id="指定偏移量（Seek）"><a href="#指定偏移量（Seek）" class="headerlink" title="指定偏移量（Seek）"></a>指定偏移量（Seek）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>这个句柄方法允许用户指定文件的偏移位置。这个很容易理解，举个例子，文件刚开始是 0 字节，写 1M 的数据下去，大小变成 1M，Offset 往后挪 1M ，默认就是往后挪。</p>
<p>现在 Seek 方法允许把写的偏移定位到任意位置，可以就可以从任意地方覆盖写入数据。</p>
<p>所以在 Go 里面，文件 IO 非常简单，先 Open 一个文件，拿到 <code>File</code> 句柄，然后就可以使用这个句柄 Write ，Read，Seek 就能进行 IO 了。</p>
<h2 id="底层的原理"><a href="#底层的原理" class="headerlink" title="底层的原理"></a>底层的原理</h2><p>Go 的标准库 <code>os</code> 提供了极其方便的封装，深入最原始的本质可以发现最核心的东西：<strong>系统调用</strong>。</p>
<p>Go 标准库的文件存储 IO 就是基于系统调用之上的。可以稍微跟一下 <code>os.OpenFile</code> 的调用：</p>
<p>os 库的 <code>OpenFile</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := openFileNolog(name, flag, perm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微看下 <code>openFileNolog</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openFileNolog</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> e <span class="type">error</span></span><br><span class="line">        r, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;darwin&quot;</span> &amp;&amp; e == syscall.EINTR &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;open&quot;</span>, name, e&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFile(<span class="type">uintptr</span>(r), name, kindOpenFile), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>syscall.Open</code> ，这个函数获取到一个整数，也就是在 c 语言里最常见的 fd 句柄，而 <code>File</code> 结构体则仅仅是基于这个的一层封装而已。</p>
<p><strong>思考下，为什么会有标准库封装这一层存在？</strong></p>
<p><strong>划重点：为了屏蔽操作系统的区别</strong>，使用这个标准库的所有操作都是跨平台的。换句话说，如果是特殊操作系统才有的特性，那么在 os 库里就找不到对应封装的 IO 操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059293-a7135eb0-0608-41ad-8262-cc658863c19d.png" alt="img"></p>
<p>那么怎么使用系统调用？</p>
<p>直接使用 syscall 库，也就是系统调用。从名字也能看出来，系统调用是和操作系统强相关的，因为是操作系统提供的调用接口，所以系统调用会因为操作系统不同而导致不同的特性，不同的接口。</p>
<p>所以，如果直接使用 syscall 库来使用系统调用，那么需要自己来承受系统带来的兼容性问题。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在 syscall 里有一层最基础的封装：</p>
<h3 id="文件-Open"><a href="#文件-Open" class="headerlink" title="文件 Open"></a>文件 Open</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="type">string</span>, mode <span class="type">int</span>, perm <span class="type">uint32</span>)</span></span> (fd <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<h3 id="文件-Read"><a href="#文件-Read" class="headerlink" title="文件 Read"></a>文件 Read</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) <span class="function"><span class="keyword">func</span> <span class="title">Pread</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>, offset <span class="type">int64</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>文件读有两个接口，一个 <code>Read</code> 是从<strong>当前默认偏移</strong>读一个 buffer 数据，<code>Pread</code> 接口则是从指定位置读数据的接口。</p>
<p>思考一个问题：<code>Pread</code> 从效果上来讲等于 <code>Seek</code> 和 <code>Read</code> 组合起来使用，那么是否可以认为 <code>Pread</code> 就可以被 <code>Seek</code> + <code>Read</code> 替代呢？</p>
<p>不行！根本原因在于 <code>Seek</code> + <code>Read</code> 是在用户层就是两步操作，而 <code>Pread</code> 虽然是 <code>Seek</code> + <code>Read</code> 的效果，但是操作系统给到用户的语义是：<code>Pread</code> 是一个原子操作。还有一个重要区别，<code>Pread</code> 不会改变当前文件的偏移量（普通的 <code>Read</code> 调用会更新偏移量）。</p>
<p><strong>所以，总结下，</strong><code>**Pread**</code> <strong>和顺序调用</strong> <code>**Seek**</code> <strong>后调用</strong> <code>**Read**</code>  <strong>有两点重要区别：</strong></p>
<ol>
<li><code>Pread</code> 对用户提供的语义是原子操作，在调用 <code>Pread</code> 时，无法中断 <code>Seek</code> 和 <code>Read</code> 操作；</li>
<li><code>Pread</code> 调用不会更新当前文件偏移量；</li>
</ol>
<h3 id="文件-Write"><a href="#文件-Write" class="headerlink" title="文件 Write"></a>文件 Write</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) <span class="function"><span class="keyword">func</span> <span class="title">Pwrite</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>, offset <span class="type">int64</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>文件写对应也是有两种接口，<code>Wrtie</code> 和 <code>Pwrite</code> 分别是对应 <code>Read</code> 和 <code>Pread</code> 。同样的，<code>Pwrite</code> 作用上也是相当于先调用 <code>Seek</code>  再调用 <code>Write</code> ，但是同样的也有<strong>两点不同</strong>：</p>
<ol>
<li><code>Pwrite</code>  完成 <code>Seek</code> 和 <code>Write</code> 对外是原子操作的语义；</li>
<li><code>Pwrite</code> 调用不会更新当前文件偏移量；</li>
</ol>
<h3 id="文件-Seek"><a href="#文件-Seek" class="headerlink" title="文件 Seek"></a>文件 Seek</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seek</span><span class="params">(fd <span class="type">int</span>, offset <span class="type">int64</span>, whence <span class="type">int</span>)</span></span> (off <span class="type">int64</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>这个函数调用允许用户指定偏移（这个会影响到 <code>Read</code> 和 <code>Write</code> 读写的位置）。一般来说，每个打开文件都有一个相关联的“当前文件偏移量”（ current file offset ）。读（<code>Read</code>）、写（<code>Write</code>）操作都是从<strong>当前文件偏移量处</strong>开始，并且 <code>Read</code> 和 <code>Write</code> 会导致偏移量增加，增加量就是所读写的字节数。</p>
<p><strong>小结一下</strong>：Go核心的 Open，Read，Write，Seek 几个系统调用，可以发现一个明显不同与标准 IO 库的区别：<strong>系统调用操作对象是一个整数句柄</strong>。<code>Open</code> 文件得到一个整数 fd，之后的所有 IO 都是针对这个 fd 来操作的。这个明显和标准库不同，os 标准库 OpenFile 得到的是一个 <code>File</code> 结构体，所有的 IO 也是针对这个结构体的。</p>
<h2 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h2><p>那么究竟封装的层次一般是什么样的呢， Unix 编程里面开篇就有一张如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059414-c1855d9c-8b70-473a-83ac-7889f7e0c8a9.png" alt="img"></p>
<p>这张图就非常形象的讲明白了整个 Unix 体系结构。</p>
<ul>
<li><p>内核是最核心的实现，包括了和 IO 设备，硬件交互等功能。与内核紧密的一层是内核提供给外部调用的系统调用，系统调用提供了用户态到内核态调用的一个通道；</p>
</li>
<li><p>对于系统调用，各个语言的标准库会有一些封装，比如 <strong>C 语言的 libc 库，Go 语言的 os ，syscall 库都是类似的地位，这个就是所谓的公共库</strong>。这层封装的作用最主要是简化普通程序员使用效率，并且屏蔽系统细节，为跨平台提供基础（同样的，为了跨平台的特性，可能会阉割很多不兼容的功能，所以才会有直接调用系统掉调用的需求）；</p>
</li>
<li><p>当然，右上角还看到一个缺口，应用程序除了可以使用公共函数库，<strong>其实是可以直接调用系统调用的，但是由此带来的复杂性又应用自己承担</strong>。这种需求也是很常见的，标准库封装了通用的东西，同样割舍了很多系统调用的功能，这种情况下，只能通过系统调用来获取；</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>IO 大类分为网络 IO 和磁盘 IO，IO 对文件来说就是读写操作，写的时候<strong>数据从内存到磁盘</strong>，读的时候<strong>数据从磁盘到内存</strong>；</p>
</li>
<li><p>Go 文件 IO 最常用的是 os 库，使用 Go 封装的标准库，<code>os.OpenFile</code> 打开，<code>File.Write</code>，<code>File.Read</code> 进行读写，操作对象都是 <code>File</code> 结构体；</p>
</li>
<li><p>Go 标准库对 IO 的封装是为了屏蔽复杂的系统调用，提供跨平台的使用姿势。然后单独提供 <code>syscall</code> 库，让程序员自我决策使用要使用更丰富的系统调用功能，当然后果自负；</p>
</li>
<li><p>Go 标准库 IO 操作对象是 <code>File</code> ，系统调用 IO 操作对象是 fd（非负整数）。</p>
</li>
<li><p><code>Open</code> 文件默认当前偏移量是 0 （文件最开始），加上 <code>O_APPEND</code> 参数之后偏移量会是文件末尾。通过 Seek 调用可以任意指定文件偏移，从而影响文件 IO 的位置；</p>
</li>
<li><p><code>Read</code>，<code>Write</code> 函数只有 buffer （buffer 有长度），偏移则使用当前文件偏移量；</p>
</li>
<li><p><code>Pread</code>，<code>Pwrite</code> 的系统调用效果等同于 <code>Seek</code> 偏移量然后 <code>Read</code>，<code>Write</code>，但是又大有不同。对外语义是原子操作，并且不更新当前文件偏移量；</p>
</li>
</ol>
<h1 id="Go-文件读写操作"><a href="#Go-文件读写操作" class="headerlink" title="Go-文件读写操作"></a>Go-文件读写操作</h1><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容进行追加*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*关闭文件流*/</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">/*读取*/</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*写入文件*/</span></span><br><span class="line">	str := <span class="string">&quot;hello FCC您好！！！\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件内容拷贝至新文件"><a href="#文件内容拷贝至新文件" class="headerlink" title="文件内容拷贝至新文件"></a>文件内容拷贝至新文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件1的内容拷贝到文件2*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file1Path := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file2Path := <span class="string">&quot;D:\\fcofficework\\DNS\\2.txt&quot;</span></span><br><span class="line">	data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read file err=%v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = ioutil.WriteFile(file2Path, data, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;write file err=%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断文件或者目录是否存在"><a href="#判断文件或者目录是否存在" class="headerlink" title="判断文件或者目录是否存在"></a>判断文件或者目录是否存在</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断文件以及目录是否存在*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前文件存在！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前文件不存在！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := <span class="string">&quot;D:\\fcofficework\\2.txt&quot;</span></span><br><span class="line">	PathExists(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件的拷贝*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>, srcFileName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	srcFile, err := os.Open(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	reader := bufio.NewReader(srcFile)</span><br><span class="line"></span><br><span class="line">	dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	writer := bufio.NewWriter(dstFile)</span><br><span class="line">	<span class="keyword">defer</span> dstFile.Close()</span><br><span class="line">	<span class="keyword">return</span> io.Copy(writer, reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;D:\\Photos\\Datapicture\\mmexport1530688562488.jpg&quot;</span></span><br><span class="line">	dstFile := <span class="string">&quot;D:\\Photos\\1.jpg&quot;</span></span><br><span class="line">	_, err := CopyFile(dstFile, srcFile)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝完成！&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝失败，err=&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件并统计文件中字符的个数"><a href="#读取文件并统计文件中字符的个数" class="headerlink" title="读取文件并统计文件中字符的个数"></a>读取文件并统计文件中字符的个数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统计文件的字符个数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/*英文的个数*/</span></span><br><span class="line">	ChCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*数字的个数*/</span></span><br><span class="line">	NumCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*空格的个数*/</span></span><br><span class="line">	SpaceCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*其他字符的个数*/</span></span><br><span class="line">	OtherCount <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">var</span> count CharCount</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">				<span class="keyword">fallthrough</span></span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">				count.ChCount++</span><br><span class="line">			<span class="keyword">case</span> v == <span class="string">&#x27; &#x27;</span> || v == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">				count.SpaceCount++</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">				count.NumCount++</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				count.OtherCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符的个数为：%v 数字的个数为：%v 空格的个数为：%v 其他字符的个数为：%v&quot;</span>,</span><br><span class="line">		count.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种读取文件的方式"><a href="#三种读取文件的方式" class="headerlink" title="三种读取文件的方式"></a>三种读取文件的方式</h3><h4 id="通过os读取"><a href="#通过os读取" class="headerlink" title="通过os读取"></a>通过os读取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;d:\\Photos\\Screenshots\\暗物质\\IMG_20180927_194619.jpg&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v&quot;</span>, file)</span><br><span class="line">	err1 := file.Close()</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;close file err = &quot;</span>, err1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲式读取文件"><a href="#缓冲式读取文件" class="headerlink" title="缓冲式读取文件"></a>缓冲式读取文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*缓冲式读取文件*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;d:\\Photos\\Screenshots\\暗物质\\IMG_20180927_194619.jpg&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件读取结束!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过ioutil读取"><a href="#通过ioutil读取" class="headerlink" title="通过ioutil读取"></a>通过ioutil读取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file := <span class="string">&quot;D:\\fcofficework\\DNS\\authorized_keys&quot;</span></span><br><span class="line">	content, err := ioutil.ReadFile(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read file err=%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, <span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件写入的案例"><a href="#文件写入的案例" class="headerlink" title="文件写入的案例"></a>文件写入的案例</h3><h4 id="在文件写入内容，没有则重新创建"><a href="#在文件写入内容，没有则重新创建" class="headerlink" title="在文件写入内容，没有则重新创建"></a>在文件写入内容，没有则重新创建</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在文件写入内容，没有文件则重新创建*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello world\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在已存在文件清空原有内容重新写入"><a href="#在已存在文件清空原有内容重新写入" class="headerlink" title="在已存在文件清空原有内容重新写入"></a>在已存在文件清空原有内容重新写入</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容重新写入*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello FCC\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在已存在文件清空原有内容进行追加"><a href="#在已存在文件清空原有内容进行追加" class="headerlink" title="在已存在文件清空原有内容进行追加"></a>在已存在文件清空原有内容进行追加</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容进行追加*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello FCC您好！！！\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析命令行参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;命令行参数有：&quot;</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;args[%v]=%v\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析命令行参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名，默认为空&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为空&quot;</span>)</span><br><span class="line">	<span class="comment">/*转换*/</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user=%v pwd=%v host=%v port=%v&quot;</span>, user, pwd, host, port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go-json序列化"><a href="#Go-json序列化" class="headerlink" title="Go-json序列化"></a>Go-json序列化</h1><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>     <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span>  <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">float64</span> <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span>  <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结构体序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMinsterStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	monster := Monster&#123;</span><br><span class="line">		Name:     <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">		Age:      <span class="number">500</span>,</span><br><span class="line">		Birthday: <span class="string">&quot;2011-11-11&quot;</span>,</span><br><span class="line">		Sal:      <span class="number">8000.0</span>,</span><br><span class="line">		Skill:    <span class="string">&quot;如意七十二变&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Map序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Map序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapSerlizer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">	a[<span class="string">&quot;age&quot;</span>] = <span class="number">10</span></span><br><span class="line">	a[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;火云洞&quot;</span></span><br><span class="line">	data, err := json.Marshal(a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;monster序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切片序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceSerlizer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;TGH&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;19&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;FCC&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;18&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;address&quot;</span>] = [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;华府&quot;</span>, <span class="string">&quot;影视帝国&quot;</span>&#125;</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;切片序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本数据类型序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FloatSerlize</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num1 <span class="type">float64</span> = <span class="number">245.56</span></span><br><span class="line">	data, err := json.Marshal(num1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;基本数据类型序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	NewMinsterStruct()</span><br><span class="line">	MapSerlizer()</span><br><span class="line">	SliceSerlizer()</span><br><span class="line">	FloatSerlize()</span><br><span class="line">&#125;</span><br><span class="line">Map序列化后=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">500</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;2011-11-11&quot;</span>,<span class="string">&quot;sal&quot;</span>:<span class="number">8000</span>,<span class="string">&quot;skill&quot;</span>:<span class="string">&quot;如意七十二变&quot;</span>&#125;</span><br><span class="line">monster序列化后=&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;火云洞&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">10</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>&#125;</span><br><span class="line">切片序列化后=[&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;19&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;TGH&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:[<span class="string">&quot;华府&quot;</span>,<span class="string">&quot;影视帝国&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;FCC&quot;</span>&#125;]</span><br><span class="line">基本数据类型序列化后=<span class="number">245.56</span></span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>     <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span>  <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">float64</span> <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span>  <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;孙悟空\&quot;,\&quot;age\&quot;:500,\&quot;birthday\&quot;:\&quot;2011-11-11\&quot;,\&quot;sal\&quot;:8000,\&quot;skill\&quot;:\&quot;如意七十二变\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化后monster：%v\n&quot;</span>, monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshallMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;address\&quot;:\&quot;火云洞\&quot;,\&quot;age\&quot;:10,\&quot;name\&quot;:\&quot;牛魔王\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化Map后：%v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:\&quot;19\&quot;,\&quot;name\&quot;:\&quot;TGH\&quot;&#125;,&quot;</span> +</span><br><span class="line">		<span class="string">&quot;&#123;\&quot;address\&quot;:[\&quot;华府\&quot;,\&quot;影视帝国\&quot;],\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;FCC\&quot;&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化Slice后：%v\n&quot;</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unmarshalStruct()</span><br><span class="line">	unmarshallMap()</span><br><span class="line">	unmarshalSlice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">反序列化后monster：&#123;孙悟空 <span class="number">500</span> <span class="number">2011</span><span class="number">-11</span><span class="number">-11</span> <span class="number">8000</span> 如意七十二变&#125; </span><br><span class="line">反序列化Map后：<span class="keyword">map</span>[address:火云洞 age:<span class="number">10</span> name:牛魔王] </span><br><span class="line">反序列化Slice后：[<span class="keyword">map</span>[address:北京 age:<span class="number">19</span> name:TGH] <span class="keyword">map</span>[address:[华府 影视帝国] age:<span class="number">18</span> name:FCC]]</span><br></pre></td></tr></table></figure>

<h1 id="Go-HTTP包的使用"><a href="#Go-HTTP包的使用" class="headerlink" title="Go-HTTP包的使用"></a>Go-HTTP包的使用</h1><p>Web是基于http协议的一个服务，Go语言里面提供了一个完善的net&#x2F;http包，通过http包可以很方便的搭建起来一个可以运行的Web服务。同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。</p>
<h2 id="http包建立Web服务器"><a href="#http包建立Web服务器" class="headerlink" title="http包建立Web服务器"></a>http包建立Web服务器</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello golang!&quot;</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码，build之后，然后执行web.exe,这个时候其实已经在8080端口监听http链接请求了。</p>
<p>在浏览器输入<code>http://localhost:8080</code></p>
<p>可以看到浏览器页面输出了<code>Hello golang!</code></p>
<p>浏览器输入地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/?url_long=var1&amp;url_long=var2</span><br></pre></td></tr></table></figure>

<p>可以看看浏览器输出的是什么</p>
<p>看到上面的代码，要编写一个Web服务器很简单，只要调用http包的两个函数就可以了。</p>
<h2 id="使用http包请求页面"><a href="#使用http包请求页面" class="headerlink" title="使用http包请求页面"></a>使用http包请求页面</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httputil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	request, err := http.NewRequest(http.MethodGet, <span class="string">&quot;http://www.imooc.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Redirect:&quot;</span>, req)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="comment">//resp, err := http.DefaultClient.Do(request)</span></span><br><span class="line">	<span class="comment">//resp, err := http.Get(&quot;http://www.imooc.com&quot;)</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行打印出HTML内容</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1603443525745-bf6b18f4-8ee9-45a8-8e21-67531abdf88b.png" alt="img"></p>
<h1 id="net-http包的坑——i-o-timeout"><a href="#net-http包的坑——i-o-timeout" class="headerlink" title="net&#x2F;http包的坑——i&#x2F;o timeout"></a>net&#x2F;http包的坑——i&#x2F;o timeout</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>来看一段日常代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr = &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">        Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">            conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body := bytes.NewReader(data)</span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">    req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Transport: tr,</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做的事情，比较简单，就是循环去请求<a href="http://www.baidu.com/">http://www.baidu.com/</a>, 然后等待响应。</p>
<p>看上去貌似没啥问题吧。</p>
<p>代码跑起来，也确实能正常收发消息。</p>
<p>但是这段代码跑一段时间，就会出现i&#x2F;o timeout的报错。</p>
<p>这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，这边对代码做了简化。</p>
<p>实际生产中发生的现象是，golang服务在发起http调用时，虽然<code>http.Transport</code>设置了3s超时，会偶发出现i&#x2F;o timeout的报错。</p>
<p>但是查看下游服务的时候，发现下游服务其实100ms就已经返回了。</p>
<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351380664-f90f9eac-6fcd-4446-8a4e-d08df02ab269.png" alt="img"></p>
<p>五层网络协议对应的消息体变化分析</p>
<p>就很奇怪了，明明服务端显示处理耗时才100ms，且客户端超时设的是3s, 怎么就出现超时报错i&#x2F;o timeout呢？</p>
<p>这里推测有两个可能。</p>
<ul>
<li>因为服务端打印的日志其实只是服务端应用层打印的日志。但客户端应用层发出数据后，中间还经过客户端的传输层，网络层，数据链路层和物理层，再经过服务端的物理层，数据链路层，网络层，传输层到服务端的应用层。服务端应用层处耗时100ms，再原路返回。那剩下的3s-100ms可能是耗在了整个流程里的各个层上。比如网络不好的情况下，传输层TCP使劲丢包重传之类的原因。</li>
<li>网络没问题，客户端到服务端链路整个收发流程大概耗时就是100ms左右。客户端处理逻辑问题导致超时。</li>
</ul>
<p>一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了，不死心就抓个包看下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351368734-c0656d47-9e8b-41c1-bdbb-115362ceebe8.png" alt="img"></p>
<p>抓包结果</p>
<p>分析下，从刚开始三次握手（画了红框的地方）。</p>
<p>到最后出现超时报错i&#x2F;o timeout（画了蓝框的地方）。</p>
<p>从time那一列从7到10，确实间隔3s。而且看右下角的蓝框，是51169端口发到80端口的一次Reset连接。</p>
<p>80端口是服务端的端口。换句话说就是客户端3s超时主动断开链接的。</p>
<p>但是再仔细看下第一行三次握手到最后客户端超时主动断开连接的中间，其实有非常多次HTTP请求。</p>
<p>回去看代码设置超时的方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">    Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">        conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这里的3s超时，其实是在建立连接之后开始算的，而不是单次调用开始算的超时。</p>
<p>看注释里写的是</p>
<p>SetDeadline sets the read and write deadlines associated with theconnection.</p>
<h3 id="超时原因"><a href="#超时原因" class="headerlink" title="超时原因"></a>超时原因</h3><p>大家知道HTTP是应用层协议，传输层用的是TCP协议。</p>
<p>HTTP协议从1.0以前，默认用的是短连接，每次发起请求都会建立TCP连接。收发数据。然后断开连接。</p>
<p>TCP连接每次都是三次握手。每次断开都要四次挥手。</p>
<p>其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。</p>
<p>于是乎，HTTP协议从1.1之后就默认使用长连接。具体相关信息可以看之前的<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484204&idx=1&sn=0e83aabb2a48570b5bec563a777f4d26&scene=21#wechat_redirect">这篇文章</a>。</p>
<p>那么golang标准库里也兼容这种实现。</p>
<p>通过建立一个连接池，针对每个域名建立一个TCP长连接，比如<a href="http://baidu.com和http//golang.com%E5%B0%B1%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9F%9F%E5%90%8D%E3%80%82">http://baidu.com和http://golang.com就是两个不同的域名。</a></p>
<p>第一次访问<a href="http://baidu.com域名的时候会建立一个连接,用完之后放到空闲连接池里,下次再要访问http//baidu.com%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E9%87%8D%E6%96%B0%E4%BB%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%87%8C%E6%8A%8A%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%8D%9E%E5%87%BA%E6%9D%A5%E5%A4%8D%E7%94%A8%E3%80%82">http://baidu.com域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问http://baidu.com的时候会重新从连接池里把这个连接捞出来复用。</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351347346-43a1b64f-2a30-46d4-8fbb-0e201084f4bd.png" alt="img"></p>
<p>复用长连接</p>
<p>为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应一个读goroutine和一个写goroutine。正因为是同一个域名，所以最后才会泄漏3个goroutine，如果不同域名的话，那就会泄漏1+2*N个协程，N就是域名数。</p>
<p>假设第一次请求要100ms，每次请求完<a href="http://baidu.com后都放入连接池中,下次继续复用,重复29次,耗时2900ms./">http://baidu.com后都放入连接池中，下次继续复用，重复29次，耗时2900ms。</a></p>
<p>第30次请求的时候，连接从建立开始到服务返回前就已经用了3000ms，刚好到设置的3s超时阈值，那么此时客户端就会报超时i&#x2F;o timeout。</p>
<p>虽然这时候服务端其实才花了100ms，但耐不住前面29次加起来的耗时已经很长。</p>
<p>也就是说只要通过<code>http.Transport</code>设置了<code>err = conn.SetDeadline(time.Now().Add(time.Second * 3))</code>，并且用了长连接，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，程序会报超时错误。</p>
<h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。</p>
<p>另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。</p>
<p>基于这两点，改一下代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr = &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">        <span class="comment">// 下面的代码被干掉了</span></span><br><span class="line">        <span class="comment">//Dial: func(netw, addr string) (net.Conn, error) &#123;</span></span><br><span class="line">        <span class="comment">//  conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时</span></span><br><span class="line">        <span class="comment">//  if err != nil &#123;</span></span><br><span class="line">        <span class="comment">//      return nil, err</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时</span></span><br><span class="line">        <span class="comment">//  if err != nil &#123;</span></span><br><span class="line">        <span class="comment">//      return nil, err</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  return conn, nil</span></span><br><span class="line">        <span class="comment">//&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body := bytes.NewReader(data)</span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">    req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Transport: tr,</span><br><span class="line">        Timeout: <span class="number">3</span>*time.Second,  <span class="comment">// 超时加在这里，是每次调用的超时</span></span><br><span class="line">    &#125;</span><br><span class="line">    res, err := client.Do(req) </span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释会发现，改动的点有两个</p>
<ul>
<li><code>http.Transport</code>里的建立连接时的一些超时设置干掉了。</li>
<li>在发起http请求的时候会场景<code>http.Client</code>，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timeout specifies a time limit forrequestsmade by this Client.</span><br></pre></td></tr></table></figure>

<p>到这里，代码就改好了，实际生产中问题也就解决了。</p>
<p>实例代码里，如果拿去跑的话，其实还会下面的错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get http://www.baidu.com/: EOF</span><br></pre></td></tr></table></figure>

<p>这个是因为调用得太猛了，<a href="http://www.baidu.com那边主动断开的连接,可以理解为一个限流措施,目的是为了保护服务器,毕竟每个人都像这么搞,服务器是会炸的.../">http://www.baidu.com那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，毕竟每个人都像这么搞，服务器是会炸的。。。</a></p>
<p>解决方案很简单，每次HTTP调用中间加个sleep间隔时间就好。</p>
<p>到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>用的go版本是1.12.7。</p>
<p>从发起一个网络请求开始跟。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> do(req *Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里进入 RoundTrip 逻辑</span></span><br><span class="line">/src/net/http/roundtrip.<span class="keyword">go</span>: <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试去获取一个空闲连接，用于发起 http 连接</span></span><br><span class="line">    pconn, err := t.getConn(treq, cm)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点关注这个函数，返回是一个长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (*persistConn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略了大量逻辑，只关注下面两点</span></span><br><span class="line">    <span class="comment">// 有空闲连接就返回</span></span><br><span class="line">    pc := &lt;-t.getIdleConnCh(cm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有创建连接</span></span><br><span class="line">    pc, err := t.dialConn(ctx, cm)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。</p>
<p>最后一个上面的代码里有个<code>getConn</code>方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。</p>
<ul>
<li>如果有空闲连接，就拿空闲连接</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:810</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getIdleConnCh(cm connectMethod) <span class="keyword">chan</span> *persistConn &#123;</span><br><span class="line">    <span class="comment">// 返回放空闲连接的chan</span></span><br><span class="line">    ch, ok := t.idleConnCh[key]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有空闲连接，就创建长连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:1357</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">  <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次发起一个http请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个读goroutine和一个写goroutine。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351204844-99fdc650-2c23-4dae-ba04-ba54b561202a.png" alt="img"></p>
<p>读写协程</p>
<p>注意上面代码里的<code>t.dial(ctx, &quot;tcp&quot;, cm.addr())</code>，如果像文章开头那样设置了<code>http.Transport</code>的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>那么这里就会在下面的dial里被执行到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dial(ctx context.Context, network, addr <span class="type">string</span>) (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c, err := t.Dial(network, addr)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用的设置超时，会执行到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> SetDeadline(t time.Time) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.fd.SetDeadline(t)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDeadlineImpl</span><span class="params">(fd *FD, t time.Time, mode <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="type">int64</span>, mode <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置一个定时器事件</span></span><br><span class="line">    rtf = netpollDeadline</span><br><span class="line">    <span class="comment">// 并将事件注册到定时器里</span></span><br><span class="line">    modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个定时器事件，假设时间设了3s，那么这个事件会在3s后发生，然后执行注册事件的逻辑。而这个注册事件就是<code>netpollDeadline</code>。注意这个<code>netpollDeadline</code>，待会会提到。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351188250-1127f116-5af1-4a96-ae6f-c326b52761f5.png" alt="img"></p>
<p>读写协程定时器事件</p>
<p>设置了超时事件，且超时事件是3s后之后，发生。再次期间正常收发数据。一切如常。</p>
<p>直到3s过后，这时候看读goroutine，会等待网络数据返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:1642</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        _, err := pc.br.Peek(<span class="number">1</span>)  <span class="comment">// 阻塞读取服务端返回的数据</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是一直跟代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src/bufio/bufio.<span class="keyword">go</span>: <span class="number">129</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b.fill() </span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> fill() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err := b.rd.Read(b.buf[b.w:])</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/net/http/transport.<span class="keyword">go</span>: <span class="number">1517</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err = pc.conn.Read(p)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /src/net/net.go: 173</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err := c.fd.Read(b)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    n, err = fd.pfd.Read(p)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/internal/poll/fd_unix.<span class="keyword">go</span>: </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> waitRead(isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pd.wait(<span class="string">&#x27;r&#x27;</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> wait(mode <span class="type">int</span>, isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">    <span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到跟到<code>runtime_pollWait</code>，这个可以简单认为是等待服务端数据返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.如果网络正常返回数据就跳出</span></span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.如果有出错情况也跳出</span></span><br><span class="line">        err = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整条链路跟下来，就是会一直等待数据，等待的结果只有两个</p>
<ul>
<li>有可以读的数据</li>
<li>出现报错</li>
</ul>
<p>这里面的报错，又有那么两种</p>
<ul>
<li>连接关闭</li>
<li>超时</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// errClosing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中提到的超时，就是指这里面返回的<code>数字2</code>，会通过下面的函数，转化为<code>ErrTimeout</code>， 而<code>ErrTimeout.Error()</code>其实就是i&#x2F;o timeout。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertErr</span><span class="params">(res <span class="type">int</span>, isFile <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> res &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> errClosing(isFile)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> ErrTimeout <span class="comment">// ErrTimeout.Error() 就是 &quot;i/o timeout&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;unreachable: &quot;</span>, res)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了。上面返回的超时错误，也就是返回2的时候的条件是怎么满足的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得刚刚提到的netpollDeadline吗？</p>
<p>这里面放了定时器3s到点时执行的逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计时器到设定时间点了，触发之前注册函数</span></span><br><span class="line">    f(arg, seq) <span class="comment">// 之前注册的是 netpollDeadline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/runtime/netpoll.<span class="keyword">go</span>: <span class="number">428</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> read &#123;</span><br><span class="line">        pd.rd = <span class="number">-1</span></span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会设置<code>pd.rd=-1</code>，是指<code>poller descriptor.read deadline</code>，含义网络轮询器文件描述符的读超时时间， 在linux里万物皆文件，这里的文件其实是指这次网络通讯中使用到的socket。</p>
<p>这时候再回去看发生超时的条件就是<code>if (mode == &#39;r&#39; &amp;&amp; pd.rd &lt; 0)</code>。</p>
<p>至此。代码里就收到了io timeout的报错。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>不要在<code>http.Transport</code>中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名io timeout报错。</li>
<li>请求的超时在创建<code>client</code>里设置。</li>
</ul>
<h1 id="Go中Unicode相关包"><a href="#Go中Unicode相关包" class="headerlink" title="Go中Unicode相关包"></a>Go中Unicode相关包</h1><h3 id="Go中Unicode相关包-1"><a href="#Go中Unicode相关包-1" class="headerlink" title="Go中Unicode相关包"></a>Go中Unicode相关包</h3><p>Go 语言让复杂的编码问题变得简单很多，极大的减轻了程序员的心智负担。为了方便对 unicode 字符串进行处理，Go 语言标准库提供三个包：unicode、unicode&#x2F;utf8 和 unicode&#x2F;utf16。</p>
<p>这里简单介绍下三个包的功能：</p>
<ul>
<li><p>unicode：unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。</p>
</li>
<li><p>unicode&#x2F;utf8：用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。</p>
</li>
<li><p>unicode&#x2F;utf16：函数比较少，主要是 UTF-16 序列的编码和解码。</p>
</li>
</ul>
<p>Go 中字符串的写法。</p>
<p>在 Go 语言中，字符串字面值有 4 种写法，比如「徐新华」可以这么写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;徐新华&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;\u5F90\u65B0\u534E&quot;</span></span><br><span class="line">s3 := <span class="string">&quot;\U00005F90\U000065B0\U0000534E&quot;</span></span><br><span class="line">s4 := <span class="string">&quot;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&quot;</span></span><br></pre></td></tr></table></figure>

<p>简单来生活就是 \u 紧跟四个十六进制数，\U 紧跟八个十六进制数。其中 \u 或 \U 代表后面是 Unicode 码点。而 \x 紧跟两个十六进制数，这些十六进制不是 Unicode 码点，而是 UTF-8 编码。</p>
<p>下面的代码有利于理解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">`徐新华`</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        buf = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>)</span><br><span class="line">        n   <span class="type">int</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(<span class="string">&quot;字符\tUnicode码点\tUTF-8编码十六进制\tUTF-8编码二进制&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        n = utf8.EncodeRune(buf, r)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q\t%U\t\t%X\t\t%b\n&quot;</span>, r, r, buf[:n], buf[:n])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;\u5F90\u65B0\u534E&quot;</span></span><br><span class="line">    s3 := <span class="string">&quot;\U00005F90\U000065B0\U0000534E&quot;</span></span><br><span class="line">    s4 := <span class="string">&quot;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">    fmt.Println(s4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">字符 Unicode码点 UTF<span class="number">-8</span>编码十六进制 UTF<span class="number">-8</span>编码二进制</span><br><span class="line"><span class="string">&#x27;徐&#x27;</span> U+<span class="number">5</span>F90  E5BE90  [<span class="number">11100101</span> <span class="number">10111110</span> <span class="number">10010000</span>]</span><br><span class="line"><span class="string">&#x27;新&#x27;</span> U+<span class="number">65</span>B0  E696B0  [<span class="number">11100110</span> <span class="number">10010110</span> <span class="number">10110000</span>]</span><br><span class="line"><span class="string">&#x27;华&#x27;</span> U+<span class="number">534</span>E  E58D8E  [<span class="number">11100101</span> <span class="number">10001101</span> <span class="number">10001110</span>]</span><br><span class="line">徐新华</span><br><span class="line">徐新华</span><br><span class="line">徐新华</span><br></pre></td></tr></table></figure>

<p>此外，关于字符串其他方面的处理，比如编码转换等，可以到 <a href="https://pkg.go.dev/golang.org/x/text">https://pkg.go.dev/golang.org/x/text</a> 里找。</p>
<h3 id="大小端问题（Little-endian-和-Big-endian）"><a href="#大小端问题（Little-endian-和-Big-endian）" class="headerlink" title="大小端问题（Little endian 和 Big endian）"></a>大小端问题（Little endian 和 Big endian）</h3><p>一个字符使用多字节存储时，涉及到哪个在前哪个在后。以汉字「徐」为例，Unicode 码点是 5F90，需要用两个字节存储，一个字节是<code>5F</code>，另一个字节是<code>90</code>。存储的时候，<code>5F</code>在前，<code>90</code> 在后，这就是 Big endian 方式；<code>90</code>在前，<code>5F</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头（Big-endian）敲开还是从小头（Little-endian）敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大端方式”（Big endian），第二个字节在前就是”小端方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大1。</p>
<p>如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式；如果头两个字节是 FF FE，就表示该文件采用小端方式。</p>
<p>但从上面关于 UTF-8 编码的说明可以看出，虽然 UTF-8 存在多字节表示一个字符的情况，但顺序是固定的，没有字节序的问题。Unix 系统下，UTF-8 没有任何前置字符，但 Windows 下记事本保存的 UTF-8 文件会带上 BOM（Byte Order Mark），即 EF BB BF 这三个字节。关于这一点，Unicode 之父 Rob Pike 明确说 UTF-8 不需要 BOM，所以一开始 Go 源文件是不允许有 BOM 的，否则编译不通过，不过现在已经可以有了。但建议还是别带 BOM。</p>
<blockquote>
<p>UTF-8 带 BOM 说不是为了区分字节序，而是为了更方便的知晓这是一个 UTF-8 文件。</p>
</blockquote>
<h1 id="Go-标准库之-unsafe-包"><a href="#Go-标准库之-unsafe-包" class="headerlink" title="Go 标准库之 unsafe 包"></a>Go 标准库之 unsafe 包</h1><h2 id="1-unsafe包"><a href="#1-unsafe包" class="headerlink" title="1.  unsafe包"></a>1.  unsafe包</h2><h2 id="1-1-ArbitraryType"><a href="#1-1-ArbitraryType" class="headerlink" title="1.1.  ArbitraryType"></a>1.1.  <code>ArbitraryType</code></h2><p><code>unsafe</code>包下定义了一个<code>ArbitratyType</code>类型，代表了任意的Go表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-Pointer"><a href="#1-2-Pointer" class="headerlink" title="1.2.  Pointer"></a>1.2.  <code>Pointer</code></h2><p><code>Pointer</code>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p><code>Pointer</code>代表了一个指向任意类型的指针，有四种只适用对<code>Pointer</code>而不适用于其他类型的操作。</p>
<ul>
<li><p>任意类型的指针值可以被转换为一个<code>Pointer</code></p>
</li>
<li><p>一个<code>Pointer</code>可以被转换为任意类型的指针值</p>
</li>
<li><p>一个<code>uintptr</code>可以被转换为一个<code>Pointer</code></p>
</li>
<li><p>一个<code>Pointer</code>也可以被转换为一个<code>uintptr</code></p>
</li>
</ul>
<p>因此，<code>Pointer</code>可以跳过类型系统而直接指向任意类型。所以需要十分小心的使用。</p>
<p>关于使用<code>Pointer</code>的规则，不使用这些规则的代码是不可用的，或者在未来是不可用的。</p>
<h3 id="1-2-1-使用Pointer作为中间者将-T1转换为-T2"><a href="#1-2-1-使用Pointer作为中间者将-T1转换为-T2" class="headerlink" title="1.2.1.  使用Pointer作为中间者将*T1转换为*T2"></a>1.2.1.  使用<code>Pointer</code>作为中间者将<code>*T1</code>转换为<code>*T2</code></h3><p>前提是T2的大小不超过T1，而且两者的内存分布相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="type">float64</span>)</span></span> <span class="type">uint64</span> &#123;  <span class="keyword">return</span> *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f))&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-把Pointer转换为uintptr"><a href="#1-2-2-把Pointer转换为uintptr" class="headerlink" title="1.2.2.  把Pointer转换为uintptr"></a>1.2.2.  把<code>Pointer</code>转换为<code>uintptr</code></h3><p>把<code>Pointer</code>转换为<code>uintptr</code>将产生一个指向类型值的<code>int</code>变量。常用来打印一个<code>uintptr</code>。</p>
<p>将<code>uintptr</code>转换为<code>Pointer</code>是不可用的。</p>
<p>因为<code>uintptr</code>是一个整数值，而不是引用。就是说<code>uintptr</code>和指针没有任何关系。可以说是将<code>Pointer</code>指向的地址的值返回给<code>uintptr</code>，即使<code>uintptr</code>中的值对应的地址的对象更新了或者删除了，<code>uintptr</code>也不会改变。</p>
<h3 id="1-2-3-把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算"><a href="#1-2-3-把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算" class="headerlink" title="1.2.3.  把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算"></a>1.2.3.  把<code>Pointer</code>转为<code>uintptr</code>再转换回<code>Pointer</code>，其中带有<code>uintptr</code>数值运算</h3><p>如果<code>Pointer</code>指向一个分配的对象，那么如下转换可以把<code>Pointer</code>指针向后移动。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p = unsafe.Pointer(<span class="type">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure>

<p>最常用的是指向结构体中不同字段或者数组中的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// equivalent to f := unsafe.Pointer(&amp;s.f)</span></span><br><span class="line"> f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line"> <span class="comment">// equivalent to e := unsafe.Pointer(&amp;x[i])</span></span><br><span class="line"> e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x[<span class="number">0</span>])) + i*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>这可以用来向前或向后移动指针，通过加或者减<code>offset</code>。指针移动之后，也应该指向该内存范围中。</p>
<p>将<code>Pointer</code>移动超过其对象的原始内存分配范围是不可用的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: end points outside allocated space.</span></span><br><span class="line"> <span class="keyword">var</span> s thing</span><br><span class="line"> end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// INVALID: end points outside allocated space.</span></span><br><span class="line"> b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line"> end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<p>当然如下代码也是错误的，因为<code>uintptr</code>不可以储存在变量中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">// before conversion back to Pointer.</span></span><br><span class="line">u := <span class="type">uintptr</span>(p)</span><br><span class="line">p = unsafe.Pointer(u + offset)</span><br><span class="line">Pointer<span class="string">`必须指向一个已经分配好的对象，而不能是`</span><span class="literal">nil</span></span><br><span class="line"><span class="comment">// INVALID: conversion of nil pointer</span></span><br><span class="line">u := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">p := unsafe.Pointer(<span class="type">uintptr</span>(u) + offset)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-当调用syscall-Syscall时，需要把Poiner转换为uintptr"><a href="#1-2-4-当调用syscall-Syscall时，需要把Poiner转换为uintptr" class="headerlink" title="1.2.4.  当调用syscall.Syscall时，需要把Poiner转换为uintptr"></a>1.2.4.  当调用<code>syscall.Syscall</code>时，需要把<code>Poiner</code>转换为<code>uintptr</code></h3><p><code>syscall</code>包下的<code>Syscall</code>函数把<code>uintptr</code>参数传递给操作系统，然后根据调用的相关信息，把相应的<code>uintptr</code>再转换为指针。</p>
<p>如果一个指针参数必须被转换为<code>uintptr</code>作为参数的话，这个转换只能在调用函数中的参数表达式完成，因为<code>uintptr</code>是不能储存在变量中的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(p)), <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<p>编译器处理函数调用中的指针时，该指针所指向的对象会被保留到函数调用结束，即使该对象在函数调用时并不使用。</p>
<p>如下是错误的代码，因为<code>uintptr</code>不能保存在变量中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">// before implicit conversion back to Pointer during system call.</span></span><br><span class="line">u := <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), u, <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-将reflect-Value-Pointer或者reflect-Value-UnsafeAddr的结果从uintptr转换为Pointer"><a href="#1-2-5-将reflect-Value-Pointer或者reflect-Value-UnsafeAddr的结果从uintptr转换为Pointer" class="headerlink" title="1.2.5.  将reflect.Value.Pointer或者reflect.Value.UnsafeAddr的结果从uintptr转换为Pointer"></a>1.2.5.  将<code>reflect.Value.Pointer</code>或者<code>reflect.Value.UnsafeAddr</code>的结果从<code>uintptr</code>转换为<code>Pointer</code></h3><p>包<code>reflect</code>下<code>Value</code>的<code>Pointer</code>方法和<code>UnsafeAddr</code>方法返回的是<code>uintptr</code>而不是<code>Pointer</code>类型，以便于调用者不使用<code>usafe</code>包就可以转换为任意类型。这也意味着，这两个方法的返回值必须使用<code>Pointer</code>进行转换才可以使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer()))</span><br></pre></td></tr></table></figure>

<p>因为这两个函数调用的返回值是<code>uintptr</code>，所以也是不可以变量储存的。</p>
<h3 id="1-2-6-reflect-SliceHeader或者reflect-StringHeader的Data字段同Pointer的相互转换"><a href="#1-2-6-reflect-SliceHeader或者reflect-StringHeader的Data字段同Pointer的相互转换" class="headerlink" title="1.2.6.  reflect.SliceHeader或者reflect.StringHeader的Data字段同Pointer的相互转换"></a>1.2.6.  <code>reflect.SliceHeader</code>或者<code>reflect.StringHeader</code>的<code>Data</code>字段同<code>Pointer</code>的相互转换</h3><p>前面说过，返回<code>uintptr</code>是为了调用者可以直接进行不同类型的转换，而不用导入<code>unsafe</code>包。这意味着，只有当指针解析为切片或者字符串时<code>SliceHeader</code>和<code>StringHeader</code>才可以被使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="comment">// case 1</span></span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))              <span class="comment">// case 6 (this case)</span></span><br><span class="line">hdr.Len = n</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>SliceHeader</code>和<code>StringHeader</code>只能作为<code>*SliceHeader</code>和<code>*StringHeader</code>使用，而不可以使用其结构体形式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: a directly-declared header will not hold Data as a reference.</span></span><br><span class="line"><span class="keyword">var</span> hdr reflect.StringHeader</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;hdr)) <span class="comment">// p possibly already lost</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-Sizeof函数"><a href="#1-3-Sizeof函数" class="headerlink" title="1.3 Sizeof函数"></a>1.3 <code>Sizeof</code>函数</h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p>直接复制标准文档中的内容，下同。</p>
<p><code>Sizeof</code>返回类型v本身数据所占用的字节数。返回值是“顶层”的数据占有的字节数。例如，若v是一个切片，它会返回该切片描述符的大小，而非该切片底层引用的内存的大小。</p>
<h2 id="1-4-Alignof"><a href="#1-4-Alignof" class="headerlink" title="1.4 Alignof"></a>1.4 <code>Alignof</code></h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(v ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p><code>Alignof</code>返回类型v的对齐方式（即类型v在内存中占用的字节数）；若是结构体类型的字段的形式，它会返回字段f在该结构体中的对齐方式。</p>
<h2 id="1-5-Offsetof"><a href="#1-5-Offsetof" class="headerlink" title="1.5 Offsetof"></a>1.5 <code>Offsetof</code></h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(v ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p><code>Offsetof</code>返回类型v所代表的结构体字段在结构体中的偏移量，它必须为结构体类型的字段的形式。换句话说，它返回该结构起始处与该字段起始处之间的字节数。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1.2中的<code>Pointer</code>和<code>uintptr</code>的区别：</p>
<p>假设在内存中有一个变量<code>a := 1</code></p>
<p>那么<code>p := Pointer(&amp;a)</code>中，p包含的就是a的实际地址，假设为<code>1000</code>，当a在内存中移动时，p中的地址值也会实时更新。</p>
<p>而<code>uintprt(p)</code>只是<code>1000</code>，就是a的地址值，但是当a在内存中移动时，原来获取的<code>uintptr</code>值并不会发生变化，一直都是1000。</p>
<p>也是因为这个原因，<code>syscall.Syscall</code>传入的<code>uintptr</code>如果代表一个对象的指针，那么该对象在内存中是一直被保留的，而且不能移动，否则的话<code>uintptr</code>指向的就不是原来的对象了，容易内存泄漏。</p>
<p>还有一个就是<code>uintptr</code>不能保存在变量中，只能使用<code>Pointer</code>进行转换然后才能保存。</p>
<h1 id="编码分析"><a href="#编码分析" class="headerlink" title="编码分析"></a>编码分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>HTTP 协议基于文本传输，字符编码将文本变为二进制，二进制编码将二进制变为文本。TCP 协议基于二进制传输，数据读取时需要处理字节序。本文将介绍常见的字符编码、二进制编码及字节序，并一探 Golang 中的实现。</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>引言：如何把“Hello world”变成字节？</p>
<ul>
<li><p>Step1：得到要表示的全量字符（字符表）</p>
</li>
<li><p>Step2：为每个字符指定一个整数编号（编码字符集）</p>
</li>
<li><p>Step3：将编号映射成有限长度比特值（字符编码表）</p>
</li>
</ul>
<p>字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。全世界共使用 5651 种语言，其中使用人数超过 5000 万的语言有 13 种，每种语言有自己的字符。汉语中，一个汉字就是一个字符。英语中，一个字母就是一个字符。甚至看不见的也可以是字符（如控制字符）。<strong>字符的集合即为字符表</strong>，如英文字母表，阿拉伯数字表。ASCII 码表中一共有 128 个字符。</p>
<h2 id="编码字符集（CCS-Coded-Character-Set）"><a href="#编码字符集（CCS-Coded-Character-Set）" class="headerlink" title="编码字符集（CCS:Coded Character Set）"></a>编码字符集（CCS:Coded Character Set）</h2><p>为字符表中的每个字符指定一个编号（<strong>码点，Code Point</strong>），即得到编码字符集。常见有 ASCII 字符集、Unicode 字符集、GB2312 字符集、BIG5 字符集、 GB18030 字符集等。ASCII 字符集中一共有 128 个字符，包括了 94 个可打印字符（英文大小写字母 52 个、阿拉伯数字 10 个、西文符号 32 个）和 34 个控制符或通信专用字符，码点值范围为[0, 128)，如下图所示。Unicode 字符集是一个很大的集合，现有容量将近 2^21 个字符，码点值范围为[0, 2^20+2^16)。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502988-ada45336-1730-4863-a573-2b9db2127675.webp" alt="img"></p>
<p>ASCII字符编码表</p>
<h2 id="字符编码表（CEF-Character-Encoding-Form）"><a href="#字符编码表（CEF-Character-Encoding-Form）" class="headerlink" title="字符编码表（CEF:Character Encoding Form）"></a>字符编码表（CEF:Character Encoding Form）</h2><p><strong>编码字符集只定义了字符与码点的映射</strong>，并没有规定码点的字节表示方式。由于 1 个字节可以表示 256 个编号，足以容纳 ASCII 字符集，因此<strong>ASCII 编码的规则很简单：直接将码点值用 uint8 表示即可</strong>。对于 Unicode 字符集，容纳 2^21 至少需要 3 字节。可以采用类似 ASCII 的编码规则：<strong>直接将编码点值用 uint32 表示即可，这正是 UTF-32 编码</strong>。</p>
<p>这种一刀切的定长编码方式虽然简单粗暴，弊端也很明显：<strong>对于纯英文文本，UTF-32 编码空间占用将是 ACSII 编码的 4 倍</strong>，造成极大的空间浪费，几乎没什么人用。有没有更优雅的解决方案？当然，这就是 UTF-8 和 UTF-16，两种当前比较流行的 Unicode 编码方式。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>历史的经验，成功的设计往往具有包容性。UTF-8 是一个典型，漂亮的实现了<strong>对 ASCII 码的向后兼容</strong>，以保证可以被大众接受。UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长，随码点变换长度（从 1 字节到 4 字节）。text</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502972-eb8483f5-fb58-4b55-a2b8-a1f52f4d9914.webp" alt="img"></p>
<p>大道至简，优雅的设计一定是简单的，UTF-8 的编码规则也诠释了这一点。编码规则如下：</p>
<ol>
<li>&lt;&#x3D;127（U+7F）的码点采用单字节编码，与 ASCII 保持一致；</li>
<li>&gt;127（U+7F）的码点采用 N 字节（N 属于 2，3，4）编码，首字节的前 N 位为 1，第 N+1 位为 0，剩余 N-1 个字节的前两位都为 10，剩下的二进制位使用字符的码点来填充。</li>
</ol>
<p>其中(U+7F)表示 Unicode 的十六进制码点值，即 127。如果觉得编码规则抽象，结合下表更加清晰：</p>
<table>
<thead>
<tr>
<th>Unicode  码点范围</th>
<th>码点数量</th>
<th>UTF-8 编码格式</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000 ~ 0000 007F</td>
<td>2^7</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 ~ 0000 07FF</td>
<td>2^11 - 2^7</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 ~ 0000 FFFF</td>
<td>2^16 - 2^11</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 ~ 0010 FFFF</td>
<td>2^20</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>举个例子，如“汉”的 Unicode 码点是 U+6C49（110 1100 0100 1001），根据上表可得需要 3 字节编码，填充码点值后得到 0xE6 0xB7 0x89（11100110 10110001 10001001）。</p>
<p>根据编码规则，解码也很简单，关键是如何判断连续的字节数：<strong>首字节连续 1 的个数即为字节数</strong>。</p>
<p>需要一提的是，<strong>在 MySQL 中，utf8 是“虚假的 utf8”</strong>，最大只支持 3 个字节，如果建表时选择 CHARSET&#x3D;utf8，会导致很多特殊字符和 emoji 表情都无法插入。<strong>utf8mb4 才是“真正的 utf8”</strong>，mb4 即most bytes 4。为什么 MySQL 中 utf8 最大只支持 3 字节？历史原因，在 MySQL 刚开发那会儿，Unicode 空间只有 2^16，Unicode 委员会还在做 “65535 个字符足够全世界用了”的美梦呢。</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>在 C&#x2F;C++ 中遇到的wchar_t类型或 Java 中的char类型，这些类型占内存两个字节，因为 Unicode 中常用的字符都处于[U+0, U+FFFF]（基本平面）的范围之内，因此<strong>两个字节几乎可以覆盖大部分的常用字符</strong>，这正是 UTF-16 编码的一个前提。</p>
<p>相比 UTF-32 与 UTF-8，<strong>UTF-16 编码是一个折中：小于（U+FFFF）2^16 的码点（基本平面）使用 2 字节编码，大于（U+FFFF）2^16 的码点（辅助码点）使用 4 字节编码</strong>。由于基础平面空间会占用 2 字节的所有比特位，无法像 UTF-8 那样留有“10”前缀。那么问题来了：<strong>当遇到两个节时，如何判断是 2 字节编码还是 4 字节编码？</strong></p>
<p>UTF-16 的编码的另一个前提：<strong>在基本平面内，</strong>**[U+D800, U+DFFF]**<strong>是一个空段（空间大小为 2^11）</strong>，这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>辅助平面容量为 2^20，至少需要 20 个二进制位，UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 2^10），称为<strong>高位</strong>（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 2^10），称为<strong>低位</strong>（L）。</p>
<p>映射方式采用线性映射。Unicode3.0 中给出了辅助平面字符的转换公式：</p>
<p>H &#x3D; Math.floor((c-0x10000) &#x2F; 0x400) + 0xD800</p>
<p>L &#x3D; (c - 0x10000) % 0x400 + 0xDC00</p>
<p>也就是说，一个辅助平面的码点，被拆成两个基本平面的空段码点表示。如果双字节的值在[U+D800, U+DBFF]中，则要和后续相邻的双字节一同解码。具体编码规则为：</p>
<ol>
<li>&lt;&#x3D; (U+FFFF)的码点采用双字节编码，直接将码点使用 uint16 表示；</li>
<li>&gt; (U+FFFF)的码点采用 4 字节编码，作差计算码点溢出值，将溢出值用 uint20 表示后，前 10 位映射到[U+D800, U+DBFF]，后 10 位映射到[U+DC00, U+DFFF];</li>
</ol>
<p>小结: 定长编码的优点是转换规则简单直观，查找效率高，缺点是空间浪费，以及不可扩展。如果 Unicode 字符集进一步扩充，UTF-16 和 UTF-32 都将不可用，而 UTF-8 具有更强的可扩展性。</p>
<h2 id="Golang-中字符编码"><a href="#Golang-中字符编码" class="headerlink" title="Golang 中字符编码"></a>Golang 中字符编码</h2><p>不像 C++、Java 等语言支持五花八门的字符编码，Golang 遵从“大道至简”的原则：<strong>全用 UTF-8</strong>。所以 go 程序员再也不用担心乱码问题，甚至可以用汉字和表情包写代码，string 与字节数组转换也是直接转换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemp</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    来自打工人的问候()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> 来自打工人的问候<span class="params">()</span></span> &#123;</span><br><span class="line">    问候语 := <span class="string">&quot;早安，打工人😁&quot;</span></span><br><span class="line">    fmt.Println(问候语)</span><br><span class="line">    bytes := []<span class="type">byte</span>(问候语)</span><br><span class="line">    fmt.Println(hex.EncodeToString(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 执行结果–&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">早安，打工人😁</span><br><span class="line">e697a9e5ae89efbc8ce68993e5b7a5e4babaf09f9881</span><br></pre></td></tr></table></figure>

<p>值得一提的是，Golang 中 string 的底层模型就是字节数组，所以类型转换过程中无需编解码。也因此，<strong>Golang 中 string 的底层模型是字节数组，其长度并非字符数，而是对应字节数</strong>。如果要取字符数，需要先将字符串转换为字符数组。<strong>字符类型（rune）实际上是 int32 的别名，即用 UTF-32 编码表示字符</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemp</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;早&quot;</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>([]<span class="type">byte</span>(<span class="string">&quot;早&quot;</span>))) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;早&quot;</span>)) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>再看一下 go 中 utf-8 编码的具体实现。首先获取字符的码点值，然后根据范围判断字节数，根据对应格式生成编码值。如果是无效的码点值，或码点值位于空段，则返回U+FFFD(即 �)。解码过程不再赘述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(p []<span class="type">byte</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// Negative values are erroneous. Making it unsigned addresses the problem.</span></span><br><span class="line">    <span class="keyword">switch</span> i := <span class="type">uint32</span>(r); &#123;</span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune1Max:</span><br><span class="line">        p[<span class="number">0</span>] = <span class="type">byte</span>(r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune2Max:</span><br><span class="line">        _ = p[<span class="number">1</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t2 | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> i &gt; MaxRune, surrogateMin &lt;= i &amp;&amp; i &lt;= surrogateMax:</span><br><span class="line">        r = RuneError</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune3Max:</span><br><span class="line">        _ = p[<span class="number">2</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t3 | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _ = p[<span class="number">3</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t4 | <span class="type">byte</span>(r&gt;&gt;<span class="number">18</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">3</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    t1 = <span class="number">0</span>b00000000</span><br><span class="line">    tx = <span class="number">0</span>b10000000</span><br><span class="line">    t2 = <span class="number">0</span>b11000000</span><br><span class="line">    t3 = <span class="number">0</span>b11100000</span><br><span class="line">    t4 = <span class="number">0</span>b11110000</span><br><span class="line">    t5 = <span class="number">0</span>b11111000</span><br><span class="line">    maskx = <span class="number">0</span>b00111111</span><br><span class="line">    mask2 = <span class="number">0</span>b00011111</span><br><span class="line">    mask3 = <span class="number">0</span>b00001111</span><br><span class="line">    mask4 = <span class="number">0</span>b00000111</span><br><span class="line">    rune1Max = <span class="number">1</span>&lt;&lt;<span class="number">7</span> - <span class="number">1</span></span><br><span class="line">    rune2Max = <span class="number">1</span>&lt;&lt;<span class="number">11</span> - <span class="number">1</span></span><br><span class="line">    rune3Max = <span class="number">1</span>&lt;&lt;<span class="number">16</span> - <span class="number">1</span></span><br><span class="line">    RuneError = <span class="string">&#x27;\uFFFD&#x27;</span> <span class="comment">// the &quot;error&quot; Rune or &quot;Unicode replacement character&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code points in the surrogate range are not valid for UTF-8.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    surrogateMin = <span class="number">0xD800</span></span><br><span class="line">    surrogateMax = <span class="number">0xDFFF</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>引言：HTTP 是怎么传输二进制数据的？</p>
<ul>
<li><p>Step1：定义字符集；</p>
</li>
<li><p>Step2：将二进制数据分组；</p>
</li>
<li><p>Step3：将每组映射为字符；</p>
</li>
</ul>
<p>字符编码是「文本」变为「二进制」的过程，那如何将任意「二进制」变为「文本」？答案是进行二进制编码，常见有 Hex 编码与 Base64 编码。</p>
<p>显然<strong>不能按字符编码直接解码</strong>，因为字符编码的结果二进制是满足编码规律的，而非「任意」的，非法格式进行字符解码会出现乱码（比如对0b11xxxxxx进行 UTF-8 解码）。</p>
<h2 id="Hex-编码"><a href="#Hex-编码" class="headerlink" title="Hex 编码"></a>Hex 编码</h2><p>Hex 编码是最直观的二进制编码方式，所见即所得。上文中的十六进制表示就是用的 Hex 编码。规则如下：</p>
<ol>
<li><p>Hex 字符集为0123456789abcdef；</p>
</li>
<li><p>每 4bit 为 1 组(2^4&#x3D;16)；</p>
</li>
<li><p>每组映射为一个 Hex 字符；</p>
</li>
</ol>
<p>计算机中二进制数据都是以字节为单位存储的，1 个字节 8bit，不会出现无法被 4 整除的情况。</p>
<p>每个字节编码为 2 个 Hex 字符，即编码后的字符数是原始数据字节数的 2 倍。<strong>在 ASCII 或 UTF-8 编码下，存储 Hex 结果字符串需要的空间是原始数据的 2 倍，存储效率为 50%。</strong></p>
<h2 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h2><p>Base64 编码，顾名思义，是基于 64 个字符进行编码。规则如下：</p>
<ol>
<li>Base64 字符集（以标准 Base64 为例, 26 大写, 26 小写, 10 数字, 以及+、&#x2F;）为ABC…YZabc…yz012…89+&#x2F;；</li>
<li>每 6bit 为一组（2^6&#x3D;64），即<strong>每 3 个字节为 4 组</strong>；</li>
<li>每组映射为一个 Base64 字符；</li>
</ol>
<p>如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？**标准编码(StdEncoding)**会先在末尾用 0x00 补齐再分组，并将最后 2 个或 1 个 6bit 分组（全为 0 填充）映射为’&#x3D;’，表示补齐的 0 字节数量。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503267-8b0246bc-28ee-459b-8ad3-1d75de4e3f9d.webp" alt="img"></p>
<p>举个例子，以0x12 34 ab cd编码为标准 base64 为例：</p>
<ol>
<li>不足 3 的倍数，先用两个 0 字节补齐 –&gt;0x12 34 ab cd 00 00</li>
<li>0x12 34 ab编码为EjSr</li>
<li>0xcd 00 00二进制为0b1100 1101 0000 0000 0000 0000，分为 4 组后为110011 010000 000000 000000，编码结果为zQ&#x3D;&#x3D;</li>
<li>最终编码结果为EjSrzQ&#x3D;&#x3D;</li>
</ol>
<p>解码过程注意末尾字节的处理即可，此处不再赘述。</p>
<ol>
<li>EjSrzQ&#x3D;&#x3D;–&gt;0x12 34 ab cd 00 00–&gt;0x12 34 ab cd</li>
</ol>
<p><strong>标准编码中编码结果字符长度一定是 4 的倍数，且是原始数据字节数的 4&#x2F;3 倍</strong>，因为会将字节数据补齐至 3 的倍数，每 3 个字节编码为 4 个字符。**在 ASCII 或 UTF-8 编码下，存储结果字符串需要的空间是原始数据的 4&#x2F;3 倍，存储效率为 75%**。</p>
<p>根据字符集的不同，Base64 编码有几个变种，除了标准编码（StdEncoding），常见的还有 URL 编码（URLEncoding）、原始标准编码（RawStdEncoding）以及原始 URL 编码（RawUrlEncoded）。</p>
<p>简单来说，Raw 指的是无 Padding，URL 指的是用-和_取代编码结果中包含的 url 关键字+和&#x2F;。不妨参考 Golang 中encoding&#x2F;base64包中的描述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StdEncoding is the standard base64 encoding, as defined in</span></span><br><span class="line"><span class="comment">// RFC 4648.</span></span><br><span class="line"><span class="keyword">var</span> StdEncoding = NewEncoding(*encodeStd*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// URLEncoding is the alternate base64 encoding defined in RFC 4648.</span></span><br><span class="line"><span class="comment">// It is typically used in URLs and file names.</span></span><br><span class="line"><span class="keyword">var</span> URLEncoding = NewEncoding(*encodeURL*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RawStdEncoding is the standard raw, unpadded base64 encoding,</span></span><br><span class="line"><span class="comment">// as defined in RFC 4648 section 3.2.</span></span><br><span class="line"><span class="comment">// This is the same as StdEncoding but omits padding characters.</span></span><br><span class="line"><span class="keyword">var</span> RawStdEncoding = StdEncoding.WithPadding(*NoPadding*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.</span></span><br><span class="line"><span class="comment">// It is typically used in URLs and file names.</span></span><br><span class="line"><span class="comment">// This is the same as URLEncoding but omits padding characters.</span></span><br><span class="line"><span class="keyword">var</span> RawURLEncoding = URLEncoding.WithPadding(*NoPadding*)</span><br></pre></td></tr></table></figure>

<p>与标准编码不同的是，<strong>原始编码中，字节数不足 3 的倍数时不会补齐字节数</strong>，采用如下方案：</p>
<ol>
<li>如果剩余 1 字节，则左移 4bit 后转换为 2 字符；</li>
<li>如果剩余 2 字节，则左移 2bit 后转化为 3 字符；</li>
</ol>
<p>即<strong>原始编码方案中，结果字符串长度可以不是 4 的倍数</strong>。</p>
<p>Hex 编码可以看成“Base16 编码”。随着字符数量的增加，存储效率也随之增加。如果有“Base256”编码，存储效率岂不就 100%了？很遗憾，主流字符编码中，单字节能表示的可打印字符只有 92 个。通过扩充多字节字符，或用组合字符实现 base256 意义不大。</p>
<h2 id="Golang-中的二进制编码"><a href="#Golang-中的二进制编码" class="headerlink" title="Golang 中的二进制编码"></a>Golang 中的二进制编码</h2><p>看一下 Golang 中 Base64 编码的实现。首先通过EncodedLen方法确定结果长度，生成输出buf，然后通过Encode方法将编码结果填充到buf并返回结果字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EncodeToString returns the base64 encoding of src.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodeToString(src []<span class="type">byte</span>) <span class="type">string</span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, enc.EncodedLen(<span class="built_in">len</span>(src)))</span><br><span class="line">    enc.Encode(buf, src)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前述，标准编码和原始编码（无 Padding）的结果长度不同：如果需要 Padding，直接根据字节数计算即可，反之则需要根据 bit 数计算。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EncodedLen returns the length in bytes of the base64 encoding</span></span><br><span class="line"><span class="comment">// of an input buffer of length n.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodedLen(n <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enc.padChar == *NoPadding* &#123;</span><br><span class="line">        <span class="keyword">return</span> (n*<span class="number">8</span> + <span class="number">5</span>) / <span class="number">6</span> <span class="comment">// minimum # chars at 6 bits per char</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">2</span>) / <span class="number">3</span> * <span class="number">4</span> <span class="comment">// minimum # 4-char quanta, 3 bytes each</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Encode方法实现了编码细节。首先遍历字节数组，将每 3 个字节编码为 4 个字符。最后处理剩余的 1 或 2 个字节（如有）：首先使用移位运算进行 0bit 填充，然后进行字符转换。如前述，无 Padding 时，剩下 1 字节对应 2 字符，剩下 2 字节对应 3 字符，即至少会有 2 字符。最后在switch代码段中，根据剩余字节数填充第 3 个字符和 Padding 字符（如有）即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> Encode(dst, src []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(src) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// enc is a pointer receiver, so the use of enc.encode within the hot</span></span><br><span class="line">    <span class="comment">// loop below means a nil check at every operation. Lift that nil check</span></span><br><span class="line">    <span class="comment">// outside of the loop to speed up the encoder.</span></span><br><span class="line">    _ = enc.encode</span><br><span class="line">    di, si := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    n := (<span class="built_in">len</span>(src) / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> si &lt; n &#123;</span><br><span class="line">        <span class="comment">// Convert 3x 8bit source bytes into 4 bytes</span></span><br><span class="line">        val := <span class="type">uint</span>(src[si+<span class="number">0</span>])&lt;&lt;<span class="number">16</span> | <span class="type">uint</span>(src[si+<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="type">uint</span>(src[si+<span class="number">2</span>])</span><br><span class="line">        dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">3</span>] = enc.encode[val&amp;<span class="number">0x3F</span>]</span><br><span class="line">        si += <span class="number">3</span></span><br><span class="line">        di += <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    remain := <span class="built_in">len</span>(src) - si</span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add the remaining small block</span></span><br><span class="line">    val := <span class="type">uint</span>(src[si+<span class="number">0</span>]) &lt;&lt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">2</span> &#123;</span><br><span class="line">        val |= <span class="type">uint</span>(src[si+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">    dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">    <span class="keyword">switch</span> remain &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        <span class="keyword">if</span> enc.padChar != *NoPadding* &#123;</span><br><span class="line">            dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> enc.padChar != *NoPadding* &#123;</span><br><span class="line">            dst[di+<span class="number">2</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">            dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>引言：拿到两个字节，如何解析为整形？</p>
<ul>
<li>Step1：明确字节高低位顺序</li>
<li>Step2：按高低位权重计算结果</li>
</ul>
<p>上述二进制编码主要用于文本传输，能不能不进行编码，直接传输二进制？当然可以，基于二进制传输协议，如 TCP 协议。那么什么是文本传输，什么是二进制传输？简单来说，文本传输，内容为文本，自带描述信息（参数名），如 HTTP 中的字段都以 KV 形式存在。二进制传输，内容为二进制，<strong>以预先定义好的格式拼在一起</strong>，如 TCP 协议报文格式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503068-102c03a4-c199-46de-89b9-c782f90e6276.webp" alt="img"></p>
<h3 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h3><p>聊到二进制传输，一个避不开的话题是<strong>字节序</strong>。什么是字节序？假设读取到一个两字节的 uint16 0x04 0x00，如果从左往右（从高位往低位）解码，得到的是 1024，反过来（从低位往高位）解码则是 4，这就是字节序。<strong>符合人类阅读习惯的（从高位往低位）是大端（BigEndian），反之为小端（LittleEndian）。</strong></p>
<p>另一种大小端的定义：LittleEndian 将低序字节存储在低地址，BigEndian 将高序字节存储在低地址。理解起来有些抽象，本质上是一致的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503204-018229fe-0d8f-4474-a462-71454212094c.webp" alt="img"></p>
<p>为什么会有小端字节序，统一都用大端不好么？</p>
<p>计算机不这么想，因为计算机中计算都是从低位开始的，电路先处理低位字节效率比较高。但是，人类还是习惯读写大端字节序。所以，<strong>除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</strong></p>
<p>那什么时候程序员需要进行字节序处理呢？当多字节整形（uint16，uint32，uint64）需要和字节数组互相转换时。<strong>字节数组是无字节序的，客户端写入啥，服务端就读取啥，不会出现逆序，写入和读取无需考虑字节序，这点大可放心</strong>。<strong>只有当多字节整形和字节数组互转时必须指明字节序。</strong></p>
<h2 id="Golang-中的字节序"><a href="#Golang-中的字节序" class="headerlink" title="Golang 中的字节序"></a>Golang 中的字节序</h2><p>以 uint16 与字节数组互转为例，看一下 Golang 中 encoding&#x2F;binary 包中的字节序处理与实现。可见实现并不复杂，注意字节顺序即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEndian</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    bytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.LittleEndian.PutUint16(bytes, <span class="number">1024</span>) <span class="comment">// 小端写 --&gt; 0x0004</span></span><br><span class="line">    binary.BigEndian.PutUint16(bytes, <span class="number">1024</span>) <span class="comment">// 大端写 --&gt; 0x0400</span></span><br><span class="line">    binary.LittleEndian.Uint16(bytes) <span class="comment">// 小端读 --&gt; 4</span></span><br><span class="line">    binary.BigEndian.Uint16(bytes) <span class="comment">// 大端读 --&gt; 1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(littleEndian)</span></span> PutUint16(b []<span class="type">byte</span>, v <span class="type">uint16</span>) &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// early bounds check to guarantee safety of writes below</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="type">byte</span>(v)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="type">byte</span>(v &gt;&gt; <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bigEndian)</span></span> PutUint16(b []<span class="type">byte</span>, v <span class="type">uint16</span>) &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// early bounds check to guarantee safety of writes below</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="type">byte</span>(v &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="type">byte</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(littleEndian)</span></span> Uint16(b []<span class="type">byte</span>) <span class="type">uint16</span> &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// bounds check hint to compiler; see golang.org/issue/14808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint16</span>(b[<span class="number">0</span>]) | <span class="type">uint16</span>(b[<span class="number">1</span>])&lt;&lt;<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bigEndian)</span></span> Uint16(b []<span class="type">byte</span>) <span class="type">uint16</span> &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// bounds check hint to compiler; see golang.org/issue/14808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint16</span>(b[<span class="number">1</span>]) | <span class="type">uint16</span>(b[<span class="number">0</span>])&lt;&lt;<span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战：加解密中的编码与字节序"><a href="#实战：加解密中的编码与字节序" class="headerlink" title="实战：加解密中的编码与字节序"></a>实战：加解密中的编码与字节序</h2><p>在加解密场景中，通常会对<strong>明文</strong>加密得到<strong>密文</strong>，对密文解密得到明文。比如对密码”123456”（明文）进行<strong>对称加密</strong>（如 SM4）得到”G7EeTPnuvSU41T68qsuc_g”（密文）。<strong>明文和密文都是由可打印字符构成的文本</strong>，通常明文人类可直接阅读其含义（不考虑二次加密），密文需要解密后才能理解含义。</p>
<p>那么上述明文变成密文，期间经历了哪些编码过程呢？以加密为例：</p>
<ol>
<li>将明文”123456”进行字符解码（如 UTF-8），得到<strong>明文字节序列</strong>0x31 32 33 34 35 36;</li>
<li>将明文字节序列输入 SM4 加密算法，输出<strong>密文字节序列</strong>0x1b b1 1e 4c f9 ee bd 25 38 d5 3e bc aa cb 9c fe；</li>
<li>将密文字节序列进行二进制编码（如 RawURLBase64），得到密文”G7EeTPnuvSU41T68qsuc_g”；</li>
</ol>
<p>同理，将”G7EeTPnuvSU41T68qsuc_g”解密成”123456”过程中，应与加密过程的编码方式对应：先进行 RawRULBase64 解码，再解密，最后再进行 UTF-8 编码。</p>
<p>加解密算法的输入输出都是字节序列，所以要将明文、密文与字节序列进行转换。有两点需要注意：</p>
<ol>
<li><strong>明文解码为明文字节序列，解码方式因场景而定</strong>。对于多次加密场景（如对“G7EeTPnuvSU41T68qsuc_g”再次加密），明文是 Base64 编码得到的，建议采用一致的方式解码。虽然也可以直接进行 UTF-8 解码，但会使加解密流程设计变得复杂。</li>
<li><strong>密文字节序列编码为密文，必须用二进制编码，不能用字符编码</strong>。使用字符编码会产生乱码（意味着数据丢失，无法逆向解码出原始数据）。上述密文序列密文序列进行 UTF-8 编码的结果是 �L���%8�&gt;��˜�。</li>
</ol>
<p>合规要求，加解密场景中应使用<strong>硬件加密机</strong>。通常硬件加密机提供<strong>基于 TCP 的字节流通信方式</strong>，比如约定每次通信数据中的前 2 字节为数据长度，后面的为真实数据。发送时，需要将真实数据长度转为 2 字节拼在前面，接收时，需要先读取前两字节得到真实数据长度 N，再读取 N 字节得到真实数据。其中<strong>长度与字节序列的转换需要关注字节序：发送方和接收方的字节序处理保持一致</strong>即可，比如全用大端。下面给出了数据发送的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *EncryptMachine)</span></span> sendData(conn net.Conn, data []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// add length</span></span><br><span class="line">    newData := m.addLength(data)</span><br><span class="line">    <span class="comment">// send new data</span></span><br><span class="line">    <span class="keyword">return</span> util.SocketWriteData(conn, newData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *EncryptMachine)</span></span> addLength(data []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">    lengthBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.BigEndian.PutUint16(lengthBytes, <span class="type">uint16</span>(<span class="built_in">len</span>(data)))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(lengthBytes, data...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>编码虽然基础，但却容易出错，切莫眼高手低。希望本文能帮助大家进一步了解字符编码、二进制编码与字节序，避免踩坑。</p>
<p><strong>未完，待续</strong></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言参考手册</title>
    <url>/2023/09/04/Go%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一个 Go 语言的参考手册，你也可以访问<a href="https://golang.org/">golang.org</a>获取更多信息和其他文档。</p>
<p>Go 是在设计时考虑了系统编程的通用型编程语言。它是强类型，有垃圾回收机制并原生支持并发编程。Go 程序由一个或多个 package 组成，这样可以高效的管理依赖。</p>
<p>Go 的语法简洁且有规则，这让自动化工具可以很容易的分析代码，例如：集成开发环境。</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>语法采用扩展巴科斯范式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Production  = production_name <span class="string">&quot;=&quot;</span> [ Expression ] <span class="string">&quot;.&quot;</span> .</span><br><span class="line">Expression  = Alternative &#123; <span class="string">&quot;|&quot;</span> Alternative &#125; .</span><br><span class="line">Alternative = Term &#123; Term &#125; .</span><br><span class="line">Term        = production_name | token [ <span class="string">&quot;…&quot;</span> token ] | Group | Option | Repetition .</span><br><span class="line">Group       = <span class="string">&quot;(&quot;</span> Expression <span class="string">&quot;)&quot;</span> .</span><br><span class="line">Option      = <span class="string">&quot;[&quot;</span> Expression <span class="string">&quot;]&quot;</span> .</span><br><span class="line">Repetition  = <span class="string">&quot;&#123;&quot;</span> Expression <span class="string">&quot;&#125;&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>产生式是由词法单元和以下操作符构成的表达式（优先级依次递增）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">|   或</span><br><span class="line">()  分组</span><br><span class="line">[]  可选 (出现 <span class="number">0</span> 或 <span class="number">1</span> 次)</span><br><span class="line">&#123;&#125;  可重复 (出现 <span class="number">0</span> 到 n 次)</span><br></pre></td></tr></table></figure>



<p>小写的产生式名称用来与词法单元区分。非终结符采用驼峰式。词法单元由双引号或反引号组成。</p>
<p><code>a...b</code> 表示从 <code>a</code> 到 <code>b</code> 之间的任意字符。省略号 <code>...</code> 也可以在规范中表示对更详细的枚举和代码片段的省略。字符 <code>...</code> 不是 Go 语言的词法单元。</p>
<h2 id="源码表示法"><a href="#源码表示法" class="headerlink" title="源码表示法"></a>源码表示法</h2><p>Go 的源代码使用 UTF-8 编码的 Unicode 文本。不过它并不是完全规范化的，单重音的代码点与由相同字符和音标组成的代码点是不同的；前者我们认为它是两个代码点。简单来讲，文档会在源代码文本中使用非规范的术语字符来表示一个 Unicode 代码点。</p>
<p>每个代码点都是不同的；相同字符的大写和小写形式表示不同的字符。</p>
<p>实现限制：为了兼容其他工具，编译器不允许出现 Utf-8 编码的源文本中的 NUL 字符（U+0000）。</p>
<p>实现限制：为了兼容其他工具，如果源文本中是以Utf-8 编码的字节序标记（U+FEFF）为起始代码点。编译器会忽略它。字节序标记不应出现在源文本的任何位置。</p>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>这些单词表示 Unicode 字符的类别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newline        = <span class="comment">/* Unicode 代码点 U+000A */</span> .</span><br><span class="line">unicode_char   = <span class="comment">/* 排除换行以外的任意 Unicode 代码点 */</span> .</span><br><span class="line">unicode_letter = <span class="comment">/* 一个字母（&quot;Letter&quot;）类型的 Unicode 代码点  */</span> .</span><br><span class="line">unicode_digit  = <span class="comment">/* 一个数字（&quot;Number, decimal digit&quot;）类型的 Unicode 代码点  */</span> .</span><br></pre></td></tr></table></figure>



<p>在 Unicode8.0 标准中，第 4.5 章节 “一般类别” 中定义了字符的类别。Go 能够处理任何字符集，包括 Lu，Li，Lt，Lm 或 Lo 作为 Unicode 字母，还可以把数字字符集 Nd 当作 Unicode 数字处理。</p>
<h4 id="字母和数字"><a href="#字母和数字" class="headerlink" title="字母和数字"></a>字母和数字</h4><p>我们认为下划线 <code>_</code> （U+005F）是一个字母：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">letter        = unicode_letter | <span class="string">&quot;_&quot;</span> .</span><br><span class="line">decimal_digit = <span class="string">&quot;0&quot;</span> … <span class="string">&quot;9&quot;</span> .</span><br><span class="line">octal_digit   = <span class="string">&quot;0&quot;</span> … <span class="string">&quot;7&quot;</span> .</span><br><span class="line">hex_digit     = <span class="string">&quot;0&quot;</span> … <span class="string">&quot;9&quot;</span> | <span class="string">&quot;A&quot;</span> … <span class="string">&quot;F&quot;</span> | <span class="string">&quot;a&quot;</span> … <span class="string">&quot;f&quot;</span> .</span><br></pre></td></tr></table></figure>



<h2 id="词汇元素"><a href="#词汇元素" class="headerlink" title="词汇元素"></a>词汇元素</h2><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释是程序的说明文档。在 Go 中有两种形式：</p>
<ul>
<li>单行注释从 <code>//</code> 开始直到行末结束。</li>
<li>通用注释从 <code>/*</code> 开始直到 <code>*/</code> 结束。</li>
</ul>
<p>注释不能嵌套在其他注释、字符串和 rune 的字面值中。不包含换行符的通用注释之间通过空格符连接，其他情况下每段注释都会另起一行。</p>
<h4 id="词汇元素-1"><a href="#词汇元素-1" class="headerlink" title="词汇元素"></a>词汇元素</h4><p>词汇元素构成了 Go 语言的词汇表。它有四种类型：标识符、关键字、操作符&#x2F;标点符号、字面值。空白符可以是空格（U+0020）、水平制表符（U+0009）、换行符（U+000D）或换行符（U+000A）。它本身会被忽略，一般用来区分不同的词汇元素。换行符或文件终止符（EOF）还可能触发编译程序在源代码的行末或文件末尾追加分号。在分解源代码的词汇元素的过程中，会把当前可以形成有效词汇元素的最长字符序列作为下一个词汇元素。</p>
<h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>正规语法在很多产生式中使用分号 “;” 作为终结符。Go 程序中遵循下面两条规则省略了大部分的分号：</p>
<ol>
<li>当某行的最后一个词汇元素是以下元素时自动补全分号：</li>
</ol>
<ul>
<li><p>一个标识符。</p>
</li>
<li><p>一个整数，浮点数，虚数，rune 或字符串字面值。</p>
</li>
<li><p>关键字 <code>break</code>、<code>continue</code>、<code>fallthrough</code> 和 <code>return</code> 其中之一。</p>
</li>
<li><p>操作符&#x2F;标点符号 <code>++</code>，<code>--</code>，<code>)</code>，<code>]</code> 和 <code>&#125;</code> 其中之一。</p>
</li>
</ul>
<ol>
<li>为了支持独占一行的复杂语句，会省略与 “)” 或 “}” 相邻的分号。</li>
</ol>
<p>为了反应惯用用途，本篇文档的所有例子都基于以上规则省略分号。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符表示程序实体单元，例如：变量、类型。一个标识符由一个或多个字母和数字组成。标识符的首字符必须为字母。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">identifier = letter &#123; letter | unicode_digit &#125; .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">_x9</span><br><span class="line">ThisVariableIsExported</span><br><span class="line">αβ</span><br></pre></td></tr></table></figure>



<p>Go 已经预定义了一些标识符。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>以下关键字是预留的，它们不能作为标识符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>



<h4 id="操作符和标点符号"><a href="#操作符和标点符号" class="headerlink" title="操作符和标点符号"></a>操作符和标点符号</h4><p>以下字符序列用于表示操作符（包括赋值运算符）和标点符号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )</span><br><span class="line">-    |     -=    |=     ||    &lt;     &lt;=    [    ]</span><br><span class="line">*    ^     *=    ^=     &lt;-    &gt;     &gt;=    &#123;    &#125;</span><br><span class="line">/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;</span><br><span class="line">%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :</span><br><span class="line">     &amp;^          &amp;^=</span><br></pre></td></tr></table></figure>



<h4 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h4><p>整型字面值是一个数字序列，相当于整型常量。可以使用前缀指定非小数进制：0 表示八进制，0x&#x2F;0X 表示十六进制。在十六进制字面值中，字母 a-f 和 A-F 都表示数字 10-15。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">int_lit     = decimal_lit | octal_lit | hex_lit .</span><br><span class="line">decimal_lit = ( <span class="string">&quot;1&quot;</span> … <span class="string">&quot;9&quot;</span> ) &#123; decimal_digit &#125; .</span><br><span class="line">octal_lit   = <span class="string">&quot;0&quot;</span> &#123; octal_digit &#125; .</span><br><span class="line">hex_lit     = <span class="string">&quot;0&quot;</span> ( <span class="string">&quot;x&quot;</span> | <span class="string">&quot;X&quot;</span> ) hex_digit &#123; hex_digit &#125; .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">0600</span></span><br><span class="line"><span class="number">0xBadFace</span></span><br><span class="line"><span class="number">170141183460469231731687303715884105727</span></span><br></pre></td></tr></table></figure>



<h4 id="浮点字面值"><a href="#浮点字面值" class="headerlink" title="浮点字面值"></a>浮点字面值</h4><p>浮点字面值是一个小数，相当于浮点数常量。它由整数部分，小数点，小数部分和指数部分构成。整数部分和小数部分用小数点链接；指数部分由  <code>e</code> &#x2F; <code>E</code> 字符后接一个有符号指数构成。整数部分和小数部分可以省略其一；小数点和指数部分可以省略其一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">float_lit = decimals <span class="string">&quot;.&quot;</span> [ decimals ] [ exponent ] |</span><br><span class="line">            decimals exponent |</span><br><span class="line">            <span class="string">&quot;.&quot;</span> decimals [ exponent ] .</span><br><span class="line">decimals  = decimal_digit &#123; decimal_digit &#125; .</span><br><span class="line">exponent  = ( <span class="string">&quot;e&quot;</span> | <span class="string">&quot;E&quot;</span> ) [ <span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span> ] decimals .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0.</span></span><br><span class="line"><span class="number">72.40</span></span><br><span class="line"><span class="number">072.40</span>  <span class="comment">// == 72.40</span></span><br><span class="line"><span class="number">2.71828</span></span><br><span class="line"><span class="number">1.e+0</span></span><br><span class="line"><span class="number">6.67428e-11</span></span><br><span class="line"><span class="number">1E6</span></span><br><span class="line"><span class="number">.25</span></span><br><span class="line"><span class="number">.12345E+5</span></span><br></pre></td></tr></table></figure>



<h4 id="虚数字面值"><a href="#虚数字面值" class="headerlink" title="虚数字面值"></a>虚数字面值</h4><p>虚数字面值是一个小数，相当于复数常量中的虚数部分。它由浮点数或者整数后接小写字母 i 构成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">imaginary_lit = (decimals | float_lit) <span class="string">&quot;i&quot;</span> .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0i</span></span><br><span class="line"><span class="number">011i</span>  <span class="comment">// == 11i</span></span><br><span class="line"><span class="number">0.i</span></span><br><span class="line"><span class="number">2.71828i</span></span><br><span class="line"><span class="number">1.e+0i</span></span><br><span class="line"><span class="number">6.67428e-11i</span></span><br><span class="line"><span class="number">1E6i</span></span><br><span class="line"><span class="number">.25i</span></span><br><span class="line"><span class="number">.12345E+5i</span></span><br></pre></td></tr></table></figure>



<h4 id="Rune-字面值"><a href="#Rune-字面值" class="headerlink" title="Rune 字面值"></a>Rune 字面值</h4><p>rune 类型字面值相当于一个 rune 常量。它是一个表示 Unicode 代码点的整数。rune 类型字面值表示为用单引号包裹的一个或多个字符，像 ‘x’ 或 ‘\n’。在单引号中除了换行符和未转义的单引号其他的字符都可以直接显示。单引号包裹的字符的值和字符在 Unicode 编码中的值相等，而以反斜线开头的多字符序列会把值翻译成多种格式。</p>
<p>使用引号表示单字符是最简单的方式；因为 Go 的源文本是 UTF-8 编码，一个整数可能代表多个 UTF-8 字节。例如， ‘a’ 可以使用单字节表示字符 a，Unicode 编码 U+0061，值 0x61，而 ‘ä’ 是两字节表示分音符的 a，Unicode 编码 U+00E4，值 0xe4。</p>
<p>反斜线能将任意值编码成 ASCII 文本。有四种方式将整数值表示为数字常量：<code>\x</code> 后接两个十六进制数；<code>\u</code> 后接四个十六进制数；<code>\U</code> 后接八个十六进制数。 <code>\</code> 后接三个八进制数。每种情况下都使用相应进制来表示字面量的整数值。</p>
<p>虽然这四种方式都以整数表示，但它们的有效区间并不相同。八进制只能表示 0 - 255 以内的整数。十六进制满可以满足需求。<code>\u</code> 和 <code>\U</code>  都可以表示 Unicode 代码点，不过其中的一些值是无效的，特别是 0x10FFFF 以上的值。</p>
<p>反斜线结合以下字符具有特殊含义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">\a   U+<span class="number">0007</span> alert or bell</span><br><span class="line">\b   U+<span class="number">0008</span> 退格符</span><br><span class="line">\f   U+<span class="number">000</span>C form feed</span><br><span class="line">\n   U+<span class="number">000</span>A line feed or newline</span><br><span class="line">\r   U+<span class="number">000</span>D carriage <span class="keyword">return</span></span><br><span class="line">\t   U+<span class="number">0009</span> 水平制表符</span><br><span class="line">\v   U+<span class="number">000</span>b 垂直制表符</span><br><span class="line">\\   U+<span class="number">005</span>c 反斜线</span><br><span class="line">\<span class="string">&#x27;   U+0027 单引号  (只在 rune 字面值中有效)</span></span><br><span class="line"><span class="string">\&quot;   U+0022 双引号  (只在字符串字面值中有效)</span></span><br></pre></td></tr></table></figure>



<p>其他所有以反斜线开头的序列在 rune 的规则中都是非法的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rune_lit         = <span class="string">&quot;&#x27;&quot;</span> ( unicode_value | byte_value ) <span class="string">&quot;&#x27;&quot;</span> .</span><br><span class="line">unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .</span><br><span class="line">byte_value       = octal_byte_value | hex_byte_value .</span><br><span class="line">octal_byte_value = <span class="string">`\`</span> octal_digit octal_digit octal_digit .</span><br><span class="line">hex_byte_value   = <span class="string">`\`</span> <span class="string">&quot;x&quot;</span> hex_digit hex_digit .</span><br><span class="line">little_u_value   = <span class="string">`\`</span> <span class="string">&quot;u&quot;</span> hex_digit hex_digit hex_digit hex_digit .</span><br><span class="line">big_u_value      = <span class="string">`\`</span> <span class="string">&quot;U&quot;</span> hex_digit hex_digit hex_digit hex_digit</span><br><span class="line">                           hex_digit hex_digit hex_digit hex_digit .</span><br><span class="line">escaped_char     = <span class="string">`\`</span> ( <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;f&quot;</span> | <span class="string">&quot;n&quot;</span> | <span class="string">&quot;r&quot;</span> | <span class="string">&quot;t&quot;</span> | <span class="string">&quot;v&quot;</span> | <span class="string">`\`</span> | <span class="string">&quot;&#x27;&quot;</span> | <span class="string">`&quot;`</span> ) .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="string">&#x27;ä&#x27;</span></span><br><span class="line"><span class="string">&#x27;本&#x27;</span></span><br><span class="line"><span class="string">&#x27;\t&#x27;</span></span><br><span class="line"><span class="string">&#x27;\000&#x27;</span></span><br><span class="line"><span class="string">&#x27;\007&#x27;</span></span><br><span class="line"><span class="string">&#x27;\377&#x27;</span></span><br><span class="line"><span class="string">&#x27;\x07&#x27;</span></span><br><span class="line"><span class="string">&#x27;\xff&#x27;</span></span><br><span class="line"><span class="string">&#x27;\u12e4&#x27;</span></span><br><span class="line"><span class="string">&#x27;\U00101234&#x27;</span></span><br><span class="line"><span class="string">&#x27;\&#x27;&#x27;</span>         <span class="comment">// 包含单引号的 rune 字面值</span></span><br><span class="line"><span class="string">&#x27;aa&#x27;</span>         <span class="comment">// 无效: 太多字符</span></span><br><span class="line"><span class="string">&#x27;\xa&#x27;</span>        <span class="comment">// 无效: 缺少十六进制数</span></span><br><span class="line"><span class="string">&#x27;\0&#x27;</span>         <span class="comment">// 无效: 缺少八进制数</span></span><br><span class="line"><span class="string">&#x27;\uDFFF&#x27;</span>     <span class="comment">// 无效: surrogate half</span></span><br><span class="line"><span class="string">&#x27;\U00110000&#x27;</span> <span class="comment">// 无效: 非法的 Unicode 代码点</span></span><br></pre></td></tr></table></figure>



<h4 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h4><p>字符串字面量表示从字符序列中获取的字符串常量。它有两种格式：原始字符串字面量和解释型字符串字面量。</p>
<p>原始字符串是由反引号包裹（<code>foo</code>）。字符串中除反引号以外的其他字符都会显示出来。原生字符串由反引号之间的（默认 UTF-8 编码）的字符组成。它的值为引号内未经解释（默认 UTF-8 编码）所有字符；尤其是，反斜线再字符串中没有特殊意义并且字符串中保留换行符。在原始字符串的值中会丢弃回车键返回 ‘\r’ 字符。</p>
<p>解释型字符串由双引号之间的字符组成（”bar”）。除了换行符和双引号其他字符都会显示出来。双引号之间的文本组成字面量的值。反斜线的转义规则与 rune 字面量基本相同（不同的是 \’ 非法，而 &quot; 合法）。三位八进制数（\nnn）和两位十六进制数（\xnn）换码符的值表示相应字符串的字节。其他的换码符都表示字符各自的 UTF-8 编码（可能是多字节）。因此字符串 \377 和 \xFF 都表示值为 0xFF&#x3D;255 的单个字节，而  <code>ÿ</code>, <code>\u00FF</code>, <code>\U000000FF</code> 和 <code>\xc3\xbf</code> 表示 UTF-8 编码字符 U+00FF 的两个字节 0xc3 0xbf。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">string_lit             = raw_string_lit | interpreted_string_lit .</span><br><span class="line">raw_string_lit         = <span class="string">&quot;`&quot;</span> &#123; unicode_char | newline &#125; <span class="string">&quot;`&quot;</span> .</span><br><span class="line">interpreted_string_lit = <span class="string">`&quot;`</span> &#123; unicode_value | byte_value &#125; <span class="string">`&quot;`</span> .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`abc`</span>                <span class="comment">// 等价于 &quot;abc&quot;</span></span><br><span class="line"><span class="string">`\n</span></span><br><span class="line"><span class="string">\n`</span>                  <span class="comment">// 等价于 &quot;\\n\n\\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\&quot;&quot;</span>                 <span class="comment">// 等价于 `&quot;`</span></span><br><span class="line"><span class="string">&quot;Hello, world!\n&quot;</span></span><br><span class="line"><span class="string">&quot;日本語&quot;</span></span><br><span class="line"><span class="string">&quot;\u65e5本\U00008a9e&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\u00FF&quot;</span></span><br><span class="line"><span class="string">&quot;\uD800&quot;</span>             <span class="comment">// 无效: surrogate half</span></span><br><span class="line"><span class="string">&quot;\U00110000&quot;</span>         <span class="comment">// 无效: 无效的 Unicode 代码点</span></span><br></pre></td></tr></table></figure>



<p>这些例子都表示相同的字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;日本語&quot;</span>                                 <span class="comment">// UTF-8 文本</span></span><br><span class="line"><span class="string">`日本語`</span>                                 <span class="comment">// UTF-8 文本作为原生字面值</span></span><br><span class="line"><span class="string">&quot;\u65e5\u672c\u8a9e&quot;</span>                    <span class="comment">// 确定的 Unicode 代码点 </span></span><br><span class="line"><span class="string">&quot;\U000065e5\U0000672c\U00008a9e&quot;</span>        <span class="comment">// 确定的 Unicode 代码点</span></span><br><span class="line"><span class="string">&quot;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&quot;</span>  <span class="comment">// 确定的 UTF-8 字节</span></span><br></pre></td></tr></table></figure>



<p>如果源代码中使用两个代码点表示一个字符，例如带音标的字母，把它放在 rune 中会报错（它不是单代码点）。并且在字符串中会显示两个代码点。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量分为：布尔型，rune型，整型，浮点型，复数型，字符串型。其中 rune，整型，浮点型，复数型统称为数字常量。</p>
<p>常量的值可以表示为一个 rune字面量，整数字面量，浮点数字面量，虚数字面量，字符串字面量，表示常量的标识符，常量表达式，一个转换结果为常量的类型转换，和一些返回值为常量的内置函数(接受任何值的<code>unsafe.Sizeof</code>，接受部分表达式的<code>cap</code> 或 <code>len</code>，接受虚数常量的<code>real</code> 和 <code>imag</code>，接受数字常量的 <code>complex</code>)。布尔类型的值为预定义常量 <code>true</code> 或 <code>false</code>，预定义的标识符 <code>iota</code> 表示一个整型常量。</p>
<p>一般情况下复数常量是常量表达式的一种形式。会在常量表达式章节详细讨论。</p>
<p>数字常量可以表示任意精度的确定值而且不会溢出。因此，没有常量可以表示非 0，无穷大和非数字值。</p>
<p>常量可以指定类型也可以不指定类型。字面值常量，<code>true</code>，<code>false</code>，<code>iota</code>，和只包含无类型常量操作的常量表达式是无类型的。</p>
<p>常量可以通过常量声明和转换时显式的指定具体类型，也可以隐式的在变量声明、赋值或作为表达式操作元时隐式的指定具体类型。如果常量的值和他的类型不匹配，会报错。</p>
<p>无类型常量由一个默认的类型，这个类型会根据使用常量时的上下文进行隐式转换。例如：短变量声明 <code>i := 0</code> 没有指定 i 的类型。无类型常量的默认类型可以是：<code>bool</code>，<code>rune</code>，<code>int</code>，<code>float64</code>，<code>complex128</code> 或者 <code>string</code>，具体选择哪种类型由常量的值决定。</p>
<p>实现限制：虽然数字常量在 Go 中是任意精度，不过编译器在实现时会在内部限制精度。这意味着每个编译器实现都要：</p>
<ul>
<li><p>至少保证整形常量有 256 位</p>
</li>
<li><p>浮点数常量（包括复数常量）都要保证至少 256 位的主体部分和至少 16 位的有符号指数部分</p>
</li>
<li><p>如果不能表示给定整数的精度抛出错误</p>
</li>
<li><p>如果浮点数或复数溢出抛出错误</p>
</li>
<li><p>如果由于精度限制不能表示浮点数或者复数进行舍入</p>
</li>
</ul>
<p>这些要求同时作用于字面量常量额和常量表达式的结果。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个用来储存值的位置。根据不同的变量类型，可以保存不同的值。</p>
<p>变量声明，函数参数和返回值，声明的函数签名，函数字面值都会为命名变量预留储存空间。调用内置的  <code>new</code>  函数或获取复合字面值的地址都会在运行时为变量分配存储空间。这种匿名变量是通过（可能是隐式的）指针间接引用的。</p>
<p>像数组，切片和结构体类型的变量，它们内部都包含很多元素或字段，而且这些元素和字段都可以直接被访问。数组和切片中的每个元素的行为和单独的变量基本相同。</p>
<p>变量的静态类型可以通过变量声明、提供给 <code>new</code> 的类型、复合字面值、结构体变量声明的元素类型以上几种方式确定。通过new或者类型初始化。接口类型的变量也有一个明确的动态类型，这个动态类型是在运行时赋值给变量的具体值类型（特例：预声明的 nil 是无类型的）。动态类型在程序的执行过程中可能并不相同，但是接口变量的值是可以分配给相同静态类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// x 的静态类型为 interface&#123;&#125; 值为 nil</span></span><br><span class="line"><span class="keyword">var</span> v *T           <span class="comment">// v 的静态类型为 *T 值为 nil</span></span><br><span class="line">x = <span class="number">42</span>             <span class="comment">// x 的动态类型为 int 值为 42</span></span><br><span class="line">x = v              <span class="comment">// x 动态类型为 *T 值为 (*T)(nil)</span></span><br></pre></td></tr></table></figure>



<p>在表达式中使用变量可以取出变量的值；这个值就是变量最近一次被赋予的值。如果没有对变量赋过值，那么他的值是该类型的零值。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>类型是一个集合，集合包括值和针对值的操作&amp;方法。一个类型可以使用类型名来表示。类型有多种表现形式：如果存在类型名，可以使用类型名表示，或者也可以使用根据已有类型组合成的类型字面值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type      = TypeName | TypeLit | <span class="string">&quot;(&quot;</span> Type <span class="string">&quot;)&quot;</span> .</span><br><span class="line">TypeName  = identifier | QualifiedIdent .</span><br><span class="line">TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |</span><br><span class="line">	    SliceType | MapType | ChannelType .</span><br></pre></td></tr></table></figure>



<p>Go 已经预先声明了某些类型的名称。并引入了类型声明。复合类型（数组、结构体、指针、函数、接口、切片、map、channel）可以使用他们的类型字面值。</p>
<p>每个类型T都有一个底层类型。如果T是预定义类型或者类型字面值。那么底层类型就是他自身。否则，T的底层类型就是它再类型声明时引用到的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	A1 = <span class="type">string</span></span><br><span class="line">	A2 = A1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	B1 <span class="type">string</span></span><br><span class="line">	B2 B1</span><br><span class="line">	B3 []B1</span><br><span class="line">	B4 B3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p><code>string</code>，<code>A1</code>，<code>A2</code>，<code>B1</code>，<code>B2</code> 的底层类型是 <code>string</code>。<code>[]B1</code>，<code>B3</code>，<code>B4</code> 的下游类型是[]B1。</p>
<h4 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h4><p>类型可能会有一个与之关联的方法集。接口类型的方法集就可以使用自身表示。对于其他类型，类型 T 的方法集由所有接收者类型为 T 的方法组成。而对应指针类型 *T 的方法集由所有接收者类型为 T 或 *T 的方法组成。如果是结构体类型且含有嵌入字段，那么方法集中可能还会包含更多的方法，具体请看结构体类型章节。其他类型的方法集都为空。方法集中的每个方法都有唯一且不为空的方法名。</p>
<p>类型的方法集用来确定类型实现的接口和以类型作为接收者能够调用的方法。</p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>布尔类型表示预定义常量 <code>true</code> 和 <code>false</code> 表示布尔真实值的集合。预定义的布尔类型为 <code>bool</code>；它是通过类型声明创建的。</p>
<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>一个数字类型相当于整型和浮点型的所有值的集合。预定义的数字类型包括：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8</span>       <span class="number">8</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">255</span>)</span><br><span class="line"><span class="type">uint16</span>      <span class="number">16</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">65535</span>)</span><br><span class="line"><span class="type">uint32</span>      <span class="number">32</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">4294967295</span>)</span><br><span class="line"><span class="type">uint64</span>      <span class="number">64</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">18446744073709551615</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int8</span>        <span class="number">8</span> 位有符号整数集合 (<span class="number">-128</span> to <span class="number">127</span>)</span><br><span class="line"><span class="type">int16</span>       <span class="number">16</span> 位有符号整数集合 (<span class="number">-32768</span> to <span class="number">32767</span>)</span><br><span class="line"><span class="type">int32</span>       <span class="number">32</span> 位有符号整数集合 (<span class="number">-2147483648</span> to <span class="number">2147483647</span>)</span><br><span class="line"><span class="type">int64</span>       <span class="number">64</span> 位有符号整数集合 (<span class="number">-9223372036854775808</span> to <span class="number">9223372036854775807</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">float32</span>     IEEE<span class="number">-754</span> <span class="number">32</span> 位浮点数集合</span><br><span class="line"><span class="type">float64</span>     IEEE<span class="number">-754</span> <span class="number">64</span> 位浮点数集合</span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span>   实部虚部都为 <span class="type">float32</span> 的复数集合</span><br><span class="line"><span class="type">complex128</span>  实部虚部都为 <span class="type">float64</span> 的复数集合</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>        <span class="type">uint8</span> 的别名</span><br><span class="line"><span class="type">rune</span>        <span class="type">int32</span> 的别名</span><br></pre></td></tr></table></figure>



<p>n 位整数的值具有 n 比特的宽度并用补码表示。</p>
<p>以下几种预定义类型由具体平台实现指定长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint</span>     <span class="number">32</span> 或 <span class="number">64</span> 位</span><br><span class="line"><span class="type">int</span>      和 <span class="type">uint</span> 位数相同</span><br><span class="line"><span class="type">uintptr</span>  能够容纳指针值的无符号整数</span><br></pre></td></tr></table></figure>



<p>为了避免移植性问题，除了被 uint8 的别名 byte 和 int32 的别名 rune，其他所有的数字类型都是通过类型声明定义。当在表达式中使用不同的数字类型需要进行类型转换。例如：int32 和 int 不是相同的类型，即使他们在指定的平台上是相等的。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串类型表示字符串的值类型。字符串的值是一个字节序列（有可能为空）。字符串一旦创建就无法修改它的值。预定义的字符串类型是 <code>string</code>，它是通过类型声明定义的。</p>
<p>可以使用内置函数 <code>len</code> 获取字符串长度。如果字符串是常量那么它的长度在编译时也为常量。可以通过数字下标 0～len(s)-1 访问字符串字节。获取字符串的地址是非法操作；如果 <code>s[i]</code> 是字符串的第 i 个字节，那么 <code>&amp;s[i]</code> 是无效的。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组是一定数量的单一类型元素序列，而这个单一类型叫做元素类型。元素的个数表示元素的长度，它永远不是负数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ArrayType   = <span class="string">&quot;[&quot;</span> ArrayLength <span class="string">&quot;]&quot;</span> ElementType .</span><br><span class="line">ArrayLength = Expression .</span><br><span class="line">ElementType = Type .</span><br></pre></td></tr></table></figure>



<p>长度是数组类型的一部分；它是一个类型为 int 的非负常量。可以用内置函数 <code>len</code> 获取数组的长度。元素可以通过下标 <code>0～len(a)-1</code> 访问。数组一般都是一维的，不过也可以是多维的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">[<span class="number">2</span>*N] <span class="keyword">struct</span> &#123; x, y <span class="type">int32</span> &#125;</span><br><span class="line">[<span class="number">1000</span>]*<span class="type">float64</span></span><br><span class="line">[<span class="number">3</span>][<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]<span class="type">float64</span>  <span class="comment">// same as [2]([2]([2]float64))</span></span><br></pre></td></tr></table></figure>



<h4 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h4><p>切片描述了底层数组的一个连续片段并提供对连续片段内元素的访问。切片类型表示元素类型的数组的所有切片的集合。没有被初始化的切片用 nil 表示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SliceType = <span class="string">&quot;[&quot;</span> <span class="string">&quot;]&quot;</span> ElementType .</span><br></pre></td></tr></table></figure>



<p>与数组一样，切片的可以使用索引访问并且有长度，切片的长度可以通过内置的 <code>len</code> 函数获取；与数组不同的是它的长度在运行时是可以变化的。我们可以通过下标 <code>0～len(s)-1</code> 来访问切片内的元素。切片的索引可能会小于相同元素再底层数组的索引。</p>
<p>切片一旦初始化，那么就有一个与之对应的底层数组保存切片中的元素。切片和底层的数组还有其他指向该数组的切片共享相同的储存空间；而不同的数组总是有着不同的存储空间。</p>
<p>切片的底层数组可能会延伸到切片末尾以外，切片的容积等于切片现在的长度加上数组中切片还没使用的长度；可以从原始切片中切出一个长度与容量相等的切片。切片的容量可以通过内置的 <code>cap(a)</code> 函数来获取。可以通过函数<code>make</code>来创建一个T类型的新切片。</p>
<p>使用内置函数 <code>make</code> 可以出实话给定元素类型 T 的切片。<code>make</code> 函数接收三个参数：切片类型、切片长度、切片容积，其中切片容积是可选参数。<code>make</code> 创建的切片会在底层分配一个切片所引用的新数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>



<p><code>make</code> 的作用就是创建新数组并切分它，所以下面两种写法是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">new</span>([<span class="number">100</span>]<span class="type">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br></pre></td></tr></table></figure>



<p>与数组相同，切片一般是一维的，不过也可以复合成多维。数组中的数组都必须是相同的长度，但是切片中的切片长度是动态变化的，不过切片中的切片需要单独初始化。</p>
<h4 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h4><p>结构体是一个命名元素序列，命名元素也叫做字段，每个字段都对应一个名称和类型，字段的名字可以是显式指定的（标识符列表）也可以是隐式的（嵌入字段）。在结构体中非空字段具有唯一性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StructType    = <span class="string">&quot;struct&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; FieldDecl <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .</span><br><span class="line">EmbeddedField = [ <span class="string">&quot;*&quot;</span> ] TypeName .</span><br><span class="line">Tag           = string_lit .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空结构体.</span></span><br><span class="line"><span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6个字段的结构体.</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="type">int</span></span><br><span class="line">	u <span class="type">float32</span></span><br><span class="line">	_ <span class="type">float32</span>  <span class="comment">// padding</span></span><br><span class="line">	A *[]<span class="type">int</span></span><br><span class="line">	F <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个指定了类型而没有指定名称的字段叫做嵌入字段，嵌入字段必须指定类型名 T 或指向非接口类型的指针类型 *T，其中 T 不能为指针类型。或者一个非接口类型的指针。并且T本身不能为指针类型。这种情况下会把类型名作为字段的名字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个包含 4 个嵌入字段 T1, *T2, P.T3 和 *P.T4 的结构体</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	T1        <span class="comment">// 字段名为 T1</span></span><br><span class="line">	*T2       <span class="comment">// 字段名为 T2</span></span><br><span class="line">	P.T3      <span class="comment">// 字段名为 T3</span></span><br><span class="line">	*P.T4     <span class="comment">// 字段名为 T4</span></span><br><span class="line">	x, y <span class="type">int</span>  <span class="comment">// 字段名为 x 和 y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以下声明是错误的因为字段名称必须唯一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	T     <span class="comment">// 嵌入字段 *T 与 *P.T 冲突</span></span><br><span class="line">	*T    <span class="comment">// 嵌入字段 T 与 *P.T 冲突</span></span><br><span class="line">	*P.T  <span class="comment">// 嵌入字段 T 与 *T 冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果 <code>x.f</code> 是表示该字段或方法 <code>f</code> 的合法选择器，则会调用结构 <code>x</code> 中嵌入字段的字段或方法 <code>f</code>。</p>
<p>从嵌入字段组合来的字段与结构体原来的字段行为基本相同，只是不能在结构体的复合字面值中直接使用。</p>
<p>给定一个结构体 S 和一个类型 T，依据以下规则生成组合后的方法集：</p>
<ul>
<li>如果 S 包含嵌入字段 T，则 S 和 *S 的方法集包括接收者为 T 的方法集，而 *S 包括 接收者为 *T 的方法集。</li>
<li>如果 S 包含字段 <em>T。那么S和</em>S均包含接收者为 T 和 *T 的所有方法集。</li>
</ul>
<p>声明字段时可以给该字段添加一个字符串的 tag。这个 tag 将会成为它所对应字段的一个属性。空 tag 和缺省 tag 是相同的。tag 的值可以通过反射的接口获取，可以作为类型结构体的类型定义的一部分，也可以忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="type">float64</span> <span class="string">&quot;&quot;</span>  <span class="comment">// 空 tag 和缺省 tag 相同</span></span><br><span class="line">	name <span class="type">string</span>  <span class="string">&quot;any string is permitted as a tag&quot;</span></span><br><span class="line">	_    [<span class="number">4</span>]<span class="type">byte</span> <span class="string">&quot;ceci n&#x27;est pas un champ de structure&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体对应一个 TimeStamp 的 protocol buffer.</span></span><br><span class="line"><span class="comment">// tag 字符串中定义了 protocol buffer 字段对应的数字;</span></span><br><span class="line"><span class="comment">// 一般使用 reflect 包读取他们.</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	microsec  <span class="type">uint64</span> <span class="string">`protobuf:&quot;1&quot;`</span></span><br><span class="line">	serverIP6 <span class="type">uint64</span> <span class="string">`protobuf:&quot;2&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>指针类型表示所有指向给定类型变量的指针集合。这个指定的类型叫做指针的基础类型。没有初始化的指针值为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PointerType = <span class="string">&quot;*&quot;</span> BaseType .</span><br><span class="line">BaseType    = Type .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*Point</span><br><span class="line">*[<span class="number">4</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>



<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>函数类型可以表示所有具有相同参数类型和返回值类型的函数。未初始化的函数类型值为 nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FunctionType   = <span class="string">&quot;func&quot;</span> Signature .</span><br><span class="line">Signature      = Parameters [ Result ] .</span><br><span class="line">Result         = Parameters | Type .</span><br><span class="line">Parameters     = <span class="string">&quot;(&quot;</span> [ ParameterList [ <span class="string">&quot;,&quot;</span> ] ] <span class="string">&quot;)&quot;</span> .</span><br><span class="line">ParameterList  = ParameterDecl &#123; <span class="string">&quot;,&quot;</span> ParameterDecl &#125; .</span><br><span class="line">ParameterDecl  = [ IdentifierList ] [ <span class="string">&quot;...&quot;</span> ] Type .</span><br></pre></td></tr></table></figure>



<p>在参数和返回值列表中，标识符列表必须同时存在或缺省。如果存在，那么每个名字都表示指定类型的一个参数&#x2F;返回值，这些标识符必须非空并且不能重复。如果缺省，指定类型的参数&#x2F;返回值使用对应的类型表示。参数列表和返回值列表一般都是需要加括号，不过在只有一个缺省返回值时，它可以不使用括号。</p>
<p>函数的最后一个参数可以添加前缀 <code>...</code>。包含这种参数的函数叫做变参函数，它可以接收零个或多个参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, _ <span class="type">int</span>, z <span class="type">float32</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>, z <span class="type">float32</span>)</span></span> (<span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(prefix <span class="type">string</span>, values ...<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>, z <span class="type">float64</span>, opt ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (success <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, *[]<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(p *T)</span></span></span><br></pre></td></tr></table></figure>



<h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><p>接口类型指定了一个方法集。一个接口类型变量可以保存任何方法集是该接口超集的类型。我们可以认为类型实现了接口。没有初始化的接口类型值为 nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">InterfaceType      = <span class="string">&quot;interface&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; MethodSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">MethodSpec         = MethodName Signature | InterfaceTypeName .</span><br><span class="line">MethodName         = identifier .</span><br><span class="line">InterfaceTypeName  = TypeName .</span><br></pre></td></tr></table></figure>



<p>在接口类型的方法集中，每个方法的名称必须是非空且唯一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple File interface</span></span><br><span class="line"><span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(b Buffer) <span class="type">bool</span></span><br><span class="line">	Write(b Buffer) <span class="type">bool</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口可以由多个类型实现，例如：类型 <code>S1</code> 和类型 <code>S2</code> 都有以下方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Read(b Buffer) <span class="type">bool</span> &#123; <span class="keyword">return</span> … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Write(b Buffer) <span class="type">bool</span> &#123; <span class="keyword">return</span> … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Close() &#123; … &#125;</span><br></pre></td></tr></table></figure>



<p>（这里的类型 T 可以表示 <code>S1</code> 也可以表示 <code>S2</code> ） <code>S1</code> 和 <code>S2</code> 都实现了接口 <code>File</code>，而不用管类型是否还有其他方法。</p>
<p>一个类型实现了任何方法集的为其子集的接口。因此它可能实现了多个不同接口。例如：所有的类型都实现了空接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>与之相似，思考下面这个定义为 <code>Locker</code> 的接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lock()</span><br><span class="line">	Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果 <code>S1</code> 和 <code>S2</code> 也实现了它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Lock() &#123; … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Unlock() &#123; … &#125;</span><br></pre></td></tr></table></figure>



<p>那它们就实现了两个接口 <code>Locker</code> 和 <code>File</code>。</p>
<p>一个接口 T 可以使用另一个接口 E 来指定方法。这种方式叫做将接口 E 嵌入进接口 T。它把 E 中所有的方法（包括导出和未导出的方法）全部添加进接口 T。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(b Buffer) <span class="type">bool</span></span><br><span class="line">	Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadWriter  <span class="comment">// 与添加 ReadWriter 接口中的方法是等价的</span></span><br><span class="line">	Locker      <span class="comment">// 与添加 Locker 接口中的方法是等价的 </span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LockedFile <span class="keyword">interface</span> &#123;</span><br><span class="line">	Locker</span><br><span class="line">	File        <span class="comment">// 无效: Lock, Unlock 不是唯一的</span></span><br><span class="line">	Lock()      <span class="comment">// 无效: Lock 不是唯一的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口 T 不能递归的嵌入进自己或已经嵌入过它的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无效: Bad 不能嵌入它自己</span></span><br><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bad</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效: Bad1 不能嵌入已经引用它的 Bad2</span></span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bad2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bad1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><p>map 类型是一种以唯一值作为键的无序集合。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MapType     = <span class="string">&quot;map&quot;</span> <span class="string">&quot;[&quot;</span> KeyType <span class="string">&quot;]&quot;</span> ElementType .</span><br><span class="line">KeyType     = Type .</span><br></pre></td></tr></table></figure>



<p>map的键类型必须能使用比较运算符 <code>==</code> 和 <code>!=</code> 进行比较。因此它的键类型不能是函数，map，或者切片。如果键是接口类型，那么比较运算符必须能比较他的动态值。如果不能会抛出一个运行时错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">map</span>[*T]<span class="keyword">struct</span>&#123; x, y <span class="type">float64</span> &#125;</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>map中元素的个数叫做它的长度。对于一个map <code>m</code>。它的长度可以通过内置函数 <code>len</code> 获得，而且它的长度可能再运行时发生变化。map 可以再运行时添加和取回元素，页可以使用内置函数 <code>delete</code>移除元素。</p>
<p>可以使用内置函数 <code>make</code> 初始化一个新的且为空的 map。它能指定 map 的类型和预留的空间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>



<p>map 的预留空间不会固定住 map 的长度；它可以通过添加一定数量的元素来增加自己的长度（nil map 不能添加元素）。nil map 和空 map 是相等的，只是 nil map 不能添加元素。</p>
<h4 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h4><p>channel提供一种手段在并发执行的函数间发送和接收指定类型的值。没有初始化的 channel 是nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ChannelType = ( <span class="string">&quot;chan&quot;</span> | <span class="string">&quot;chan&quot;</span> <span class="string">&quot;&lt;-&quot;</span> | <span class="string">&quot;&lt;-&quot;</span> <span class="string">&quot;chan&quot;</span> ) ElementType .</span><br></pre></td></tr></table></figure>



<p>操作符 <code>&lt;-</code> 可以指定 channel 的数据流动方向。如果没有指定方向，channel 默认是双向的。channel 可以通过转换和赋值来限制只读和只写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送 T 类型的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">float64</span>  <span class="comment">// 只能发送 float64 类型的值</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span>      <span class="comment">// 只能接收</span></span><br></pre></td></tr></table></figure>



<p><code>&lt;-</code> 与最左侧的 <code>chan</code> 关联：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">chan</span> <span class="type">int</span>    <span class="comment">// 等价于 chan&lt;- (chan int)</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- &lt;-<span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">// 等价于 chan&lt;- (&lt;-chan int)</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">// 等价于 &lt;-chan (&lt;-chan int)</span></span><br><span class="line"><span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>



<p>可以通过内置的 <code>make</code> 函数初始化 channel。<code>make</code> 函数可以指定channel的类型和容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>



<p>容量是设置了最大能缓存元素的数量。如果没有设置容量或值为 0，channel 就是没有缓存的，这时只有当发送者和接收者都准备好后才会传输数据。而带缓存的 channel 在缓存没有满的时候依然可以成功发送数据，当缓存不为空的时候可以成功接收到数据，值为 nil 的 channel 不能传输数据。</p>
<p>可以通过内置函数 <code>close</code> 关闭 channel。在接收端的第二个返回值可以用来提示接收者在关闭的 channel 是否还包含数据。</p>
<p>channel 可以在发送语句，接收操作中使用。可以不考虑同步性直接在多个 goroutine 中对 channel 调用内置函数 <code>len</code> 和 <code>cap</code> 。channel 的行为和 FIFO 队列相同。举个例子，一个 goruntine 发送数据，另一个 goruntine 接收他们，接收数据的顺序和发送数据的顺序是相同的。</p>
<h2 id="类型的属性和值"><a href="#类型的属性和值" class="headerlink" title="类型的属性和值"></a>类型的属性和值</h2><h4 id="类型标识"><a href="#类型标识" class="headerlink" title="类型标识"></a>类型标识</h4><p>两个类型可能相同也可能不同。</p>
<p>定义的类型都是不同类型。如果两个类型的底层类型在结构上是相同的，那它们也是相等的。总的来说：</p>
<ul>
<li><p>2 个数组的长度和元素类型相同，那么它们就是相同类型。</p>
</li>
<li><p>如果两个切片的元素类型相同那么它们就是相同类型。</p>
</li>
<li><p>如果两个结构体字段顺序相同，并且字段名称、字段类型和 tag 都相同那么它们就是相等的。非导出字段的字段名在不同的包中总是不同的。</p>
</li>
<li><p>如果两个指针的基础类型相同那么他们具有相同类型。</p>
</li>
<li><p>如果两个函数具有相同的参数和返回值列表，并且他们的类型相同那么他们就是相同的，参数的名称不一定要相同。</p>
</li>
<li><p>如果两个接口的方法集完全相同（方法的顺序）。</p>
</li>
<li><p>如果两个 map 类型的键类型和值类型相同那它们就是相等的。</p>
</li>
<li><p>如果两个 channel 类型包含的对象类型和 channel 的方向都是相同的那它们就是相同的。</p>
</li>
</ul>
<p>给出下列声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	A0 = []<span class="type">string</span></span><br><span class="line">	A1 = A0</span><br><span class="line">	A2 = <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125;</span><br><span class="line">	A3 = <span class="type">int</span></span><br><span class="line">	A4 = <span class="function"><span class="keyword">func</span><span class="params">(A3, <span class="type">float64</span>)</span></span> *A0</span><br><span class="line">	A5 = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, _ <span class="type">float64</span>)</span></span> *[]<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	B0 A0</span><br><span class="line">	B1 []<span class="type">string</span></span><br><span class="line">	B2 <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125;</span><br><span class="line">	B3 <span class="keyword">struct</span>&#123; a, c <span class="type">int</span> &#125;</span><br><span class="line">	B4 <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">float64</span>)</span></span> *B0</span><br><span class="line">	B5 <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">float64</span>)</span></span> *A1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>	C0 = B0</span><br></pre></td></tr></table></figure>



<p>这些类型是相等的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A0, A1, and []<span class="type">string</span></span><br><span class="line">A2 and <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125;</span><br><span class="line">A3 and <span class="type">int</span></span><br><span class="line">A4, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">float64</span>)</span></span> *[]<span class="type">string</span>, and A5</span><br><span class="line"></span><br><span class="line">B0, B0, and C0</span><br><span class="line">[]<span class="type">int</span> and []<span class="type">int</span></span><br><span class="line"><span class="keyword">struct</span>&#123; a, b *T5 &#125; and <span class="keyword">struct</span>&#123; a, b *T5 &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">float64</span>)</span></span> *[]<span class="type">string</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">float64</span>)</span></span> (result *[]<span class="type">string</span>), and A5</span><br></pre></td></tr></table></figure>



<p>B0 和 B1 不是一种类型因为它们是通过类型定义方式分别定义的；<code>func(int, float64) *B0</code> 和 <code>func(x int, y float64) *[]string</code> 是不同的，因为 B0 和 []string 不是相同类型。</p>
<h4 id="可分配性"><a href="#可分配性" class="headerlink" title="可分配性"></a>可分配性</h4><p>在以下情况下，可以将 x 分配给类型为 T 的变量（把 x 分配给 T）：</p>
<ul>
<li><p>x 的类型为 T</p>
</li>
<li><p>x 的类型 V 和 T 有相同的底层类型并且类型 T 或 V 至少一个定义的类型</p>
</li>
<li><p>T 是一个接口类型并且 x 实现了 T</p>
</li>
<li><p>x 是一个 channel，并且 T 是channel类型，类型V和类型T有相同的元素类型，并且 2 种类型至少有一种不是定义的类型</p>
</li>
<li><p>x 等于 nil 并且 T 是一个指针，函数，切片，map，channel 或接口类型</p>
</li>
<li><p>x 是一个可以表示 T 类型值的无类型常量</p>
</li>
</ul>
<h4 id="代表性"><a href="#代表性" class="headerlink" title="代表性"></a>代表性</h4><p>满足以下条件时可以用 T 类型的值表示常量 x：</p>
<ul>
<li><p>T 值的集合包括 x</p>
</li>
<li><p>T 是浮点型，而 x 在没有溢出的情况下能够近似成 T 类型。近似规则使用 <code>IEEE 754 round-to-even</code>，负零和无符号的零相同。需要注意的是，常量的值不会为负零，NaN，或无限值。</p>
</li>
<li><p>T 为复数类型，并且 x 的 <code>real(x)</code> 和 <code>imag(x)</code> 部分由复数类型对应的浮点类型（<code>float32</code> 或 <code>float64</code> ）组成。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x                   T           x 可以表示 T 的值，因为：</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>                 <span class="type">byte</span>        <span class="number">97</span> 在 <span class="type">byte</span> 类型值的集合中</span><br><span class="line"><span class="number">97</span>                  <span class="type">rune</span>        <span class="type">rune</span> 是 <span class="type">int32</span> 的别名，<span class="number">97</span> 在 <span class="number">32</span> 位整型值的集合中</span><br><span class="line"><span class="string">&quot;foo&quot;</span>               <span class="type">string</span>      <span class="string">&quot;foo&quot;</span> 在字符串值的集合中</span><br><span class="line"><span class="number">1024</span>                <span class="type">int16</span>       <span class="number">1024</span> 在 <span class="number">16</span> 位整型值的集合中</span><br><span class="line"><span class="number">42.0</span>                <span class="type">byte</span>        <span class="number">42</span> 在 <span class="number">8</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">1e10</span>                <span class="type">uint64</span>      <span class="number">10000000000</span> 在 <span class="number">64</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">2.718281828459045</span>   <span class="type">float32</span>     <span class="number">2.718281828459045</span> 的近似值 <span class="number">2.7182817</span> 在 <span class="type">float32</span> 类型值的集合中</span><br><span class="line"><span class="number">-1e-1000</span>            <span class="type">float64</span>     <span class="number">-1e-1000</span> 的近视值 IEEE <span class="number">-0.0</span>，等于 <span class="number">0</span> </span><br><span class="line"><span class="number">0i</span>                  <span class="type">int</span>         <span class="number">0</span> 是整型值</span><br><span class="line">(<span class="number">42</span> + <span class="number">0i</span>)           <span class="type">float32</span>     <span class="number">42.0</span> (<span class="number">0</span> 虚部) 在 <span class="type">float32</span> 类型值的集合中</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x                   T           x 不能表示 T 的值，因为：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>                   <span class="type">bool</span>        <span class="number">0</span> 不在布尔值的集合中</span><br><span class="line"><span class="string">&#x27;a&#x27;</span>                 <span class="type">string</span>      <span class="string">&#x27;a&#x27;</span> 是 <span class="type">rune</span> 类型, 它不在字符串类型的值集合中</span><br><span class="line"><span class="number">1024</span>                <span class="type">byte</span>        <span class="number">1024</span> 不在 <span class="number">8</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">-1</span>                  <span class="type">uint16</span>      <span class="number">-1</span> 不在 <span class="number">16</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">1.1</span>                 <span class="type">int</span>         <span class="number">1.1</span> 不是整型值</span><br><span class="line"><span class="number">42i</span>                 <span class="type">float32</span>     (<span class="number">0</span> + <span class="number">42i</span>) 不在 <span class="type">float32</span> 类型值的集合中</span><br><span class="line"><span class="number">1e1000</span>              <span class="type">float64</span>     <span class="number">1e1000</span> 取近似值时会溢出成 IEEE</span><br></pre></td></tr></table></figure>



<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块是用大括号括起来的声明和语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Block = <span class="string">&quot;&#123;&quot;</span> StatementList <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">StatementList = &#123; Statement <span class="string">&quot;;&quot;</span> &#125; .</span><br></pre></td></tr></table></figure>



<p>除了源码中显式的代码块，也有一些隐式的代码块。</p>
<ul>
<li><p>包含所有的Go代码的全局代码块。</p>
</li>
<li><p>包含所有包的代码的包代码块。</p>
</li>
<li><p>包含文件内的所有代码的文件代码块。</p>
</li>
<li><p>每个 if，switch和 for 的范围都会形成隐式的块。</p>
</li>
<li><p>每个 switch 和 select 条件都有自己的代码块。</p>
</li>
</ul>
<p>代码块可以嵌套并且影响作用域。</p>
<h2 id="声明和作用域"><a href="#声明和作用域" class="headerlink" title="声明和作用域"></a>声明和作用域</h2><p>一段声明可以给常量，类型，变量，函数，标签，和包绑定标识符。程序中每个标识符都需要声明。相同标识符不能在同一个代码块中声明2次。并且相同标识符不能同时在文件和 package 代码块中声明。</p>
<p>空标识符可以和其他标识符一样在声明中使用。不过它不绑定标识符，等于没有声明。在 package 代码块中 <code>init</code> 标识符只能用做 <code>init</code> 函数的标识符，就像空标识符一样，它不会引入新的绑定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Declaration   = ConstDecl | TypeDecl | VarDecl .</span><br><span class="line">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span><br></pre></td></tr></table></figure>



<p>声明过的标识符的作用域就是声明标识符所在的作用域。</p>
<p>go使用块来规定词汇的方位：</p>
<ul>
<li><p>预定义的标识符具有全局作用域。</p>
</li>
<li><p>所有定义的顶级标识符具有包作用域。</p>
</li>
<li><p>import进来的包的名字标识符具有文件作用域。</p>
</li>
<li><p>方法的接收者，函数参数，返回值变量具有函数作用域。</p>
</li>
<li><p>函数内定义的参量和变量标识符的作用域是标识符被声明到容纳他的块结束。</p>
</li>
</ul>
<p>一个代码块中声明的标识符可以在它内部的代码块中重新声明。在内部代码块的作用域中标识符表示在内部代码块中声明的实体。</p>
<p>pakcage 语句不属于声明。包名不会出现在任何的作用域中。它的作用只是用来标识属于相同包的多个文件并在导入时指定默认包名。</p>
<h4 id="标签的作用域"><a href="#标签的作用域" class="headerlink" title="标签的作用域"></a>标签的作用域</h4><p>可以使用标签语句来声明标签，并且可以在 <code>break</code>，<code>continue</code>，<code>goto</code> 语法中使用。如果只声明但没有使用标签时非法的。标签的作用域只有定义时的函数体，早递归函数体中没有作用。</p>
<h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>空标识符使用下划线 <code>_</code> 代表。与一般的非空标识符不同，它作为匿名标识符在声明，运算元和赋值语句中都有特殊含义。</p>
<h4 id="预定义的标识符"><a href="#预定义的标识符" class="headerlink" title="预定义的标识符"></a>预定义的标识符</h4><p>以下标识符已经在全局作用域中预先声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Types:</span><br><span class="line">	<span class="type">bool</span> <span class="type">byte</span> <span class="type">complex64</span> <span class="type">complex128</span> <span class="type">error</span> <span class="type">float32</span> <span class="type">float64</span></span><br><span class="line">	<span class="type">int</span> <span class="type">int8</span> <span class="type">int16</span> <span class="type">int32</span> <span class="type">int64</span> <span class="type">rune</span> <span class="type">string</span></span><br><span class="line">	<span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">Constants:</span><br><span class="line">	<span class="literal">true</span> <span class="literal">false</span> <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">Zero value:</span><br><span class="line">	<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Functions:</span><br><span class="line">	<span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">close</span> <span class="built_in">complex</span> <span class="built_in">copy</span> <span class="built_in">delete</span> <span class="built_in">imag</span> <span class="built_in">len</span></span><br><span class="line">	<span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">panic</span> <span class="built_in">print</span> <span class="built_in">println</span> <span class="built_in">real</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>



<h4 id="导出标识符"><a href="#导出标识符" class="headerlink" title="导出标识符"></a>导出标识符</h4><p>标识符可以导出供其他包使用。在以下两种情况同时满足时标识符是导出的：</p>
<ul>
<li>标识符的首字母是大写（Unicode 的 <code>Lu</code> 类）</li>
<li>标识符声明在包作用域或者它是字段名&#x2F;方法名。</li>
</ul>
<p>其他任何标识符都不是导出的。</p>
<h4 id="标识符的唯一性"><a href="#标识符的唯一性" class="headerlink" title="标识符的唯一性"></a>标识符的唯一性</h4><p>给定一个标识符集合，一个标识符与集合中的每个标识符都不相同，那就认为这个标识符是唯一的。假设有两个标识符，如果它们的拼写不同，或者它们在不同的包中并没有导出，那它们就是不同标识符。相反，其他情况下都认为标识符是相同的。</p>
<h4 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h4><p>常量声明使用常量表达式绑定一系列标识符。标识符的数量必须等于表达式的数量。左侧第 n 个标识符绑定右侧第 n 个表达式的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ConstDecl      = <span class="string">&quot;const&quot;</span> ( ConstSpec | <span class="string">&quot;(&quot;</span> &#123; ConstSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;)&quot;</span> ) .</span><br><span class="line">ConstSpec      = IdentifierList [ [ Type ] <span class="string">&quot;=&quot;</span> ExpressionList ] .</span><br><span class="line"></span><br><span class="line">IdentifierList = identifier &#123; <span class="string">&quot;,&quot;</span> identifier &#125; .</span><br><span class="line">ExpressionList = Expression &#123; <span class="string">&quot;,&quot;</span> Expression &#125; .</span><br></pre></td></tr></table></figure>



<p>如果给定类型，常量会指定类型，并且表达式的值必须能对这个类型进行赋值。</p>
<p>如果没有给定类型。常量会转换成相应的表达式类型。如果表达式的值是无类型常量，那么声明的常量也是无类型的，并且常量的标识符代表常量的值。例如：即使小数部分是 0，只要表达式是浮点数字面值，常量标识符也表示为浮点数常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span>         <span class="comment">// 无类型浮点数常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">	eof        = <span class="number">-1</span>  <span class="comment">// 无类型整型常量</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span>  <span class="comment">// a = 3, b = 4, c = &quot;foo&quot;, 无类型整型和字符串常量</span></span><br><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span>    <span class="comment">// u = 0.0, v = 3.0</span></span><br></pre></td></tr></table></figure>



<p>括号内的常量声明列表的表达式除了第一个必须声明其他表达式可以不写。空的表达式列表的值和类型都和前面的非空表达式相同。缺省的表达式列表等价于重复之前的表达式。标识符的数量必须等于表达式的数量。<code>iota</code>常量生成器是一个可以快速生成序列值的机制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Sunday = <span class="literal">iota</span></span><br><span class="line">	Monday</span><br><span class="line">	Tuesday</span><br><span class="line">	Wednesday</span><br><span class="line">	Thursday</span><br><span class="line">	Friday</span><br><span class="line">	Partyday</span><br><span class="line">	numberOfDays  <span class="comment">// 非导出常量</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="Iota"><a href="#Iota" class="headerlink" title="Iota"></a>Iota</h4><p>在常量声明中，预定义的标识符 <code>iota</code> 表示连续的无类型整型常量。它的值为常量声明中每个常量定义的位置（从零开始）。它能够用来生成一个关联常量集合：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></span><br><span class="line">	c0 = <span class="literal">iota</span>  <span class="comment">// c0 == 0</span></span><br><span class="line">	c1 = <span class="literal">iota</span>  <span class="comment">// c1 == 1</span></span><br><span class="line">	c2 = <span class="literal">iota</span>  <span class="comment">// c2 == 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></span><br><span class="line">	a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// a == 1</span></span><br><span class="line">	b = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// b == 2</span></span><br><span class="line">	c = <span class="number">3</span>          <span class="comment">// c == 3  (没有使用 iota 不过它的值依然递增)</span></span><br><span class="line">	d = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// d == 8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></span><br><span class="line">	u         = <span class="literal">iota</span> * <span class="number">42</span>  <span class="comment">// u == 0     (无类型整型常量)</span></span><br><span class="line">	v <span class="type">float64</span> = <span class="literal">iota</span> * <span class="number">42</span>  <span class="comment">// v == 42.0  (float64 类型常量)</span></span><br><span class="line">	w         = <span class="literal">iota</span> * <span class="number">42</span>  <span class="comment">// w == 84    (无类型整型常量)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="literal">iota</span>  <span class="comment">// x == 0  (iota 被重置)</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="literal">iota</span>  <span class="comment">// y == 0  (iota 被重置)</span></span><br></pre></td></tr></table></figure>



<p>根据定义，在同一个常量定义中多次使用 <code>iota</code> 会得到相同的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	bit0, mask0 = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>, <span class="number">1</span>&lt;&lt;<span class="literal">iota</span> - <span class="number">1</span>  <span class="comment">// bit0 == 1, mask0 == 0  (iota == 0)</span></span><br><span class="line">	bit1, mask1                           <span class="comment">// bit1 == 2, mask1 == 1  (iota == 1)</span></span><br><span class="line">	_, _                                  <span class="comment">//                        (iota == 2, unused)</span></span><br><span class="line">	bit3, mask3                           <span class="comment">// bit3 == 8, mask3 == 7  (iota == 3)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>最后一个例子利用了最后一个非空表达式列表的隐式重复。</p>
<h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><p>类型声明为类型绑定一个标识符。类型声明有2种方式：类型声明和别名声明。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TypeDecl = <span class="string">&quot;type&quot;</span> ( TypeSpec | <span class="string">&quot;(&quot;</span> &#123; TypeSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;)&quot;</span> ) .</span><br><span class="line">TypeSpec = AliasDecl | TypeDef .</span><br></pre></td></tr></table></figure>



<h5 id="Alias声明"><a href="#Alias声明" class="headerlink" title="Alias声明"></a>Alias声明</h5><p>别名声明给指定类型绑定一个标识符名称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">AliasDecl = identifier <span class="string">&quot;=&quot;</span> Type .</span><br></pre></td></tr></table></figure>



<p>在标识符作用域内，它作为类型的别名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	nodeList = []*Node  <span class="comment">// nodeList 和 []*Node 是相同类型</span></span><br><span class="line">	Polar    = polar    <span class="comment">// Polar 和 polar 表示相同类型</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="Type-定义"><a href="#Type-定义" class="headerlink" title="Type 定义"></a>Type 定义</h5><p>类型定义会创建一个新类型并绑定一个标识符，新类型与给定类型具有相同的底层类型和操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TypeDef = identifier Type .</span><br></pre></td></tr></table></figure>



<p>这个类型叫做定义类型，它和其他所有类型都不相同，包括创建它的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Point <span class="keyword">struct</span>&#123; x, y <span class="type">float64</span> &#125;  <span class="comment">// Point 和 struct&#123; x, y float64 &#125; 是不同类型</span></span><br><span class="line">	polar Point                   <span class="comment">// polar 和 Point 表示不同类型</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	left, right *TreeNode</span><br><span class="line">	value *Comparable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">	BlockSize() <span class="type">int</span></span><br><span class="line">	Encrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">	Decrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义类型可以关联该类型的方法。它不会继承原来类型的任何方法。但是接口类型的方法集和类型的结构没有改变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutex 是一个拥有 Lock 和 Unlock 两个方法的数据类型。</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span>         &#123; <span class="comment">/* Mutex fields */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock()    &#123; <span class="comment">/* Lock implementation */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()  &#123; <span class="comment">/* Unlock implementation */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMutex 与 Mutex 结构相同不过方法集为空。</span></span><br><span class="line"><span class="keyword">type</span> NewMutex Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrMutex 的底层类型 *Mutex 的方法集没有改变，</span></span><br><span class="line"><span class="comment">// 但是 PtrMutex 的方法集为空。</span></span><br><span class="line"><span class="keyword">type</span> PtrMutex *Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// *PrintableMutex 包含嵌入字段 Mutex 的 Lock 和 Unlock 方法。</span></span><br><span class="line"><span class="keyword">type</span> PrintableMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBlock 是与 Block 有相同方法集的接口类型</span></span><br><span class="line"><span class="keyword">type</span> MyBlock Block</span><br></pre></td></tr></table></figure>



<p>类型定义可以定义方法集不同的布尔值、数字和字符串类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TimeZone <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	EST TimeZone = -(<span class="number">5</span> + <span class="literal">iota</span>)</span><br><span class="line">	CST</span><br><span class="line">	MST</span><br><span class="line">	PST</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tz TimeZone)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;GMT%+dh&quot;</span>, tz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>变量声明可以创建一个或多个变量，并绑定对应的标识符、指定类型和初始值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">VarDecl     = <span class="string">&quot;var&quot;</span> ( VarSpec | <span class="string">&quot;(&quot;</span> &#123; VarSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;)&quot;</span> ) .</span><br><span class="line">VarSpec     = IdentifierList ( Type [ <span class="string">&quot;=&quot;</span> ExpressionList ] | <span class="string">&quot;=&quot;</span> ExpressionList ) .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> U, V, W <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">float32</span> = <span class="number">-1</span>, <span class="number">-2</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	i       <span class="type">int</span></span><br><span class="line">	u, v, s = <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="string">&quot;bar&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> re, im = complexSqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">var</span> _, found = entries[name]  <span class="comment">// map lookup; only interested in &quot;found&quot;</span></span><br></pre></td></tr></table></figure>



<p>如果给定一个表达式列表。变量会根据赋值规则使用表达式进行初始化。否则，每个变量都会初始化成变量类型的零值。</p>
<p>如果指定类型，变量会为指定类型。如果没有指定类型，变量会使用分配的初始值类型。如果初始值为无类型常量，它会转换成初始值的默认类型。如果是一个无类型布尔值，那么变量的类型就是 <code>bool</code>。值 <code>nil</code> 不能给没有指定类型的变量赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = math.Sin(<span class="number">0.5</span>)  <span class="comment">// d is float64</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">42</span>             <span class="comment">// i is int</span></span><br><span class="line"><span class="keyword">var</span> t, ok = x.(T)      <span class="comment">// t is T, ok is bool</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">nil</span>            <span class="comment">// illegal</span></span><br></pre></td></tr></table></figure>



<p>实现的限制：在函数体内声明的变量如果没有使用过编译器需要报错。</p>
<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>短变量声明的语法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ShortVarDecl = IdentifierList <span class="string">&quot;:=&quot;</span> ExpressionList .</span><br></pre></td></tr></table></figure>



<p>它比正常使用初始化表达式进行变量声明的方式要短，而且不指定类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;var&quot;</span> IdentifierList = ExpressionList .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, j := <span class="number">0</span>, <span class="number">10</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">7</span> &#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">r, w := os.Pipe(fd)  <span class="comment">// os.Pipe() 返回两个值</span></span><br><span class="line">_, y, _ := coord(p)  <span class="comment">// coord() 返回三个值，我们只关注 y</span></span><br></pre></td></tr></table></figure>



<p>和常规变量声明不同，即使之前在相同代码块中声明过的变量，也可以在短变量重新声明相同类型的变量，并且保证至少会有一个新的非空变量。总之，只应该在多变量短声明的时候重新声明变量，重新声明并不会使用新的变量，而是给变量分配新值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">field1, offset := nextField(str, <span class="number">0</span>)</span><br><span class="line">field2, offset := nextField(str, offset)  <span class="comment">// 重新声明 offset</span></span><br><span class="line">a, a := <span class="number">1</span>, <span class="number">2</span>                              <span class="comment">// 非法：声明了 a 两次并且没有新的变量</span></span><br></pre></td></tr></table></figure>



<p>短变量声明只能在函数中使用，例如在 <code>if</code>、<code>for</code>、<code>switch</code>语句的上下文中声明临时变量。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明为函数绑定标识符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FunctionDecl = <span class="string">&quot;func&quot;</span> FunctionName Signature [ FunctionBody ] .</span><br><span class="line">FunctionName = identifier .</span><br><span class="line">FunctionBody = Block .</span><br></pre></td></tr></table></figure>



<p>如果函数指定了返回参数。函数体的语句必须以终止语句结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="type">string</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">   	<span class="keyword">if</span> c == r &#123;</span><br><span class="line">   		<span class="keyword">return</span> i</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 无效：缺少 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数声明可以没有函数体。这样的声明提供一个函数声明，并由其他外部实现，例如汇编脚本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flushICache</span><span class="params">(begin, end <span class="type">uintptr</span>)</span></span>  <span class="comment">// 由外部实现</span></span><br></pre></td></tr></table></figure>



<h4 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h4><p>方法是一个带接收者的函数，方法声明为方法绑定标识符作为方法名并指定方法对应的接收者类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MethodDecl = <span class="string">&quot;func&quot;</span> Receiver MethodName Signature [ FunctionBody ] .</span><br><span class="line">Receiver   = Parameters .</span><br></pre></td></tr></table></figure>



<p>接收者通过在方法增加一个额外的参数来指定。这个参数必须是一个非可变参数。它的类型必须是 T 或者 T 的指针（可能包含括号）。T 被称作接收者的基础类型；它不能是指针或接口类型，并且只能在同一个包中定义方法。声明后，我们认为方法绑定了基础类型，并且可以通过 T 或 *T 选择器访问方法名。</p>
<p>非空的接收者标识符在方法签名中必须是唯一的。如果接收者的值没有在该方法中使用，那么接收者标识符可以省略。函数和方法的参数也是一样。</p>
<p>对于一个基础类型。绑定的非空的方法名必须是唯一的。如果基础类型是一个结构体，非空的方法名也不能与结构体字段重复。</p>
<p>给定一个<code>Point</code>类型。声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> Length() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(p.x * p.x + p.y * p.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> Scale(factor <span class="type">float64</span>) &#123;</span><br><span class="line">	p.x *= factor</span><br><span class="line">	p.y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为类型 <code>*Point</code>绑定了2个方法 <code>Length</code> 和 <code>Scale</code>。</p>
<p>方法的类型就是以接收者作为第一个参数的函数类型，例如 <code>Scale</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Point, factor <span class="type">float64</span>)</span></span></span><br></pre></td></tr></table></figure>



<p>但是以这种方式声明的函数并不是方法。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式通过针对运算元使用运算符和函数来获取计算值。</p>
<h4 id="运算元"><a href="#运算元" class="headerlink" title="运算元"></a>运算元</h4><p>运算元代表表达式中的一个简单的。运算元可以是字面值，非空标识符。或括号表达式。</p>
<p>空标识符只能出现在赋值声明的左侧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Operand     = Literal | OperandName | MethodExpr | <span class="string">&quot;(&quot;</span> Expression <span class="string">&quot;)&quot;</span> .</span><br><span class="line">Literal     = BasicLit | CompositeLit | FunctionLit .</span><br><span class="line">BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .</span><br><span class="line">OperandName = identifier | QualifiedIdent.</span><br></pre></td></tr></table></figure>



<h4 id="修饰标识符"><a href="#修饰标识符" class="headerlink" title="修饰标识符"></a>修饰标识符</h4><p>修饰标识符是以包名作为前缀修饰的标识符。包名和标识符都不能为空。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">QualifiedIdent = PackageName <span class="string">&quot;.&quot;</span> identifier .</span><br></pre></td></tr></table></figure>



<p>修饰标识符可以用来访问不同包（需要先导入）中的标识符。标识符必须是导出的并在包级代码块声明才能够被访问。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">math.Sin	<span class="comment">// 表示 math 包中的 Sin 函数</span></span><br></pre></td></tr></table></figure>



<h4 id="复合字面值"><a href="#复合字面值" class="headerlink" title="复合字面值"></a>复合字面值</h4><p>复合字面值能为结构体、数组、切片和 map 初始化值。它每次只能创建一个值。字面值由一个字面值类型和使用括号括起来的元素列表组成。元素前也可以声明元素对应的键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">CompositeLit  = LiteralType LiteralValue .</span><br><span class="line">LiteralType   = StructType | ArrayType | <span class="string">&quot;[&quot;</span> <span class="string">&quot;...&quot;</span> <span class="string">&quot;]&quot;</span> ElementType |</span><br><span class="line">                SliceType | MapType | TypeName .</span><br><span class="line">LiteralValue  = <span class="string">&quot;&#123;&quot;</span> [ ElementList [ <span class="string">&quot;,&quot;</span> ] ] <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">ElementList   = KeyedElement &#123; <span class="string">&quot;,&quot;</span> KeyedElement &#125; .</span><br><span class="line">KeyedElement  = [ Key <span class="string">&quot;:&quot;</span> ] Element .</span><br><span class="line">Key           = FieldName | Expression | LiteralValue .</span><br><span class="line">FieldName     = identifier .</span><br><span class="line">Element       = Expression | LiteralValue .</span><br></pre></td></tr></table></figure>



<p>字面值类型的底层类型必须是一个结构体，数组，切片或 map 类型（如果没有指定类型名就会强制执行这个约束）。元素的类型和键都必须能够分配给相应的字段的元素和键类型；没有额外的类型转换。键可以表示结构体的字段名，切片和数组的索引，map 类型的键。对于 map 字面值，所有的元素都必须有键。如果相同字段名或常量值的键对应多个元素就会报错。如果 map 类型的键为非常量类型，请看求值顺序章节。</p>
<p>结构体字面值遵循以下规则：</p>
<ul>
<li><p>在结构体中，键必须是它的字段名。</p>
</li>
<li><p>不包含任何键的元素列表的顺序需要与结构体字段的声明顺序相同。</p>
</li>
<li><p>如果一个元素指定了键，那么所有的元素都必须指定键。</p>
</li>
<li><p>包含键的元素列表不需要指定结构体的每个字字段，缺省字段会使用字段类型的零值。</p>
</li>
<li><p>字面值可以不指定元素；这样的字面值等于该类型的零值。</p>
</li>
<li><p>指定非本包的非导出字段会报错。</p>
</li>
</ul>
<p>给定声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point3D <span class="keyword">struct</span> &#123; x, y, z <span class="type">float64</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Line <span class="keyword">struct</span> &#123; p, q Point3D &#125;</span><br></pre></td></tr></table></figure>



<p>我们可以使用这种写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">origin := Point3D&#123;&#125;                            <span class="comment">// Point3D 的零值</span></span><br><span class="line">line := Line&#123;origin, Point3D&#123;y: <span class="number">-4</span>, z: <span class="number">12.3</span>&#125;&#125;  <span class="comment">// line.q.x 的零值</span></span><br></pre></td></tr></table></figure>



<p>数组和切片遵循以下规则：</p>
<ul>
<li><p>每个元素都关联一个数字索引标记元素再数组中的位置。</p>
</li>
<li><p>给元素指定的键会作为它的索引。键必须是能够表示非负的 <code>int</code> 类型值的常量；如果是指定类型的常量，那么常量必须是整型。</p>
</li>
<li><p>元素没有指定键时会使用之前的索引加一。如果第一个元素没有指定键，它的索引为零。</p>
</li>
</ul>
<p>对复合字面值取址会生成指向由字面量初始化的变量的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pointer *Point3D = &amp;Point3D&#123;y: <span class="number">1000</span>&#125;</span><br></pre></td></tr></table></figure>



<p>数组字面值需要在类型中指定数组的长度。如果提供的元素少于数组的长度，那么缺少元素的位置将会使用元素类型的零值替代。如果索引超过数组的长度会报错。<code>…</code> 表示数组的长度等于最大元素索引加一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">buffer := [<span class="number">10</span>]<span class="type">string</span>&#123;&#125;             <span class="comment">// len(buffer) == 10</span></span><br><span class="line">intSet := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;       <span class="comment">// len(intSet) == 6</span></span><br><span class="line">days := [...]<span class="type">string</span>&#123;<span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>&#125;  <span class="comment">// len(days) == 2</span></span><br></pre></td></tr></table></figure>



<p>切片字面值底层其实就是数组字面值。因此它的长度和容量都是元素的最大索引加一。切片字面值的格式为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]T&#123;x1, x2, … xn&#125;</span><br></pre></td></tr></table></figure>



<p>可以在数组上进行切片操作从而获得切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tmp := [n]T&#123;x1, x2, … xn&#125;</span><br><span class="line">tmp[<span class="number">0</span> : n]</span><br></pre></td></tr></table></figure>



<p>在一个数组、切片或 map 类型 T 中。元素或者 map 的键可能有自己的字面值类型，如果字面值类型和元素或者键类型相同，那么对应的类型标识符可以省略。与之类似，如果元素或键的类型为 <code>*T</code>，那么它们的 <code>&amp;T</code> 也可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[...]Point&#123;&#123;<span class="number">1.5</span>, <span class="number">-3.5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;     <span class="comment">// same as [...]Point&#123;Point&#123;1.5, -3.5&#125;, Point&#123;0, 0&#125;&#125;</span></span><br><span class="line">[][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;&#125;          <span class="comment">// same as [][]int&#123;[]int&#123;1, 2, 3&#125;, []int&#123;4, 5&#125;&#125;</span></span><br><span class="line">[][]Point&#123;&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;&#125;         <span class="comment">// same as [][]Point&#123;[]Point&#123;Point&#123;0, 1&#125;, Point&#123;1, 2&#125;&#125;&#125;</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]Point&#123;<span class="string">&quot;orig&quot;</span>: &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;    <span class="comment">// same as map[string]Point&#123;&quot;orig&quot;: Point&#123;0, 0&#125;&#125;</span></span><br><span class="line"><span class="keyword">map</span>[Point]<span class="type">string</span>&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;: <span class="string">&quot;orig&quot;</span>&#125;    <span class="comment">// same as map[Point]string&#123;Point&#123;0, 0&#125;: &quot;orig&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PPoint *Point</span><br><span class="line">[<span class="number">2</span>]*Point&#123;&#123;<span class="number">1.5</span>, <span class="number">-3.5</span>&#125;, &#123;&#125;&#125;          <span class="comment">// same as [2]*Point&#123;&amp;Point&#123;1.5, -3.5&#125;, &amp;Point&#123;&#125;&#125;</span></span><br><span class="line">[<span class="number">2</span>]PPoint&#123;&#123;<span class="number">1.5</span>, <span class="number">-3.5</span>&#125;, &#123;&#125;&#125;          <span class="comment">// same as [2]PPoint&#123;PPoint(&amp;Point&#123;1.5, -3.5&#125;), PPoint(&amp;Point&#123;&#125;)&#125;</span></span><br></pre></td></tr></table></figure>



<p>当复合字面值使用字面值类型的类型名格式出现在 <code>if</code>、<code>for</code> 或 <code>switch</code> 语句的关键字和括号之间并且没有使用圆括号包裹的时候，会引发语法歧义。在这种特殊的情况下字面值的括号会被认为是语句的代码块。为了避免歧义，复合字面值必须用括号括起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == (T&#123;a,b,c&#125;[i]) &#123; … &#125;</span><br><span class="line"><span class="keyword">if</span> (x == T&#123;a,b,c&#125;[i]) &#123; … &#125;</span><br></pre></td></tr></table></figure>



<p>下面是合法的数组、切片和 map 的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list of prime numbers</span></span><br><span class="line">primes := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2147483647</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vowels[ch] is true if ch is a vowel</span></span><br><span class="line">vowels := [<span class="number">128</span>]<span class="type">bool</span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;e&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;i&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;o&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;u&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;y&#x27;</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the array [10]float32&#123;-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1&#125;</span></span><br><span class="line">filter := [<span class="number">10</span>]<span class="type">float32</span>&#123;<span class="number">-1</span>, <span class="number">4</span>: <span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">9</span>: <span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frequencies in Hz for equal-tempered scale (A4 = 440Hz)</span></span><br><span class="line">noteFrequency := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;</span><br><span class="line">	<span class="string">&quot;C0&quot;</span>: <span class="number">16.35</span>, <span class="string">&quot;D0&quot;</span>: <span class="number">18.35</span>, <span class="string">&quot;E0&quot;</span>: <span class="number">20.60</span>, <span class="string">&quot;F0&quot;</span>: <span class="number">21.83</span>,</span><br><span class="line">	<span class="string">&quot;G0&quot;</span>: <span class="number">24.50</span>, <span class="string">&quot;A0&quot;</span>: <span class="number">27.50</span>, <span class="string">&quot;B0&quot;</span>: <span class="number">30.87</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数字面值"><a href="#函数字面值" class="headerlink" title="函数字面值"></a>函数字面值</h4><p>函数字面值表示一个匿名函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FunctionLit = <span class="string">&quot;func&quot;</span> Function .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>, z <span class="type">float64</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> a*b &lt; <span class="type">int</span>(z) &#125;</span><br></pre></td></tr></table></figure>



<p>函数字面值能分配给变量或直接调用。</p>
<p>函数字面值是一个闭包。它可以引用包裹函数中的变量，这些变量在包裹函数和函数字面值之间是共享的。并且它会一直存在直到生命周期结束。</p>
<h4 id="主要表达式"><a href="#主要表达式" class="headerlink" title="主要表达式"></a>主要表达式</h4><p>主要表达式是一元和二元表达式的运算元。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PrimaryExpr =</span><br><span class="line">	Operand |</span><br><span class="line">	Conversion |</span><br><span class="line">	PrimaryExpr Selector |</span><br><span class="line">	PrimaryExpr Index |</span><br><span class="line">	PrimaryExpr Slice |</span><br><span class="line">	PrimaryExpr TypeAssertion |</span><br><span class="line">	PrimaryExpr Arguments .</span><br><span class="line"></span><br><span class="line">Selector       = <span class="string">&quot;.&quot;</span> identifier .</span><br><span class="line">Index          = <span class="string">&quot;[&quot;</span> Expression <span class="string">&quot;]&quot;</span> .</span><br><span class="line">Slice          = <span class="string">&quot;[&quot;</span> [ Expression ] <span class="string">&quot;:&quot;</span> [ Expression ] <span class="string">&quot;]&quot;</span> |</span><br><span class="line">                 <span class="string">&quot;[&quot;</span> [ Expression ] <span class="string">&quot;:&quot;</span> Expression <span class="string">&quot;:&quot;</span> Expression <span class="string">&quot;]&quot;</span> .</span><br><span class="line">TypeAssertion  = <span class="string">&quot;.&quot;</span> <span class="string">&quot;(&quot;</span> Type <span class="string">&quot;)&quot;</span> .</span><br><span class="line">Arguments      = <span class="string">&quot;(&quot;</span> [ ( ExpressionList | Type [ <span class="string">&quot;,&quot;</span> ExpressionList ] ) [ <span class="string">&quot;...&quot;</span> ] [ <span class="string">&quot;,&quot;</span> ] ] <span class="string">&quot;)&quot;</span> .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">(s + <span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">f(<span class="number">3.1415</span>, <span class="literal">true</span>)</span><br><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">m[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s[i : j + <span class="number">1</span>]</span><br><span class="line">obj.color</span><br><span class="line">f.p[i].x()</span><br></pre></td></tr></table></figure>



<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>对于一个 x 不是包名的主要表达式，选择器表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.f</span><br></pre></td></tr></table></figure>



<p>表示 x 的字段或方法 f（有时为 *x）。标识符 f 叫做（字段&#x2F;方法）选择器。它不能是空标识符。选择器表达式的类型就是 f 的类型。如果 x 是包名。请参考修饰标识符。</p>
<p>选择器 f 可以表示类型 T 的方法或字段 f。也可以表示类型 T 的嵌入方法或字段 f。访问 f 所需穿过的嵌套层数叫做它在类型 T 中的深度。声明在 T 中的字段或方法的深度为 0。声明在 T 的嵌入字段 A 中的方法或字段的深度等于 f 在 A 中的深度加一。</p>
<p>选择器遵循以下原则：</p>
<ul>
<li><p>对于非指针&#x2F;接口类型 T&#x2F;*T 的值 x，x.f 表示第一层的方法&#x2F;字段。如果在第一层没有对应的 f，选择器表达式就是非法的。</p>
</li>
<li><p>对于接口类型 I 的值 x，<code>x.f</code>表示动态值 x 的方法名 f。如果接口 I 的方法集中没有 f 方法，选择器就是非法的。</p>
</li>
<li><p>作为例外，如果 x 是一个指针类型并且 (*x).f 是合法的选择器表达式（只能表示字段，不能表示方法）。那么(*x).f 可以简写成 x.f。</p>
</li>
<li><p>在其他情况下，x.f 都是非法的。</p>
</li>
<li><p>如果x是指针类型，并且值为 nil，其中 f 为结构体字段。赋值或取值 x.f 会引起运行时恐慌。</p>
</li>
<li><p>如果x是接口类型，并且值为 nil。调用 x.f  会引起运行时恐慌。</p>
</li>
</ul>
<p>例如给定声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T0)</span></span> M0()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T1)</span></span> M1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	z <span class="type">int</span></span><br><span class="line">	T1</span><br><span class="line">	*T0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T2)</span></span> M2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Q *T2</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T2     <span class="comment">// with t.T0 != nil</span></span><br><span class="line"><span class="keyword">var</span> p *T2    <span class="comment">// with p != nil and (*p).T0 != nil</span></span><br><span class="line"><span class="keyword">var</span> q Q = p</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.z          <span class="comment">// t.z</span></span><br><span class="line">t.y          <span class="comment">// t.T1.y</span></span><br><span class="line">t.x          <span class="comment">// (*t.T0).x</span></span><br><span class="line"></span><br><span class="line">p.z          <span class="comment">// (*p).z</span></span><br><span class="line">p.y          <span class="comment">// (*p).T1.y</span></span><br><span class="line">p.x          <span class="comment">// (*(*p).T0).x</span></span><br><span class="line"></span><br><span class="line">q.x          <span class="comment">// (*(*q).T0).x        (*q).x is a valid field selector</span></span><br><span class="line"></span><br><span class="line">p.M0()       <span class="comment">// ((*p).T0).M0()      M0 expects *T0 receiver</span></span><br><span class="line">p.M1()       <span class="comment">// ((*p).T1).M1()      M1 expects T1 receiver</span></span><br><span class="line">p.M2()       <span class="comment">// p.M2()              M2 expects *T2 receiver</span></span><br><span class="line">t.M2()       <span class="comment">// (&amp;t).M2()           M2 expects *T2 receiver, see section on Calls</span></span><br></pre></td></tr></table></figure>



<p>但是下面这种方式是不合法的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">q.M0()       <span class="comment">// (*q).M0 is valid but not a field selector</span></span><br></pre></td></tr></table></figure>



<h4 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h4><p>如果 M 在类型 T 的方法集中。那么 T.M 就是能够正常调用的函数。使用与 M 相同的参数只是在参数列表的最前面增加了接收者参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MethodExpr    = ReceiverType <span class="string">&quot;.&quot;</span> MethodName .</span><br><span class="line">ReceiverType  = TypeName | <span class="string">&quot;(&quot;</span> <span class="string">&quot;*&quot;</span> TypeName <span class="string">&quot;)&quot;</span> | <span class="string">&quot;(&quot;</span> ReceiverType <span class="string">&quot;)&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>假设结构体 T 有两个方法。接收者类型为 T 的 Mv 方法和接收者类型为 *T 的 Mp 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tv  T)</span></span> Mv(a <span class="type">int</span>) <span class="type">int</span>         &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;  <span class="comment">// value receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *T)</span></span> Mp(f <span class="type">float32</span>) <span class="type">float32</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;  <span class="comment">// pointer receiver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br></pre></td></tr></table></figure>



<p>表达式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">T.Mv</span><br></pre></td></tr></table></figure>



<p>将会生成一个等价于 Mv 方法只是第一个参数显式声明接受者的函数。它的签名为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tv T, a <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>这个函数能够通过接收者正常调用，以下5种方式是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Mv(<span class="number">7</span>)</span><br><span class="line">T.Mv(t, <span class="number">7</span>)</span><br><span class="line">(T).Mv(t, <span class="number">7</span>)</span><br><span class="line">f1 := T.Mv; f1(t, <span class="number">7</span>)</span><br><span class="line">f2 := (T).Mv; f2(t, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>



<p>与之类似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*T).Mp</span><br></pre></td></tr></table></figure>



<p>生成表示 Mp 的函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tp *T, f <span class="type">float32</span>)</span></span> <span class="type">float32</span></span><br></pre></td></tr></table></figure>



<p>对于一个把值作为接收者的方法，我们可以显式的从指针接收者获得函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*T).Mv</span><br></pre></td></tr></table></figure>



<p>生成表示 Mv 的函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tv *T, a <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>这样的函数会通过接收者间接的创建一个值作为接收者传入底层方法中。方法内不能修改接收者的值，因为它的地址是在函数的调用栈里面。</p>
<p>最后一个例子。把值作为接收者函数当做指针作为接收者的方法是非法的，因为指针接收者的方法集中不包含值类型的方法集。</p>
<p>通过函数调用语法从方法中获取函数的值。接收者作为调用函数的第一个参数。给定  <code>f :=T.Mv</code>，f 作为<code>f(t,7)</code> 进行调用而不是 <code>t.f(7)</code>。想创建一个绑定接收者的函数可以使用函数字面值或者方法值。</p>
<p>在接口类型中定义函数获取函数值是合法的。最终的函数调用会使用接口类型作为接收者。</p>
<h4 id="方法值"><a href="#方法值" class="headerlink" title="方法值"></a>方法值</h4><p>如果表达式 x 拥有静态类型 T 并且 M 在类型 T 的方法集中。x.M 叫做方法值。方法值 <code>x.M</code> 是一个函数值，这个函数和 x.M 拥有相同的参数列表。表达式 x 在计算方法值时会被保存和计算，这个拷贝的副本会作为任何接下来调用的接收者。</p>
<p>类型 T 可能是接口类型也可能不是接口类型。</p>
<p>与方法表达式中讲过的一样，假设类型 T 有两个方法：接收者类型为 T 的 Mv 和接受者类型为 *T 的 Mp ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tv  T)</span></span> Mv(a <span class="type">int</span>) <span class="type">int</span>         &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;  <span class="comment">// value receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *T)</span></span> Mp(f <span class="type">float32</span>) <span class="type">float32</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;  <span class="comment">// pointer receiver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line"><span class="keyword">var</span> pt *T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeT</span><span class="params">()</span></span> T</span><br></pre></td></tr></table></figure>



<p>表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Mv</span><br></pre></td></tr></table></figure>



<p>生成一个类型的函数值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>以下两种调用是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Mv(<span class="number">7</span>)</span><br><span class="line">f := t.Mv; f(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>



<p>相似的，表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pt.Mp</span><br></pre></td></tr></table></figure>



<p>生成一个类型的函数值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">float32</span>)</span></span> <span class="type">float32</span></span><br></pre></td></tr></table></figure>



<p>与选择器相同，使用指针调用以值作为接收者的非接口方法会自动将指针解引用：<code>pt.Mv</code> 等价于 <code>(*pt).Mv</code>。</p>
<p>与方法调用相同，使用值调用以指针作为接收者的非接口方法会自动对值取址：<code>pt.Mv</code> 等价于 <code>(&amp;pt).Mv</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := t.Mv; f(<span class="number">7</span>)   <span class="comment">// like t.Mv(7)</span></span><br><span class="line">f := pt.Mp; f(<span class="number">7</span>)  <span class="comment">// like pt.Mp(7)</span></span><br><span class="line">f := pt.Mv; f(<span class="number">7</span>)  <span class="comment">// like (*pt).Mv(7)</span></span><br><span class="line">f := t.Mp; f(<span class="number">7</span>)   <span class="comment">// like (&amp;t).Mp(7)</span></span><br><span class="line">f := makeT().Mp   <span class="comment">// invalid: result of makeT() is not addressable</span></span><br></pre></td></tr></table></figure>



<p>尽管上面使用的都是非接口类型的例子，不过对于接口类型同样适用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span> &#123; M(<span class="type">int</span>) &#125; = myVal</span><br><span class="line">f := i.M; f(<span class="number">7</span>)  <span class="comment">// like i.M(7)</span></span><br></pre></td></tr></table></figure>



<h4 id="index表达式"><a href="#index表达式" class="headerlink" title="index表达式"></a>index表达式</h4><p>主要表达式格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[x]</span><br></pre></td></tr></table></figure>



<p>可以表示数组元素、数组的指针、切片、字符串或 map 类型 a 索引 x 对应的值。x 称作索引或者 map 的键。遵循以下规则：</p>
<p>如果a不是 map 类型：</p>
<ul>
<li><p>索引 x 必须是整型或无类型常量。</p>
</li>
<li><p>常量索引必须是非负数且可以使用 int 类型表示。</p>
</li>
<li><p>无类型的常量索引会作为 int 型的值。</p>
</li>
<li><p>索引 x 的范围在 <code>0&lt;=x&lt;len(a)</code> 内，否则就是越界。</p>
</li>
</ul>
<p>对于数组类型 A：</p>
<ul>
<li><p>常量索引必须在合法范围内。</p>
</li>
<li><p>如果 x 在运行时越界会引起运行时恐慌。</p>
</li>
<li><p><code>a[x]</code> 表示数组在索引 x 处的元素。<code>a[x]</code> 的类型就是 A 的元素类型。</p>
</li>
</ul>
<p>对于数组的指针类型：</p>
<ul>
<li>可以使用 <code>a[x]</code> 表示 <code>(*a)[x]</code>。</li>
</ul>
<p>对于切片类型 S：</p>
<ul>
<li>如果 x 在运行时越界会引起运行时恐慌。</li>
<li><code>a[x]</code> 表示切片在索引 x 处的元素。<code>a[x]</code> 的类型就是 S 的元素类型。</li>
</ul>
<p>对于字符串类型：</p>
<ul>
<li><p>如果字符串 a 为常量，那么常量索引必须在合法范围内。</p>
</li>
<li><p>如果 x 在运行时越界会引起运行时恐慌。</p>
</li>
<li><p>a[x] 表示索引 x 处的非常量字节，它是byte类型。</p>
</li>
<li><p>不能对 a[x] 分配值。</p>
</li>
</ul>
<p>对于 map 类型 M：</p>
<ul>
<li><p>必须保证 x 的类型能够给 M 的键分配值。</p>
</li>
<li><p>如果map包含键为 x 的值，a[x] 就是 map 中键 x 对应的值，它的类型就是 M 的元素类型。</p>
</li>
<li><p>如果 map 值为 nil 或不包含这个实体，那么 a[x] 为 M 元素类型的零值。</p>
</li>
</ul>
<p>否则 a[x] 就是非法的。</p>
<p>基于 <code>map[K]V</code> 类型  a 的索引表达式可以使用特殊格式的赋值和初始化语法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok = a[x]</span><br><span class="line">v, ok := a[x]</span><br><span class="line"><span class="keyword">var</span> v, ok = a[x]</span><br></pre></td></tr></table></figure>



<p>它会额外生成一个无类型的布尔值。如果 ok 是 true，那么代表在map中有该键，如果没有 ok 为 false。</p>
<p>给一个值为 nil 的 map 类型变量赋值会导致运行时恐慌。</p>
<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式可以基于字符串、数组、数组指针、切片创建字符串子串或切片。它有两种变体，一种是简单的格式是指定开始和结束位置，完全格式的语法还可以指定容量。</p>
<p>####### 简单切片表达式</p>
<p>对于数组、字符串、指针数组、切片 a，主要表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[low:high]</span><br></pre></td></tr></table></figure>



<p>可以构造字符串子串或切片。索引 <code>low</code> 和 <code>high</code> 决定结果切片中的元素。结果切片的索引从 0 开始，长度为 <code>high - low</code>。从数组切分出的切片 s 拥有类型 <code>[]int</code>，长度为 3 ，容积为 4。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] == <span class="number">2</span></span><br><span class="line">s[<span class="number">1</span>] == <span class="number">3</span></span><br><span class="line">s[<span class="number">2</span>] == <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>为了方便起见，索引值都可以缺省。当 low 缺省时默认从 0 开始。当缺 high 缺省时默认的取切片的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// same as a[2 : len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// same as a[0 : 3]</span></span><br><span class="line">a[:]   <span class="comment">// same as a[0 : len(a)]</span></span><br></pre></td></tr></table></figure>



<p>如果 a 是一个数组指针，那么 <code>a[low:high]</code> 可以表示 <code>(*a)[low : high]</code>。</p>
<p>对于数组或者字符串，索引的范围是<code>0&lt;=low&lt;=high&lt;=len(a)</code>。对于切片，最大的索引值可以为切片的容量，而不是切片的长度。常量索引必须为非负数，且能够转换成 int 类型。对于数组或者常量字符串。常量索引值必须在合法范围内。如果2个索引都是常量。low 必须小于 high。如果索引在运行时访问了非法内存，程序会发生运行时恐慌。</p>
<p>除了无类型字符串，对于切片和字符串的操作结果是非常量类型的值，它的类型与运算元相同。如果运算元为无类型字符串，那么结果类型会为 string。如果把数组作为运算元，它必须是可寻址的，并且获得的切片和原数组具有同一元素类型。</p>
<p>如果切片运算元为 nil，那么结果也是 nil。否则结果切片会和运算元共享相同的底层无类型数组。</p>
<h6 id="完全切片表达式"><a href="#完全切片表达式" class="headerlink" title="完全切片表达式"></a>完全切片表达式</h6><p>对于数组，数组指针或非字符串切片，主要表达式为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure>



<p>它会构造一个同类型切片，并具有与简单切片表达式的 <code>a[low:high]</code> 相同的长度和元素。另外，它还可以把切片的容量设置为 <code>max - low</code>。这时只有第一个索引可以为缺省值，默认为零。从数组中获得切片以后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>



<p>切片 t 为 []int 类型，长度为 2，容量为 4，并且元素为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t[<span class="number">0</span>] == <span class="number">2</span></span><br><span class="line">t[<span class="number">1</span>] == <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>和简单切片表达式一样，如果 a 是数组指针 ，那么 <code>a[low:high:max]</code> 可以简写为 <code>(*a)[low:high:max]</code>。如果切分操作元是数组，那么这个数组必须是可以寻址的。</p>
<p>如果索引必须在 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code> 范围内。常量索引不能是负数并且能够使用 <code>int</code> 类型表示；对于数组，索引必须在合法范围内。如果有多个索引都是常量的，那么所有索引都需要在合法范围内。如果索引是非法的，会引起运行时恐慌。</p>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>对于接口类型 x 和类型 T，主要表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure>



<p>可以断言 x 不是 nil  且 x 的值是 T 类型。标记 x.(T) 叫做类型断言。</p>
<p>更确切的说，如果 T 不是接口类型，那么 x.(T) 将会断言动态类型 x 的类型是不是 T。</p>
<p>这时，T 必须实现了 x 的（接口）类型。否则断言会是非法的因为 x 不能保存 T 类型的值。如果 T 是接口类型，那么可以断言动态类型 x 是否实现了 T 接口。</p>
<p>如果类型断言成功，表达式的值为 x 的值，但它的类型是T。如果断言失败，将会导致运行时恐慌。换句话说，即使 x 是运行时确定的，x.(T) 也必须是编程时就确认存在的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">7</span>          <span class="comment">// x 拥有动态类型 int 值为 7</span></span><br><span class="line">i := x.(<span class="type">int</span>)                   <span class="comment">// i 为 int 类型值为 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123; m() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(y I)</span></span> &#123;</span><br><span class="line">   s := y.(<span class="type">string</span>)        <span class="comment">// 非法: 字符串没有实现接口 I （缺少 m 方法）</span></span><br><span class="line">   r := y.(io.Reader)     <span class="comment">// r 拥有接口 io.Reader 所以 y 的动态类型必须同时实现 I 和 io.Reader</span></span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类型断言可以使用特定格式的赋值和初始化语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok = x.(T)</span><br><span class="line">v, ok := x.(T)</span><br><span class="line"><span class="keyword">var</span> v, ok = x.(T)</span><br><span class="line"><span class="keyword">var</span> v, ok T1 = x.(T)</span><br></pre></td></tr></table></figure>



<p>这时将会额外生成一个无类型的布尔值。如果断言成功，ok返回 <code>true</code>，否则是 <code>false</code>。并且 v 会是 T 类型的零值。这时不会有恐慌发生。</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>给定函数类型为 F 的表达式 f：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f(a1, a2, … an)</span><br></pre></td></tr></table></figure>



<p>可以使用 a1,a2…an 来调用函数 f。除一种特殊情况之外，函数参数必须是对应 F 函数参数类型的单值表达式，且在函数调用前就已经完成求值。表达式的结果类型是 f 的结果类型。函数调用和方法调用相似，只是方法额外需要一个接收者类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">math.Atan2(x, y)  <span class="comment">// function call</span></span><br><span class="line"><span class="keyword">var</span> pt *Point</span><br><span class="line">pt.Scale(<span class="number">3.5</span>)     <span class="comment">// method call with receiver pt</span></span><br></pre></td></tr></table></figure>



<p>在函数调用中，函数的值和参数是按照顺序求值的。在计算之后作为参数会传进函数，函数开始执行。当函数执行完成后返回的参数将会返回给函数的调用者。</p>
<p>调用值为 nil 的函数会导致运行时恐慌。</p>
<p>作为特例，如果函数或者方法的返回值等于参数列表的个数，那么会嵌套调用。这将把返回值直接赋值给下一次调用函数的参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s <span class="type">string</span>, pos <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> s[<span class="number">0</span>:pos], s[pos:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s + t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Join(Split(value, <span class="built_in">len</span>(value)/<span class="number">2</span>)) != value &#123;</span><br><span class="line">	log.Panic(<span class="string">&quot;test fails&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果 x 的方法集中包含 m 那么 <code>x.m()</code> 是合法的。并且参数列表和 m 的参数列表相同。如果x是可寻址的，那么那么x指针的方法集<code>(&amp;x).m()</code>可以简写成<code>x.m()</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p Point</span><br><span class="line">p.Scale(<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>



<p>没有方法类型，也没有方法字面值。</p>
<h4 id="通过-来传递参数"><a href="#通过-来传递参数" class="headerlink" title="通过 ... 来传递参数"></a>通过 <code>...</code> 来传递参数</h4><p>如果 f 的最后一个参数 p 的类型是 <code>...T</code>。那么在函数内部 p 参数的类型就是 <code>[]T</code>。如果 f 调用时没有传入 p 对应的参数，那么p为 nil。否则这些参数会以切片方式传入，在新的底层切片中。切片中的类型都是能赋值给类型 T 的值。这个切片的长度和容量在不同的调用中有所不同。</p>
<p>给定函数调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greeting</span><span class="params">(prefix <span class="type">string</span>, who ...<span class="type">string</span>)</span></span></span><br><span class="line">Greeting(<span class="string">&quot;nobody&quot;</span>)</span><br><span class="line">Greeting(<span class="string">&quot;hello:&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Eileen&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>在 <code>Greeting</code> 中，第一次调用时，<code>who</code>是 nil 类型。而在第二次调用时是<code>[]string&#123;&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;&#125;</code>。</p>
<p>如果在调用的时候的最后一个参数是[]T，那么我们可以使用<code>...</code>来将切片中的值依次赋值给参数列表。</p>
<p>给定切片s并且调用:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Jasmine&quot;</span>&#125;</span><br><span class="line">Greeting(<span class="string">&quot;goodbye:&quot;</span>, s...)</span><br></pre></td></tr></table></figure>



<p>z 在 <code>Greeting</code>。中 <code>who</code> 会和切片 s 共享相同的底层数组。</p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>操作符用来连接运算元。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Expression = UnaryExpr | Expression binary_op Expression .</span><br><span class="line">UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .</span><br><span class="line"></span><br><span class="line">binary_op  = <span class="string">&quot;||&quot;</span> | <span class="string">&quot;&amp;&amp;&quot;</span> | rel_op | add_op | mul_op .</span><br><span class="line">rel_op     = <span class="string">&quot;==&quot;</span> | <span class="string">&quot;!=&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> .</span><br><span class="line">add_op     = <span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span> | <span class="string">&quot;|&quot;</span> | <span class="string">&quot;^&quot;</span> .</span><br><span class="line">mul_op     = <span class="string">&quot;*&quot;</span> | <span class="string">&quot;/&quot;</span> | <span class="string">&quot;%&quot;</span> | <span class="string">&quot;&lt;&lt;&quot;</span> | <span class="string">&quot;&gt;&gt;&quot;</span> | <span class="string">&quot;&amp;&quot;</span> | <span class="string">&quot;&amp;^&quot;</span> .</span><br><span class="line"></span><br><span class="line">unary_op   = <span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span> | <span class="string">&quot;!&quot;</span> | <span class="string">&quot;^&quot;</span> | <span class="string">&quot;*&quot;</span> | <span class="string">&quot;&amp;&quot;</span> | <span class="string">&quot;&lt;-&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>比较运算符在此处讨论。对于其他二元操作符，两个操作元的类型必须是相同的，除了位移和无类型常量。针对常量的操作，请看常量表达式章节。</p>
<p>除了位移操作，如果其中一个操作符是无类型常量，而另个不是，那么无类型的常量会转换成另一个运算元的类型。</p>
<p>在右移表达式中的运算元必须是无符号的整数或者可以转换成 uint 的无类型的常量。如果左移一个无类型常量那么结果依然是无类型的。他首先会转换成指定类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">uint</span> = <span class="number">33</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>&lt;&lt;s           <span class="comment">// 1 has type int</span></span><br><span class="line"><span class="keyword">var</span> j <span class="type">int32</span> = <span class="number">1</span>&lt;&lt;s     <span class="comment">// 1 has type int32; j == 0</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="type">uint64</span>(<span class="number">1</span>&lt;&lt;s)   <span class="comment">// 1 has type uint64; k == 1&lt;&lt;33</span></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span> = <span class="number">1.0</span>&lt;&lt;s     <span class="comment">// 1.0 has type int; m == 0 if ints are 32bits in size</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1.0</span>&lt;&lt;s == j    <span class="comment">// 1.0 has type int32; n == true</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="number">1</span>&lt;&lt;s == <span class="number">2</span>&lt;&lt;s   <span class="comment">// 1 and 2 have type int; o == true if ints are 32bits in size</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="number">1</span>&lt;&lt;s == <span class="number">1</span>&lt;&lt;<span class="number">33</span>  <span class="comment">// illegal if ints are 32bits in size: 1 has type int, but 1&lt;&lt;33 overflows int</span></span><br><span class="line"><span class="keyword">var</span> u = <span class="number">1.0</span>&lt;&lt;s         <span class="comment">// illegal: 1.0 has type float64, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> u1 = <span class="number">1.0</span>&lt;&lt;s != <span class="number">0</span>   <span class="comment">// illegal: 1.0 has type float64, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> u2 = <span class="number">1</span>&lt;&lt;s != <span class="number">1.0</span>   <span class="comment">// illegal: 1 has type float64, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> v <span class="type">float32</span> = <span class="number">1</span>&lt;&lt;s   <span class="comment">// illegal: 1 has type float32, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> w <span class="type">int64</span> = <span class="number">1.0</span>&lt;&lt;<span class="number">33</span>  <span class="comment">// 1.0&lt;&lt;33 is a constant shift expression</span></span><br></pre></td></tr></table></figure>



<h6 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h6><p>一元运算符拥有最高优先级。++ 和 – 是语句而不是表达式，他们在运算符的优先级之外。所以 (*p)++ 和 *p++ 是一样的。</p>
<p>二元运算符有 5 个优先级。乘法运算符在最高级，紧接着是加法运算符。比较运算符，&amp;&amp; 运算符，最后是 ||。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>



<p>相同优先级的二元运算符的执行顺序是由左到右。例如 <code>x/y*z</code>和<code>(x/y)*z</code> 是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+x</span><br><span class="line"><span class="number">23</span> + <span class="number">3</span>*x[i]</span><br><span class="line">x &lt;= f()</span><br><span class="line">^a &gt;&gt; b</span><br><span class="line">f() || g()</span><br><span class="line">x == y+<span class="number">1</span> &amp;&amp; &lt;-chanPtr &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算数运算符应用在 2 个数字值之间，别切生成一个相同类型的值作为第一个运算元。四种算数运算符(+,-,*,&#x2F;)应用在数字，浮点，复合类型之中。+ 也可以用于字符串。位运算和位移运算只适用于整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+    sum                    integers, floats, <span class="built_in">complex</span> values, strings</span><br><span class="line">-    difference             integers, floats, <span class="built_in">complex</span> values</span><br><span class="line">*    product                integers, floats, <span class="built_in">complex</span> values</span><br><span class="line">/    quotient               integers, floats, <span class="built_in">complex</span> values</span><br><span class="line">%    remainder              integers</span><br><span class="line"></span><br><span class="line">&amp;    bitwise AND            integers</span><br><span class="line">|    bitwise OR             integers</span><br><span class="line">^    bitwise XOR            integers</span><br><span class="line">&amp;^   bit clear (AND NOT)    integers</span><br><span class="line"></span><br><span class="line">&lt;&lt;   left shift             integer &lt;&lt; unsigned integer</span><br><span class="line">&gt;&gt;   right shift            integer &gt;&gt; unsigned integer</span><br></pre></td></tr></table></figure>



<h6 id="数字运算符"><a href="#数字运算符" class="headerlink" title="数字运算符"></a>数字运算符</h6><p>对于两个整数 x 和 y。整数商 <code>q=x/y</code> 和余数 <code>r=x%y</code> 遵循以下规律。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = q*y + r  and  |r| &lt; |y|</span><br></pre></td></tr></table></figure>



<p><code>x/y</code> 截断为 0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x     y     x / y     x % y</span><br><span class="line"> <span class="number">5</span>     <span class="number">3</span>       <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">-5</span>     <span class="number">3</span>      <span class="number">-1</span>        <span class="number">-2</span></span><br><span class="line"> <span class="number">5</span>    <span class="number">-3</span>      <span class="number">-1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">-5</span>    <span class="number">-3</span>       <span class="number">1</span>        <span class="number">-2</span></span><br></pre></td></tr></table></figure>



<p>作为这个规则的例外情况，如果 x 非常大，那么 <code>q=x/-1</code> 等于 x。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, q</span><br><span class="line"><span class="type">int8</span>                     <span class="number">-128</span></span><br><span class="line"><span class="type">int16</span>                  <span class="number">-32768</span></span><br><span class="line"><span class="type">int32</span>             <span class="number">-2147483648</span></span><br><span class="line"><span class="type">int64</span>    <span class="number">-9223372036854775808</span></span><br></pre></td></tr></table></figure>



<p>如果除数是一个常量。那么它不能是 0，如果除数在运行时为 0，会导致运行时恐慌。如果除数是负数并且除数是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x     x / <span class="number">4</span>     x % <span class="number">4</span>     x &gt;&gt; <span class="number">2</span>     x &amp; <span class="number">3</span></span><br><span class="line"> <span class="number">11</span>      <span class="number">2</span>         <span class="number">3</span>         <span class="number">2</span>          <span class="number">3</span></span><br><span class="line"><span class="number">-11</span>     <span class="number">-2</span>        <span class="number">-3</span>        <span class="number">-3</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>位移运算符移动左侧运算元右侧元算元指定的位数。如果左侧是有符号整型，那它就实现了位移运算，如果是无符号整数使用逻辑位移。位移运算没有上限，位移操作让左边运算元位移 n 个 1。<code>x&lt;&lt;1</code> 和 <code>x*2</code> 是相等的。并且 <code>x&gt;&gt;1</code> 和 <code>x/2</code> 是相同的。</p>
<p>对于整数运算元，一元运算符+-^定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+x                          is <span class="number">0</span> + x</span><br><span class="line">-x    negation              is <span class="number">0</span> - x</span><br><span class="line">^x    bitwise complement    is m ^ x  with m = <span class="string">&quot;all bits set to 1&quot;</span> <span class="keyword">for</span> unsigned x</span><br><span class="line">                                      and  m = <span class="number">-1</span> <span class="keyword">for</span> signed x</span><br></pre></td></tr></table></figure>



<h6 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h6><p>对于无符号的值，运算符+-*和&lt;&lt;都是2禁止运算。这里的n是无符号类型的宽度，无符号整型将会丢弃溢出的位，并且程序将会返回<code>wrap around</code>。</p>
<p>对于有符号的整数，操作符+&#x3D;*&lt;&lt;都会溢出并且值存在，并且代表相应的有符号的值。在运算时不会抛出异常。标一起不会报错。所以不是所有情况下x&lt;x+1都成立。</p>
<h6 id="浮点数运算符"><a href="#浮点数运算符" class="headerlink" title="浮点数运算符"></a>浮点数运算符</h6><p>对于浮点数和其他复杂数字，+x和x是一样的，-x是x的对立面。除了IEEE-754还没有指定浮点数除0或者复数的结果。是否抛出异常将会依赖其具体实现。</p>
<p>一种实现可以合并多个浮点操作进一个操作，有可能是夸语句的，并且他的结果可能和依次单独执行的结果不一样。1个浮点数类型将会转变成目标的精度，防止四舍五入的融合。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FMA allowed for computing r, because x*y is not explicitly rounded:</span></span><br><span class="line">r  = x*y + z</span><br><span class="line">r  = z;   r += x*y</span><br><span class="line">t  = x*y; r = t + z</span><br><span class="line">*p = x*y; r = *p + z</span><br><span class="line">r  = x*y + <span class="type">float64</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FMA disallowed for computing r, because it would omit rounding of x*y:</span></span><br><span class="line">r  = <span class="type">float64</span>(x*y) + z</span><br><span class="line">r  = z; r += <span class="type">float64</span>(x*y)</span><br><span class="line">t  = <span class="type">float64</span>(x*y); r = t + z</span><br></pre></td></tr></table></figure>



<h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>字符串可以使用+和+&#x3D;操作符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hi&quot;</span> + <span class="type">string</span>(c)</span><br><span class="line">s += <span class="string">&quot; and good bye&quot;</span></span><br></pre></td></tr></table></figure>



<p>字符串想家将会创建一个新的字符串。</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符比较连个运算元，并且生成一个无类型的布尔值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">==    equal</span><br><span class="line">!=    not equal</span><br><span class="line">&lt;     less</span><br><span class="line">&lt;=    less or equal</span><br><span class="line">&gt;     greater</span><br><span class="line">&gt;=    greater or equal</span><br></pre></td></tr></table></figure>



<p>在任何比较运算元中2种类型必须是可以分配的。</p>
<p>使用等于运算符<code>==</code>和<code>!=</code>的运算元必须是可比较的。使用顺序运算符<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>和<code>&gt;=</code>必须是可比较的。这些限制导致比较运算符被定义成以下的方式。</p>
<ul>
<li><p>布尔值是可比较的，两个布尔值当他们同为<code>true</code>或者false的使用是相等的</p>
</li>
<li><p>整数值是可比较和排序的</p>
</li>
<li><p>浮点数是可比较和排序的，具体定义在IEEE-754标准中。</p>
</li>
<li><p>复数是可比较的，2个复数当实部和虚部都相等时就是相等的。</p>
</li>
<li><p>字符串是可以比较和排序的。是按照字节顺序排序。</p>
</li>
<li><p>指针式可以排序的，连个指针当指向相同变量时是相同的，或者他们2个都是nil。指向一个为非配的变量的结果是未定义的。</p>
</li>
<li><p>channel是可比较的。当两个管道是用同一个make出来的，或者都是nil时时相等的。</p>
</li>
<li><p>接口值时可以比较的，2个接口值时相等的如果2个标识符的动态类型是一样的或者他们都是nil。</p>
</li>
<li><p>一个非接口类型的值x和一个接口类型的值T在非接口类型是可以比较的并且非接口类型实现了接口是是可以比较的。当他们的动态类型类型相同时时相等的。</p>
</li>
<li><p>当结构体内的所有字段都是可以比较的时候，他是可以比较的。连个结构体的值当非空字段都相等时他们是相等的。</p>
</li>
<li><p>数组类型的值时可比较的，如果数组的原属时可以比较的，那么当数组的所有值是相等的时候他们就是相等的。</p>
</li>
</ul>
<p>使用两个动态类型的标识符来比较接口的值。如果这个类型的值时不可比较的，那么将会引起一个panic。这个行为不仅仅时接口，数组结构体接口字段都有这个问题。</p>
<p>切片，map，和函数值都是不可比较的，然而，作为一个特殊的例子，切片，map和函数的值的nil时可以比较的，指针，channel和接口的值nil也是可以比较的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">3</span> &lt; <span class="number">4</span>            <span class="comment">// c is the untyped boolean constant true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyBool <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// The result of a comparison is an untyped boolean.</span></span><br><span class="line">	<span class="comment">// The usual assignment rules apply.</span></span><br><span class="line">	b3        = x == y <span class="comment">// b3 has type bool</span></span><br><span class="line">	b4 <span class="type">bool</span>   = x == y <span class="comment">// b4 has type bool</span></span><br><span class="line">	b5 MyBool = x == y <span class="comment">// b5 has type MyBool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h4><p>逻辑运算符使用布尔值值，并且生成一个相同类型的结果值作为操作元。右面的操作元计算是有条件的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;&amp;    conditional AND    p &amp;&amp; q  is  <span class="string">&quot;if p then q else false&quot;</span></span><br><span class="line">||    conditional OR     p || q  is  <span class="string">&quot;if p then true else q&quot;</span></span><br><span class="line">!     NOT                !p      is  <span class="string">&quot;not p&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="地址操作符"><a href="#地址操作符" class="headerlink" title="地址操作符"></a>地址操作符</h4><p>以类型 T 的 x 作为运算元，取址操作 <code>&amp;x</code> 会生成一个类型为 <code>*T</code> 并指向 x 的指针。运算元必须是能够取址的，它可以是一个变量，指针，切片的取值操作；或是一个可取址结构体的字段选择器；或是对于可取址数组的索引取值操作。作为寻址能力的例外，x 可能是一个复合字面值。如果对 x 进行取址操作将会 panic，<code>&amp;x</code> 也会 panic。</p>
<p>对于一个 <code>*T</code> 类型的运算元 x，指针解引用 <code>*x</code> 表示 x 指向的 T 类型。如果 x 为 nil，那么解引用 <code>*x</code> 会 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;x</span><br><span class="line">&amp;a[f(<span class="number">2</span>)]</span><br><span class="line">&amp;Point&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">*p</span><br><span class="line">*pf(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">*x   <span class="comment">// causes a run-time panic</span></span><br><span class="line">&amp;*x  <span class="comment">// causes a run-time panic</span></span><br></pre></td></tr></table></figure>



<h4 id="接收操作符"><a href="#接收操作符" class="headerlink" title="接收操作符"></a>接收操作符</h4><p>对于管道类型的运算元 <code>ch</code>，接收操作 <code>&lt;-ch</code> 返回值是管道 <code>ch</code> 接收到的值。带方向的管道需要有接受权限，接收操作的类型也是通道的元素类型。表达式会一直阻塞直到接收到返回值。从 nil 通道接收值会一直阻塞。从一个已经关闭的通道接收数据会在其他数据都被接收以后生成该通道元素类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v1 := &lt;-ch</span><br><span class="line">v2 = &lt;-ch</span><br><span class="line">f(&lt;-ch)</span><br><span class="line">&lt;-strobe  <span class="comment">// wait until clock pulse and discard received value</span></span><br></pre></td></tr></table></figure>



<p>接收数据的表达式可以使用赋值表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, ok = &lt;-ch</span><br><span class="line">x, ok := &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok = &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok T = &lt;-ch</span><br></pre></td></tr></table></figure>



<p>它还可以生成一个额外的无类型布尔值来表示通道是否关闭。如果 ok 为 <code>true</code> 说明获取到的是发送到通道内的数据，而 <code>false</code> 它就返回一个零值因为通道内没有元素且已经关闭。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换表达式 <code>T(x)</code> 其中 T 代表类型，x 代表可以转换成 T 类型的表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Conversion = Type <span class="string">&quot;(&quot;</span> Expression [ <span class="string">&quot;,&quot;</span> ] <span class="string">&quot;)&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>如果类型是以 <code>*</code> 或 <code>&lt;-</code> 开头，或以关键字 <code>func</code> 开头并且没有返回值列表，那么它必须用括号括起来避免歧义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*Point(p)        <span class="comment">// same as *(Point(p))</span></span><br><span class="line">(*Point)(p)      <span class="comment">// p is converted to *Point</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span>(c)    <span class="comment">// same as &lt;-(chan int(c))</span></span><br><span class="line">(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)(c)  <span class="comment">// c is converted to &lt;-chan int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>(x)        <span class="comment">// function signature func() x</span></span><br><span class="line">(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(x)      <span class="comment">// x is converted to func()</span></span><br><span class="line">(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>)(x)  <span class="comment">// x is converted to func() int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>(x)    <span class="comment">// x is converted to func() int (unambiguous)</span></span><br></pre></td></tr></table></figure>



<p>常量 x 可以在可以用类型 T 表示时自动转换。作为一个特例，整数常量 x 可以转换成字符串类型就和非常量 x 一样。</p>
<p>对常量的转换会生成一个指定类型的常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint</span>(<span class="literal">iota</span>)               <span class="comment">// iota value of type uint</span></span><br><span class="line"><span class="type">float32</span>(<span class="number">2.718281828</span>)     <span class="comment">// 2.718281828 of type float32</span></span><br><span class="line"><span class="type">complex128</span>(<span class="number">1</span>)            <span class="comment">// 1.0 + 0.0i of type complex128</span></span><br><span class="line"><span class="type">float32</span>(<span class="number">0.49999999</span>)      <span class="comment">// 0.5 of type float32</span></span><br><span class="line"><span class="type">float64</span>(<span class="number">-1e-1000</span>)        <span class="comment">// 0.0 of type float64</span></span><br><span class="line"><span class="type">string</span>(<span class="string">&#x27;x&#x27;</span>)              <span class="comment">// &quot;x&quot; of type string</span></span><br><span class="line"><span class="type">string</span>(<span class="number">0x266c</span>)           <span class="comment">// &quot;♬&quot; of type string</span></span><br><span class="line">MyString(<span class="string">&quot;foo&quot;</span> + <span class="string">&quot;bar&quot;</span>)  <span class="comment">// &quot;foobar&quot; of type MyString</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>&#125;)      <span class="comment">// not a constant: []byte&#123;&#x27;a&#x27;&#125; is not a constant</span></span><br><span class="line">(*<span class="type">int</span>)(<span class="literal">nil</span>)              <span class="comment">// not a constant: nil is not a constant, *int is not a boolean, numeric, or string type</span></span><br><span class="line"><span class="type">int</span>(<span class="number">1.2</span>)                 <span class="comment">// illegal: 1.2 cannot be represented as an int</span></span><br><span class="line"><span class="type">string</span>(<span class="number">65.0</span>)             <span class="comment">// illegal: 65.0 is not an integer constant</span></span><br></pre></td></tr></table></figure>



<p>非常量 x 可以在以下情况下转换成类型 T：</p>
<ul>
<li><p>x 可以给类型 T 赋值</p>
</li>
<li><p>忽略的结构体标签，x 的类型和 T 具有相同的底层类型</p>
</li>
<li><p>忽略的结构体标签，x 的类型和 T 都是指针类型，并且指针所指的类型具有相同的底层类型</p>
</li>
<li><p>x 的类型和 T 都是整数或者浮点数类型</p>
</li>
<li><p>x 的类型和 T 都是复数类型</p>
</li>
<li><p>x 是一个字符串而 T 时字节切片或者 rune 切片</p>
</li>
</ul>
<p>在比较两个结构体类型的时候会忽略结构体标签：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Address *<span class="keyword">struct</span> &#123;</span><br><span class="line">		Street <span class="type">string</span></span><br><span class="line">		City   <span class="type">string</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data *<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Address *<span class="keyword">struct</span> &#123;</span><br><span class="line">		Street <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">		City   <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = (*Person)(data)  <span class="comment">// ignoring tags, the underlying types are identical</span></span><br></pre></td></tr></table></figure>



<p>这个规则也适用于数字类型与字符串类型间的相互转换。这个转换可能会改变 x 的值并且会增加运行时消耗。包 unsafe 实现了这个功能底层的限制。</p>
<h6 id="数字之间的转换"><a href="#数字之间的转换" class="headerlink" title="数字之间的转换"></a>数字之间的转换</h6><p>对于非常量的数字转换，需要遵守以下规则：</p>
<ul>
<li><p>在转换整型数字时，如果是一个有符号整型，它是继承有符号的无限精度；否则就不用继承符号。转换时会截断数字以适应类型的大小。例如：如果 <code>v:=uint16(0x10F0)</code>，然后 &#96;&#96;uint32(int8(v)) &#x3D;&#x3D; 0xFFFFFFF0 。类型转换总是生成有效值，并且永远不会溢出。</p>
</li>
<li><p>如果要将浮点数转换成整型，会丢弃小数部分（截断为零）。</p>
</li>
<li><p>如果要将整型或浮点型转换成浮点数类型，或或者一个复数转换成其他复数类型，结果会四舍五入成指定精度。例如： 可以使用超出IEEE-754 32位数的附加精度来存储float32类型的变量x的值，但float32（x）表示将x的值舍入为32位精度的结果。x + 0.1 会使用超过 32 位的精度，而 <code>float32(x+0.1)</code> 不会。</p>
</li>
</ul>
<p>在所有浮点数和复数的非常量转换中，如果结构类型不能成功表示数据，那么结果将会依赖于具体平台实现。</p>
<h6 id="字符串的类型转换"><a href="#字符串的类型转换" class="headerlink" title="字符串的类型转换"></a>字符串的类型转换</h6><ol>
<li>转换一个有符号或者无符号的整型值会转换成对应的 UTF-8 表示整型值。不在范围内的 Unicode 代码点会转换成 “\uFFFD”。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>(<span class="string">&#x27;a&#x27;</span>)       <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">-1</span>)        <span class="comment">// &quot;\ufffd&quot; == &quot;\xef\xbf\xbd&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">0xf8</span>)      <span class="comment">// &quot;\u00f8&quot; == &quot;ø&quot; == &quot;\xc3\xb8&quot;</span></span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line">MyString(<span class="number">0x65e5</span>)  <span class="comment">// &quot;\u65e5&quot; == &quot;日&quot; == &quot;\xe6\x97\xa5&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将字节切片转换成字符串类型会生成一个由切片元素组成的字符串</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;\xc3&#x27;</span>, <span class="string">&#x27;\xb8&#x27;</span>&#125;)   <span class="comment">// &quot;hellø&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">byte</span>&#123;&#125;)                                     <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">byte</span>(<span class="literal">nil</span>))                                  <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyBytes []<span class="type">byte</span></span><br><span class="line"><span class="type">string</span>(MyBytes&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;\xc3&#x27;</span>, <span class="string">&#x27;\xb8&#x27;</span>&#125;)  <span class="comment">// &quot;hellø&quot;</span></span><br></pre></td></tr></table></figure>



<ol>
<li>将 rune 切片转换成字符串类型会生成一个由切片元素组成的字符串</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>([]<span class="type">rune</span>&#123;<span class="number">0x767d</span>, <span class="number">0x9d6c</span>, <span class="number">0x7fd4</span>&#125;)   <span class="comment">// &quot;\u767d\u9d6c\u7fd4&quot; == &quot;白鵬翔&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">rune</span>&#123;&#125;)                         <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">rune</span>(<span class="literal">nil</span>))                      <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyRunes []<span class="type">rune</span></span><br><span class="line"><span class="type">string</span>(MyRunes&#123;<span class="number">0x767d</span>, <span class="number">0x9d6c</span>, <span class="number">0x7fd4</span>&#125;)  <span class="comment">// &quot;\u767d\u9d6c\u7fd4&quot; == &quot;白鵬翔&quot;</span></span><br></pre></td></tr></table></figure>



<ol>
<li>将字符串转换成字节切片会生成由字符串中每个字节组成的切片</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="type">byte</span>(<span class="string">&quot;hellø&quot;</span>)   <span class="comment">// []byte&#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;\xc3&#x27;, &#x27;\xb8&#x27;&#125;</span></span><br><span class="line">[]<span class="type">byte</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// []byte&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">MyBytes(<span class="string">&quot;hellø&quot;</span>)  <span class="comment">// []byte&#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;\xc3&#x27;, &#x27;\xb8&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将字符串转换成 rune 切片会生成由字符串中每个 Unicode 代码点组成的切片</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="type">rune</span>(MyString(<span class="string">&quot;白鵬翔&quot;</span>))  <span class="comment">// []rune&#123;0x767d, 0x9d6c, 0x7fd4&#125;</span></span><br><span class="line">[]<span class="type">rune</span>(<span class="string">&quot;&quot;</span>)                 <span class="comment">// []rune&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">MyRunes(<span class="string">&quot;白鵬翔&quot;</span>)           <span class="comment">// []rune&#123;0x767d, 0x9d6c, 0x7fd4&#125;</span></span><br></pre></td></tr></table></figure>



<h6 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h6><p>常量表达式只包含常量运算元并且在编译程序时就已经计算完成。</p>
<p>无类型布尔值，数值和字符串常量都可以当作运算元。除了位置操作符，如果二元运算符石不同类型的常量，操作元，和非布尔值，和即将在接下来出现的：整型，rune，浮点数和复数类型。例如：一个无类型整型常量减去无类型复数常量，结果为复数常量。</p>
<p>一个常量的比较运算会生成无类型的布尔常量。如果左移运算是一个无类型常量，结果会是一个整型常量。它会和原来常量为相同类型。其他与无类型常量的运算都会生成相同类型的结果（布尔值，整型，浮点数，复数，字符串常量）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span> + <span class="number">3.0</span>          <span class="comment">// a == 5.0   (untyped floating-point constant)</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15</span> / <span class="number">4</span>           <span class="comment">// b == 3     (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">15</span> / <span class="number">4.0</span>         <span class="comment">// c == 3.75  (untyped floating-point constant)</span></span><br><span class="line"><span class="keyword">const</span> Θ <span class="type">float64</span> = <span class="number">3</span>/<span class="number">2</span>      <span class="comment">// Θ == 1.0   (type float64, 3/2 is integer division)</span></span><br><span class="line"><span class="keyword">const</span> Π <span class="type">float64</span> = <span class="number">3</span>/<span class="number">2.</span>     <span class="comment">// Π == 1.5   (type float64, 3/2. is float division)</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">1</span> &lt;&lt; <span class="number">3.0</span>         <span class="comment">// d == 8     (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">1.0</span> &lt;&lt; <span class="number">3</span>         <span class="comment">// e == 8     (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="type">int32</span>(<span class="number">1</span>) &lt;&lt; <span class="number">33</span>   <span class="comment">// illegal    (constant 8589934592 overflows int32)</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="type">float64</span>(<span class="number">2</span>) &gt;&gt; <span class="number">1</span>  <span class="comment">// illegal    (float64(2) is a typed floating-point constant)</span></span><br><span class="line"><span class="keyword">const</span> h = <span class="string">&quot;foo&quot;</span> &gt; <span class="string">&quot;bar&quot;</span>    <span class="comment">// h == true  (untyped boolean constant)</span></span><br><span class="line"><span class="keyword">const</span> j = <span class="literal">true</span>             <span class="comment">// j == true  (untyped boolean constant)</span></span><br><span class="line"><span class="keyword">const</span> k = <span class="string">&#x27;w&#x27;</span> + <span class="number">1</span>          <span class="comment">// k == &#x27;x&#x27;   (untyped rune constant)</span></span><br><span class="line"><span class="keyword">const</span> l = <span class="string">&quot;hi&quot;</span>             <span class="comment">// l == &quot;hi&quot;  (untyped string constant)</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="type">string</span>(k)        <span class="comment">// m == &quot;x&quot;   (type string)</span></span><br><span class="line"><span class="keyword">const</span> Σ = <span class="number">1</span> - <span class="number">0.707i</span>       <span class="comment">//            (untyped complex constant)</span></span><br><span class="line"><span class="keyword">const</span> Δ = Σ + <span class="number">2.0e-4</span>       <span class="comment">//            (untyped complex constant)</span></span><br><span class="line"><span class="keyword">const</span> Φ = <span class="literal">iota</span>*<span class="number">1i</span> - <span class="number">1</span>/<span class="number">1i</span>   <span class="comment">//            (untyped complex constant)</span></span><br></pre></td></tr></table></figure>



<p>对一个无类型整数，rune，或浮点数应用内置的 <code>complex</code> 函数会生成无类型的复数常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ic = <span class="built_in">complex</span>(<span class="number">0</span>, c)   <span class="comment">// ic == 3.75i  (untyped complex constant)</span></span><br><span class="line"><span class="keyword">const</span> iΘ = <span class="built_in">complex</span>(<span class="number">0</span>, Θ)   <span class="comment">// iΘ == 1i     (type complex128)</span></span><br></pre></td></tr></table></figure>



<p>常量表达式总是一个明确的值；中间值和常量自己可以比语言所支持的精度更高，下面的声明是合法的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Huge = <span class="number">1</span> &lt;&lt; <span class="number">100</span>         <span class="comment">// Huge == 1267650600228229401496703205376  (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> Four <span class="type">int8</span> = Huge &gt;&gt; <span class="number">98</span>  <span class="comment">// Four == 4                                (type int8)</span></span><br></pre></td></tr></table></figure>



<p>常量的除法的除数不能为 0:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span> / <span class="number">0.0</span>   <span class="comment">// illegal: division by zero</span></span><br></pre></td></tr></table></figure>



<p>定义了类型的常量的精度必须根据常量类型定义。所以下面的常量表达式是非法的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint</span>(<span class="number">-1</span>)     <span class="comment">// -1 cannot be represented as a uint</span></span><br><span class="line"><span class="type">int</span>(<span class="number">3.14</span>)    <span class="comment">// 3.14 cannot be represented as an int</span></span><br><span class="line"><span class="type">int64</span>(Huge)  <span class="comment">// 1267650600228229401496703205376 cannot be represented as an int64</span></span><br><span class="line">Four * <span class="number">300</span>   <span class="comment">// operand 300 cannot be represented as an int8 (type of Four)</span></span><br><span class="line">Four * <span class="number">100</span>   <span class="comment">// product 400 cannot be represented as an int8 (type of Four)</span></span><br></pre></td></tr></table></figure>



<p>补码使用的一元操作符 ^ 对于非常量的匹配模式：补码对于无符号常量为 1，对于有符号和无类型常量为 -1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">^<span class="number">1</span>         <span class="comment">// untyped integer constant, equal to -2</span></span><br><span class="line"><span class="type">uint8</span>(^<span class="number">1</span>)  <span class="comment">// illegal: same as uint8(-2), -2 cannot be represented as a uint8</span></span><br><span class="line">^<span class="type">uint8</span>(<span class="number">1</span>)  <span class="comment">// typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)</span></span><br><span class="line"><span class="type">int8</span>(^<span class="number">1</span>)   <span class="comment">// same as int8(-2)</span></span><br><span class="line">^<span class="type">int8</span>(<span class="number">1</span>)   <span class="comment">// same as -1 ^ int8(1) = -2</span></span><br></pre></td></tr></table></figure>



<p>实现限制：编译器在处理无类型浮点数和复数时会取近似值；具体请看常量章节。这个取近似值的操作在浮点数在整数上下文时会产生无效值，即使在计算过后是一个整型。</p>
<h4 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h4><p>在包级别，初始化的依赖性由变量声明的初始化表达式顺序决定。否则，当计算表达式内的操作数时，赋值，返回语句，所有函数调用，方法调用，和通信操作都会由左向右计算。</p>
<p>例如，在函数作用域中的赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()</span><br></pre></td></tr></table></figure>



<p>函数调用和通信的发生顺序为：<code>f()</code>，<code>h()</code>，<code>i()</code>，<code>j()</code>，<code>&lt;-c</code>，<code>g()</code> 和 <code>k()</code>。但是对 y 和 x 的取值操作没有指定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; a++; <span class="keyword">return</span> a &#125;</span><br><span class="line">x := []<span class="type">int</span>&#123;a, f()&#125;            <span class="comment">// x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;a: <span class="number">1</span>, a: <span class="number">2</span>&#125;  <span class="comment">// m may be &#123;2: 1&#125; or &#123;2: 2&#125;: evaluation order between the two map assignments is not specified</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;a: f()&#125;      <span class="comment">// n may be &#123;2: 3&#125; or &#123;3: 3&#125;: evaluation order between the key and the value is not specified</span></span><br></pre></td></tr></table></figure>



<p>在包级别，依赖的初始化顺序会覆盖这个从左向右的规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c = f() + v(), g(), sqr(u()) + v()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">int</span>        &#123; <span class="keyword">return</span> c &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> <span class="type">int</span>        &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqr</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*x &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// functions u and v are independent of all other variables and functions</span></span><br></pre></td></tr></table></figure>



<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句控制程序的执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Statement =</span><br><span class="line">	Declaration | LabeledStmt | SimpleStmt |</span><br><span class="line">	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span><br><span class="line">	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span><br><span class="line">	DeferStmt .</span><br><span class="line"></span><br><span class="line">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span><br></pre></td></tr></table></figure>



<h4 id="终止语句"><a href="#终止语句" class="headerlink" title="终止语句"></a>终止语句</h4><p>终止语句会阻止相同代码块中下面所有语句的执行。以下语句属于终止语句：</p>
<ol>
<li><p><code>return</code> 和 <code>goto</code> 语句</p>
</li>
<li><p>对内置 <code>panic</code> 函数的调用</p>
</li>
<li><p>代码块结束</p>
</li>
<li><p><code>if</code> 语句中：</p>
</li>
<li><p>else 分支</p>
</li>
<li><p>所有分支末尾</p>
</li>
<li><p><code>for</code>语句中：</p>
</li>
<li><p><code>break</code> 语句和循环结束</p>
</li>
<li><p><code>switch</code> 语句：</p>
</li>
<li><p>在 <code>switch</code> 语句中没有 <code>break</code> 语句，</p>
</li>
<li><p>有一个默认的 case</p>
</li>
<li><p>语句列表中的每个 case 语句和有可能存在的 <code>fallthrough</code> 语句</p>
</li>
<li><p><code>select</code> 语句中：</p>
</li>
<li><p>没有 break 语句</p>
</li>
<li><p>每个 case 中的语句列表，如果包含默认 case</p>
</li>
</ol>
<p>所有其他语句都不是中断语句。</p>
<p>如果语句序列不为空并且最后一个非空语句是终止语句，那么语句序列就以终结语句结尾。</p>
<h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>空语句不做任何事情。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">EmptyStmt = .</span><br></pre></td></tr></table></figure>



<h4 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h4><p>标签语句可以作为 <code>goto</code>，<code>break</code> 和 <code>continue</code> 语句的目标。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LabeledStmt = Label <span class="string">&quot;:&quot;</span> Statement .</span><br><span class="line">Label       = identifier .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Error: log.Panic(<span class="string">&quot;error encountered&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h4><p>除了特定的内置函数，一般的函数、方法和接收操作都可以出现在表达式语句的上下文中。这些语句可以使用括号括起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ExpressionStmt = Expression .</span><br></pre></td></tr></table></figure>



<p>下面的内置函数不允许出现在语句的上下文中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">complex</span> <span class="built_in">imag</span> <span class="built_in">len</span> <span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">real</span></span><br><span class="line">unsafe.Alignof unsafe.Offsetof unsafe.Sizeof</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h(x+y)</span><br><span class="line">f.Close()</span><br><span class="line">&lt;-ch</span><br><span class="line">(&lt;-ch)</span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;foo&quot;</span>)  <span class="comment">// illegal if len is the built-in function</span></span><br></pre></td></tr></table></figure>



<h4 id="发送语句"><a href="#发送语句" class="headerlink" title="发送语句"></a>发送语句</h4><p>发送语句可以向通道发送一个值。通道表达式必须是通道类型，通道方向必须允许发送操作，并且值类型是可以分配给通道元素通道类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SendStmt = Channel <span class="string">&quot;&lt;-&quot;</span> Expression .</span><br><span class="line">Channel  = Expression .</span><br></pre></td></tr></table></figure>



<p>通道类型和值表达式会在发送之前求值。发送操作会一致阻塞，直到可以进行发送操作。如果接收者已经准备好向没有缓存的通道发送值可以立即执行。如果通道内还有缓存空间，向通道内发送值也会立即执行。向关闭的通道发送数据会导致运行时恐慌。像值为 nil 的通道发送数据会一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">3</span>  <span class="comment">// send value 3 to channel ch</span></span><br></pre></td></tr></table></figure>



<h4 id="递增-递减语句"><a href="#递增-递减语句" class="headerlink" title="递增&#x2F;递减语句"></a>递增&#x2F;递减语句</h4><p>“++” 和 “–” 语句可以递增或者递减运算元一个无类型常量 1。作为一个赋值语句，运算元必须是可寻址的或者 map 的索引表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">IncDecStmt = Expression ( <span class="string">&quot;++&quot;</span> | <span class="string">&quot;--&quot;</span> ) .</span><br></pre></td></tr></table></figure>



<p>下面的赋值语句在语义上是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">IncDec statement    Assignment</span><br><span class="line">x++                 x += <span class="number">1</span></span><br><span class="line">x--                 x -= <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Assignment = ExpressionList assign_op ExpressionList .</span><br><span class="line"></span><br><span class="line">assign_op = [ add_op | mul_op ] <span class="string">&quot;=&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>所有左侧运算元都必须是可寻址的、map 索引表达式或空标识符其中之一。运算元可以用括号括起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">*p = f()</span><br><span class="line">a[i] = <span class="number">23</span></span><br><span class="line">(k) = &lt;-ch  <span class="comment">// same as: k = &lt;-ch</span></span><br></pre></td></tr></table></figure>



<p>对于赋值操作 <code>x op= y</code> 其中 <code>op</code> 为二元运算符，它和 <code>x=x op (y)</code> 是等价的，不过它只计算一次 x。<code>op=</code> 是单独的一个词汇单元，在赋值操作中左侧表达式和右侧表达式必须都是单值表达式，并且左侧表达式不能是空白标识符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[i] &lt;&lt;= <span class="number">2</span></span><br><span class="line">i &amp;^= <span class="number">1</span>&lt;&lt;n</span><br></pre></td></tr></table></figure>



<p>元祖赋值语句会把运算返回的多个值分别分配给变量列表。它有两种格式，第一种：它是返回多值的表达式，例如函数调用、通道和 map 运算、类型断言。左侧运算元的数量必须等于返回值的数量。如果函数返回两个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y = f()</span><br></pre></td></tr></table></figure>



<p>它会将第一个返回值分配给 x ，把第二个返回值分配给 y。第二种格式中，左侧运算元的数量必须等于右侧运算元的数量。每个表达式都只能返回单一值，右侧第 n 个值会赋值给左侧第 n 个变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">one, two, three = <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span></span><br></pre></td></tr></table></figure>



<p>空标识符可以在分配时忽略一个右面位置的表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = x       <span class="comment">// evaluate x but ignore it</span></span><br><span class="line">x, _ = f()  <span class="comment">// evaluate f() but ignore second result value</span></span><br></pre></td></tr></table></figure>



<p>赋值分为两个阶段。首先会计算左侧运算元的索引表达式和指针的解引用工作并以一定顺序计算右侧表达式的值。</p>
<p>然后依次对左侧运算元赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b = b, a  <span class="comment">// exchange a and b</span></span><br><span class="line"></span><br><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">i, x[i] = <span class="number">1</span>, <span class="number">2</span>  <span class="comment">// set i = 1, x[0] = 2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">x[i], i = <span class="number">2</span>, <span class="number">1</span>  <span class="comment">// set x[0] = 2, i = 1</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>], x[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">2</span>  <span class="comment">// set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">1</span>], x[<span class="number">3</span>] = <span class="number">4</span>, <span class="number">5</span>  <span class="comment">// set x[1] = 4, then panic setting x[3] = 5.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123; x, y <span class="type">int</span> &#125;</span><br><span class="line"><span class="keyword">var</span> p *Point</span><br><span class="line">x[<span class="number">2</span>], p.x = <span class="number">6</span>, <span class="number">7</span>  <span class="comment">// set x[2] = 6, then panic setting p.x = 7</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">x = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, x[i] = <span class="keyword">range</span> x &#123;  <span class="comment">// set i, x[2] = 0, x[0]</span></span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after this loop, i == 0 and x == []int&#123;3, 5, 3&#125;</span></span><br></pre></td></tr></table></figure>



<p>在赋值语句中每个值都必须能分配给左侧指定类型的值。除了以下特例：</p>
<ol>
<li><p>任何类型都能分配给空标识符。</p>
</li>
<li><p>如果把无类型常量分配给接口类型或者空标识符，它会转换成默认类型。</p>
</li>
<li><p>如果无类型的布尔值分配给了接口类型或者空标识符，它会先转换成 <code>bool</code> 类型。</p>
</li>
</ol>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p><code>if</code> 语句根据布尔值表达式的值来决定执行条件分支的代码。如果表达式为真，就执行 <code>if</code> 分支内的代码，否则执行 <code>else</code> 分支的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">IfStmt = <span class="string">&quot;if&quot;</span> [ SimpleStmt <span class="string">&quot;;&quot;</span> ] Expression Block [ <span class="string">&quot;else&quot;</span> ( IfStmt | Block ) ] .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; max &#123;</span><br><span class="line">	x = max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>表达式可能先于普通语句，它会在表达式求值之前发生。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x := f(); x &lt; y &#123;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; z &#123;</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>for 语句可以用来重复执行一段代码。它有三种格式：迭代器可以是单一条件、for 分句或者 range 语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ForStmt = <span class="string">&quot;for&quot;</span> [ Condition | ForClause | RangeClause ] Block .</span><br><span class="line">Condition = Expression .</span><br></pre></td></tr></table></figure>



<h6 id="单一条件的-for-语句"><a href="#单一条件的-for-语句" class="headerlink" title="单一条件的 for 语句"></a>单一条件的 for 语句</h6><p>这种情况下 for 会在条件为 true 时一直重复。条件会在每次迭代时都重新计算。如果没有指定条件，默认一直为 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a &lt; b &#123;</span><br><span class="line">	a *= <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="带分句的-for-语句"><a href="#带分句的-for-语句" class="headerlink" title="带分句的 for 语句"></a>带分句的 for 语句</h6><p>带分句的 for 语句也是由条件控制，只是它有一个初始化和寄送的过程。例如赋值、递增或者递减语句。初始化语句可以是短变量声明，但是寄送语句不能。在初始化语句中声明的变量可以在迭代过程中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ForClause = [ InitStmt ] <span class="string">&quot;;&quot;</span> [ Condition ] <span class="string">&quot;;&quot;</span> [ PostStmt ] .</span><br><span class="line">InitStmt = SimpleStmt .</span><br><span class="line">PostStmt = SimpleStmt .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	f(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果初始化语句非空，它会在进入迭代前执行一次；post 语句在每次循环后都会执行一次。在只有条件的情况下可以省略分号。如果缺省条件语句，默认为 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cond &#123; S() &#125;    is the same as    <span class="keyword">for</span> ; cond ; &#123; S() &#125;</span><br><span class="line"><span class="keyword">for</span>      &#123; S() &#125;    is the same as    <span class="keyword">for</span> <span class="literal">true</span>     &#123; S() &#125;</span><br></pre></td></tr></table></figure>



<h6 id="带-range-分句的-for-语句"><a href="#带-range-分句的-for-语句" class="headerlink" title="带 range 分句的 for 语句"></a>带 range 分句的 for 语句</h6><p>带 range 分句的 for 语句可以访问数组、切片、字符串、map 的所有元素，还可以从通道中接收值。迭代获得元素分配给了相应的迭代变量并执行代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">RangeClause = [ ExpressionList <span class="string">&quot;=&quot;</span> | IdentifierList <span class="string">&quot;:=&quot;</span> ] <span class="string">&quot;range&quot;</span> Expression .</span><br></pre></td></tr></table></figure>



<p>右侧的 range 分句表达式叫做 range 表达式，它可能是数组、数组的指针、切片、字符串、map 或通道接收者类型。在分配时，左侧运算元必须是可寻址的或者 map 的索引表达式；它们作为迭代变量。如果 range 表达式是一个通道类型，至少需要有一个变量，它也可以有两个变量。如果迭代变量是空标识符，就代表在分句中不存在该标识符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Range expression                          <span class="number">1</span>st value          <span class="number">2</span>nd value</span><br><span class="line"></span><br><span class="line">array or slice  a  [n]E, *[n]E, or []E    index    i  <span class="type">int</span>    a[i]       E</span><br><span class="line"><span class="type">string</span>          s  <span class="type">string</span> <span class="keyword">type</span>            index    i  <span class="type">int</span>    see below  <span class="type">rune</span></span><br><span class="line"><span class="keyword">map</span>             m  <span class="keyword">map</span>[K]V                key      k  K      m[k]       V</span><br><span class="line">channel         c  <span class="keyword">chan</span> E, &lt;-<span class="keyword">chan</span> E       element  e  E</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testdata *<span class="keyword">struct</span> &#123;</span><br><span class="line">	a *[<span class="number">7</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> testdata.a &#123;</span><br><span class="line">	<span class="comment">// testdata.a is never evaluated; len(testdata.a) is constant</span></span><br><span class="line">	<span class="comment">// i ranges from 0 to 6</span></span><br><span class="line">	f(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i, s := <span class="keyword">range</span> a &#123;</span><br><span class="line">	<span class="comment">// type of i is int</span></span><br><span class="line">	<span class="comment">// type of s is string</span></span><br><span class="line">	<span class="comment">// s == a[i]</span></span><br><span class="line">	g(i, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> val <span class="keyword">interface</span> &#123;&#125;  <span class="comment">// element type of m is assignable to val</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;mon&quot;</span>:<span class="number">0</span>, <span class="string">&quot;tue&quot;</span>:<span class="number">1</span>, <span class="string">&quot;wed&quot;</span>:<span class="number">2</span>, <span class="string">&quot;thu&quot;</span>:<span class="number">3</span>, <span class="string">&quot;fri&quot;</span>:<span class="number">4</span>, <span class="string">&quot;sat&quot;</span>:<span class="number">5</span>, <span class="string">&quot;sun&quot;</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, val = <span class="keyword">range</span> m &#123;</span><br><span class="line">	h(key, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key == last map key encountered in iteration</span></span><br><span class="line"><span class="comment">// val == map[key]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Work = producer()</span><br><span class="line"><span class="keyword">for</span> w := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	doWork(w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty a channel</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ch &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Go-语句"><a href="#Go-语句" class="headerlink" title="Go 语句"></a>Go 语句</h4><p><code>go</code> 语句会开始在相同地址空间中的单独 goroutine 中调用函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GoStmt = <span class="string">&quot;go&quot;</span> Expression .</span><br></pre></td></tr></table></figure>



<p>表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数有表达式语句的限制。</p>
<p>函数的值和参数会按顺序在调用的 goroutine 中求值。不像普通的函数调用，程序不会等待函数调用完成，而是直接开启一个新的 goroutine 执行函数。函数退出时，goroutine 也会退出。函数的任何返回值都会被丢弃。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> Server()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">bool</span>)</span></span> &#123; <span class="keyword">for</span> &#123; sleep(<span class="number">10</span>); ch &lt;- <span class="literal">true</span> &#125;&#125; (c)</span><br></pre></td></tr></table></figure>



<h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><p>select 语句会在接收&#x2F;发送操作集中选择一个执行。它看起来和 switch 很像，只不过是专门针对通信操作的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SelectStmt = <span class="string">&quot;select&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; CommClause &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">CommClause = CommCase <span class="string">&quot;:&quot;</span> StatementList .</span><br><span class="line">CommCase   = <span class="string">&quot;case&quot;</span> ( SendStmt | RecvStmt ) | <span class="string">&quot;default&quot;</span> .</span><br><span class="line">RecvStmt   = [ ExpressionList <span class="string">&quot;=&quot;</span> | IdentifierList <span class="string">&quot;:=&quot;</span> ] RecvExpr .</span><br><span class="line">RecvExpr   = Expression .</span><br></pre></td></tr></table></figure>



<p>接收表达式可以将接收表达式的值分配给一个或两个变量。接收表达式必须是一个接收运算元（可以使用括号括起来）。它最多允许有一个 default 语句。</p>
<p>select 语句执行以下几个步骤：</p>
<ol>
<li><p>对于 select 语句的所有分句，接收操作的通道运算元、通道、发送语句的右侧表达式都会执行一次操作。</p>
</li>
<li><p>如果一个或多个通信同时发生，它会通过一致性随机选择一个执行。如果没有 default 语句，select 语句会一直阻塞。</p>
</li>
<li><p>除了 default 分句，其他分句只有在开始进行通信的时候才会执行。</p>
</li>
<li><p>如果 select 分句是一个接收语句，它可以给变量分配值。</p>
</li>
<li><p>执行 select 分句内的内容。</p>
</li>
</ol>
<p>如果向 nil 通道发送信息在没有 default 分句的情况下会一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</span><br><span class="line">	<span class="comment">// same as:</span></span><br><span class="line">	<span class="comment">// case t := &lt;-c4</span></span><br><span class="line">	<span class="comment">//	a[f()] = t</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;  <span class="comment">// send random sequence of bits to c</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- <span class="number">0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></span><br><span class="line">	<span class="keyword">case</span> c &lt;- <span class="number">1</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;  <span class="comment">// block forever</span></span><br></pre></td></tr></table></figure>



<h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><p><code>return</code> 语句会终止函数 F 的执行并可选的返回一个或多个返回值。所有的滞后函数都会在 F 返回到它的调用者之前执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ReturnStmt = <span class="string">&quot;return&quot;</span> [ ExpressionList ] .</span><br></pre></td></tr></table></figure>



<p>如果函数没有返回值类型，return 不能返回任何值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noResult</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有三种方式能够返回指定类型的值：</p>
<ol>
<li>返回值可以直接在 return 语句中列出。每个表达式都必须返回一个值并且能够分配给相应的返回值类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleF</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complexF1</span><span class="params">()</span></span> (re <span class="type">float64</span>, im <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-7.0</span>, <span class="number">-4.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>return 语句的表达式列表可以是一个返回多值的函数调用。这时会使用临时变量来获取函数调用的返回值并直接将其作为 return 语句的表达式列表。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complexF2</span><span class="params">()</span></span> (re <span class="type">float64</span>, im <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> complexF1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果制定了返回值的标识符那么 return 的表达式列表可以为空。返回值参数会作为普通的本地变量按需分配。return 语句会直接返回它们。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complexF3</span><span class="params">()</span></span> (re <span class="type">float64</span>, im <span class="type">float64</span>) &#123;</span><br><span class="line">	re = <span class="number">7.0</span></span><br><span class="line">	im = <span class="number">4.0</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(devnull)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, _ <span class="type">error</span>) &#123;</span><br><span class="line">	n = <span class="built_in">len</span>(p)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不管如何声明，所有的返回值都会在进入函数前提前初始化成类型的零值。return 语句会在所有 defer 函数之前指定返回值。</p>
<p>实现限制：编译器不允许在覆盖了命名返回值的作用域中直接返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="type">int</span>)</span></span> (res <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := f(n<span class="number">-1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="comment">// invalid return statement: err is shadowed</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><p><code>break</code> 语句会在 <code>for</code>、<code>switch</code> 或 <code>select</code> 语句内部退出到相同函数的某个位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BreakStmt = <span class="string">&quot;break&quot;</span> [ Label ] .</span><br></pre></td></tr></table></figure>



<p>如果想指定标签，它必须出现在它所中止的 <code>for</code>、<code>switch</code> 或 <code>select</code> 语句旁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">			<span class="keyword">switch</span> a[i][j] &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">				state = Error</span><br><span class="line">				<span class="keyword">break</span> OuterLoop</span><br><span class="line">			<span class="keyword">case</span> item:</span><br><span class="line">				state = Found</span><br><span class="line">				<span class="keyword">break</span> OuterLoop</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p><code>continue</code> 语句会提前 <code>for</code> 语句的下一次迭代。<code>for</code> 语句必须和 <code>continue</code> 在相同函数中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">RowLoop:</span><br><span class="line">	<span class="keyword">for</span> y, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">		<span class="keyword">for</span> x, data := <span class="keyword">range</span> row &#123;</span><br><span class="line">			<span class="keyword">if</span> data == endOfRow &#123;</span><br><span class="line">				<span class="keyword">continue</span> RowLoop</span><br><span class="line">			&#125;</span><br><span class="line">			row[x] = data + bias(x, y)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><p><code>goto</code> 会将程序跳转到相同函数的指定标签处。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GotoStmt = <span class="string">&quot;goto&quot;</span> Label .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> Error</span><br></pre></td></tr></table></figure>



<p>goto 语句不允许跳过作用域内程序变量的初始化工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> L  <span class="comment">// BAD</span></span><br><span class="line">	v := <span class="number">3</span></span><br><span class="line">L:</span><br></pre></td></tr></table></figure>



<p>上面的程序是错误的，因为它跳过了变量 v 的初始化过程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">	<span class="keyword">goto</span> L1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">	f()</span><br><span class="line">	n--</span><br><span class="line">L1:</span><br><span class="line">	f()</span><br><span class="line">	n--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>标签作用域外的 goto 语句不能跳转到标签处，所以上面的代码是错误的。</p>
<h4 id="Fallthrough-语句"><a href="#Fallthrough-语句" class="headerlink" title="Fallthrough 语句"></a>Fallthrough 语句</h4><p><code>fallthrough</code> 语句会跳转到 <code>switch</code> 语句中的下一个 case 分句中。它应该只在最后一个非空分句中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FallthroughStmt = <span class="string">&quot;fallthrough&quot;</span> .</span><br></pre></td></tr></table></figure>



<h4 id="Defer-语句"><a href="#Defer-语句" class="headerlink" title="Defer 语句"></a>Defer 语句</h4><p><code>defer</code> 语句会在包裹函数返回后触发函数调用。这里的返回泛指函数因为 return 语句终止、到达函数末尾或者当前 goroutine 触发运行时恐慌。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DeferStmt = <span class="string">&quot;defer&quot;</span> Expression .</span><br></pre></td></tr></table></figure>



<p>表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数会有一些限制。</p>
<p>每次执行 defer 语句执行时都会计算函数的参数和值，但是并不会调用函数。相反，函数的调用是在包裹函数返回后进行，它们的执行顺序与声明顺序正好相反。如果 defer 对应的函数值为 nil，会在调用函数的时候导致运行时恐慌而不是声明 defer 语句的时候。</p>
<p>例如：当 defer 函数为函数字面值且包裹函数具有命名结果值，此时，我们在defer 函数中可以访问和修改命名的结果值。defer 函数的所有返回值都会被忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lock(l)</span><br><span class="line"><span class="keyword">defer</span> unlock(l)  <span class="comment">// unlocking happens before surrounding function returns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prints 3 2 1 0 before surrounding function returns</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f returns 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		result++</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>内置函数是预定义的。调用他们和其他函数一样只是他们接受一个类型而不是一个表达式。</p>
<p>内置函数没有标准的 Go 类型，所以他们只能作为调用表达式；而不能作为函数的值。</p>
<h6 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h6><p>对于管道类型 c，内置函数 <code>close(c)</code> 意味着不在有数据插入到管道中。如果 <code>c</code> 是一个只接收数据的管道，会发生错误。向已经关闭的发送数据或者重复关闭已经关闭的管道会导致运行时恐慌。关闭 nil 管道会引起运行时恐慌。调用 close 后所有之前发送的数据都能接收到，并且在最后不会阻塞而返回零值。多值的接收操作能够返回接收到的数据和表示管道是否关闭的布尔值。</p>
<h6 id="长度和容积"><a href="#长度和容积" class="headerlink" title="长度和容积"></a>长度和容积</h6><p>内置函数 <code>len</code> 和 <code>cap</code> 可以接收多种类型的参数，并且返回一个 int 类型结果值。函数的实现能够确保结果值不会溢出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Call      Argument <span class="keyword">type</span>    Result</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(s)    <span class="type">string</span> <span class="keyword">type</span>      <span class="type">string</span> length in bytes</span><br><span class="line">          [n]T, *[n]T      array length (== n)</span><br><span class="line">          []T              slice length</span><br><span class="line">          <span class="keyword">map</span>[K]T          <span class="keyword">map</span> length (number of defined keys)</span><br><span class="line">          <span class="keyword">chan</span> T           number of elements queued in channel buffer</span><br><span class="line"></span><br><span class="line"><span class="built_in">cap</span>(s)    [n]T, *[n]T      array length (== n)</span><br><span class="line">          []T              slice capacity</span><br><span class="line">          <span class="keyword">chan</span> T           channel buffer capacity</span><br></pre></td></tr></table></figure>



<p>切片的容积底层数组包含的元素个数。在任何情况下都有以下关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= <span class="built_in">len</span>(s) &lt;= <span class="built_in">cap</span>(s)</span><br></pre></td></tr></table></figure>



<p><code>nil</code> 切片，map，或者 channel 的长度都为 0。<code>nil</code> 切片，管道的容积都为 0。</p>
<p>表达式 <code>len(x)</code> 在 <code>s</code> 是字符串常量时也为常量。如果 <code>s</code> 为数组或者指向数组的指针并且表达式 s 不包含 <code>channel</code> 接收器或者函数调用那么 <code>len(s)</code> 和 <code>cap(s)</code> 也是常量；在这个情况下 s 时不能求值的。其他情况下 <code>len</code> 和 <code>cap</code> 不是常量并且 <code>s</code> 是可以求值的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	c1 = <span class="built_in">imag</span>(<span class="number">2i</span>)                    <span class="comment">// imag(2i) = 2.0 is a constant</span></span><br><span class="line">	c2 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;<span class="number">2</span>&#125;)         <span class="comment">// [10]float64&#123;2&#125; contains no function calls</span></span><br><span class="line">	c3 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;c1&#125;)        <span class="comment">// [10]float64&#123;c1&#125; contains no function calls</span></span><br><span class="line">	c4 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;<span class="built_in">imag</span>(<span class="number">2i</span>)&#125;)  <span class="comment">// imag(2i) is a constant and no function call is issued</span></span><br><span class="line">	c5 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;<span class="built_in">imag</span>(z)&#125;)   <span class="comment">// invalid: imag(z) is a (non-constant) function call</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span></span><br></pre></td></tr></table></figure>



<h6 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h6><p>内置函数 <code>new</code> 接收一个类型 T，它会在运行时给变量分配内存，并且返回一个指向类型 <code>T</code> 的 <code>*T</code> 类型指针。变量的初始化在初始化值章节中介绍。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123; a <span class="type">int</span>; b <span class="type">float64</span> &#125;</span><br><span class="line"><span class="built_in">new</span>(S)</span><br></pre></td></tr></table></figure>



<p>给 S 类型的变量分配空间，并初始化它（<code>a=0</code>，<code>b=0.0</code>），并且返回一个 <code>*S</code> 类型值保存变量所在的位置。</p>
<h6 id="创建切片，map-和-管道"><a href="#创建切片，map-和-管道" class="headerlink" title="创建切片，map 和 管道"></a>创建切片，map 和 管道</h6><p>内置函数 <code>make</code> 以一个类型作为参数，它必须是一个切片，map 或者管道类型，它返回一个 T 类型的值，而不是（*T）类型，它会按初始化值章节描述的方式进行初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Call             Type T     Result</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(T, n)       slice      slice of <span class="keyword">type</span> T with length n and capacity n</span><br><span class="line"><span class="built_in">make</span>(T, n, m)    slice      slice of <span class="keyword">type</span> T with length n and capacity m</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(T)          <span class="keyword">map</span>        <span class="keyword">map</span> of <span class="keyword">type</span> T</span><br><span class="line"><span class="built_in">make</span>(T, n)       <span class="keyword">map</span>        <span class="keyword">map</span> of <span class="keyword">type</span> T with initial space <span class="keyword">for</span> approximately n elements</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(T)          channel    unbuffered channel of <span class="keyword">type</span> T</span><br><span class="line"><span class="built_in">make</span>(T, n)       channel    buffered channel of <span class="keyword">type</span> T, buffer size n</span><br></pre></td></tr></table></figure>



<p>n 和 m 必须是整数类型或者无类型常量。一个常量参数不能为负数并且该值在 <code>int</code> 类型的范围内；如果它是无类型常量，会被转换成 <code>int</code> 类型。如果 n 和 m 都是常量，那么 n 必须大于 m。如果 n 是负数或者大于 m 会引发运行时 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">100</span>)       <span class="comment">// slice with len(s) == 10, cap(s) == 100</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1e3</span>)           <span class="comment">// slice with len(s) == cap(s) == 1000</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>&lt;&lt;<span class="number">63</span>)         <span class="comment">// illegal: len(s) is not representable by a value of type int</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">0</span>)         <span class="comment">// illegal: len(s) &gt; cap(s)</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)         <span class="comment">// channel with a buffer size of 10</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>)  <span class="comment">// map with initial space for approximately 100 elements</span></span><br></pre></td></tr></table></figure>



<p>使用 make 来指定大小初始化 map 类型将会创建一个预留 n 个元素空间的 map 类型。更详细的行为依赖于具体实现。</p>
<h6 id="追加或者拷贝切片"><a href="#追加或者拷贝切片" class="headerlink" title="追加或者拷贝切片"></a>追加或者拷贝切片</h6><p>内置函数 <code>append</code> 和 <code>copy</code> 可以进行切片的通用操作。对于这两个函数，一个是拷贝内存，一个是引用内存。</p>
<p>可变参数的函数 <code>append</code> 可以向切片 s 中追加一个或多个 x 值，并返回这个切片。传进 <code>...T</code> 的值会根据参数传值。作为特例，<code>append</code> 在 s 为 <code>[]byte</code> 切片时，可以使用字符串后面跟 <code>...</code> 作为参数。</p>
<p>如果 s 的容积容纳不下这些元素，那么 <code>append</code> 会分配一个新的足够大的数组。否则会使用原来的底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s0 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">s1 := <span class="built_in">append</span>(s0, <span class="number">2</span>)                <span class="comment">// append a single element     s1 == []int&#123;0, 0, 2&#125;</span></span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)          <span class="comment">// append multiple elements    s2 == []int&#123;0, 0, 2, 3, 5, 7&#125;</span></span><br><span class="line">s3 := <span class="built_in">append</span>(s2, s0...)            <span class="comment">// append a slice              s3 == []int&#123;0, 0, 2, 3, 5, 7, 0, 0&#125;</span></span><br><span class="line">s4 := <span class="built_in">append</span>(s3[<span class="number">3</span>:<span class="number">6</span>], s3[<span class="number">2</span>:]...)   <span class="comment">// append overlapping slice    s4 == []int&#123;3, 5, 7, 2, 3, 5, 7, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = <span class="built_in">append</span>(t, <span class="number">42</span>, <span class="number">3.1415</span>, <span class="string">&quot;foo&quot;</span>)   <span class="comment">//                             t == []interface&#123;&#125;&#123;42, 3.1415, &quot;foo&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">&quot;bar&quot;</span>...)            <span class="comment">// append string contents      b == []byte&#123;&#x27;b&#x27;, &#x27;a&#x27;, &#x27;r&#x27; &#125;</span></span><br></pre></td></tr></table></figure>



<p><code>copy</code> 函数从 <code>src</code> 拷贝原属到 <code>dst</code> 并且返回拷贝元素的个数。参数中所有的元素类型必须是 T 类型或者能转换成 T 的类型。拷贝元素的数量是 <code>len(src)</code> 和 <code>len(dst)</code> 中的较小值。作为特例，<code>copy</code> 可以从 string 类型拷贝元素到 <code>[]byte</code> 类型。这会把字符串中的元素拷贝到字节切片中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dst, src []T) <span class="type">int</span></span><br><span class="line"><span class="built_in">copy</span>(dst []<span class="type">byte</span>, src <span class="type">string</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">n1 := <span class="built_in">copy</span>(s, a[<span class="number">0</span>:])            <span class="comment">// n1 == 6, s == []int&#123;0, 1, 2, 3, 4, 5&#125;</span></span><br><span class="line">n2 := <span class="built_in">copy</span>(s, s[<span class="number">2</span>:])            <span class="comment">// n2 == 4, s == []int&#123;2, 3, 4, 5, 4, 5&#125;</span></span><br><span class="line">n3 := <span class="built_in">copy</span>(b, <span class="string">&quot;Hello, World!&quot;</span>)  <span class="comment">// n3 == 5, b == []byte(&quot;Hello&quot;)</span></span><br></pre></td></tr></table></figure>



<h6 id="删除-map-中的元素"><a href="#删除-map-中的元素" class="headerlink" title="删除 map 中的元素"></a>删除 map 中的元素</h6><p>内置函数 <code>delete</code> 移除 map 类型 m 中的键值 k。k 的类型必须是能够转换成 m 键类型的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, k)  <span class="comment">// remove element m[k] from map m</span></span><br></pre></td></tr></table></figure>



<p>如果 map 类型 m 是 nil 或者 m[k] 不存在，那么 <code>delete</code> 函数不做任何事情。</p>
<h6 id="操作复数"><a href="#操作复数" class="headerlink" title="操作复数"></a>操作复数</h6><p>有三个函数可以组装或者分解复数。内置函数 <code>complex</code> 会构造一个复数，<code>real</code> 和 <code>imag</code> 会分解出复数的实部和虚部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>(realPart, imaginaryPart floatT) complexT</span><br><span class="line"><span class="built_in">real</span>(complexT) floatT</span><br><span class="line"><span class="built_in">imag</span>(complexT) floatT</span><br></pre></td></tr></table></figure>



<p>参数的类型和返回值类型是对应的。对于 <code>complex</code>，两个参数必须是相同的浮点类型，并返回由相同浮点数组成的复数类型。<code>complex64</code> 是 <code>float32</code> 对应的类型，<code>complex128</code> 是 <code>float64</code> 对应的参数类型。如果参数是一个无类型常量，它会转换成另一个参数的类型。如果两个参数都是无类型常量，他们必须实数或者虚数部分为零，并且它会返回一个无类型的复数常量。</p>
<p><code>real</code> 和 <code>imag</code> 函数和 <code>complex</code> 正好相反的，所以对于一个值复数类型 Z 的值 z，<code>z==Z(complex(real(z),imag(z)))</code>。</p>
<p>如果这么操作都是常量，那么返回的值也是常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">complex</span>(<span class="number">2</span>, <span class="number">-2</span>)             <span class="comment">// complex128</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">complex</span>(<span class="number">1.0</span>, <span class="number">-1.4</span>)       <span class="comment">// untyped complex constant 1 - 1.4i</span></span><br><span class="line">x := <span class="type">float32</span>(math.Cos(math.Pi/<span class="number">2</span>))  <span class="comment">// float32</span></span><br><span class="line"><span class="keyword">var</span> c64 = <span class="built_in">complex</span>(<span class="number">5</span>, -x)           <span class="comment">// complex64</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">uint</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">0</span>)         <span class="comment">// untyped complex constant 1 + 0i can be converted to uint</span></span><br><span class="line">_ = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>&lt;&lt;s)               <span class="comment">// illegal: 2 assumes floating-point type, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> rl = <span class="built_in">real</span>(c64)                 <span class="comment">// float32</span></span><br><span class="line"><span class="keyword">var</span> im = <span class="built_in">imag</span>(a)                   <span class="comment">// float64</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">imag</span>(b)                  <span class="comment">// untyped constant -1.4</span></span><br><span class="line">_ = <span class="built_in">imag</span>(<span class="number">3</span> &lt;&lt; s)                   <span class="comment">// illegal: 3 assumes complex type, cannot shift</span></span><br></pre></td></tr></table></figure>



<h6 id="处理-panic"><a href="#处理-panic" class="headerlink" title="处理 panic"></a>处理 panic</h6><p>两个内置函数 <code>panic</code> 和 <code>recover</code>，可以抛出和处理运行时 <code>panic</code> 和程序的错误条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>当执行 F 函数时，显式的调用 <code>panic</code>或者运行时 panic 都会中断 F 的执行。但是 F 中的延迟函数还会执行。接下来调用 F 函数处的延迟函数也会执行，一直到顶级的延迟函数。鉴于这点，程序关闭并且错误条件可以抛出。包括 <code>panic</code> 中的值。这个顺序叫做 <code>panicking</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="number">42</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(Error(<span class="string">&quot;cannot parse&quot;</span>))</span><br></pre></td></tr></table></figure>



<p><code>recover</code> 函数允许程序从一个 panicking 中恢复执行。假设函数 G 延迟执行函数 D ，在 D 中调用 <code>recover</code> 这时如果在 G 执行时发生 panic 会在 D 中恢复。当函数执行到 D，<code>recover</code> 的返回值会返回 <code>panic</code> 对应的错误，并且终止 <code>panicking</code> 。在这个情况下 G 函数和 <code>panic</code> 之间的代码不会执行。任何在 D 中 G 之前的延迟函数会返回到调用者。</p>
<p>在下面两种情况下 <code>recover</code> 会返回 nil：</p>
<ul>
<li><p>panic 的参数为 nil</p>
</li>
<li><p>携程里没有发生 panic</p>
</li>
<li><p>recover 不是在延迟函数中执行</p>
</li>
</ul>
<p>本例中的 <code>protect</code> 函数会在 g 发生 panic 的时候恢复执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;done&quot;</span>)  <span class="comment">// Println executes normally even if there is a panic</span></span><br><span class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;run time panic: %v&quot;</span>, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	log.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>这个实现提供了多个内置函数来帮助进行初始化。这些函数用来输出信息但是不确定会一直存在于语言中，他们都没有返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Function   Behavior</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>      prints all arguments; formatting of arguments is implementation-specific</span><br><span class="line"><span class="built_in">println</span>    like <span class="built_in">print</span> but prints spaces between arguments and a newline at the end</span><br></pre></td></tr></table></figure>



<p>实现限制：<code>print</code> 和 <code>println</code> 不接受除了布尔值，数字，字符串以外的其他类型。</p>
<h4 id="程序的初始化和执行"><a href="#程序的初始化和执行" class="headerlink" title="程序的初始化和执行"></a>程序的初始化和执行</h4><h6 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h6><p>当为变量分配内存空间时，不管是声明还是调用 <code>new</code> 或者使用字面值和 <code>make</code> 初始化，只要创建了一个新值变量都会有一个默认值。这样的元素和值会使用它类型的零值：<code>false</code> 是布尔值的零值，0 为数值类型零值，”” 为字符串零值，nil 为指针，函数，接口，切片，频道，字典。初始化会递归完成，所以结构体里的数组中的元素也都会有它自己的零值。</p>
<p>下面两个声明时相等的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>请看下面的声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; i <span class="type">int</span>; f <span class="type">float64</span>; next *T &#125;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line">t.i == <span class="number">0</span></span><br><span class="line">t.f == <span class="number">0.0</span></span><br><span class="line">t.next == <span class="literal">nil</span></span><br></pre></td></tr></table></figure>



<p>这和下面的声明时同等效果的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br></pre></td></tr></table></figure>



<h6 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h6><p>保级变量会按声明的顺序进行初始化，如果依赖其他变量，则会在其他变量之后进行初始化。</p>
<p>更确切的说，如果包级变量还没初始化并且没有初始化表达式或者表达式中不包含对其他未初始化变量的依赖，那么会认为它正在等待初始化。初始化过程会从最早声明的变量开始向下一个包级变量重复，直到没有需要初始化的变量。</p>
<p>如果在初始化过程完成后还有未初始化的变量，那么这些变量可能是循环初始化了，这事程序不是合法的。</p>
<p>在多个文件中变量的声明顺序会依据编译时文件出现的顺序：声明在第一个文件中的变量优先于第二个文件中声明的变量，依此类推。</p>
<p>对依赖关系的分析不会根据变量的具体值，它只分析在源码中是否引用了其他变量。例如，如果变量 x 的初始化表达式引用了变量 y 那么 x 就依赖于 y：</p>
<ul>
<li><p>引用一个变量或者函数中用到了一个变量</p>
</li>
<li><p>引用了一个方法值 <code>m</code> 或者方法表达式 <code>t.m</code> (这里的静态类型 <code>t</code> 不是借口类型，并且方法 <code>m</code> 是 <code>t</code> 方法集中的方法)。<code>t.m</code> 的返回值不会在此时影响。</p>
</li>
<li><p>变量，函数，或者方法 x 依赖变量 y</p>
</li>
</ul>
<p>依赖分析会在每个包中执行；他只考虑当前包中的析变量，函数，和方法。</p>
<p>例如，给定声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a = c + b</span><br><span class="line">	b = f()</span><br><span class="line">	c = f()</span><br><span class="line">	d = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	d++</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化顺序为 d，b，c，a。</p>
<p>变量可以在包中声明的初始化函数 <code>init</code> 中进行初始化，它没有参数和返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>可以为每个包定义多个该函数，甚至在一个文件中也可以。并且不会声明该该标识符。因此 init 函数不能在程序中调用。</p>
<p>还未导入的包会先初始化包级的变量然后按照 <code>init</code> 函数在源码中的顺序调用，它可能在包的多个文件中。如果需要导入一个包，它会在初始化自己之前先初始化这个需要导入的包。如果导入一个包多次，那这个包只会初始化一次。导入的包不能存在循环引用。</p>
<p>包的初始化——变量初始化和对 init 函数的调用会按顺序发生在同一个 goroutine 中。 <code>init</code> 函数可能会启动其他 goroutine。不过一般 <code>init</code> 函数都是按序进行初始化的：它只在上一步已经执行完成时才会调用下一个步骤。</p>
<p>确保初始化行为是可以复现的，构建系统鼓励在同一个包中包含多个文件这些文件在编译器中会以字母排序。</p>
<h6 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h6><p>一个完整的程序由一个 <code>main</code> 包导入所有需要的包。<code>main</code> 包必须以 <code>main</code> 作为包名并且声明一个没有参数和返回值的 <code>main</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>程序先初始化 <code>main</code> 包然后调用 <code>main</code> 函数。当 <code>main</code> 函数返回时，程序就会退出。它不会等待其他 goroutines 完成。</p>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>预定义的错误类型为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它是表示错误信息的常规接口，nil 代表没有发生错误。例如，在文件中读取数据可以定义为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(f *File, b []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h4 id="运行时恐慌"><a href="#运行时恐慌" class="headerlink" title="运行时恐慌"></a>运行时恐慌</h4><p>运行时错误（例如数组的越界访问）会造成运行时恐慌，它和以 <code>runtime.Error</code> 接口实现调用内置的 <code>panic</code> 函数一样。<code>runtime.Error</code> 满足预定义的 <code>error</code> 接口。不同的错误值代表不同的运行时错误条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> runtime</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="type">error</span></span><br><span class="line">	<span class="comment">// and perhaps other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h4><h6 id="unsafe-包"><a href="#unsafe-包" class="headerlink" title="unsafe 包"></a>unsafe 包</h6><p><code>unsafe</code> 是编译器已知的内置包，可以通过导入路径 <code>unsafe</code> 访问包内容，提供 <code>unsafe</code> 包目的是支持底层编程（包括操作非 Go 类型的数据结构）。使用 <code>unsafe</code> 包必须自己保证类型安全而且它有可能破坏程序的移植性。<code>unsafe</code> 包提供了以下接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span>  <span class="comment">// 任意一个 Go 类型；它不是一个具体的类型。</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(variable ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(selector ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(variable ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>



<p><code>Pointer</code> 是一个指针类型，但是不能解引用 <code>Pointer</code> 的值。所有底层类型 <code>uintptr</code> 的指针和值都能转换成 <code>Pointer</code> 类型，反之亦然。<code>Pointer</code> 和  <code>uintptr</code> 之间的转换效果由具体实现定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br><span class="line">bits = *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f))</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ptr unsafe.Pointer</span><br><span class="line">bits = *(*<span class="type">uint64</span>)(ptr(&amp;f))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p ptr = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>



<p>假设变量 v 由 <code>var v = x</code> 定义。<code>Alignof</code> 以表达式 x 作为参数并返回 x 的对齐字节数。<code>Sizeof</code> 以表达式 x 作为参数并返回 x 的大小。</p>
<p>函数 <code>Offsetof</code> 以选择器 <code>s.f</code>（ s 或者 *s 结构体中的 f 字段）作为参数，返回字段相对结构体首地址的位置。如果 f 是一个嵌入字段，那 f 必须可以直接访问（不能通过指针进行间接访问）。对于结构体 s 的 f 字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == <span class="type">uintptr</span>(unsafe.Pointer(&amp;s.f))</span><br></pre></td></tr></table></figure>



<p>计算机的体系结构要求对齐内存地址（对于一个变量的地址有多种因素影响对齐）。<code>Alignof</code> 函数获取一个人和类型的表达式并返回变量对齐的字节数。对于变量 x：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>编译时 <code>uintptr</code> 类型常量表达式会调用 <code>Alignof</code>，<code>Offsetof</code>，和 <code>Sizeof</code>。</p>
<h6 id="确定的大小和对齐字节数"><a href="#确定的大小和对齐字节数" class="headerlink" title="确定的大小和对齐字节数"></a>确定的大小和对齐字节数</h6><p>对于数字类型，确定有以下尺寸：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>                                 size in bytes</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>, <span class="type">uint8</span>, <span class="type">int8</span>                     <span class="number">1</span></span><br><span class="line"><span class="type">uint16</span>, <span class="type">int16</span>                         <span class="number">2</span></span><br><span class="line"><span class="type">uint32</span>, <span class="type">int32</span>, <span class="type">float32</span>                <span class="number">4</span></span><br><span class="line"><span class="type">uint64</span>, <span class="type">int64</span>, <span class="type">float64</span>, <span class="type">complex64</span>     <span class="number">8</span></span><br><span class="line"><span class="type">complex128</span>                           <span class="number">16</span></span><br></pre></td></tr></table></figure>



<p>Go 中规定的最小对齐特性：</p>
<ol>
<li><p>对于任意变量类型 x：<code>unsafe.Alignof(x)</code> 至少为 1。</p>
</li>
<li><p>对于结构体类型：<code>unsafe.Alignof(x)</code> 是所有内部字段 <code>unsafe.Alignof(x.f)</code> 的最大值，并且至少为 1。</p>
</li>
<li><p>对于数组类型：<code>unsafe.Alignof(x)</code> 和数组元素类型的 alignment 相同。</p>
</li>
</ol>
<p>结构体（数组）在内部没有字段（元素）的时候大小为 0。两个所占空间大小为 0 的不同变量可能在内存中拥有相同地址。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI/ISO七层网络</title>
    <url>/2023/08/31/OSI-ISO%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp; 七层网络的常见设备，如下图所示：<br><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png" alt="七层网络的常见设备"></p>
<p>&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：<br><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif" alt="七层网络的常见协议与功能"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>IP数据报</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 OGNL 与  Mybatis 源代码分析一次 Mybatis 升级引发的线上事故</title>
    <url>/2023/08/31/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -&gt; 3.4.4：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png" alt="mybatis前后版本升级"></p>
<p>&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="报错信息"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。</p>
<p>&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png" alt="分别引入两个版本的依赖"></p>
<p>&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png" alt="数据库脚本"></p>
<p>&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png" alt="dao层方法调用"></p>
<p>&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">invalid comparision:  java.util.HashMap and java.lang.String</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!&#x3D;’’ 将_parameter 与 ‘’ 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 ‘’ 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 但是问题又来了，<strong>为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？</strong> 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png" alt="ifnode"></p>
<p>&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 … &amp;&amp; _parameter!&#x3D;’’ 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mybatis-3.2.5  -&gt;  ognl-2.6.9</span><br><span class="line">mybatis-3.4.4  -&gt;  ognl-3.1.14</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png" alt="高版本 OGNL 代码"></p>
<p>&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png" alt="低版本 OGNL 代码"></p>
<p>&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png" alt="类型标记"></p>
<p>&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!&#x3D;’’ 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ‘’）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png" alt="调试信息如下"></p>
<p>&ensp;&ensp;&ensp;&ensp; 解释一下：t1 &#x3D; t2 &#x3D; 10，表示 _parameter 与 ‘’ 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 &#x3D; ‘’。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。</p>
<p>&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -&gt; String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本。接下来我们看方法外面这个 equals 的来源：</strong></p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png" alt="equals"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。</p>
<p>&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： _<em>低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 <em>parameter!&#x3D;’’ 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。</em></em></p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>反思：</strong></p>
<ul>
<li><strong>日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。</strong></li>
<li><strong>组件升级要慎之又慎，测试要充分。</strong></li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>问题记录</tag>
        <tag>线上事故</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>GC——全流程</title>
    <url>/2023/08/29/GC%E2%80%94%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、minorGC-和-Full-GC-区别"><a href="#1、minorGC-和-Full-GC-区别" class="headerlink" title="1、minorGC 和 Full GC 区别"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>
<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>
<h4 id="2、minorGC-过程详解"><a href="#2、minorGC-过程详解" class="headerlink" title="2、minorGC 过程详解"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png" alt="图一"></p>
<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png" alt="图二"></p>
<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png" alt="图三"></p>
<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png" alt="图四"></p>
<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png" alt="图五"></p>
<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png" alt="图六"></p>
<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png" alt="图七"></p>
<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>
<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>
<h4 id="3、整体描述"><a href="#3、整体描述" class="headerlink" title="3、整体描述"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>
<h4 id="4、GC-触发条件"><a href="#4、GC-触发条件" class="headerlink" title="4、GC 触发条件"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>
<ul>
<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>
<li>老年代空间不足；</li>
<li>方法去空间不足；</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>
<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>
</ul>
<h4 id="5、对象进入老年代的四种情况"><a href="#5、对象进入老年代的四种情况" class="headerlink" title="5、对象进入老年代的四种情况"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png" alt="图八"></p>
<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png" alt="图九"></p>
<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>
<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png" alt="图十"></p>
<h4 id="6、空间分配担保"><a href="#6、空间分配担保" class="headerlink" title="6、空间分配担保"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>
<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S架构图</title>
    <url>/2023/08/29/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 谷歌早期内部 Brog 系统架构图：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/Brog%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Brog架构图"></p>
<p>&ensp;&ensp;&ensp;&ensp; K8S 架构图：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="K8S架构图"></p>
<p>&ensp;&ensp;&ensp;&ensp; K8S 分层架构：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.webp" alt="K8S分层架构"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算领域</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>IP数据报</title>
    <url>/2023/08/29/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>
<!-- ![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true) -->


<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="IP报文结构"></p>
<h4 id="1、固定部分"><a href="#1、固定部分" class="headerlink" title="1、固定部分"></a><strong>1、固定部分</strong></h4><ul>
<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>
<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>
<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>
<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>
<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>
<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>
<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>
<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>
<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>
<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>
<li>源地址和目的地址：32位，IPV4 地址。</li>
</ul>
<h4 id="2、可变部分"><a href="#2、可变部分" class="headerlink" title="2、可变部分"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>
<ul>
<li>安全和处理限制（用于军事领域）。</li>
<li>记录路径（让每个路由器都记下它的IP地址）。</li>
<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>
<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>
<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>IP数据报</tag>
      </tags>
  </entry>
  <entry>
    <title>Innodb中的事务隔离级别和锁实现</title>
    <url>/2023/08/29/Innodb%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring全景</title>
    <url>/2023/08/29/Spring%E5%85%A8%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png" alt="Spring 全景图"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java EE</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 架构图</title>
    <url>/2023/08/29/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="Dubbo 架构图"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>Java EE</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>保持敬畏之心</title>
    <url>/2023/08/29/%E4%BF%9D%E6%8C%81%E6%95%AC%E7%95%8F%E4%B9%8B%E5%BF%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行常用指令</title>
    <url>/2023/08/29/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp; MySQL 创建数据库并指定字符集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop schema if exists `test`;</span><br><span class="line">CREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; Brew 相关的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 先卸载Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class="line">// 然后在安装</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">// 搜索包</span><br><span class="line">brew search mysql</span><br><span class="line">// 安装包</span><br><span class="line">brew install mysql</span><br><span class="line">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span><br><span class="line">brew info mysql</span><br><span class="line">// 卸载包</span><br><span class="line">brew uninstall wget</span><br><span class="line">// 显示已安装的包</span><br><span class="line">brew list</span><br><span class="line">// 查看brew的帮助</span><br><span class="line">brew –help</span><br><span class="line">// 更新， 这会更新 Homebrew 自己</span><br><span class="line">brew update</span><br><span class="line">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class="line">brew outdated</span><br><span class="line">brew outdated mysql</span><br><span class="line">// 升级所有可以升级的软件们</span><br><span class="line">brew upgrade</span><br><span class="line">brew upgrade mysql</span><br><span class="line">// 清理不需要的版本极其安装包缓存</span><br><span class="line">brew cleanup</span><br><span class="line">brew cleanup mysql</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-DCMAKE_BUILD_TYPE=Debug</span><br><span class="line">-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build</span><br><span class="line">-DWITH_SSL=system</span><br><span class="line"></span><br><span class="line">./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \</span><br><span class="line">--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \</span><br><span class="line">--initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; Git 相关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm origin </span><br><span class="line">git remote add origin [url]</span><br><span class="line">git config --global user.name &quot;杨海波&quot;</span><br><span class="line">git config --global user.email “3546514206@QQ.COM&quot;</span><br><span class="line"></span><br><span class="line">git rm -r --cached</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; 设置主机名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo scutil --set HostName SetsunaYang</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; Macbook Pro 显示被隐藏的文件或文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder </span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder</span><br><span class="line"></span><br><span class="line">chflags hidden</span><br><span class="line">chflags nohidden</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; 设置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;/opt/homebrew/opt/go@1.20/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; 修改环境变量相关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前 shell 是 zsh 还是 bash</span></span><br><span class="line">dscl . -read /Users/$USER UserShell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是 bash</span></span><br><span class="line">open ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 如果是 zsh</span></span><br><span class="line">open ~/.zshrc </span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; IDEA 相关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决 Goland 无法调试的问题。在 bin/goland.vmoptions 增加如下虚拟机参数</span></span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-Djava.net.preferIPv6Addresses=true</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>回调机制</title>
    <url>/2023/08/29/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、C语言中的回调"><a href="#1、C语言中的回调" class="headerlink" title="1、C语言中的回调"></a><strong>1、C语言中的回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp;max; <span class="comment">// &amp;可以省略 </span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = <span class="built_in">p</span>(<span class="built_in">p</span>(a, b), c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 输出的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入三个数字:1 2 3 </span><br><span class="line">最大的数字是: 3</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure>

<h4 id="2、什么是回调"><a href="#2、什么是回调" class="headerlink" title="2、什么是回调"></a><strong>2、什么是回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 </p>
<p>&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。</p>
<p>&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 </p>
<p>&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg" alt="程序调用的几种方式"></p>
<p>&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：</p>
<ul>
<li><p>属于工作流的一个部分； </p>
</li>
<li><p>必须按照工作流指定的调用约定来申明（定义）； </p>
</li>
<li><p>他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title>GC——基础知识</title>
    <url>/2023/08/28/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>
<h4 id="1、可达性分析算法（GC-Roots）"><a href="#1、可达性分析算法（GC-Roots）" class="headerlink" title="1、可达性分析算法（GC Roots）"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>
<ul>
<li>虚拟机栈（本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ul>
<h4 id="2、JVM中的堆结构"><a href="#2、JVM中的堆结构" class="headerlink" title="2、JVM中的堆结构"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png" alt="JVM 分代比例"></p>
<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="JVM 内存模型全景"></p>
<h4 id="2-1、为何新生代要分为三个区"><a href="#2-1、为何新生代要分为三个区" class="headerlink" title="2.1、为何新生代要分为三个区"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>
<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>
<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>
<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>
<h4 id="2-2、新生代对象的分配和回收"><a href="#2-2、新生代对象的分配和回收" class="headerlink" title="2.2、新生代对象的分配和回收"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>
<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>
<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>
<h4 id="2-3、老年代对象的分配和回收"><a href="#2-3、老年代对象的分配和回收" class="headerlink" title="2.3、老年代对象的分配和回收"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>
<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>
<h4 id="3、JVM完整的GC流程"><a href="#3、JVM完整的GC流程" class="headerlink" title="3、JVM完整的GC流程"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>
<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>
<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>内核页表设计</title>
    <url>/2023/08/28/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png" alt="内核页表设计"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
