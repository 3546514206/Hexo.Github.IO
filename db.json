{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/SETSUNAYANG.JPG","path":"images/SETSUNAYANG.JPG","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/beian.png","path":"images/beian.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/gitee.png","path":"images/gitee.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/github.png","path":"images/github.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","path":"images/hexo-tag-chart.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/hexo.png","path":"images/hexo.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","path":"js/jquery-3.6.0.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/dz.js","path":"js/dz.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","path":"css/fonts/remixicon.eot","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","path":"css/fonts/remixicon.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","path":"css/fonts/remixicon.ttf","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","path":"css/fonts/remixicon.woff","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","path":"css/fonts/remixicon.woff2","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.css","path":"css/fonts/remixicon.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/GC—全过程.md","hash":"de0d35c3308e274b2e799b1dba90fc6290dfd30a","modified":1693298806083},{"_id":"source/_posts/IP数据报.md","hash":"3414c22799b309e1c3ec403ca1a103e536e22429","modified":1693297924881},{"_id":"source/_posts/Innodb中的事务隔离级别和锁实现.md","hash":"fabf5ccf276bb4a920822527dfe96f5463336913","modified":1693270339195},{"_id":"source/_posts/GC—基础知识.md","hash":"8219b8ff1d2210e4b399beb15441db650d016723","modified":1693297892113},{"_id":"source/_posts/Qt简介.md","hash":"9c065482308d5a3f3893be53ca9d5291d7cf7ca6","modified":1693270271155},{"_id":"source/_posts/Spring全景.md","hash":"bedf71622137fddf363040d0070c244cf1d8d536","modified":1693297967817},{"_id":"source/_posts/C-程序内存分区.md","hash":"6c75135ddf277cf84506f2526da3afaddc020e9d","modified":1693242893164},{"_id":"source/_posts/Tomcat启动流程.md","hash":"c46385ca4d413ab3bc63a2e6e3f1320bec08eaa6","modified":1693270322837},{"_id":"source/_posts/内核页表设计.md","hash":"06cdb3cda566e8e882f452984b99dbfe760ddcb2","modified":1693297836275},{"_id":"source/_posts/保持敬畏之心.md","hash":"d6fa6f11e1ce3364201bdd863e3afcc4b34adf42","modified":1693270377511},{"_id":"source/_posts/K8S架构图.md","hash":"122c7de78560ab48872bb396307af83fb2d7315c","modified":1693297946736},{"_id":"source/_posts/命令行常用指令.md","hash":"84b0ab44f05eee533752435bc531bd3b778e7bc0","modified":1693243120791},{"_id":"source/_posts/回调机制.md","hash":"47e40adba8930c718502ddaa11d387ec26d81614","modified":1693242813897},{"_id":"source/_posts/本地调试Docker源码.md","hash":"dc8555351a31d323ce7016070c8e6432dade5872","modified":1693275776563},{"_id":"source/tags/index.md","hash":"231b06c7394538c47cd161c9d171c94890467b58","modified":1693237837078},{"_id":"source/categories/index.md","hash":"f4d7281acde67e8ebc5ffe566d10cad2ca568468","modified":1693237447813},{"_id":"themes/ayer/.DS_Store","hash":"cf44a39e65f9f875509e24e4548cbc77adf58775","modified":1693283450829},{"_id":"themes/ayer/_config.yml","hash":"069697c615fedec2854b2a6def49fb4ee77b6c0a","modified":1693291855209},{"_id":"themes/ayer/LICENSE","hash":"5f10900ed75022def5bf4c8639812671f0a6e2de","modified":1693145314875},{"_id":"themes/ayer/index.js","hash":"19292aa9df268dbab8ac51a2a3aa7a20ac1eb00a","modified":1693144166186},{"_id":"themes/ayer/README.md","hash":"06421a758735285fcc9f6b605f3576a958ee1e8a","modified":1693145314875},{"_id":"themes/ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1693144166197},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1693144166195},{"_id":"themes/ayer/layout/categories.ejs","hash":"c40f84aacdf7d33cfcb4eb9f78f331dad699abff","modified":1693144166195},{"_id":"themes/ayer/rollup.config.js","hash":"13b61821acd9fc27131a34853037184b94ae8577","modified":1693144166197},{"_id":"themes/ayer/package.json","hash":"6f287150874e25757493857c564be64189c0c008","modified":1693145314875},{"_id":"themes/ayer/layout/friends.ejs","hash":"18382cd4429588e58bf046beacaed06704832fe3","modified":1693144166195},{"_id":"themes/ayer/layout/index.ejs","hash":"77347cbb8635611d8b1fb84bde75f9dedaf8632d","modified":1693144166195},{"_id":"themes/ayer/move_config.js","hash":"e310bdb9a8738e506e53a40bd3cd895008d4cd61","modified":1693144166197},{"_id":"themes/ayer/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1693144166197},{"_id":"themes/ayer/layout/tags.ejs","hash":"88b34dd8d7b1e64fa27aa6ed72af996cf6700809","modified":1693144166197},{"_id":"themes/ayer/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1693144166197},{"_id":"themes/ayer/languages/default.yml","hash":"7e16c460c2c3d953c3bdebdef471ea747812b7a1","modified":1693144166186},{"_id":"themes/ayer/languages/en.yml","hash":"7e16c460c2c3d953c3bdebdef471ea747812b7a1","modified":1693144166187},{"_id":"themes/ayer/layout/plain-page.ejs","hash":"39cce1936f5f0e2feb924a7af2f52a631d81b84f","modified":1693144166197},{"_id":"themes/ayer/languages/es.yml","hash":"a3e8d81b99f62f86b3f34708253070b8806b31c8","modified":1693144166187},{"_id":"themes/ayer/languages/de.yml","hash":"cdeed93d1eb4e65195aaf97d8c517e97106ddfd5","modified":1693144166186},{"_id":"themes/ayer/languages/fr.yml","hash":"4a3cb84884988624943c6b0f8c1754da34943092","modified":1693144166187},{"_id":"themes/ayer/languages/no.yml","hash":"f8d7294f0d73ec35c37c050462cb725ea25a0fcc","modified":1693144166188},{"_id":"themes/ayer/languages/ja.yml","hash":"d2ccb7ac8c9ff2ee721843741bb30b019d0a8083","modified":1693144166187},{"_id":"themes/ayer/layout/layout.ejs","hash":"84864bd6b4fc92bdd0a8ccba491fe490a8ecbf9b","modified":1693283959738},{"_id":"themes/ayer/languages/pt.yml","hash":"b137b9aead0dc4e2c2d9217ceb270460e41f5cb3","modified":1693144166188},{"_id":"themes/ayer/languages/ru.yml","hash":"cdce73598db1aefb17b1c91658cfa4c906b98e24","modified":1693144166189},{"_id":"themes/ayer/languages/vi.yml","hash":"7d019ee795816a6a030a039d8238b71be04098fd","modified":1693144166189},{"_id":"themes/ayer/languages/nl.yml","hash":"2c289e97000c0c67636d96895aaa801c8abec0d4","modified":1693144166188},{"_id":"themes/ayer/languages/ko.yml","hash":"7dc54c2db864e5b725b55e201030e92acc1c422e","modified":1693144166187},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"edb2654bdb684fe0f21e8d6c841496c3506006ed","modified":1693144166189},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"68400b1859e58cba03b05020ac8f47b807933027","modified":1693144166189},{"_id":"themes/ayer/scripts/default_config.js","hash":"70d6ee032d75410d540b6789b5949739a47f0125","modified":1693144166199},{"_id":"themes/ayer/layout/_partial/ads.ejs","hash":"d36962c66e3653aa94cc428731dd43a7ea4f979d","modified":1693144166189},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1693283423888},{"_id":"themes/ayer/source/404.html","hash":"6e6ebc1161643ffa524c9ecf38af7cd8cf1c9ecc","modified":1693283423880},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"a56c8905987fa86657a9f081a89c12e5a5a5df54","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"3895f24a1ba9ef5d4a024b1f45a5f30bff9f9c7c","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"17ccda6fb61f1b6df94d23db936665c00a29a85b","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"9be7173badcca6582c1136204adb3aa432aada21","modified":1693144166189},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"01ca257dde90dcadf1288a641401f6cf21a0ad43","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1693144166190},{"_id":"themes/ayer/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1693282854268},{"_id":"themes/ayer/source-src/main.js","hash":"13c57a2cec878217a5a3ee9afb6705d4c3cc0d3c","modified":1693144166209},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"61100fe248a744fab5dc71fb610992cbeff27e54","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/float-btns.ejs","hash":"43ba0cd1f9e898bcbd873b1e9a2d47249d6aaf77","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"ca81abe75c80ab32d6b6c4fe65de8e74df07bef3","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/broadcast.ejs","hash":"c228fa93bcf2f8403729342854211ea976df9a9f","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"752666b28d5caed5e7d82d697d7546461e451d6f","modified":1693144166190},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"d38a59e2316b8a9c233c2f41edc2a03eab2c0a2e","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"cf441365eff1f8143e3c9ae54954d0ebe0a358e5","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"e3b411aef6e5f25f6c5c66b93d653ef70da8d4af","modified":1693144166194},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"7bcde0d6384819fd4c975a6e6e24e0919fbb1593","modified":1693144166194},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"7b3df58faaa875d17afbf74ddef5601116f2ce3d","modified":1693144166200},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"f9c8fceb2130929b8f11e22b1c3476c99d1574a8","modified":1693144166200},{"_id":"themes/ayer/scripts/events/index.js","hash":"2c84d99e881f5cd1ee8a406b595a4365f3aea41e","modified":1693144166199},{"_id":"themes/ayer/scripts/lib/core.js","hash":"7908a82a86d63f35c6f785cacb1cfaf99ae7e0f9","modified":1693144166200},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e435b782178da75656f9616c7af564fb9ff0de50","modified":1693144166199},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"58f4c93d22e4eb9743915223444335fb6fe06d21","modified":1693144166199},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"cde5caf73f120b1300ec7539bbf675597688c734","modified":1693144166191},{"_id":"themes/ayer/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1693144166200},{"_id":"themes/ayer/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1693144166200},{"_id":"themes/ayer/layout/_partial/lock.ejs","hash":"bbb00715c204197e7790d08be9a29afe5976146e","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"80a159273db944026701fe5062403e0f17cb8277","modified":1693145314909},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"017f9b628806eeb199da2e77485cd9ac8e2117b3","modified":1693283423880},{"_id":"themes/ayer/source/css/custom.styl","hash":"56276abe6cd7cbf49fbf4fd4c986733188374160","modified":1693283423880},{"_id":"themes/ayer/source/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1693283423888},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1693283423891},{"_id":"themes/ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1693283423891},{"_id":"themes/ayer/source/dist/main.js","hash":"158d69f927d1cee076a485e894f307fadbe9656c","modified":1693283423888},{"_id":"themes/ayer/source/images/SETSUNAYANG.JPG","hash":"b7612fc376c8afaccc1f6733a50bc35e8e897500","modified":1693283423889},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1693283423889},{"_id":"themes/ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1693283423891},{"_id":"themes/ayer/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1693283423891},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1693283423906},{"_id":"themes/ayer/source/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1693283423906},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1693283423906},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1693283423906},{"_id":"themes/ayer/source/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1693283423906},{"_id":"themes/ayer/source/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1693283423906},{"_id":"themes/ayer/source/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1693283423911},{"_id":"themes/ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1693283423908},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1693283423911},{"_id":"themes/ayer/source/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1693283423911},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1693283423911},{"_id":"themes/ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1693283423911},{"_id":"themes/ayer/source/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1693283423912},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1693283423912},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"66dc025b7f87fed31fabdba62a405f85ae443788","modified":1693145314905},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"8dedef428b6ac7d629e1d1f6039b0f60dacc4c5e","modified":1693144166200},{"_id":"themes/ayer/source-src/js/share.js","hash":"7edce2efe23e75e29765201dc8b00fd2a5b5c9d2","modified":1693144166209},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1693144166200},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"630e719b9e805a26182a37152435d4787c0f1734","modified":1693144166200},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1693283423912},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"ce395318edf69766fe11161c4587a97f84521d85","modified":1693144166207},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"910dd0682971a616e1610daec23e7ff5a556df98","modified":1693144166207},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"219753a5cf40cfbd557fbde01a71f589e6de4327","modified":1693144166200},{"_id":"themes/ayer/source-src/css/style.styl","hash":"3941939bdb95297488d19e3e3716d5925b6eed44","modified":1693144166208},{"_id":"themes/ayer/layout/_partial/post/author.ejs","hash":"57738b222e00bbd110be65d300d8bed34d73b3ea","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4647234e5c4529d754c9d0fc53ca9e9205f21443","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"cfb16c9dda7a609776a28702e0c3854a52e422a7","modified":1693144166191},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"4a21fd3d7335ffcd0661036fee81a927c125e2e2","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"85f0ebeceee1c32623bfa1e4170dbe1e34442fea","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"9f86e3d222555181a3e631a09bcdabdd44507cb8","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"5f8487fe7bed9a09001c6655244ff35f583cf1eb","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"e59198918e92ef92156aeefbf6023584ac1cae64","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"bc540478d35780e142b069ba2adafd5d5ce8a7b0","modified":1693144166192},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"3b076a65b9847cd6e0d424f5c2874046ef51d4d9","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"9898b0dd9237e21908ba40292a8a9f947bed44d2","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/twikoo.ejs","hash":"63bc5c056b2db2aca479705fc94eaa7fd26a7976","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"0a364766931f48df60b7c92fec8fde1067a93e00","modified":1693144166192},{"_id":"themes/ayer/scripts/events/lib/merge-configs.js","hash":"54836a1b41ebb32acc41839f53e1892779f66bb2","modified":1693144166199},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"fea793e132f627a8148059a9aee8bc33550506d1","modified":1693144166193},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"4b8e8455709debd73fba6bf3aad63378c4156dc1","modified":1693144166194},{"_id":"themes/ayer/scripts/events/lib/hello.js","hash":"96213218d7ce78eccf087d01038245be5169fee0","modified":1693145314889},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"369396d0c5b669df7a26df95f7a1b8a52f4eea65","modified":1693144166194},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"94342884feac98e5ef58c9bd2781fc8f35220c1c","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/ads.styl","hash":"d4be39f60a81dd0e5bdd49671e7308deddc572de","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"3044bf059522e79a726265c9a2f603ec8dc4222d","modified":1693144166201},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"712cb4d8f3cef18dc33281bd8e9b6879efdb1687","modified":1693144166202},{"_id":"themes/ayer/source-src/css/_partial/friends.styl","hash":"9dd116846c92daee1c8f80b79cab231613b164b2","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"1a4576c38ef19834a4d0a8ac887e7b55d21f2f13","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"3b11d0c6c4439b0856ba81c50bd8867d5bb081da","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"39a0bc6c5cf85f0527d6ee81f6feebce8550c1dd","modified":1693144166202},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1693144166203},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"e894b3a1aff76e84137e1e6db59a75afd0a53f52","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"b81d13334cf39941792dff0e3af393fb7b8cc214","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"da8a82a48852411c10e279dfee43038d46f4f273","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1693144166204},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"f2f43ae9831c3df017b35c68caa94f5eb911f697","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"da34b6125de01938d11de6ad3c0fed2c75faf40a","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a8a069ea34a0fd043832890db5341405e9f462cd","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"007bca390ec685349add74e033ff2cb90a1701bc","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bde7bf3577c66a3ac829410d52fa2144212282ef","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"9e9d8dc167ed2c332e4520cbf41244c34c1ebf64","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"f81076fc6d4a83be3371bcb79ab54d88e2605714","modified":1693144166205},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"87df748185edfba222c3f9a4b9ef8eee0e8e5ad3","modified":1693144166206},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"9ce2dd3ffdc4e170dfcb975a7158f913bc40b8d8","modified":1693144166205},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1693283423896},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1693283423912},{"_id":"themes/ayer/source/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1693283423880},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1693283423887},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1693283423888},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1693283423906},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1693144166199},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1693283423893},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1693283423898},{"_id":"themes/ayer/source/images/alipay.jpg","hash":"74e90e8757a66b03304fd6e2abb086e85dd72edf","modified":1693283423891},{"_id":"themes/ayer/source/images/wechat.jpg","hash":"d560cecf759485dfd385af9bad8f4f200aff21e5","modified":1693283423910},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1693283423882},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1693283423887},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1693283423901},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1693283423905},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","hash":"94144debfb5761d37d79336a10ef674f82baec1b","modified":1693283423885},{"_id":"public/search.xml","hash":"0c05ff13967deaf163ba1ef486b531d1919cc532","modified":1693298817666},{"_id":"public/categories/index.html","hash":"d22e1a75c394019a3e9c654b10c55cb1674d5294","modified":1693298817666},{"_id":"public/tags/index.html","hash":"ee6a45e3c9168c6095f96408ab31712b36251980","modified":1693298817666},{"_id":"public/archives/page/2/index.html","hash":"5d4dc8d68aceb4fc39a7ad937962a70282b1982f","modified":1693298817666},{"_id":"public/archives/2023/page/2/index.html","hash":"56c4344e75fafdfc6501c974b9ea76d83d99bde1","modified":1693298817666},{"_id":"public/archives/2023/08/page/2/index.html","hash":"c2ac15f5ca7ddcbf28f7c0fba6e7ad2bac207d5b","modified":1693298817666},{"_id":"public/categories/基本功/计算机网络/index.html","hash":"984f3213291e627c5ddd83f383280e94ad38a9fe","modified":1693298817666},{"_id":"public/categories/思考/index.html","hash":"a9a4de18fa388d8f5d7aa48d37c176817c6aca5a","modified":1693298817666},{"_id":"public/categories/工程/服务端/index.html","hash":"bccdce0c09fd4e6bf6a008db7bed2bee88150683","modified":1693298817666},{"_id":"public/categories/基本功/操作系统/index.html","hash":"f4febf700db2f0c16d49a39e355ee4c7a5609bbf","modified":1693298817666},{"_id":"public/categories/其他/index.html","hash":"00c8457dfd5d00b01a38ba31b21c099f2f2ad311","modified":1693298817666},{"_id":"public/categories/基本功/编程基础/Java/index.html","hash":"cc09c3547366bbc972e21a717fd65f37d2cb97dd","modified":1693298817666},{"_id":"public/categories/基本功/编程基础/编程理论/index.html","hash":"0d95439be2cfaec2854e7c696eb3874feede48c0","modified":1693298817666},{"_id":"public/categories/工程/云计算/index.html","hash":"dd34d1cf57b06ad192374da2c48cdbf49c1ab287","modified":1693298817666},{"_id":"public/categories/工程/Qt/index.html","hash":"e573f46e75bff6c24b1e61f1ddc2436f1066755b","modified":1693298817666},{"_id":"public/categories/基本功/编程基础/C/index.html","hash":"0f733c326d24433202955413d293737241d0a8ee","modified":1693298817666},{"_id":"public/categories/思考/读书笔记/index.html","hash":"f91c8b77191d4fdde7afce179ff66da8bb9c78ea","modified":1693298817666},{"_id":"public/categories/工程/服务端/MySQL/index.html","hash":"7973704935d4328ddfb8036296d008d911f5e987","modified":1693298817666},{"_id":"public/categories/基本功/编程基础/Java/JVM/index.html","hash":"8fde9b8ff8c1407d6823eb472fdef9299a413cea","modified":1693298817666},{"_id":"public/categories/工程/云计算/Docker/index.html","hash":"d0e05d2bd5c2f2c430fe41eb67916d875708cc9c","modified":1693298817666},{"_id":"public/categories/工程/云计算/K8S/index.html","hash":"5b0a260ed270bbb8e522c934d19c79f336ec8946","modified":1693298817666},{"_id":"public/categories/工程/服务端/Spring/index.html","hash":"adca2104f9e414eb2477937f9089e84692ec762b","modified":1693298817666},{"_id":"public/categories/工程/服务端/Tomcat/index.html","hash":"52bcf40ebf59462e4f863eb68e78bf72c6250269","modified":1693298817666},{"_id":"public/tags/JVM/index.html","hash":"771ba04d28d2129b7f39596acfb1b9cb7c64f607","modified":1693298817666},{"_id":"public/tags/基础知识/index.html","hash":"cfc1679f1da87c815f96707b78378ca7a0c9d1f2","modified":1693298817666},{"_id":"public/tags/C/index.html","hash":"c6d9d70b75073a2086bcb509a1c0c64c67c1d1ec","modified":1693298817666},{"_id":"public/tags/回调/index.html","hash":"22553ee8a89dbcc99f9ea07a2e61022dc1d698ad","modified":1693298817666},{"_id":"public/tags/数据库/index.html","hash":"c22c78b111f294ff92f909e71ad4a1eaf749c81b","modified":1693298817666},{"_id":"public/tags/Qt/index.html","hash":"f9b54518c6dc799237b711a3394528ac1af69e30","modified":1693298817666},{"_id":"public/tags/桌面开发/index.html","hash":"41d037ef0ebd16f9f8c237067e1989a874a3d1bd","modified":1693298817666},{"_id":"public/tags/云计算领域/index.html","hash":"e720433279292f79c0d3a6af9210edaf9b4b4fa3","modified":1693298817666},{"_id":"public/tags/K8S/index.html","hash":"2b8a4527bbae0d70bd456268fc0535d49cfebb69","modified":1693298817666},{"_id":"public/tags/Spring/index.html","hash":"ce0747039eed43f2804d6d983a89874b6f82f6fb","modified":1693298817666},{"_id":"public/tags/Java-EE/index.html","hash":"4d2e98c1b85365666964e40a82c7c4b549f7dde3","modified":1693298817666},{"_id":"public/tags/Tomcat/index.html","hash":"52fcb9fde04bfc2d0db7d5d995669fab4e2aef82","modified":1693298817666},{"_id":"public/tags/Java-Web/index.html","hash":"3baee75d364afa8f84e22ab17718192a3da8c0cc","modified":1693298817666},{"_id":"public/tags/Servlet/index.html","hash":"0be67ff2838bba70aa36625ae555644081d4f315","modified":1693298817666},{"_id":"public/tags/操作系统/index.html","hash":"0a8bc22147dd127b2be789e683b26e36cc2b023a","modified":1693298817666},{"_id":"public/tags/工具类/index.html","hash":"da95f7f4a0c23b0686c7940fd3d364b9db423134","modified":1693298817666},{"_id":"public/tags/Docker/index.html","hash":"3d099186e79e7f7fd8c9b92c1e3c976e027e70c6","modified":1693298817666},{"_id":"public/2023/08/29/GC—全过程/index.html","hash":"8fbbfc8ea62eff2dcdd1413c5ac6ec34cdbbbe29","modified":1693298817666},{"_id":"public/2023/08/29/K8S架构图/index.html","hash":"b8216aa623f52c0cab7e8b20bd1e6d7057f8e3aa","modified":1693298817666},{"_id":"public/2023/08/29/本地调试Docker源码/index.html","hash":"efdf6483b74b4cd2214e112f1cc3e42b65e18011","modified":1693298817666},{"_id":"public/2023/08/29/Qt简介/index.html","hash":"36f314bb329d3b350b2eb1fb0399b6b3ec3cdd48","modified":1693298817666},{"_id":"public/2023/08/29/IP数据报/index.html","hash":"9ebb4e7ccd2e882a9979f3406eda9063cc081c97","modified":1693298817666},{"_id":"public/2023/08/29/Innodb中的事务隔离级别和锁实现/index.html","hash":"d7c1b571226538db9546c2f9df359e9fe5993551","modified":1693298817666},{"_id":"public/2023/08/29/Spring全景/index.html","hash":"d7e29e48bb2b12df55edbeb23a77d8e1457e38d6","modified":1693298817666},{"_id":"public/2023/08/29/保持敬畏之心/index.html","hash":"d7a06b598025010130daab562aece8c38e125dab","modified":1693298817666},{"_id":"public/2023/08/29/命令行常用指令/index.html","hash":"b65e02cadeb8384cc86238f1976000f71991688a","modified":1693298817666},{"_id":"public/2023/08/29/Tomcat启动流程/index.html","hash":"56f96e5c2f3e1881aa3dafff4481185bf22340ef","modified":1693298817666},{"_id":"public/2023/08/29/C-程序内存分区/index.html","hash":"123f032844a4f0c2254a4d80250333b905e455af","modified":1693298817666},{"_id":"public/2023/08/29/回调机制/index.html","hash":"f5335605a52fc2895a39b632b364e1453a8249d3","modified":1693298817666},{"_id":"public/2023/08/28/GC—基础知识/index.html","hash":"520eb3e648422797acd3f9591418fa96da837d4f","modified":1693298817666},{"_id":"public/2023/08/28/内核页表设计/index.html","hash":"5368ad139594f4c09f85c0c9ae28400411997be3","modified":1693298817666},{"_id":"public/archives/index.html","hash":"80cab642f2d9847aaae266f4e115c4e919dadc60","modified":1693298817666},{"_id":"public/archives/2023/index.html","hash":"dd9aeb9b9261e40554452057b063e2ae3d03721e","modified":1693298817666},{"_id":"public/archives/2023/08/index.html","hash":"f408918d9639c49b4366a436dfcc0ffb3fcf5cd0","modified":1693298817666},{"_id":"public/categories/基本功/index.html","hash":"b67819b22bf847d63866e3e306267c898009ea2b","modified":1693298817666},{"_id":"public/categories/工程/index.html","hash":"4034311d6709a0e8ea208a4374757aec791e17aa","modified":1693298817666},{"_id":"public/categories/基本功/编程基础/index.html","hash":"aba2ce3e0c470bde9bd6cf98d4e0e84d1316f29c","modified":1693298817666},{"_id":"public/index.html","hash":"aa76ce2847b15868b7cae11b520e45521ca34fcd","modified":1693298817666},{"_id":"public/page/2/index.html","hash":"050e65f25fc8841900fec5a2d0454c8d4a5884eb","modified":1693298817666},{"_id":"public/tags/Java/index.html","hash":"d40f21a03af46f2ffe4d95c434d79efc209fbd84","modified":1693298817666},{"_id":"public/images/SETSUNAYANG.JPG","hash":"b7612fc376c8afaccc1f6733a50bc35e8e897500","modified":1693298817666},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1693298817666},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1693298817666},{"_id":"public/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1693298817666},{"_id":"public/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1693298817666},{"_id":"public/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1693298817666},{"_id":"public/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1693298817666},{"_id":"public/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1693298817666},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1693298817666},{"_id":"public/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1693298817666},{"_id":"public/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1693298817666},{"_id":"public/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1693298817666},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1693298817666},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1693298817666},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1693298817666},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1693298817666},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1693298817666},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1693298817666},{"_id":"public/lib/hbe.js","hash":"fb05fcd82bb28d3b2887d388cabea7f9b1a318eb","modified":1693298817666},{"_id":"public/css/hbe.style.css","hash":"72959894400fd5c350106cb558c39fa51f722cbd","modified":1693298817666},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1693298817666},{"_id":"public/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1693298817666},{"_id":"public/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1693298817666},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1693298817666},{"_id":"public/404.html","hash":"6e6ebc1161643ffa524c9ecf38af7cd8cf1c9ecc","modified":1693298817666},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1693298817666},{"_id":"public/css/custom.css","hash":"58950a4f4cd82465f85428ec17b3bc05f8153b56","modified":1693298817666},{"_id":"public/dist/main.js","hash":"158d69f927d1cee076a485e894f307fadbe9656c","modified":1693298817666},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1693298817666},{"_id":"public/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1693298817666},{"_id":"public/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1693298817666},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1693298817666},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1693298817666},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1693298817666},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1693298817666},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1693298817666},{"_id":"public/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1693298817666},{"_id":"public/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1693298817666},{"_id":"public/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1693298817666},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1693298817666},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1693298817666},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1693298817666},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1693298817666},{"_id":"public/images/alipay.jpg","hash":"74e90e8757a66b03304fd6e2abb086e85dd72edf","modified":1693298817666},{"_id":"public/images/wechat.jpg","hash":"d560cecf759485dfd385af9bad8f4f200aff21e5","modified":1693298817666},{"_id":"public/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1693298817666},{"_id":"public/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1693298817666},{"_id":"public/assets/js/DPlayer.min.js","hash":"290283e41ac69bfd570c90800680097f998e4e0c","modified":1693298817666},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1693298817666},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1693298817666},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1693298817666},{"_id":"public/css/fonts/remixicon.svg","hash":"94144debfb5761d37d79336a10ef674f82baec1b","modified":1693298817666}],"Category":[{"name":"基本功","_id":"cllw2e9uy0004wkwx79o85ill"},{"name":"工程","_id":"cllw2e9v2000hwkwxd1htcd13"},{"name":"编程基础","parent":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v3000mwkwx4atv993u"},{"name":"计算机网络","parent":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v4000swkwx8s45cb82"},{"name":"思考","_id":"cllw2e9v6001hwkwxejw9171u"},{"name":"服务端","parent":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9v7001jwkwxgtle2fd8"},{"name":"操作系统","parent":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v7001mwkwxc20g6m4u"},{"name":"其他","_id":"cllw2e9v7001pwkwxb17sajtv"},{"name":"Java","parent":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9v7001twkwxdfli1eot"},{"name":"编程理论","parent":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9v7001ywkwx6pm8ajf8"},{"name":"云计算","parent":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9v70021wkwx4v3c9xkd"},{"name":"Qt","parent":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9v80025wkwx1k323pw8"},{"name":"C++","parent":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9v80029wkwxc0p5hufv"},{"name":"读书笔记","parent":"cllw2e9v6001hwkwxejw9171u","_id":"cllw2e9va002vwkwxfbfcdqjf"},{"name":"MySQL","parent":"cllw2e9v7001jwkwxgtle2fd8","_id":"cllw2e9va002zwkwxhppx7x9w"},{"name":"JVM","parent":"cllw2e9v7001twkwxdfli1eot","_id":"cllw2e9va0035wkwx0m4nc3c0"},{"name":"Docker","parent":"cllw2e9v70021wkwx4v3c9xkd","_id":"cllw2e9va0039wkwx7l0e9dqa"},{"name":"K8S","parent":"cllw2e9v70021wkwx4v3c9xkd","_id":"cllw2e9vb003dwkwxaa4d3h2k"},{"name":"Spring","parent":"cllw2e9v7001jwkwxgtle2fd8","_id":"cllw2e9vb003gwkwxhb3x9jje"},{"name":"Tomcat","parent":"cllw2e9v7001jwkwxgtle2fd8","_id":"cllw2e9vb003mwkwx545q0cm5"}],"Data":[],"Page":[{"title":"categories","date":"2023-08-28T15:21:32.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-08-28 23:21:32\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2023-08-28T15:44:07.813Z","path":"categories/index.html","comments":1,"_id":"cllw2e9uv0000wkwx98of8cc9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2023-08-28T15:23:28.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-08-28 23:23:28\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2023-08-28T15:50:37.078Z","path":"tags/index.html","comments":1,"_id":"cllw2e9ux0002wkwx6uxzcf2j","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"GC-全流程","date":"2023-08-29T07:46:59.000Z","_content":"\n\n#### __1、minorGC 和 Full GC 区别__\n&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n\n&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n#### __2、minorGC 过程详解__\n&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-\nXX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n#### __3、整体描述__\n&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -> Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。\n\n#### __4、GC 触发条件__\n&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：\n* 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；\n* 老年代空间不足；\n* 方法去空间不足；\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存；\n* 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n#### __5、对象进入老年代的四种情况__\n&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没\"熬过\"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。\n\n&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true)\n\n#### __6、空间分配担保__\n&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。\n\n&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。\n\n&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。\n\n\n\n\n\n\n\n","source":"_posts/GC—全过程.md","raw":"---\ntitle: GC-全流程\ndate: 2023-08-29 15:46:59\ncategories:\n- 基本功\n- 编程基础\n- Java\n- JVM\ntags:\n- Java\n- JVM\n- 基础知识\n---\n\n\n#### __1、minorGC 和 Full GC 区别__\n&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n\n&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n#### __2、minorGC 过程详解__\n&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n\n&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-\nXX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n\n#### __3、整体描述__\n&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -> Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。\n\n#### __4、GC 触发条件__\n&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：\n* 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；\n* 老年代空间不足；\n* 方法去空间不足；\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存；\n* 由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。\n\n#### __5、对象进入老年代的四种情况__\n&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没\"熬过\"一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。\n\n&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。\n\n![](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true)\n\n#### __6、空间分配担保__\n&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。\n\n&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。\n\n&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。\n\n\n\n\n\n\n\n","slug":"GC—全过程","published":1,"updated":"2023-08-29T08:46:46.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9uw0001wkwxb4882azt","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h4 id=\"1、minorGC-和-Full-GC-区别\"><a href=\"#1、minorGC-和-Full-GC-区别\" class=\"headerlink\" title=\"1、minorGC 和 Full GC 区别\"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>\n<h4 id=\"2、minorGC-过程详解\"><a href=\"#2、minorGC-过程详解\" class=\"headerlink\" title=\"2、minorGC 过程详解\"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<h4 id=\"3、整体描述\"><a href=\"#3、整体描述\" class=\"headerlink\" title=\"3、整体描述\"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>\n<h4 id=\"4、GC-触发条件\"><a href=\"#4、GC-触发条件\" class=\"headerlink\" title=\"4、GC 触发条件\"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>\n<ul>\n<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>\n<li>老年代空间不足；</li>\n<li>方法去空间不足；</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>\n<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>\n</ul>\n<h4 id=\"5、对象进入老年代的四种情况\"><a href=\"#5、对象进入老年代的四种情况\" class=\"headerlink\" title=\"5、对象进入老年代的四种情况\"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true\"></p>\n<h4 id=\"6、空间分配担保\"><a href=\"#6、空间分配担保\" class=\"headerlink\" title=\"6、空间分配担保\"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1、minorGC-和-Full-GC-区别\"><a href=\"#1、minorGC-和-Full-GC-区别\" class=\"headerlink\" title=\"1、minorGC 和 Full GC 区别\"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>\n<h4 id=\"2、minorGC-过程详解\"><a href=\"#2、minorGC-过程详解\" class=\"headerlink\" title=\"2、minorGC 过程详解\"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>\n<h4 id=\"3、整体描述\"><a href=\"#3、整体描述\" class=\"headerlink\" title=\"3、整体描述\"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>\n<h4 id=\"4、GC-触发条件\"><a href=\"#4、GC-触发条件\" class=\"headerlink\" title=\"4、GC 触发条件\"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>\n<ul>\n<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>\n<li>老年代空间不足；</li>\n<li>方法去空间不足；</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>\n<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>\n</ul>\n<h4 id=\"5、对象进入老年代的四种情况\"><a href=\"#5、对象进入老年代的四种情况\" class=\"headerlink\" title=\"5、对象进入老年代的四种情况\"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true\"></p>\n<h4 id=\"6、空间分配担保\"><a href=\"#6、空间分配担保\" class=\"headerlink\" title=\"6、空间分配担保\"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>\n"},{"title":"C++程序内存分区","date":"2023-08-28T17:14:22.000Z","_content":"","source":"_posts/C-程序内存分区.md","raw":"---\ntitle: C++程序内存分区\ndate: 2023-08-29 01:14:22\ncategories: \n- 基本功\n- 编程基础\n- C++\ntags:\n- C++\n- Java\n- 回调\n---\n","slug":"C-程序内存分区","published":1,"updated":"2023-08-28T17:14:53.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9ux0003wkwx93q9bs40","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"GC—基础知识","date":"2023-08-28T15:31:37.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样\n的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？\n\n#### __1、可达性分析算法（GC Roots）__\n\n&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现\n方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之\n间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标\n记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下\n几种：\n* 虚拟机栈（本地变量表）中引用的对象\n* 方法区中类静态属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中引用的对象\n\n#### __2、JVM中的堆结构__\n&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：\n![JVM 分代比例](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to\n区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：\n![JVM 内存模型全景](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)\n\n#### __2.1、为何新生代要分为三个区__\n&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小\n相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。\n\n&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。\n\n&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。\n\n&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。\n\n#### __2.2、新生代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；\n\n&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；\n\n&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：\nfrom 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）\n\n#### __2.3、老年代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经\n过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-\nXX:PretenureSizeThreshold=30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。\n\n&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和\n大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己\n的晋升年龄。\n\n#### __3、JVM完整的GC流程__\n&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。\n\n&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重\n影响性能。\n\n&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。\n处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾\n回收器等。","source":"_posts/GC—基础知识.md","raw":"---\ntitle: GC—基础知识\ndate: 2023-08-28 23:31:37\ncategories: \n- 基本功\n- 编程基础\n- Java\n- JVM\ntags:\n- Java\n- JVM\n- 基础知识\n---\n\n&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样\n的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？\n\n#### __1、可达性分析算法（GC Roots）__\n\n&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现\n方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之\n间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标\n记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下\n几种：\n* 虚拟机栈（本地变量表）中引用的对象\n* 方法区中类静态属性引用的对象\n* 方法区中常量引用的对象\n* 本地方法栈中引用的对象\n\n#### __2、JVM中的堆结构__\n&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：\n![JVM 分代比例](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true)\n\n&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to\n区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：\n![JVM 内存模型全景](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)\n\n#### __2.1、为何新生代要分为三个区__\n&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小\n相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。\n\n&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。\n\n&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。\n\n&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。\n\n#### __2.2、新生代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；\n\n&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；\n\n&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：\nfrom 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）\n\n#### __2.3、老年代对象的分配和回收__\n&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经\n过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。\n\n&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-\nXX:PretenureSizeThreshold=30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。\n\n&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和\n大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己\n的晋升年龄。\n\n#### __3、JVM完整的GC流程__\n&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -> Survivor 区 -> 老年代。\n\n&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重\n影响性能。\n\n&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。\n处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾\n回收器等。","slug":"GC—基础知识","published":1,"updated":"2023-08-29T08:31:32.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9uz0006wkwxggntd7ci","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>\n<h4 id=\"1、可达性分析算法（GC-Roots）\"><a href=\"#1、可达性分析算法（GC-Roots）\" class=\"headerlink\" title=\"1、可达性分析算法（GC Roots）\"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>\n<ul>\n<li>虚拟机栈（本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n</ul>\n<h4 id=\"2、JVM中的堆结构\"><a href=\"#2、JVM中的堆结构\" class=\"headerlink\" title=\"2、JVM中的堆结构\"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true\" alt=\"JVM 分代比例\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"JVM 内存模型全景\"></p>\n<h4 id=\"2-1、为何新生代要分为三个区\"><a href=\"#2-1、为何新生代要分为三个区\" class=\"headerlink\" title=\"2.1、为何新生代要分为三个区\"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>\n<h4 id=\"2-2、新生代对象的分配和回收\"><a href=\"#2-2、新生代对象的分配和回收\" class=\"headerlink\" title=\"2.2、新生代对象的分配和回收\"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>\n<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>\n<h4 id=\"2-3、老年代对象的分配和回收\"><a href=\"#2-3、老年代对象的分配和回收\" class=\"headerlink\" title=\"2.3、老年代对象的分配和回收\"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>\n<h4 id=\"3、JVM完整的GC流程\"><a href=\"#3、JVM完整的GC流程\" class=\"headerlink\" title=\"3、JVM完整的GC流程\"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>\n<h4 id=\"1、可达性分析算法（GC-Roots）\"><a href=\"#1、可达性分析算法（GC-Roots）\" class=\"headerlink\" title=\"1、可达性分析算法（GC Roots）\"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>\n<ul>\n<li>虚拟机栈（本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中引用的对象</li>\n</ul>\n<h4 id=\"2、JVM中的堆结构\"><a href=\"#2、JVM中的堆结构\" class=\"headerlink\" title=\"2、JVM中的堆结构\"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true\" alt=\"JVM 分代比例\"></p>\n<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"JVM 内存模型全景\"></p>\n<h4 id=\"2-1、为何新生代要分为三个区\"><a href=\"#2-1、为何新生代要分为三个区\" class=\"headerlink\" title=\"2.1、为何新生代要分为三个区\"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>\n<h4 id=\"2-2、新生代对象的分配和回收\"><a href=\"#2-2、新生代对象的分配和回收\" class=\"headerlink\" title=\"2.2、新生代对象的分配和回收\"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>\n<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>\n<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>\n<h4 id=\"2-3、老年代对象的分配和回收\"><a href=\"#2-3、老年代对象的分配和回收\" class=\"headerlink\" title=\"2.3、老年代对象的分配和回收\"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>\n<h4 id=\"3、JVM完整的GC流程\"><a href=\"#3、JVM完整的GC流程\" class=\"headerlink\" title=\"3、JVM完整的GC流程\"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>\n<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>\n"},{"title":"Innodb中的事务隔离级别和锁实现","date":"2023-08-28T17:28:46.000Z","_content":"","source":"_posts/Innodb中的事务隔离级别和锁实现.md","raw":"---\ntitle: Innodb中的事务隔离级别和锁实现\ndate: 2023-08-29 01:28:46\ncategories: \n- 工程\n- 服务端\n- MySQL\ntags:\n- 数据库\n---\n","slug":"Innodb中的事务隔离级别和锁实现","published":1,"updated":"2023-08-29T00:52:19.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9uz0007wkwxguxu6zcr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"IP数据报","date":"2023-08-28T17:29:54.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。\n\n\n![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### __1、固定部分__\n* 版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。\n* 首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。\n* 区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。\n* 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。\n* 标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。\n* 标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF=0 时才允许分片。\n* 片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。\n* 生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。\n* 协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。\n* 首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。\n* 源地址和目的地址：32位，IPV4 地址。\n\n#### __2、可变部分__\n&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：\n* 安全和处理限制（用于军事领域）。\n* 记录路径（让每个路由器都记下它的IP地址）。\n* 时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。\n* 宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。\n* 严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。\n&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。\n","source":"_posts/IP数据报.md","raw":"---\ntitle: IP数据报\ndate: 2023-08-29 01:29:54\ncategories: \n- 基本功\n- 计算机网络\ntags:\n- 数据库\n---\n\n&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。\n\n\n![IP报文结构](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true)\n\n#### __1、固定部分__\n* 版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。\n* 首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。\n* 区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。\n* 总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。\n* 标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。\n* 标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF=1 即表示后面“还有分片”的数据报。MF=0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF=0 时才允许分片。\n* 片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。\n* 生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。\n* 协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。\n* 首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。\n* 源地址和目的地址：32位，IPV4 地址。\n\n#### __2、可变部分__\n&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：\n* 安全和处理限制（用于军事领域）。\n* 记录路径（让每个路由器都记下它的IP地址）。\n* 时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。\n* 宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。\n* 严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。\n&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。\n","slug":"IP数据报","published":1,"updated":"2023-08-29T08:32:04.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v00008wkwx5fuwghs1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"IP报文结构\"></p>\n<h4 id=\"1、固定部分\"><a href=\"#1、固定部分\" class=\"headerlink\" title=\"1、固定部分\"></a><strong>1、固定部分</strong></h4><ul>\n<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>\n<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>\n<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>\n<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>\n<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>\n<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>\n<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>\n<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>\n<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>\n<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址和目的地址：32位，IPV4 地址。</li>\n</ul>\n<h4 id=\"2、可变部分\"><a href=\"#2、可变部分\" class=\"headerlink\" title=\"2、可变部分\"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>\n<ul>\n<li>安全和处理限制（用于军事领域）。</li>\n<li>记录路径（让每个路由器都记下它的IP地址）。</li>\n<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>\n<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>\n<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。<br>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>\n<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true\" alt=\"IP报文结构\"></p>\n<h4 id=\"1、固定部分\"><a href=\"#1、固定部分\" class=\"headerlink\" title=\"1、固定部分\"></a><strong>1、固定部分</strong></h4><ul>\n<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>\n<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>\n<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>\n<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>\n<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>\n<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>\n<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>\n<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>\n<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>\n<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址和目的地址：32位，IPV4 地址。</li>\n</ul>\n<h4 id=\"2、可变部分\"><a href=\"#2、可变部分\" class=\"headerlink\" title=\"2、可变部分\"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>\n<ul>\n<li>安全和处理限制（用于军事领域）。</li>\n<li>记录路径（让每个路由器都记下它的IP地址）。</li>\n<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>\n<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>\n<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。<br>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</li>\n</ul>\n"},{"title":"Qt简介","date":"2023-08-29T00:49:39.000Z","_content":"","source":"_posts/Qt简介.md","raw":"---\ntitle: Qt简介\ndate: 2023-08-29 08:49:39\ncategories: \n- 工程\n- Qt\ntags:\n- Qt\n- 桌面开发\n---\n","slug":"Qt简介","published":1,"updated":"2023-08-29T00:51:11.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v1000bwkwxcvdpd5j1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"K8S架构图","date":"2023-08-29T02:33:27.000Z","_content":"\n\n![K8S架构图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)","source":"_posts/K8S架构图.md","raw":"---\ntitle: K8S架构图\ndate: 2023-08-29 10:33:27\ncategories: \n- 工程\n- 云计算\n- K8S\ntags:\n- 云计算领域\n- K8S\n---\n\n\n![K8S架构图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)","slug":"K8S架构图","published":1,"updated":"2023-08-29T08:32:26.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v1000cwkwx1dz012rz","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"K8S架构图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true\" alt=\"K8S架构图\"></p>\n"},{"title":"Spring全景","date":"2023-08-28T17:20:39.000Z","_content":"\n\n![Spring 全景图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true)","source":"_posts/Spring全景.md","raw":"---\ntitle: Spring全景\ndate: 2023-08-29 01:20:39\ncategories: \n- 工程\n- 服务端\n- Spring\ntags:\n- Spring\n- Java EE\n---\n\n\n![Spring 全景图](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true)","slug":"Spring全景","published":1,"updated":"2023-08-29T08:32:47.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v1000fwkwxc380cf4n","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true\" alt=\"Spring 全景图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true\" alt=\"Spring 全景图\"></p>\n"},{"title":"Tomcat启动流程","date":"2023-08-28T17:16:02.000Z","_content":"","source":"_posts/Tomcat启动流程.md","raw":"---\ntitle: Tomcat启动流程\ndate: 2023-08-29 01:16:02\ncategories: \n- 工程\n- 服务端\n- Tomcat\ntags:\n- Tomcat\n- Java Web\n- Servlet\n- Java EE\n---\n","slug":"Tomcat启动流程","published":1,"updated":"2023-08-29T00:52:02.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v1000gwkwx4kt546tn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"保持敬畏之心","date":"2023-08-28T17:19:15.000Z","_content":"","source":"_posts/保持敬畏之心.md","raw":"---\ntitle: 保持敬畏之心\ndate: 2023-08-29 01:19:15\ncategories: \n- 思考\n- 读书笔记\ntags:\n- C++\n- Java\n- 回调\n---\n","slug":"保持敬畏之心","published":1,"updated":"2023-08-29T00:52:57.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v2000jwkwx9z484uzj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"内核页表设计","date":"2023-08-28T15:31:37.000Z","_content":"\n![内核页表设计](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true)\n","source":"_posts/内核页表设计.md","raw":"---\ntitle: 内核页表设计\ndate: 2023-08-28 23:31:37\ncategories: \n- 基本功\n- 操作系统\ntags:\n- 操作系统\n---\n\n![内核页表设计](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true)\n","slug":"内核页表设计","published":1,"updated":"2023-08-29T08:30:36.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v2000lwkwx4r6ffzfa","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true\" alt=\"内核页表设计\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true\" alt=\"内核页表设计\"></p>\n"},{"title":"命令行常用指令","date":"2023-08-28T17:17:53.000Z","_content":"","source":"_posts/命令行常用指令.md","raw":"---\ntitle: 命令行常用指令\ndate: 2023-08-29 01:17:53\ncategories: \n- 其他\ntags:\n- 工具类\n---\n","slug":"命令行常用指令","published":1,"updated":"2023-08-28T17:18:40.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v3000pwkwxaapeadhn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"回调机制","date":"2023-08-28T17:12:29.000Z","_content":"","source":"_posts/回调机制.md","raw":"---\ntitle: 回调机制\ndate: 2023-08-29 01:12:29\ncategories: \n- 基本功\n- 编程基础\n- 编程理论\ntags:\n- C++\n- Java\n- 回调\n---\n","slug":"回调机制","published":1,"updated":"2023-08-28T17:13:33.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v3000rwkwx0bpnabh2","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"本地调试Docker源码","date":"2023-08-29T00:50:52.000Z","_content":"","source":"_posts/本地调试Docker源码.md","raw":"---\ntitle: 本地调试Docker源码\ndate: 2023-08-29 08:50:52\ncategories: \n- 工程\n- 云计算\n- Docker\ntags:\n- 云计算领域\n- Docker\n---\n","slug":"本地调试Docker源码","published":1,"updated":"2023-08-29T02:22:56.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllw2e9v4000uwkwx24ly6pdu","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cllw2e9v00008wkwx5fuwghs1","category_id":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v4000zwkwxdik5e6i2"},{"post_id":"cllw2e9v00008wkwx5fuwghs1","category_id":"cllw2e9v4000swkwx8s45cb82","_id":"cllw2e9v40012wkwxfgpfba5g"},{"post_id":"cllw2e9v2000lwkwx4r6ffzfa","category_id":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v7001swkwx4kdw6lvz"},{"post_id":"cllw2e9v2000lwkwx4r6ffzfa","category_id":"cllw2e9v7001mwkwxc20g6m4u","_id":"cllw2e9v7001vwkwxh7oa35ka"},{"post_id":"cllw2e9v3000pwkwxaapeadhn","category_id":"cllw2e9v7001pwkwxb17sajtv","_id":"cllw2e9v7001xwkwxh7wa22gh"},{"post_id":"cllw2e9v3000rwkwx0bpnabh2","category_id":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v80024wkwx7pvyh4a7"},{"post_id":"cllw2e9v3000rwkwx0bpnabh2","category_id":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9v80026wkwxg2190u2e"},{"post_id":"cllw2e9v3000rwkwx0bpnabh2","category_id":"cllw2e9v7001ywkwx6pm8ajf8","_id":"cllw2e9v80028wkwxg9qj0j1c"},{"post_id":"cllw2e9v1000bwkwxcvdpd5j1","category_id":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9v8002bwkwxejapdj9m"},{"post_id":"cllw2e9v1000bwkwxcvdpd5j1","category_id":"cllw2e9v80025wkwx1k323pw8","_id":"cllw2e9v8002ewkwxdjb90icn"},{"post_id":"cllw2e9ux0003wkwx93q9bs40","category_id":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9v8002hwkwx34i2dpfz"},{"post_id":"cllw2e9ux0003wkwx93q9bs40","category_id":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9v9002kwkwx18z28iga"},{"post_id":"cllw2e9ux0003wkwx93q9bs40","category_id":"cllw2e9v80029wkwxc0p5hufv","_id":"cllw2e9v9002nwkwxeay5bodk"},{"post_id":"cllw2e9v2000jwkwx9z484uzj","category_id":"cllw2e9v6001hwkwxejw9171u","_id":"cllw2e9va0033wkwx9mpq6lwl"},{"post_id":"cllw2e9v2000jwkwx9z484uzj","category_id":"cllw2e9va002vwkwxfbfcdqjf","_id":"cllw2e9va0036wkwx88hm34gc"},{"post_id":"cllw2e9uz0007wkwxguxu6zcr","category_id":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9va0038wkwxbllv5vh2"},{"post_id":"cllw2e9uz0007wkwxguxu6zcr","category_id":"cllw2e9v7001jwkwxgtle2fd8","_id":"cllw2e9va003bwkwxb8tgbqgs"},{"post_id":"cllw2e9uz0007wkwxguxu6zcr","category_id":"cllw2e9va002zwkwxhppx7x9w","_id":"cllw2e9vb003cwkwx7i2q6bvw"},{"post_id":"cllw2e9uw0001wkwxb4882azt","category_id":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9vb003ewkwx2s4ohz9g"},{"post_id":"cllw2e9uw0001wkwxb4882azt","category_id":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9vb003fwkwx3saq5yxi"},{"post_id":"cllw2e9uw0001wkwxb4882azt","category_id":"cllw2e9v7001twkwxdfli1eot","_id":"cllw2e9vb003hwkwxfo7s2z64"},{"post_id":"cllw2e9uw0001wkwxb4882azt","category_id":"cllw2e9va0035wkwx0m4nc3c0","_id":"cllw2e9vb003iwkwxdjbh7i8w"},{"post_id":"cllw2e9v4000uwkwx24ly6pdu","category_id":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9vb003kwkwx4r82cza3"},{"post_id":"cllw2e9v4000uwkwx24ly6pdu","category_id":"cllw2e9v70021wkwx4v3c9xkd","_id":"cllw2e9vb003lwkwx72298ttg"},{"post_id":"cllw2e9v4000uwkwx24ly6pdu","category_id":"cllw2e9va0039wkwx7l0e9dqa","_id":"cllw2e9vb003nwkwx7u0v2eq5"},{"post_id":"cllw2e9v1000cwkwx1dz012rz","category_id":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9vb003owkwx06gg0jl5"},{"post_id":"cllw2e9v1000cwkwx1dz012rz","category_id":"cllw2e9v70021wkwx4v3c9xkd","_id":"cllw2e9vb003pwkwx7ake89g1"},{"post_id":"cllw2e9v1000cwkwx1dz012rz","category_id":"cllw2e9vb003dwkwxaa4d3h2k","_id":"cllw2e9vb003qwkwx7b1ke8pu"},{"post_id":"cllw2e9v1000fwkwxc380cf4n","category_id":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9vb003rwkwxd9mfeq4j"},{"post_id":"cllw2e9v1000fwkwxc380cf4n","category_id":"cllw2e9v7001jwkwxgtle2fd8","_id":"cllw2e9vb003swkwxhgyo3bxg"},{"post_id":"cllw2e9v1000fwkwxc380cf4n","category_id":"cllw2e9vb003gwkwxhb3x9jje","_id":"cllw2e9vb003twkwxe3x77sli"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","category_id":"cllw2e9uy0004wkwx79o85ill","_id":"cllw2e9vb003uwkwx8tjd0fbc"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","category_id":"cllw2e9v3000mwkwx4atv993u","_id":"cllw2e9vb003vwkwxfd2n0apf"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","category_id":"cllw2e9v7001twkwxdfli1eot","_id":"cllw2e9vb003wwkwxdymw396f"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","category_id":"cllw2e9va0035wkwx0m4nc3c0","_id":"cllw2e9vc003xwkwx0qp77azd"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","category_id":"cllw2e9v2000hwkwxd1htcd13","_id":"cllw2e9vc003ywkwxaget41l3"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","category_id":"cllw2e9v7001jwkwxgtle2fd8","_id":"cllw2e9vc003zwkwxgj0l1d31"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","category_id":"cllw2e9vb003mwkwx545q0cm5","_id":"cllw2e9vc0040wkwx5ec3d4x9"}],"PostTag":[{"post_id":"cllw2e9uw0001wkwxb4882azt","tag_id":"cllw2e9uz0005wkwxa3cj0e7f","_id":"cllw2e9v2000kwkwx5p647htw"},{"post_id":"cllw2e9uw0001wkwxb4882azt","tag_id":"cllw2e9v0000awkwxfa1a3zsz","_id":"cllw2e9v3000nwkwx69vac536"},{"post_id":"cllw2e9uw0001wkwxb4882azt","tag_id":"cllw2e9v1000ewkwx5mi639pk","_id":"cllw2e9v3000qwkwxd0e42ku0"},{"post_id":"cllw2e9ux0003wkwx93q9bs40","tag_id":"cllw2e9v2000iwkwxaw14g1uq","_id":"cllw2e9v4000xwkwx3tr2fiuq"},{"post_id":"cllw2e9ux0003wkwx93q9bs40","tag_id":"cllw2e9uz0005wkwxa3cj0e7f","_id":"cllw2e9v40010wkwx23ac793e"},{"post_id":"cllw2e9ux0003wkwx93q9bs40","tag_id":"cllw2e9v4000twkwx6wvz9w4j","_id":"cllw2e9v40013wkwxcyq4gzdg"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","tag_id":"cllw2e9uz0005wkwxa3cj0e7f","_id":"cllw2e9v50018wkwxhnhm8kn6"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","tag_id":"cllw2e9v0000awkwxfa1a3zsz","_id":"cllw2e9v5001awkwxavc87axn"},{"post_id":"cllw2e9uz0006wkwxggntd7ci","tag_id":"cllw2e9v1000ewkwx5mi639pk","_id":"cllw2e9v5001cwkwxh4iwd1h3"},{"post_id":"cllw2e9uz0007wkwxguxu6zcr","tag_id":"cllw2e9v50017wkwxd2t512u0","_id":"cllw2e9v5001ewkwx0ok3h2wa"},{"post_id":"cllw2e9v00008wkwx5fuwghs1","tag_id":"cllw2e9v50017wkwxd2t512u0","_id":"cllw2e9v6001gwkwx60356ipo"},{"post_id":"cllw2e9v1000bwkwxcvdpd5j1","tag_id":"cllw2e9v5001fwkwxbgibbh0v","_id":"cllw2e9v7001lwkwx99is3e4g"},{"post_id":"cllw2e9v1000bwkwxcvdpd5j1","tag_id":"cllw2e9v6001iwkwxean89d73","_id":"cllw2e9v7001nwkwx6lfxc8kz"},{"post_id":"cllw2e9v1000cwkwx1dz012rz","tag_id":"cllw2e9v7001kwkwx3fxyefe2","_id":"cllw2e9v7001rwkwx72cvcdbw"},{"post_id":"cllw2e9v1000cwkwx1dz012rz","tag_id":"cllw2e9v7001owkwxhi9eg72v","_id":"cllw2e9v7001uwkwxgzpd20fa"},{"post_id":"cllw2e9v1000fwkwxc380cf4n","tag_id":"cllw2e9v7001qwkwx3ryx2st0","_id":"cllw2e9v70020wkwx86t66b9n"},{"post_id":"cllw2e9v1000fwkwxc380cf4n","tag_id":"cllw2e9v7001wwkwxbpcb5ocp","_id":"cllw2e9v80022wkwx7kd9b7s4"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","tag_id":"cllw2e9v7001zwkwxfbrk86zg","_id":"cllw2e9v8002fwkwxcow462to"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","tag_id":"cllw2e9v80023wkwxff335994","_id":"cllw2e9v8002iwkwx1973amts"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","tag_id":"cllw2e9v80027wkwx4mc35y5a","_id":"cllw2e9v9002lwkwx682kabe8"},{"post_id":"cllw2e9v1000gwkwx4kt546tn","tag_id":"cllw2e9v7001wwkwxbpcb5ocp","_id":"cllw2e9v9002owkwx247l7am5"},{"post_id":"cllw2e9v2000jwkwx9z484uzj","tag_id":"cllw2e9v2000iwkwxaw14g1uq","_id":"cllw2e9v9002qwkwx6ht1c5ut"},{"post_id":"cllw2e9v2000jwkwx9z484uzj","tag_id":"cllw2e9uz0005wkwxa3cj0e7f","_id":"cllw2e9v9002swkwxeih40grw"},{"post_id":"cllw2e9v2000jwkwx9z484uzj","tag_id":"cllw2e9v4000twkwx6wvz9w4j","_id":"cllw2e9va002uwkwxfzd84zp5"},{"post_id":"cllw2e9v2000lwkwx4r6ffzfa","tag_id":"cllw2e9v8002jwkwxgzxp2lhv","_id":"cllw2e9va002wwkwxey0ffz3a"},{"post_id":"cllw2e9v3000pwkwxaapeadhn","tag_id":"cllw2e9v9002pwkwx1sxc43o1","_id":"cllw2e9va002ywkwx1gm6gesk"},{"post_id":"cllw2e9v3000rwkwx0bpnabh2","tag_id":"cllw2e9v2000iwkwxaw14g1uq","_id":"cllw2e9va0030wkwx1xfbduzs"},{"post_id":"cllw2e9v3000rwkwx0bpnabh2","tag_id":"cllw2e9uz0005wkwxa3cj0e7f","_id":"cllw2e9va0032wkwx6jxx9bg2"},{"post_id":"cllw2e9v3000rwkwx0bpnabh2","tag_id":"cllw2e9v4000twkwx6wvz9w4j","_id":"cllw2e9va0034wkwx6cojh6ta"},{"post_id":"cllw2e9v4000uwkwx24ly6pdu","tag_id":"cllw2e9v7001kwkwx3fxyefe2","_id":"cllw2e9va0037wkwx6a8409ow"},{"post_id":"cllw2e9v4000uwkwx24ly6pdu","tag_id":"cllw2e9va0031wkwx1nlj7vk8","_id":"cllw2e9va003awkwxfsg3gjhw"}],"Tag":[{"name":"Java","_id":"cllw2e9uz0005wkwxa3cj0e7f"},{"name":"JVM","_id":"cllw2e9v0000awkwxfa1a3zsz"},{"name":"基础知识","_id":"cllw2e9v1000ewkwx5mi639pk"},{"name":"C++","_id":"cllw2e9v2000iwkwxaw14g1uq"},{"name":"回调","_id":"cllw2e9v4000twkwx6wvz9w4j"},{"name":"数据库","_id":"cllw2e9v50017wkwxd2t512u0"},{"name":"Qt","_id":"cllw2e9v5001fwkwxbgibbh0v"},{"name":"桌面开发","_id":"cllw2e9v6001iwkwxean89d73"},{"name":"云计算领域","_id":"cllw2e9v7001kwkwx3fxyefe2"},{"name":"K8S","_id":"cllw2e9v7001owkwxhi9eg72v"},{"name":"Spring","_id":"cllw2e9v7001qwkwx3ryx2st0"},{"name":"Java EE","_id":"cllw2e9v7001wwkwxbpcb5ocp"},{"name":"Tomcat","_id":"cllw2e9v7001zwkwxfbrk86zg"},{"name":"Java Web","_id":"cllw2e9v80023wkwxff335994"},{"name":"Servlet","_id":"cllw2e9v80027wkwx4mc35y5a"},{"name":"操作系统","_id":"cllw2e9v8002jwkwxgzxp2lhv"},{"name":"工具类","_id":"cllw2e9v9002pwkwx1sxc43o1"},{"name":"Docker","_id":"cllw2e9va0031wkwx1nlj7vk8"}]}}