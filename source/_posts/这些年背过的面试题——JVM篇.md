---
title: 这些年背过的面试题——JVM篇
date: 2024-03-23 14:47:06
categories:
- 基本功
- 编程基础
tags:
- 基础知识
---


&ensp;&ensp;&ensp;&ensp; __1、JVM运行时数据区域__


&ensp;&ensp;&ensp;&ensp; 堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器。

![内存划分](/pic/基本功/编程基础/这些年背过的面试题——JVM篇/内存划分.webp)

&ensp;&ensp;&ensp;&ensp; __Heap(堆)：__

&ensp;&ensp;&ensp;&ensp; 对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配。堆细分：新生代、老年代，对于新生代又分为：Eden 区和 Surviver1 和 Surviver2 区。

&ensp;&ensp;&ensp;&ensp; __方法区：__

&ensp;&ensp;&ensp;&ensp; 对于 JVM 的方法区也可以称之为永久区，它储存的是已经被 java 虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；当应用中的 Java 类过多时，比如 Spring 等一些使用动态代理的框架生成了很多类，如果占用空间超出了我们的设定值，就会发生元空间溢出。

&ensp;&ensp;&ensp;&ensp; __虚拟机栈：__

&ensp;&ensp;&ensp;&ensp; 虚拟机栈是线程私有的，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的栈帧，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（局部变量表、操作数栈 、动态链接 、返回地址）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

&ensp;&ensp;&ensp;&ensp; 局部变量表：局部变量表是一组变量值存储空间，用来存放方法参数、方法内部定义的局部变量。底层是变量槽（variable slot）

&ensp;&ensp;&ensp;&ensp; 操作数栈：是用来记录一个方法在执行的过程中，字节码指令向操作数栈中进行入栈和出栈的过程。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种字节码指令往操作数栈中入栈和出栈。

&ensp;&ensp;&ensp;&ensp; 动态链接：因为字节码文件中有很多符号的引用，这些符号引用一部分会在类加载的解析阶段或第一次使用的时候转化成直接引用，这种称为静态解析；另一部分会在运行期间转化为直接引用，称为动态链接。

&ensp;&ensp;&ensp;&ensp; 返回地址（returnAddress）：类型（指向了一条字节码指令的地址）

&ensp;&ensp;&ensp;&ensp; JIT即时编译器（Just In Time Compiler），简称 JIT 编译器: 

&ensp;&ensp;&ensp;&ensp; 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等。


