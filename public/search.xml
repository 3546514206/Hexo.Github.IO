<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>谈谈什么是云原生</title>
    <url>/2023/09/13/%E8%B0%88%E8%B0%88%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 之前关于云计算技术底座的部门会谈，我本着程序员实事求是的精神跟领导表示我不懂云原生——其实是不懂那些花里胡哨、似是而非的说法，比如下面的：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E5%8E%9F%E7%94%9F/%E8%B0%88%E8%B0%88%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9F%90%E6%96%87%E7%AB%A0.jpg?raw=true" alt="阿里云云原生公众号某文章"></p>
<p>&ensp;&ensp;&ensp;&ensp; 在没有实际实践过云原生应用开发之前，我对云原生的理解的真实状态也就是“似是而非”的。但是看过很多材料和案例（感觉接触的案例也不是很典型，哪里不典型也说不上来，就是呈现出来的样子跟那些云原生的文章所描述的场景不太契合）之后，我也尝试以咬文嚼字的方式简单概括给以下自己对于云原生的理解。</p>
<p>&ensp;&ensp;&ensp;&ensp; 云原生这个词其实可以拆为“云”和”原生“两个词，这其中其实隐藏了一个词——“云计算”。云原生一定是云计算，所以理解云原生一定要理解云计算的历史渊源。假设我们已经对云计算的发展都是很清楚的，那么一句话来说云原生就是：云原生是最大化发挥云计算所有优势的最短路径。实践这个“最短路径”，我总结成需要从三个方面考虑：应用架构、计算模型、代表技术。</p>
<p>&ensp;&ensp;&ensp;&ensp; 代表技术是最容易理解的：docker、K8S、定制化的 IAAS 底座（飞天系统等）。但是有人说：用了容器技术就是云原生，显然这也是比较片面的。为了最大化发挥云原生的计算优势，应用侧应该也要做架构升级——例如微服务化，在弹性扩缩的时候以更细的粒度进行算力分配，更精确的分配云计算底座资源（计算、存储、网络）——当然，这只是我简单作示意的一种说法。这种说法换个侧面来看，单体应用就不能上云计算么？当然可以，但是那就不叫云原生了，因为单体无法发挥出云计算的最大优势。最后来说计算模型，云原生计算模型强调了应用程序的可伸缩性、弹性、自动化和可维护性，以适应现代云环境中的需求。当然，应用的可伸缩、弹性自动化运维这些并不是应用自身具备的能力，而是在云上环境被赋予的，但是需要从应用侧做一定的开发任务，“以适应现代云环境中的需求”。</p>
]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>云计算领域</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>一种git分支模型</title>
    <url>/2023/09/10/%E4%B8%80%E7%A7%8Dgit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E5%B7%A5%E5%85%B7/git/%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B.png?raw=true" alt="git 分支模型"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>分支模型</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之模板方法模式和策略模式</title>
    <url>/2023/09/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 这篇博客的设计模式应用案例来自于这个仓库，完整代码可以参考本仓库：</p>
<p>&ensp;&ensp;&ensp;&ensp; <a href="https://github.com/3546514206/WxChatGPT">微信大模型接入</a></p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E4%BB%93%E5%BA%93.png?raw=true" alt="仓库主页"></p>
<p>&ensp;&ensp;&ensp;&ensp; 简单介绍一下这个仓库：1）实现了微信接入；2）实现了大模型接入；3）将微信的提问发给大模型，将大模型的回答返回给微信（欢迎给个 star）。</p>
<h4 id="1、背景分析"><a href="#1、背景分析" class="headerlink" title="1、背景分析"></a><strong>1、背景分析</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 1）我们预期接入的大模型肯定不止一种，现在市面上除了最牛的 GhatGPT，国内也陆续退出了豆包、文心一言、星火大模型等。为了获得良好的扩展性，我们可以基于策略模式对模型通讯模块进行封装，将不同的模型定义为一种通讯策略，程序中可以通过参数指定不同的模型工作；</p>
<p>&ensp;&ensp;&ensp;&ensp; 2）通讯的过程无非就是三个阶段：通信前参数组装、进行通讯、通讯完成处理结果，这里显然是可以通过模板方法进行封装的。结合策略模式，我们可以规定将来接入新模型的时候，有统一的代码组织形式和良好的扩展接口。</p>
<h4 id="2、知识补充"><a href="#2、知识补充" class="headerlink" title="2、知识补充"></a><strong>2、知识补充</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 我们这里不再对设计模式本身进行专门的讲解。</p>
<p>&ensp;&ensp;&ensp;&ensp; <a href="https://www.runoob.com/design-pattern/strategy-pattern.html">策略模式</a></p>
<p>&ensp;&ensp;&ensp;&ensp; <a href="https://www.runoob.com/design-pattern/template-pattern.html">模板方法模式</a></p>
<h4 id="3、代码分析"><a href="#3、代码分析" class="headerlink" title="3、代码分析"></a><strong>3、代码分析</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 如下图所示，DefaultHandler 是程序写给微信接入模块的一个回调（实现了消息处理接口 IMsgHandlerFace），当微信接入模块接收到微信消息，便会触发此回调，执行用户预定义行为。也就是在这个地方，我们接入了大模型，并将模型的问答结果返回给微信。 </p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E7%9A%84%E5%9C%B0%E6%96%B9.png?raw=true" alt="模型接入的地方"></p>
<p>&ensp;&ensp;&ensp;&ensp; 一下三行代码的作用分别是：获取聊天模型的策略上下文（请参考上文中菜鸟教程——策略模式），返回的策略上下文会包含具体的执行策略，执行策略的选择是程序参数定义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 聊天模型策略</span></span><br><span class="line"><span class="type">StrategyContext</span> <span class="variable">context</span> <span class="operator">=</span> getStrategyContext();</span><br><span class="line"><span class="comment">// 构建聊天请求</span></span><br><span class="line"><span class="type">ChatRequest</span> <span class="variable">request</span> <span class="operator">=</span> buildChatRequest(msg);</span><br><span class="line"><span class="comment">// 进行聊天</span></span><br><span class="line"><span class="type">ChatResponse</span> <span class="variable">response</span> <span class="operator">=</span> context.executeStrategy(request);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B.png?raw=true" alt="程序参数指定执行策略"></p>
<h4 id="3、策略模式实现"><a href="#3、策略模式实现" class="headerlink" title="3、策略模式实现"></a><strong>3、策略模式实现</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 首先，定义策略接口，策略接口中的 exec 方法是所有具体的策略类都需要实现的。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3.png?raw=true" alt="策略接口"></p>
<p>&ensp;&ensp;&ensp;&ensp; 定义策略上下文，上下文是统一交给用户侧的一个”句柄”（可以参考上文 DefaultHandler 的代码，用户侧通过获取策略上下文来执行具体的策略实现的），用于持有具体的策略实现。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E4%B8%8A%E4%B8%8B%E6%96%87.png?raw=true" alt="策略上下文"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我们这里的策略实现类稍有不同，没有直接实现 exec 方法，也没有直接实现 IStrategy 接口。这涉及到另外一个设计模式——模板方法模式。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E7%B1%BB.png?raw=true" alt="策略实现类"></p>
<h4 id="4、-模板方法模式"><a href="#4、-模板方法模式" class="headerlink" title="4、 模板方法模式"></a><strong>4、</strong> 模板方法模式</h4><p>&ensp;&ensp;&ensp;&ensp; 抽象策略类定义了一个算法模板方法，这个模板方法规定了 exec 方法执行时发生的三个算法步骤：postChatRequest (执行前的参数处理)、doExec (执行通讯请求)、postChatResponse(通讯完成之后的响应报文处理)。但是我并没有对这三个步骤进行实现，他们都是抽象的，延迟到了将来的策略实现类去实现。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E7%AD%96%E7%95%A5%E7%B1%BB.jpg?raw=true" alt="抽象策略类"></p>
<p>&ensp;&ensp;&ensp;&ensp; 所有的策略实现类，实现的不是策略接口 IStrategy，而是继承抽象策略类 AbstractStrategy，也不再去实现 exec 方法，而是实现抽象类中算法模板规定的三个算法步骤。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%88%B6%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.jpg?raw=true" alt="实现抽象策略类中规定的三个既定步骤"></p>
<h4 id="5、-其他一些想法"><a href="#5、-其他一些想法" class="headerlink" title="5、 其他一些想法"></a><strong>5、</strong> 其他一些想法</h4><p>&ensp;&ensp;&ensp;&ensp; 面向对象语言最重要的三个基本特性：封装、多态、继承，是软件工程七大原则开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特原则和合成复用原则的重要支撑点，设计模式是一种如何最大化发挥三个基本特性，从而能够遵循七大原则的一种编码层级上的技术，这也是 Java、C++ 等完美支持 OOP 编程范式语言，在面临庞大复杂工程时，总能将源代码组织得很好的原因之一吧。从这个角度出发，Go 语言在多态、继承的表现力上不足，也许是因为我还比较缺乏 Go 开发的实战经验，所以我不确定在面临复杂的建模场景的时候，Go 语言的编程方式还能不能进行有效表达。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>设计模式</category>
        <category>策略模式、模板方法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础语法宝典</title>
    <url>/2023/09/04/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9D%E5%85%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言设计的关键字，了解这些关键字有助于命名变量的冲突避免</p>
<h3 id="go的二十五个关键字"><a href="#go的二十五个关键字" class="headerlink" title="go的二十五个关键字"></a>go的二十五个关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p><code>var</code>和<code>const</code> 是 Go语言基础里面的变量和常量申明</p>
</li>
<li><p><code>package</code>和<code>import</code> 用于分包和导入</p>
</li>
<li><p><code>func</code> 用于定义函数和方法</p>
</li>
<li><p><code>return</code> 用于从函数返回</p>
</li>
<li><p><code>defer</code> 用于类似析构函数</p>
</li>
<li><p><code>go</code> 用于并发</p>
</li>
<li><p><code>select</code> 用于选择不同类型的通讯</p>
</li>
<li><p><code>interface</code> 用于定义接口</p>
</li>
<li><p><code>struct</code> 用于定义抽象数据类型</p>
</li>
<li><p><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 用于流程控制</p>
</li>
<li><p><code>chan</code>用于channel通讯</p>
</li>
<li><p><code>type</code>用于声明自定义类型</p>
</li>
<li><p><code>map</code>用于声明map类型数据</p>
</li>
<li><p><code>range</code>用于读取slice、map、channel数据</p>
</li>
</ul>
<h1 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Go语言里面定义变量有多种方式。</p>
<p>使用<code>var</code>关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义三个类型都是“type”的变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义变量并初始化值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>

<p>同时初始化多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span>= v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>是不是觉得上面这样的定义有点繁琐？有一种写法可以让它变得简单一点。可以直接忽略类型声明，那么上面的代码变成这样了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    然后Go会根据其相应值的类型来初始化它们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>觉得上面的还是有些繁琐，继续简化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    编译器会根据初始化的值自动推导出相应的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>现在是不是看上去非常简洁了？<code>:=</code>这个符号直接取代了<code>var</code>和<code>type</code>,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用<code>var</code>方式来定义全局变量。</p>
<p><code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，将值<code>35</code>赋予<code>b</code>，并同时丢弃<code>34</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了<code>i</code>但未使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<p>它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>下面是一些常量声明的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> MaxThread = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;astaxie_&quot;</span></span><br></pre></td></tr></table></figure>

<p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给<code>float32</code>自动缩短为<code>32bit</code>，指定给<code>float64</code>自动缩短为<code>64bit</code>，详情参考 <code>http://golang.org/ref/spec#Constants</code> (需科学上网)</p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="type">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="type">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。</p>
<p>如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)</p>
<p>var a int8</p>
<p>var b int32</p>
<p>c:&#x3D;a + b</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p>
<p>Go还支持复数。它的默认类型是<code>complex128</code>（64位实数+64位虚数）。如果需要小一些的，也有<code>complex64</code>(32位实数+32位虚数)。复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。下面是一个使用复数的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="type">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code> </code>）括起来定义，它的类型是<code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="type">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="type">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">    frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但如果真的想要修改怎么办呢？下面的代码可以实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br></pre></td></tr></table></figure>

<p>Go中可以使用<code>+</code>操作符来连接两个字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure>

<p>修改字符串也可写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>

<p>如果要声明一个多行的字符串怎么办？可以通过&#96;&#96;&#96;来声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">    world`</span></span><br></pre></td></tr></table></figure>

<p>`&#96;&#96; 括起的字符串为<code>Raw</code>字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure>

<h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h2><p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。</p>
<p>例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> prefix <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>可以分组写成如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    pi <span class="type">float32</span></span><br><span class="line">    prefix <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h2><p>Go里面有一个关键字<code>iota</code>，这个关键字用来声明<code>enum</code>的时候采用，它默认开始值是0，const中每增加一行加1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">    y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">    z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">    w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">    b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">    c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">    d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">    g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p>
<h2 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h2><p>Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
<li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数。</li>
</ul>
<h2 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a><code>array</code>、<code>slice</code>、<code>map</code></h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h3><p><code>array</code>就是数组，它的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">//返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure>

<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组可以使用另一种<code>:=</code>来声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line">b := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure>

<p>Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p>在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和声明array一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>接下来可以声明一个<code>slice</code>，并初始化数据，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="type">byte</span></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"><span class="comment">// b是数组ar的另一个slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure>

<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
<h4 id="slice有一些简便的操作"><a href="#slice有一些简便的操作" class="headerlink" title="slice有一些简便的操作"></a><code>slice</code>有一些简便的操作</h4><ul>
<li><p><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></p>
</li>
<li><p><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></p>
</li>
<li><p>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></p>
</li>
</ul>
<p>下面这个例子展示了更多关于<code>slice</code>的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="type">byte</span></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:]  <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>]  <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>]  <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:]   <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>aSlice</code>中元素的值，那么<code>bSlice</code>相对应的值也会改变。</p>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li><p>一个指针，指向数组中<code>slice</code>指定的开始位置</p>
</li>
<li><p>长度，即<code>slice</code>的长度</p>
</li>
<li><p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Array_a := [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line">    Slice_a := Array_a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="slice有几个有用的内置函数"><a href="#slice有几个有用的内置函数" class="headerlink" title="slice有几个有用的内置函数"></a><code>slice</code>有几个有用的内置函数</h4><ul>
<li><p><code>len</code> 获取<code>slice</code>的长度</p>
</li>
<li><p><code>cap</code> 获取<code>slice</code>的最大容量</p>
</li>
<li><p><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></p>
</li>
<li><p><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</p>
</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。</p>
<p>但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<p>从Go1.2开始<code>slice</code>支持了三个参数的<code>slice</code>，之前一直采用这种方式在<code>slice</code>或者<code>array</code>基础上来获取一个<code>slice</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>上面这个的容量就是<code>7-2</code>，即5。这样这个产生的新的<code>slice</code>就没办法访问最后的三个元素。</p>
<p>如果<code>slice</code>是这样的形式<code>array[:i:j]</code>，即第一个参数为空，默认值就是0。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span><span class="string">`也就是Python中字典的概念，它的格式为`</span><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure>

<p>看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是｀int｀类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure>

<p>这个<code>map</code>就像平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用<code>map</code>过程中需要注意的几点：</p>
<ul>
<li><p><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</p>
</li>
<li><p><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</p>
</li>
<li><p>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</p>
</li>
<li><p><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></p>
</li>
<li><p><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p>
</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure>

<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Bonjour&quot;</span></span><br><span class="line">m1 := m</span><br><span class="line">m1[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Salut&quot;</span>  <span class="comment">// 现在m[&quot;hello&quot;]的值已经是Salut了</span></span><br></pre></td></tr></table></figure>

<h2 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a><code>make</code>、<code>new</code>操作</h2><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<p>内建函数<code>new</code>本质上说跟其它语言中的同名函数功能一样：<code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。有一点非常重要：</p>
<p><code>new</code>返回指针。</p>
<p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个<code>slice</code>，是一个包含指向数据（内部<code>array</code>）的指针、长度和容量的三项描述符；在这些项目被初始化之前，<code>slice</code>为<code>nil</code>。对于<code>slice</code>、<code>map</code>和<code>channel</code>来说，<code>make</code>初始化了内部的数据结构，填充适当的值。</p>
<p><code>make</code>返回初始化后的（非零）值。</p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。</p>
<p>此处罗列 部分类型 的 “零值”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>     <span class="number">0</span></span><br><span class="line"><span class="type">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="type">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="type">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="type">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="type">rune</span>    <span class="number">0</span> <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="type">byte</span>    <span class="number">0x0</span> <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="type">float32</span> <span class="number">0</span> <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="type">float64</span> <span class="number">0</span> <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="type">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="type">string</span>  <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的<code>if</code>还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>多个条件的时候如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Go有<code>goto</code>语句——请明智地使用它。用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">Here:   <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">goto</span> Here   <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签名是大小写敏感的。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go里面最强大的一个控制逻辑就是<code>for</code>，它既可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，看看下面的例子吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure>

<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果忽略<code>expression1</code>和<code>expression3</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，这就是<code>while</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code>   ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure>

<p><code>break</code>和<code>continue</code>还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值</p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>有些时候需要写很多的<code>if-else</code>来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候<code>switch</code>就能很好的解决这个问题。它的语法如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的类型必须一致。Go的<code>switch</code>非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果<code>switch</code>没有表达式，它会匹配<code>true</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第5行中，把很多值聚合在了一个<code>case</code>里面，同时，Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以使用<code>fallthrough</code>强制执行后面的case代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是Go里面的核心设计，它通过关键字<code>func</code>来声明，它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line">    <span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">    <span class="comment">//返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出</p>
<ul>
<li><p>关键字<code>func</code>用来声明一个函数<code>funcName</code></p>
</li>
<li><p>函数可以有一个或者多个参数，每个参数后面带有类型，通过<code>,</code>分隔</p>
</li>
<li><p>函数可以返回多个值</p>
</li>
<li><p>上面返回值声明了两个变量<code>output1</code>和<code>output2</code>，如果不想声明也可以，直接就两个类型</p>
</li>
<li><p>如果只有一个返回值且不声明返回值变量，那么可以省略 包括返回值的括号</p>
</li>
<li><p>如果没有返回值，那么就直接省略最后的返回信息</p>
</li>
<li><p>如果有返回值， 那么必须在函数的外层添加return语句</p>
</li>
</ul>
<p>下面来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line">    max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个里面可以看到<code>max</code>函数有两个参数，它们的类型都是<code>int</code>，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<p>直接看例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子可以看到直接返回了两个参数，当然也可以命名返回参数的变量，这个例子里面只是用了两个类型，也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">    add = A+B</span><br><span class="line">    Multiplied = A*B</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p>
<p>为了验证上面的说法，来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a = a+<span class="number">1</span> <span class="comment">// 改变了a的值</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">//返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(x)  <span class="comment">//调用add1(x)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出&quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出&quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然调用了<code>add1</code>函数，并且在<code>add1</code>中执行<code>a = a+1</code>操作，但是上面例子中<code>x</code>变量的值没有发生变化</p>
<p>理由很简单：因为当调用<code>add1</code>的时候，<code>add1</code>接收的参数其实是<code>x</code>的copy，而不是<code>x</code>本身。</p>
<p>如果真的需要传这个<code>x</code>本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p>
<ul>
<li><p>传指针使得多个函数能操作同一个对象。</p>
</li>
<li><p>传指针比较轻量级 (8bytes),只是传内存地址，可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。</p>
</li>
<li><p>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</p>
</li>
</ul>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言中有种不错的设计，即延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有很多重复的代码，Go的<code>defer</code>有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在<code>defer</code>后指定的函数会在函数退出前调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，defer会用在释放数据库连接，关闭文件等需要在函数结束时处理的操作。</p>
<h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在Go中函数也是一种变量，可以通过<code>type</code>来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 inputType1 , input2 inputType2 [, ...])</span></span> (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure>

<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">bool</span> <span class="comment">// 声明了一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="type">int</span>, f testInt)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数当做值和类型在写一些通用接口的时候非常有用，通过上面例子看到<code>testInt</code>这个类型是一个函数类型，然后两个<code>filter</code>函数的参数和返回值与<code>testInt</code>类型是一样的，但是可以实现很多种的逻辑，这样使得程序变得非常的灵活。</p>
<h2 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h2><p>Go没有像Java那样的异常机制，它不能抛出异常，而是使用了<code>panic</code>和<code>recover</code>机制。一定要记住，应当把它作为最后的手段来使用，也就是说，代码中应当没有，或者很少有<code>panic</code>的东西。这是个强大的工具，请明智地使用它。</p>
<p>Panic</p>
<p>是一个内建函数，可以中断原有的控制流程，进入一个<code>panic</code>状态中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。<code>panic</code>可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p>
<p>Recover</p>
<p>是一个内建的函数，可以让进入<code>panic</code>状态的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p>
<p>下面这个函数演示了如何在过程中使用<code>panic</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span></span>) (b <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>defer</code>必须在<code>panic</code>语句之前。</p>
<p><code>recover</code>必须配合<code>defer</code>使用。</p>
<h2 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h2><p>Go里面有两个保留的函数：<code>init</code>函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p>
<p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p>
<p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在写Go代码的时候经常用到import这个命令用来导入包文件，经常看到的方式参考如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后代码里面可以通过如下的方式调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<h3 id="1、相对路径"><a href="#1、相对路径" class="headerlink" title="1、相对路径"></a>1、相对路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./model&quot;</span> <span class="comment">//当前文件同一目录的model目录，但是不建议这种方式来import</span></span><br></pre></td></tr></table></figure>

<h3 id="2、绝对路径"><a href="#2、绝对路径" class="headerlink" title="2、绝对路径"></a>2、绝对路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;shorturl/model&quot;</span> <span class="comment">//加载gopath/src/shorturl/model模块</span></span><br></pre></td></tr></table></figure>

<p>上面展示了一些import常用的几种方式，但是还有一些</p>
<h3 id="特殊的import"><a href="#特殊的import" class="headerlink" title="特殊的import"></a>特殊的import</h3><h4 id="1、点操作"><a href="#1、点操作" class="headerlink" title="1、点操作"></a>1、点操作</h4><p>有时候会看到如下的方式导入包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个点操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名，也就是前面调用的fmt.Println(“hello world”)可以省略的写成<code>Println(&quot;hello world&quot;)</code></p>
<h4 id="2、别名操作"><a href="#2、别名操作" class="headerlink" title="2、别名操作"></a>2、别名操作</h4><p>别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">        f <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>别名操作的话调用包函数时前缀变成了前缀，即<code>f.Println(&quot;hello world&quot;)</code></p>
<h4 id="3、-操作"><a href="#3、-操作" class="headerlink" title="3、_操作"></a>3、_操作</h4><p>这个操作经常是让很多人费解的一个操作符，请看下面这个<code>import</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/ziutek/mymysql/godrv&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>_</code>操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的<code>init函数</code>。</p>
<h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct类型的声明"><a href="#struct类型的声明" class="headerlink" title="struct类型的声明"></a>struct类型的声明</h2><p>Go语言中，也和C或者其他语言一样，可以声明新的类型，作为其它类型的属性或字段的容器。例如，可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型称之<code>struct</code>。如下代码所示:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>struct</code>如此简单，上面的类型包含有两个字段</p>
<ul>
<li>一个<code>string</code>类型的字段name，用来保存用户名称这个属性</li>
<li>一个<code>int</code>类型的字段age，用来保存用户年龄这个属性</li>
</ul>
<p>使用<code>struct</code>看下面的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值&quot;Astaxie&quot;给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值&quot;25&quot;给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure>

<p>除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p>
<ol>
<li><p>按照顺序提供初始化值<br><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p>
</li>
<li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序<br><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p>
</li>
<li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code><br><code>P := new(person)</code></p>
</li>
</ol>
<p>看一个完整的使用<code>struct</code>的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span></span> (person, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> p1.age&gt;p2.age &#123;  <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tom person</span><br><span class="line">    <span class="comment">// 赋值初始化</span></span><br><span class="line">    tom.name, tom.age = <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span></span><br><span class="line">    <span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">    bob := person&#123;age:<span class="number">25</span>, name:<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">    paul := person&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">43</span>&#125;</span><br><span class="line">    tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">    tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">    bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a><code>struct</code>的匿名字段</h2><p>定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
<p>当匿名字段是一个<code>struct</code>的时候，那么这个<code>struct</code>所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p>
<p>看一个例子，让上面说的这些更具体化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，匿名字段就是这样，能够实现字段的继承。student还能访问Human这个字段作为字段名。请看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mark.Human = Human&#123;<span class="string">&quot;Marcus&quot;</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过匿名访问和修改字段相当的有用，但是不仅仅是<code>struct</code>字段，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">    Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">    <span class="type">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化学生Jane</span></span><br><span class="line">    jane := Student&#123;Human:Human&#123;<span class="string">&quot;Jane&quot;</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">&quot;Biology&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 现在访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her name is &quot;</span>, jane.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her age is &quot;</span>, jane.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her weight is &quot;</span>, jane.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her speciality is &quot;</span>, jane.speciality)</span><br><span class="line">    <span class="comment">// 修改他的skill技能字段</span></span><br><span class="line">    jane.Skills = []<span class="type">string</span>&#123;<span class="string">&quot;anatomy&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills are &quot;</span>, jane.Skills)</span><br><span class="line">    fmt.Println(<span class="string">&quot;She acquired two new ones &quot;</span>)</span><br><span class="line">    jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">&quot;physics&quot;</span>, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills now are &quot;</span>, jane.Skills)</span><br><span class="line">    <span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">    jane.<span class="type">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her preferred number is&quot;</span>, jane.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面例子看出来<code>struct</code>不仅仅能够将<code>struct</code>作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p>
<p>这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p>
<p>Go里面很简单的解决了这个问题，最外层的优先访问，也就是当通过<code>student.phone</code>访问的时候，是访问student里面的字段，而不是human里面的字段。</p>
<p>这样就允许去重载通过匿名字段继承的一些字段，当然如果想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// Human类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段Human</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// 雇员的phone字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">    <span class="comment">// 如果要访问Human的phone字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>函数的另一种形态，带有接收者的函数，称为<code>method</code></p>
<h2 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，定义了一个struct叫做长方形，现在想要计算他的面积，那么按照一般的思路应该会用下面的方式来实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r Rectangle)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, area(r1))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p>
<p>这样实现当然没有问题，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，想计算他们的面积的时候怎么办？那就只能增加新的函数，但是函数名就必须要跟着换了，变成<code>area_rectangle, area_circle, area_triangle...</code></p>
<p> 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p>
<p>很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p>
<p>基于上面的原因所以就有了<code>method</code>的概念，<code>method</code>是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在<code>func</code>后面增加了一个receiver(也就是method所依从的主体)。</p>
<p>用上面提到的形状的例子来说，method <code>area()</code> 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p>
<p>更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p>
<p>用Rob Pike的话来说就是：</p>
<p>“A method is a function with an implicit first argument, called a receiver.”</p>
<p>method的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r ReceiverType)</span></span> funcName(parameters) (results)</span><br></pre></td></tr></table></figure>

<p>下面用最开始的例子用method来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用method的时候重要注意几点</p>
<ul>
<li><p>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</p>
</li>
<li><p>method里面可以访问接收者的字段</p>
</li>
<li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p>
</li>
</ul>
<p>在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle&#x2F;Circle 发出的。</p>
<p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p>
<p>那是不是method只能作用在struct上面呢？当然不是，他可以定义在任何自定义的类型、内置类型、struct等各种类型上面。什么叫自定义类型，自定义类型不就是struct，其实不是这样的，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type typeName typeLiteral</span><br></pre></td></tr></table></figure>

<p>请看下面这个申明自定义类型的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ages <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> money <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> months <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m := months &#123;</span><br><span class="line">    <span class="string">&quot;January&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;February&quot;</span>:<span class="number">28</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;December&quot;</span>:<span class="number">31</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int，回到<code>method</code> 可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让看一个复杂一点的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    WHITE = <span class="literal">iota</span></span><br><span class="line">    BLACK</span><br><span class="line">    BLUE</span><br><span class="line">    RED</span><br><span class="line">    YELLOW</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Color <span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height, depth <span class="type">float64</span></span><br><span class="line">    color Color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span></span> Volume() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">    b.color = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> BiggestColor() Color &#123;</span><br><span class="line">    v := <span class="number">0.00</span></span><br><span class="line">    k := Color(WHITE)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        <span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">            v = bv</span><br><span class="line">            k = b.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> PaintItBlack() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        bl[i].SetColor(BLACK)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    strings := []<span class="type">string</span> &#123;<span class="string">&quot;WHITE&quot;</span>, <span class="string">&quot;BLACK&quot;</span>, <span class="string">&quot;BLUE&quot;</span>, <span class="string">&quot;RED&quot;</span>, <span class="string">&quot;YELLOW&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boxes := BoxList &#123;</span><br><span class="line">        Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">        Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">        Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;We have %d boxes in our set\n&quot;</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">    fmt.Println(<span class="string">&quot;The volume of the first one is&quot;</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">&quot;cm³&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the last one is&quot;</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s paint them all black&quot;</span>)</span><br><span class="line">    boxes.PaintItBlack()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the second one is&quot;</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Obviously, now, the biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过const定义了一些常量，然后定义了一些自定义类型</p>
<ul>
<li><p>Color作为byte的别名</p>
</li>
<li><p>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</p>
</li>
<li><p>定义了一个slice:BoxList，含有Box</p>
</li>
</ul>
<p>然后以上面的自定义类型为接收者定义了一些method</p>
<ul>
<li><p>Volume()定义了接收者为Box，返回Box的容量</p>
</li>
<li><p>SetColor(c Color)，把Box的颜色改为c</p>
</li>
<li><p>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</p>
</li>
<li><p>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</p>
</li>
<li><p>String()定义在Color上面，返回Color的具体颜色(字符串格式)</p>
</li>
</ul>
<p>上面的代码通过文字描述出来之后是不是很简单？一般解决问题都是通过问题的描述，去写相应的代码实现。</p>
<h2 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h2><p>现在让回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，可以使用*Box。</p>
<p>定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以需要传入指针。</p>
<p>这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p>
<p>这里也许会问SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,需要读取到指针相应的值。</p>
<p>其实Go里面这两种方式都是正确的，当用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值。PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。这两种方式都可以，因为Go知道receiver是指针，他自动转了。</p>
<p>也就是说：</p>
<p>如果一个method的receiver是*T,可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p>
<p>类似的</p>
<p>如果一个method的receiver是T，可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method</p>
<p>所以不用担心是调用的指针的method还是不是指针的method，Go知道要做的一切，这对于有多年C&#x2F;C++编程经验的同学来说，真是解决了一个很大的痛苦。</p>
<h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>通过字段的继承的学习，发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。来看下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><p>上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些内容，可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>Go语言里面设计最精妙的应该算<code>interface</code>，它让面向对象，内容组织实现非常的方便</p>
<h2 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，<code>interface</code>是一组<code>method</code>签名的组合，通过<code>interface</code>来定义对象的一组行为。</p>
<p>前面例子中<code>Student</code>和<code>Employee</code>都能<code>SayHi</code>，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p>
<p>继续做更多的扩展，<code>Student</code>和<code>Employee</code>实现另一个方法<code>Sing</code>，然后<code>Student</code>实现方法<code>BorrowMoney</code>而<code>Employee</code>实现<code>SpendSalary</code>。</p>
<p>这样<code>Student</code>实现了三个方法：<code>SayHi</code>、<code>Sing</code>、<code>BorrowMoney</code>；而<code>Employee</code>实现了<code>SayHi</code>、<code>Sing</code>、<code>SpendSalary</code>。</p>
<p>上面这些方法的组合称为<code>interface</code>(被对象<code>Student</code>和<code>Employee</code>实现)。例如<code>Student</code>和<code>Employee</code>都实现了<code>interface</code>：<code>SayHi</code>和<code>Sing</code>，也就是这两个对象是该<code>interface</code>类型。而<code>Employee</code>没有实现这个<code>interface：SayHi、Sing</code>和<code>BorrowMoney</code>，因为<code>Employee</code>没有实现<code>BorrowMoney</code>这个方法。</p>
<h2 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h2><p><code>interface</code>类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，interface可以被任意的对象实现。看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p>最后，任意的类型都实现了空interface(这样定义：interface{})，也就是包含0个method的interface。</p>
<h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><p>那么interface里面到底能存什么值呢？如果定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p>因为m能够持有这三种类型的对象，所以可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和传统意义上面的slice有所不同。</p>
<p>来看一下下面这个例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">    <span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line">    <span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">    <span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">    <span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，发现<code>interface</code>就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了<code>duck-typing</code>:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure>

<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回<code>interface&#123;&#125;</code>,那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h2 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h2><p>interface的变量可以持有任意实现该interface类型的对象，这给编写函数(包括method)提供了一些额外的思考，是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println是常用的一个函数，是否注意到它可以接受任意类型的数据。打开fmt的源码文件，会看到这样一个定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，任何实现了String方法的类型都能作为参数被<code>fmt.Println</code>调用,来试一试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在再回顾一下前面的Box示例，发现Color结构也定义了一个<code>method：String</code>。其实这也是实现了<code>fmt.Stringer</code>这个<code>interface</code>，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现<code>Stringer</code>这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure>

<p>注：实现了<code>error</code>接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
<h2 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h2><p>interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<ul>
<li>Comma-ok断言</li>
</ul>
<p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok &#x3D; element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p>
<p>通过一个例子来更加深入的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="type">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否注意到了多个if里面，if里面允许初始化变量。断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。</p>
<ul>
<li>switch测试</li>
</ul>
<p>重写上面的这个实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要强调的是：<code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用<code>comma-ok</code>。</p>
<h2 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h2><p>Go里面真正吸引人的是它内置的逻辑语法，就像在学习Struct时学习的匿名字段，那么相同的逻辑引入到interface里面，更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p>
<p>可以看到源码包<code>container/heap</code>里面有这样的一个定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>sort.Interface</code>其实就是嵌入字段，把<code>sort.Interface</code>的所有<code>method</code>给隐式的包含进来了。也就是下面三个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子就是io包下面的 <code>io.ReadWriter</code> ，它包含了io包下面的<code>Reader</code>和<code>Writer</code>两个<code>interface</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。一般用到的包是<code>reflect</code>包。如何运用<code>reflect</code>包，官方的这篇文章详细的讲解了<code>reflect</code>包的实现原理，<code>laws of reflection</code> 链接地址为 <a href="http://golang.org/doc/articles/laws_of_reflection.html">http://golang.org/doc/articles/laws_of_reflection.html</a></p>
<p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了<code>空interface</code>)，首先需要把它转化成<code>reflect</code>对象(<code>reflect.Type</code>或者<code>reflect.Value</code>，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>

<p>转化为reflect对象之后就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>

<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>

<p>最后，反射的话，那么反射的字段必须是可修改的，前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<p>如果要修改相应的值，必须这样写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go从语言层面支持了并行。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><code>goroutine</code>是<code>Go</code>并行设计的核心。<code>goroutine</code>说到底其实就是协程，但是它比线程更小，十几个<code>goroutine</code>可能体现在底层就是五六个线程，Go语言内部实现了这些<code>goroutine</code>之间的内存共享。执行<code>goroutine</code>只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。<code>goroutine</code>比<code>thread</code>更易用、更高效、更轻便。</p>
<p><code>goroutine</code>是通过Go的<code>runtime</code>管理的一个线程管理器。<code>goroutine</code>通过<code>go</code>关键字实现了，其实就是一个普通的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure>

<p>通过关键字go就启动了一个<code>goroutine</code>。来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>可以看到go关键字很方便的就实现了并发编程。</p>
<p>上面的多个<code>goroutine</code>运行在同一个进程里面，共享内存数据，不过设计上要遵循：不要通过共享来通信，而要通过通信来共享。</p>
<p><code>runtime.Gosched()</code>表示让CPU把时间片让给别人,下次某个时候继续恢复执行该<code>goroutine</code>。</p>
<p>默认情况下，在Go 1.5将标识并发系统线程个数的<code>runtime.GOMAXPROCS</code>的初始值由1改为了<code>运行环境的CPU核数</code>。</p>
<p>但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要程序中显式调用 <code>runtime.GOMAXPROCS(n)</code> 告诉调度器同时使用多个线程。<code>GOMAXPROCS</code> 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果<code>n &lt; 1</code>，不会改变当前设置。</p>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p><code>goroutine</code>运行在相同的地址空间，因此访问共享内存必须做好同步。那么<code>goroutine</code>之间如何进行数据的通信呢，Go提供了一个很好的通信机制<code>channel</code>。<code>channel</code>可以与<code>Unix shell</code> 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：<code>channel类型</code>。定义一个<code>channel</code>时，也需要定义发送到<code>channel</code>的值的类型。注意，必须使用<code>make</code> 创建<code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><code>channel</code>通过操作符<code>&lt;-</code>来接收和发送数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure>

<p>把这些应用到例子中来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>channel</code>接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得<code>Goroutines</code>同步变的更加的简单，而不需要显式的<code>lock</code>。所谓阻塞，也就是如果读取（<code>value := &lt;-ch</code>）它将会被阻塞，直到有数据接收。其次，任何发送（<code>ch&lt;-5</code>）将会被阻塞，直到数据被读出。无缓冲<code>channel</code>是在多个<code>goroutine</code>之间同步很棒的工具。</p>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。<code>ch:= make(chan bool</code>, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure>

<p>当 <code>value = 0</code> 时，channel 是无缓冲阻塞读写的，当<code>value &gt; 0</code> 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p>
<p>看一下下面这个例子，可以在自己本机测试一下，修改相应的value值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改为1报如下的错误:</span></span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>

<h2 id="Range和Close"><a href="#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h2><p>上面这个例子中，需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for i := range c</code>能够不断的读取<code>channel</code>里面的数据，直到该<code>channel</code>被显式的关闭。上面代码看到可以显式的关闭<code>channel</code>，生产者通过内置函数<code>close</code>关闭<code>channel</code>。关闭<code>channel</code>之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试<code>channel</code>是否被关闭。如果ok返回false，那么说明<code>channel</code>已经没有任何数据并且已经被关闭。</p>
<p>记住应该在生产者的地方关闭<code>channel</code>，而不是消费的地方去关闭它，这样容易引起<code>panic</code></p>
<p>另外记住一点的就是<code>channel</code>不像文件之类的，不需要经常去关闭，只有确实没有任何发送数据了，或者想显式的结束<code>range</code>循环之类的</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>上面介绍的都是只有一个<code>channel</code>的情况，那么如果存在多个<code>channel</code>的时候，该如何操作呢，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听<code>channel</code>上的数据流动。</p>
<p><code>select</code>默认是阻塞的，只有当监听的<code>channel</code>中有发送或接收可以进行时才会运行，当多个<code>channel</code>都准备好的时候，<code>select</code>是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>select</code>里面还有<code>default</code>语法，<code>select</code>其实就是类似<code>switch</code>的功能，<code>default</code>就是当监听的<code>channel</code>都没有准备好的时候，默认执行的（<code>select</code>不再阻塞等待<code>channel</code>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现<code>goroutine</code>阻塞的情况，那么如何避免整个程序进入阻塞的情况呢？可以利用<code>select</code>来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p><code>runtime</code>包中有几个处理<code>goroutine</code>的函数：</p>
<ul>
<li><p><code>Goexit</code> : 退出当前执行的goroutine，但是defer函数还会继续调用</p>
</li>
<li><p><code>Gosched</code>: 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p><code>NumCPU</code> : 返回 CPU 核数量</p>
</li>
<li><p><code>NumGoroutine</code>: 返回正在执行和排队的任务总数</p>
</li>
<li><p><code>GOMAXPROCS</code> : 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言主要的设计准则是：简洁、明白，简洁是指语法和C类似，相当的简单，明白是指任何语句都是很明显的，不含有任何隐含的东西，在错误处理方案的设计中也贯彻了这一思想。</p>
<p>在C语言里面是通过返回<code>-1</code>或者<code>NULL</code>之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而<code>Go</code>定义了一个叫做<code>error</code>的类型，来显式表达错误。在使用时，通过把返回的<code>error</code>变量与<code>nil</code>的比较，来判定操作是否成功。例如<code>os.Open</code>函数在打开文件失败时将返回一个不为<code>nil</code>的<code>error</code>变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>下面这个例子通过调用<code>os.Open</code>打开一个文件，如果出现错误，那么就会调用<code>log.Fatal</code>来输出错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;filename.ext&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于<code>os.Open</code>函数，标准包中所有可能出错的API都会返回一个<code>error</code>变量，以方便错误处理，这个小节将详细地介绍<code>error</code>类型的设计，和讨论开发Web应用中如何更好地处理<code>error</code>。</p>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>error是一个内置的接口类型，可以在<code>/builtin/</code>包下面找到相应的定义。而在很多内部包里面用到的 <code>error</code>是<code>errors</code>包下面的实现的私有结构<code>errorString</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<code>errors.New</code>把一个字符串转化为<code>errorString</code>，以得到一个满足接口<code>error</code>的对象，其内部实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子演示了如何使用<code>errors.New</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，在调用Sqrt的时候传递的一个负数，然后就得到了<code>non-nil</code>的<code>error</code>对象，将此对象与<code>nil</code>比较，结果为<code>true</code>，所以<code>fmt.Println</code>(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := Sqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Error"><a href="#自定义Error" class="headerlink" title="自定义Error"></a>自定义Error</h2><p><code>error</code>是一个<code>interface</code>，所以在实现自己的包的时候，通过定义实现此接口的结构，就可以实现自己的错误定义，请看来自Json包的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="type">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="type">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>

<p><code>Offset</code>字段在调用<code>Error</code>的时候不会被打印，但可以通过类型断言获取错误类型，然后可以打印相应的错误信息，请看下面的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">        line, col := findLine(f, serr.Offset)</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s:%d:%d: %v&quot;</span>, f.Name(), line, col, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数返回自定义错误时，返回值推荐设置为<code>error</code>类型，而非自定义错误类型，特别需要注意的是不应预声明自定义错误类型的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">()</span></span> *SyntaxError &#123; <span class="comment">// 错误，将可能导致上层调用者err!=nil的判断永远为true。</span></span><br><span class="line">    <span class="keyword">var</span> err *SyntaxError     <span class="comment">// 预声明错误变量</span></span><br><span class="line">    <span class="keyword">if</span> 出错条件 &#123;</span><br><span class="line">        err = &amp;SyntaxError&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err               <span class="comment">// 错误，err永远等于非nil，导致上层调用者err!=nil的判断始终为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因见 <code>http://golang.org/doc/faq#nil_error</code> (需科学上网)</p>
<p>上面例子简单的演示了如何自定义Error类型。但是如果还需要更复杂的错误处理呢？此时，来参考一下net包采用的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的地方，通过类型断言<code>err</code>是不是<code>net.Error</code>,来细化错误的处理，例如下面的例子，如果一个网络发生临时性错误，那么将会sleep 1秒之后重试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go在错误处理上采用了与C类似的检查返回值的方式，而不是其他多数主流语言采用的异常方式，这造成了代码编写上的一个很大的缺点:错误处理代码的冗余，对于这种情况是通过复用检测函数来减少类似的代码。</p>
<p>请看下面这个例子代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/view&quot;</span>, viewRecord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中获取数据和模板展示调用时都有检测错误，当有错误发生时，调用了统一的处理函数<code>http.Error</code>，返回给客户端500错误码，并显示相应的错误数据。但是当越来越多的<code>HandleFunc</code>加入之后，这样的错误处理逻辑代码就会越来越多，其实可以通过自定义路由器来缩减代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fn(w, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了自定义的路由器，然后可以通过如下方式来注册函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/view&quot;</span>, appHandler(viewRecord))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求<code>/view</code>的时候逻辑处理可以变成如下代码，和第一种实现方式相比较已经简单了很多。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewTemplate.Execute(w, record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子错误处理的时候所有的错误返回给用户的都是500错误码，然后打印出来相应的错误代码，其实可以把这个错误信息定义的更加友好，调试的时候也方便定位问题，可以自定义返回的错误类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   <span class="type">error</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样自定义路由器可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> *appError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">&quot;%v&quot;</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改完自定义错误之后，逻辑处理可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> *appError &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在访问view的时候可以根据不同的情况获取不同的错误码和错误信息，虽然这个和第一个版本的代码量差不多，但是这个显示的错误更加明显，提示的错误信息更加友好，扩展性也比第一个更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在程序设计中，容错是相当重要的一部分工作，在Go中它是通过错误处理来实现的，error虽然只是一个接口，但是其变化却可以有很多，可以根据自己的需求来实现不同的处理。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang新手可能会踩的50个坑</title>
    <url>/2023/09/04/Golang%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%8450%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p>
<p>如果花时间学习官方 doc、wiki、<a href="https://groups.google.com/forum/#!forum/golang-nuts">讨论邮件列表</a>、 <a href="https://github.com/robpike">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p>
<h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-不能单独放一行"><a href="#1-左大括号-不能单独放一行" class="headerlink" title="1. 左大括号 { 不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;    <span class="comment">// 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.&#x2F;main.go: missing function body</p>
</blockquote>
<blockquote>
<p>.&#x2F;main.go: syntax error: unexpected semicolon or newline before {</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p>
<p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span>     <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span>     <span class="comment">// error: one declared and not used</span></span><br><span class="line">    two := <span class="number">2</span>    <span class="comment">// error: two declared and not used</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span>    <span class="comment">// error: three declared and not used</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">    _ = one</span><br><span class="line"></span><br><span class="line">    two := <span class="number">2</span></span><br><span class="line">    <span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">    one = three</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">    four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p>
<p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span>    <span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>    <span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = log.Println</span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>    <span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>, <span class="number">2</span>    <span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">    one, two = two, one    <span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span>    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p>
<p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 2    // 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Go 开发者常犯的错，而且不易被发现。</p>
<p>可使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; go tool vet -shadow main.go</span><br><span class="line">main.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5</span><br></pre></td></tr></table></figure>

<p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; $GOPATH/bin/<span class="keyword">go</span>-nyet main.<span class="keyword">go</span></span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">3</span>:Shadowing variable <span class="string">`x`</span></span><br></pre></td></tr></table></figure>

<h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>    <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11. string 类型的变量值不能为 nil"></a>11. string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;    <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span>    <span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p>
<p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)            <span class="comment">// [1 2 3]    // 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改参数数组：</p>
<ul>
<li>直接传递指向这个数组的指针类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v)    <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;    <span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p>
<p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p>
<p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p>
<ol>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</li>
<li>使用“独立”的切片分两步：</li>
</ol>
<ul>
<li><p>创建外部 slice</p>
</li>
<li><p>对每个内部 slice 进行内存分配<br>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用“共享底层数组”的切片</li>
</ol>
<ul>
<li><p>创建一个存放原始数据的容器 slice</p>
</li>
<li><p>创建其他的 slice</p>
</li>
<li><p>切割原始 slice 来初始化其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化原始 slice</span></span><br><span class="line">    fmt.Println(raw, &amp;raw[<span class="number">4</span>])    <span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">        table[i] = raw[i*w : i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])    <span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于多维数组的参考</p>
<p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p>
<p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p>
<h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; php -r &#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure>

<p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p>
<p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)    <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p>
<p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span>        <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>    <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="type">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">    x = <span class="type">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p>
<p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p>
<ul>
<li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li>
<li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li>
</ul>
<p>雾：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p>
<h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p>
<p>这种处理方式和其他语言一样，比如 PHP 中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span>    <span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;中文&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;�&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;中&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>])        <span class="comment">// 97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p>
<h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p>
<p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>然而在 Go 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内建函数 <code>len()</code> 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。</p>
<p>如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    char := &quot;é&quot;</span><br><span class="line">    fmt.Println(len(char))    // 3</span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    // 2</span><br><span class="line">    fmt.Println(&quot;cafe\u0301&quot;)    // café    // 法文的 cafe，实际上是两个 rune 的组合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.golang.org/normalization">normalization</a></p>
<h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">    z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p>
<h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p>
<h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p>
<p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079494-de9e6a55-0bd7-4d37-9cf8-4edc3c9ee978.png" alt="img"></p>
<h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p>
<p>也可以改写 case 为多条件判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code> 只作为运算符而非表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i            <span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">    fmt.Println(data[i++])    <span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(~<span class="number">2</span>)        <span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)        <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p>
<p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">10000010</span> [A]</span><br><span class="line"><span class="number">00000010</span> [B]</span><br><span class="line"><span class="number">11111101</span> (NOT B)</span><br><span class="line"><span class="number">00000010</span> ^ <span class="number">11111111</span> = <span class="number">11111101</span> [B XOR <span class="number">0xff</span>]</span><br><span class="line"><span class="number">10000010</span> ^ <span class="number">00000010</span> = <span class="number">10000000</span> [A XOR B]</span><br><span class="line"><span class="number">10000010</span> &amp; <span class="number">00000010</span> = <span class="number">00000010</span> [A AND B]</span><br><span class="line"><span class="number">10000010</span> &amp;^<span class="number">00000010</span> = <span class="number">10000000</span> [A <span class="string">&#x27;AND NOT&#x27;</span> B]</span><br><span class="line"><span class="number">10000010</span>&amp;(^<span class="number">00000010</span>)= <span class="number">10000000</span> [A AND (NOT B)]</span><br></pre></td></tr></table></figure>

<h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)    <span class="comment">// &amp; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)    <span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)    <span class="comment">// | 优先 ^</span></span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级列表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>

<h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)    <span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(encoded))    <span class="comment">// &#123;&quot;One&quot;:1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out)     <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079610-d9523090-8363-463a-b6f0-aa4e55a1b7ef.png" alt="img"></p>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079522-5d8f767c-aa6d-4960-bcd3-795aca54b1da.png" alt="img"></p>
<p>看起来好像 goroutine 都执行完了，然而报错：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p>
<p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-48ae068a-8fe5-49b8-ba79-6aecc941525a.png" alt="img"></p>
<h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079544-84c1140a-23ae-4858-80b7-b0adf759ee18.png" alt="img"></p>
<h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p>
<p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p>
<p>向已关闭的 channel 中发送数据会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)        <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)            <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)    <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-645d7d98-a284-417a-94d0-a0b810b6d032.png" alt="img"></p>
<p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079515-81889255-1ad8-424a-9b46-20de774153b4.png" alt="img"></p>
<h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil 的 channel"></a>34. 使用了值为 <code>nil</code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 死锁错误：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>goroutine 1 [chan receive (nil chan)]</p>
<p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inCh</span><br><span class="line">            <span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">                out = outCh</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inCh &lt;- <span class="number">1</span></span><br><span class="line">    inCh &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079586-ec05c601-40cf-4ae1-b8f6-c02b63226d74.png" alt="img"></p>
<h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="type">int</span></span><br><span class="line">    key   *<span class="type">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">    this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc()    <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()    <span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-aac01481-dec9-4479-b0be-d9f7165af772.png" alt="img"></p>
<h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<p>应该先检查HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Get <a href="https://api.ipify.org/?format=json">https://api.ipify.org?format=...</a>: x509: certificate signed by unknown authority</p>
<p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p>
<ul>
<li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li>
<li>手动调用 <code>defer</code> 来关闭响应体：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkError(err)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p>
<p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_, err = io.Copy(ioutil.Discard, resp.Body)    // 手动丢弃读取完毕的数据</span><br></pre></td></tr></table></figure>

<p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)</span><br></pre></td></tr></table></figure>

<h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p>
<ul>
<li>直接设置请求变量的 <code>Close</code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li>
<li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)    // 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)    <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需求选择使用场景：</p>
<ul>
<li>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</li>
<li>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</li>
</ul>
<h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])    <span class="comment">// float64</span></span><br><span class="line">    <span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)    <span class="comment">// 类型断言错误</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: interface conversion: interface {} is float64, not int</p>
<p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p>
<ul>
<li>将 int 值转为 float 统一使用</li>
<li>将 decode 后需要的 float 值转为 int 使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">    decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">      decoder.UseNumber()</span><br><span class="line">      <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">      err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">    checkError(err)</span><br><span class="line">       fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">          Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">      checkError(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型<br>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">            StatusCode <span class="type">uint64</span></span><br><span class="line">            StatusName <span class="type">string</span></span><br><span class="line">            Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">            Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">        checkError(err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusName = name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusCode = code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="type">int</span></span><br><span class="line">    fp      <span class="type">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">    str     <span class="type">string</span></span><br><span class="line">    char    <span class="type">rune</span></span><br><span class="line">    yes     <span class="type">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="type">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="type">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>    <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="type">byte</span>            <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared)</p>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">       <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>DeepEqual()</code> 并不总适合于比较 slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code> 和 <code>strings.EqualFold()</code></p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto&#x2F;subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p>
<ul>
<li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 &#x2F; 中断 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 什么都不会捕捉</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)    <span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recobered:  panic: not good</p>
<h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span>    <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])    <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]    <span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p>
<p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAA</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/uffixBBBB    // 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改</p>
<p>解决方法：</p>
<ul>
<li>重新分配新的 slice 并拷贝你需要的数据</li>
<li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]        <span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p>
<h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)    <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)    <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)    <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p>
<p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 类型声明也保留它的方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line">            <span class="comment">//break    // 死循环，一直打印 breaking out...</span></span><br><span class="line">            <span class="keyword">break</span> loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p>
<h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vCopy := v</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vCopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下边这个稍复杂的 3 个示例区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;    <span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>result: 2</p>
<h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)    <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()    <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建 10000 个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> n in &#123;<span class="number">1.</span><span class="number">.10000</span>&#125;; do</span><br><span class="line">    echo content &gt; <span class="string">&quot;file$&#123;n&#125;.txt&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079519-ec32c68a-4892-4e5c-bced-cd3d864c960f.png" alt="img"></p>
<p>解决办法：defer 延迟执行的函数写入匿名函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p>
<h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p>
<p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p>
<p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p>
<p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p>
<ul>
<li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel <code>default</code> 语句：<br><code>default</code> 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p>
<h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>()    <span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    in.<span class="built_in">print</span>()    <span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()    <span class="comment">// m[&quot;x&quot;] 是不可寻址的    // 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot use data literal (type data) as type printer in assignment:</p>
<p>data does not implement printer (print method has pointer receiver)</p>
<p>cannot call pointer method on m[“x”]</p>
<p>cannot take the address of m[“x”]</p>
<h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot assign to struct field m[“x”].name in map</p>
<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p>
<p>更新 map 中 struct 元素的字段值，有 2 个方法：</p>
<ul>
<li>使用局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">    r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">    fmt.Println(m)    <span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指向元素的 map 指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span>    <span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])    <span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; false    // data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)    <span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)            <span class="comment">// *struct &#123;&#125;    // res 不是 nil，它的值为 nil</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)            <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>    <span class="comment">// 明确指明返回 nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)    <span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p>
<p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。</p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置：</p>
<p> <img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079583-c6b22446-874e-41ce-8898-39d36c0881b5.png" alt="img"></p>
<h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p>
<p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p>
<p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/">文档</a></p>
<p><code>GOMAXPROCS</code> 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())    <span class="comment">// 4</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> u1()    <span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-1ec1022c-6083-4b1a-93fd-982ef37ae959.png" alt="img"></p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p>
<h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)    <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079553-0bfc962d-ba49-426c-b720-43d42581d3af.png" alt="img"></p>
<p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079699-1d179d4e-3e72-4be3-8595-67d600aa223e.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢原作者 <a href="https://twitter.com/kcqon">kcqon</a> 总结的这篇博客，让我受益匪浅。</p>
<p>由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang精编100题</title>
    <url>/2023/09/04/Golang%E7%B2%BE%E7%BC%96100%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="能力模型"><a href="#能力模型" class="headerlink" title="能力模型"></a>能力模型</h2><table>
<thead>
<tr>
<th>级别</th>
<th>模型</th>
</tr>
</thead>
<tbody><tr>
<td>初级</td>
<td></td>
</tr>
<tr>
<td>primary</td>
<td>熟悉基本语法，能够看懂代码的意图；</td>
</tr>
<tr>
<td>在他人指导下能够完成用户故事的开发，编写的代码符合CleanCode规范；</td>
<td></td>
</tr>
<tr>
<td>中级</td>
<td></td>
</tr>
<tr>
<td>intermediate</td>
<td>能够独立完成用户故事的开发和测试；</td>
</tr>
<tr>
<td>能够嗅出代码的坏味道，并知道如何重构达成目标；</td>
<td></td>
</tr>
<tr>
<td>高级</td>
<td></td>
</tr>
<tr>
<td>senior</td>
<td>能够开发出高质量高性能的代码；</td>
</tr>
<tr>
<td>能够熟练使用高级特性，开发编程框架或测试框架；</td>
<td></td>
</tr>
</tbody></table>
<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="1、-primary-下面属于关键字的是（）"><a href="#1、-primary-下面属于关键字的是（）" class="headerlink" title="1、**[primary]** 下面属于关键字的是（）"></a>1、**[primary]** 下面属于关键字的是（）</h3><p>A. func</p>
<p>B. def</p>
<p>C. struct</p>
<p>D. class</p>
<p>参考答案：AC</p>
<h3 id="2、-primary-定义一个包内全局字符串变量，下面语法正确的是-（）"><a href="#2、-primary-定义一个包内全局字符串变量，下面语法正确的是-（）" class="headerlink" title="2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）"></a>2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）</h3><p>A. var str string</p>
<p>B. str :&#x3D; “”</p>
<p>C. str &#x3D; “”</p>
<p>D. var str &#x3D; “”</p>
<p>参考答案：AD</p>
<h3 id="3、-primary-通过指针变量-p-访问其成员变量-name，下面语法正确的是（）"><a href="#3、-primary-通过指针变量-p-访问其成员变量-name，下面语法正确的是（）" class="headerlink" title="3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）"></a>3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）</h3><p>A. p.name</p>
<p>B. (*p).name</p>
<p>C. (&amp;p).name</p>
<p>D. p-&gt;name</p>
<p>参考答案：AB</p>
<h3 id="4、-primary-关于接口和类的说法，下面说法正确的是（）"><a href="#4、-primary-关于接口和类的说法，下面说法正确的是（）" class="headerlink" title="4、**[primary]** 关于接口和类的说法，下面说法正确的是（）"></a>4、**[primary]** 关于接口和类的说法，下面说法正确的是（）</h3><p>A. 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口</p>
<p>B. 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理</p>
<p>C. 类实现接口时，需要导入接口所在的包</p>
<p>D. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p>
<p>参考答案：ABD</p>
<h3 id="5、-primary-关于字符串连接，下面语法正确的是（）"><a href="#5、-primary-关于字符串连接，下面语法正确的是（）" class="headerlink" title="5、**[primary]** 关于字符串连接，下面语法正确的是（）"></a>5、**[primary]** 关于字符串连接，下面语法正确的是（）</h3><p>A. str :&#x3D; ‘abc’ + ‘123’</p>
<p>B. str :&#x3D; “abc” + “123”</p>
<p>C. str ：&#x3D; ‘123’ + “abc”</p>
<p>D. fmt.Sprintf(“abc%d”, 123)</p>
<p>参考答案：BD</p>
<h3 id="6、-primary-关于协程，下面说法正确是（）"><a href="#6、-primary-关于协程，下面说法正确是（）" class="headerlink" title="6、**[primary]** 关于协程，下面说法正确是（）"></a>6、**[primary]** 关于协程，下面说法正确是（）</h3><p>A. 协程和线程都可以实现程序的并发执行</p>
<p>B. 线程比协程更轻量级</p>
<p>C. 协程不存在死锁问题</p>
<p>D. 通过channel来进行协程间的通信</p>
<p>参考答案：AD</p>
<h3 id="7、-intermediate-关于init函数，下面说法正确的是（）"><a href="#7、-intermediate-关于init函数，下面说法正确的是（）" class="headerlink" title="7、**[intermediate]** 关于init函数，下面说法正确的是（）"></a>7、**[intermediate]** 关于init函数，下面说法正确的是（）</h3><p>A. 一个包中，可以包含多个init函数</p>
<p>B. 程序编译时，先执行导入包的init函数，再执行本包内的init函数</p>
<p>C. main包中，不能有init函数</p>
<p>D. init函数可以被其他函数调用</p>
<p>参考答案：AB</p>
<h3 id="8、-primary-关于循环语句，下面说法正确的有（）"><a href="#8、-primary-关于循环语句，下面说法正确的有（）" class="headerlink" title="8、**[primary]** 关于循环语句，下面说法正确的有（）"></a>8、**[primary]** 关于循环语句，下面说法正确的有（）</h3><p>A. 循环语句既支持for关键字，也支持while和do-while</p>
<p>B. 关键字for的基本使用方法与C&#x2F;C++中没有任何差异</p>
<p>C. for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环</p>
<p>D. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</p>
<p>参考答案：CD</p>
<h3 id="9、-intermediate-对于函数定义："><a href="#9、-intermediate-对于函数定义：" class="headerlink" title="9、**[intermediate]** 对于函数定义："></a>9、**[intermediate]** 对于函数定义：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">            sum += arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">下面对add函数调用正确的是（）</span><br><span class="line">A. add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">B. add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">C. add([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">D. add([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;...)</span><br></pre></td></tr></table></figure>

<p>参考答案：ABD</p>
<h3 id="10、-primary-关于类型转化，下面语法正确的是（）"><a href="#10、-primary-关于类型转化，下面语法正确的是（）" class="headerlink" title="10、**[primary]** 关于类型转化，下面语法正确的是（）"></a>10、**[primary]** 关于类型转化，下面语法正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = i</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = (MyInt)i</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = MyInt(i)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = i.(MyInt)</span><br></pre></td></tr></table></figure>

<p>参考答案：C</p>
<h3 id="11、-primary-关于局部变量的初始化，下面正确的使用方式是（）"><a href="#11、-primary-关于局部变量的初始化，下面正确的使用方式是（）" class="headerlink" title="11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）"></a>11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）</h3><p>A. var i int &#x3D; 10</p>
<p>B. var i &#x3D; 10</p>
<p>C. i :&#x3D; 10</p>
<p>D. i &#x3D; 10</p>
<p>参考答案：ABC</p>
<h3 id="12、-primary-关于const常量定义，下面正确的使用方式是（）"><a href="#12、-primary-关于const常量定义，下面正确的使用方式是（）" class="headerlink" title="12、**[primary]** 关于const常量定义，下面正确的使用方式是（）"></a>12、**[primary]** 关于const常量定义，下面正确的使用方式是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">        eof = <span class="number">-1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        ERR_ELEM_EXIST <span class="type">error</span> = errors.New(<span class="string">&quot;element already exists&quot;</span>)</span><br><span class="line">        ERR_ELEM_NT_EXIST <span class="type">error</span> = errors.New(<span class="string">&quot;element not exists&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考答案：ABD</p>
<h3 id="13、-primary-关于布尔变量b的赋值，下面错误的用法是（）"><a href="#13、-primary-关于布尔变量b的赋值，下面错误的用法是（）" class="headerlink" title="13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）"></a>13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）</h3><p>A. b &#x3D; true</p>
<p>B. b &#x3D; 1</p>
<p>C. b &#x3D; bool(1)</p>
<p>D. b &#x3D; (1 &#x3D;&#x3D; 2)</p>
<p>参考答案：BC</p>
<h3 id="14、-intermediate-下面的程序的运行结果是（）"><a href="#14、-intermediate-下面的程序的运行结果是（）" class="headerlink" title="14、**[intermediate]** 下面的程序的运行结果是（）"></a>14、**[intermediate]** 下面的程序的运行结果是（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A. 321</p>
<p>B. 32</p>
<p>C. 31</p>
<p>D. 13</p>
<p>参考答案：C</p>
<h3 id="15、-primary-关于switch语句，下面说法正确的有（）"><a href="#15、-primary-关于switch语句，下面说法正确的有（）" class="headerlink" title="15、**[primary]** 关于switch语句，下面说法正确的有（）"></a>15、**[primary]** 关于switch语句，下面说法正确的有（）</h3><p>A. 条件表达式必须为常量或者整数</p>
<p>B. 单个case中，可以出现多个结果选项</p>
<p>C. 需要用break来明确退出一个case</p>
<p>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case</p>
<p>参考答案：BD</p>
<h3 id="16、-intermediate-golang中没有隐藏的this指针，这句话的含义是（）"><a href="#16、-intermediate-golang中没有隐藏的this指针，这句话的含义是（）" class="headerlink" title="16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）"></a>16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）</h3><p>A. 方法施加的对象显式传递，没有被隐藏起来</p>
<p>B. golang沿袭了传统面向对象编程中的诸多概念，比如继承、虚函数和构造函数</p>
<p>C. golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达</p>
<p>D. 方法施加的对象不需要非得是指针，也不用非得叫this</p>
<p>参考答案：ACD</p>
<h3 id="17、-intermediate-golang中的引用类型包括（）"><a href="#17、-intermediate-golang中的引用类型包括（）" class="headerlink" title="17、**[intermediate]** golang中的引用类型包括（）"></a>17、**[intermediate]** golang中的引用类型包括（）</h3><p>A. 数组切片</p>
<p>B. map</p>
<p>C. channel</p>
<p>D. interface</p>
<p>参考答案：ABCD</p>
<h3 id="18、-intermediate-golang中的指针运算包括（）"><a href="#18、-intermediate-golang中的指针运算包括（）" class="headerlink" title="18、**[intermediate]** golang中的指针运算包括（）"></a>18、**[intermediate]** golang中的指针运算包括（）</h3><p>A. 可以对指针进行自增或自减运算</p>
<p>B. 可以通过“&amp;”取指针的地址</p>
<p>C. 可以通过“*”取指针指向的数据</p>
<p>D. 可以对指针进行下标运算</p>
<p>参考答案：BC</p>
<h3 id="19、-primary-关于main函数（可执行程序的执行起点），下面说法正确的是（）"><a href="#19、-primary-关于main函数（可执行程序的执行起点），下面说法正确的是（）" class="headerlink" title="19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）"></a>19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）</h3><p>A. main函数不能带参数</p>
<p>B. main函数不能定义返回值</p>
<p>C. main函数所在的包必须为main包</p>
<p>D. main函数中可以使用flag包来获取和解析命令行参数</p>
<p>参考答案：ABCD</p>
<h3 id="20、-intermediate-下面赋值正确的是（）"><a href="#20、-intermediate-下面赋值正确的是（）" class="headerlink" title="20、**[intermediate]** 下面赋值正确的是（）"></a>20、**[intermediate]** 下面赋值正确的是（）</h3><p>A. var x &#x3D; nil</p>
<p>B. var x interface{} &#x3D; nil</p>
<p>C. var x string &#x3D; nil</p>
<p>D. var x error &#x3D; nil</p>
<p>参考答案：BD</p>
<h3 id="21、-intermediate-关于整型切片的初始化，下面正确的是（）"><a href="#21、-intermediate-关于整型切片的初始化，下面正确的是（）" class="headerlink" title="21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）"></a>21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）</h3><p>A. s :&#x3D; make([]int)</p>
<p>B. s :&#x3D; make([]int, 0)</p>
<p>C. s :&#x3D; make([]int, 5, 10)</p>
<p>D. s :&#x3D; []int{1, 2, 3, 4, 5}</p>
<p>参考答案：BCD</p>
<h3 id="22、-intermediate-从切片中删除一个元素，下面的算法实现正确的是（）"><a href="#22、-intermediate-从切片中删除一个元素，下面的算法实现正确的是（）" class="headerlink" title="22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）"></a>22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                <span class="keyword">if</span> i== <span class="built_in">len</span>(*s) - <span class="number">1</span> &#123;</span><br><span class="line">                    *s = (*s)[:i]</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">2</span>:]...)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                <span class="built_in">delete</span>(*s, v)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">1</span>:]...)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：D</p>
<h3 id="23、-primary-对于局部变量整型切片x的赋值，下面定义正确的是（）"><a href="#23、-primary-对于局部变量整型切片x的赋值，下面定义正确的是（）" class="headerlink" title="23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）"></a>23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：ACD</p>
<h3 id="24、-primary-关于变量的自增和自减操作，下面语句正确的是（）"><a href="#24、-primary-关于变量的自增和自减操作，下面语句正确的是（）" class="headerlink" title="24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）"></a>24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">i++</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">j = i++</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">++i</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">i--</span><br></pre></td></tr></table></figure>



<p>参考答案：AD</p>
<h3 id="25、-intermediate-关于函数声明，下面语法错误的是（）"><a href="#25、-intermediate-关于函数声明，下面语法错误的是（）" class="headerlink" title="25、**[intermediate]** 关于函数声明，下面语法错误的是（）"></a>25、**[intermediate]** 关于函数声明，下面语法错误的是（）</h3><p>A. func f(a, b int) (value int, err error)</p>
<p>B. func f(a int, b int) (value int, err error)</p>
<p>C. func f(a, b int) (value int, error)</p>
<p>D. func f(a int, b int) (int, int, error)</p>
<p>参考答案：C</p>
<h3 id="26、-intermediate-如果Add函数的调用代码为："><a href="#26、-intermediate-如果Add函数的调用代码为：" class="headerlink" title="26、**[intermediate]** 如果Add函数的调用代码为："></a>26、**[intermediate]** 如果Add函数的调用代码为：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = &amp;a</span><br><span class="line">        sum := i.(*Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27、则Add函数定义正确的是（）"><a href="#27、则Add函数定义正确的是（）" class="headerlink" title="27、则Add函数定义正确的是（）"></a>27、则Add函数定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：AC</p>
<h3 id="28、-intermediate-如果Add函数的调用代码为："><a href="#28、-intermediate-如果Add函数的调用代码为：" class="headerlink" title="28、**[intermediate]** 如果Add函数的调用代码为："></a>28、**[intermediate]** 如果Add函数的调用代码为：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line">        sum := i.(Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="29、则Add函数定义正确的是（）"><a href="#29、则Add函数定义正确的是（）" class="headerlink" title="29、则Add函数定义正确的是（）"></a>29、则Add函数定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：A</p>
<h3 id="30、-intermediate-关于GetPodAction定义，下面赋值正确的是（）"><a href="#30、-intermediate-关于GetPodAction定义，下面赋值正确的是（）" class="headerlink" title="30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）"></a>30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fragment <span class="keyword">interface</span> &#123;</span><br><span class="line">        Exec(transInfo *TransInfo) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetPodAction <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GetPodAction)</span></span> Exec(transInfo *TransInfo) <span class="type">error</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>A. var fragment Fragment &#x3D; new(GetPodAction)</p>
<p>B. var fragment Fragment &#x3D; GetPodAction</p>
<p>C. var fragment Fragment &#x3D; &amp;GetPodAction{}</p>
<p>D. var fragment Fragment &#x3D; GetPodAction{}</p>
<p>参考答案：ACD</p>
<h3 id="31、-intermediate-关于GoMock，下面说法正确的是（）"><a href="#31、-intermediate-关于GoMock，下面说法正确的是（）" class="headerlink" title="31、**[intermediate]** 关于GoMock，下面说法正确的是（）"></a>31、**[intermediate]** 关于GoMock，下面说法正确的是（）</h3><p>A. GoMock可以对interface打桩</p>
<p>B. GoMock可以对类的成员函数打桩</p>
<p>C. GoMock可以对函数打桩</p>
<p>D. GoMock打桩后的依赖注入可以通过GoStub完成</p>
<p>参考答案：AD</p>
<h3 id="32、-intermediate-关于接口，下面说法正确的是（）"><a href="#32、-intermediate-关于接口，下面说法正确的是（）" class="headerlink" title="32、**[intermediate]** 关于接口，下面说法正确的是（）"></a>32、**[intermediate]** 关于接口，下面说法正确的是（）</h3><p>A. 只要两个接口拥有相同的方法列表（次序不同不要紧），那么它们就是等价的，可以相互赋值</p>
<p>B. 如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A</p>
<p>C. 接口查询是否成功，要在运行期才能够确定</p>
<p>D. 接口赋值是否可行，要在运行期才能够确定</p>
<p>参考答案：ABC</p>
<h3 id="33、-primary-关于channel，下面语法正确的是（）"><a href="#33、-primary-关于channel，下面语法正确的是（）" class="headerlink" title="33、**[primary]** 关于channel，下面语法正确的是（）"></a>33、**[primary]** 关于channel，下面语法正确的是（）</h3><p>A. var ch chan int</p>
<p>B. ch :&#x3D; make(chan int)</p>
<p>C. &lt;- ch</p>
<p>D. ch &lt;-</p>
<p>参考答案：ABC</p>
<h3 id="34、-primary-关于同步锁，下面说法正确的是（）"><a href="#34、-primary-关于同步锁，下面说法正确的是（）" class="headerlink" title="34、**[primary]** 关于同步锁，下面说法正确的是（）"></a>34、**[primary]** 关于同步锁，下面说法正确的是（）</h3><p>A. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex</p>
<p>B. RWMutex在读锁占用的情况下，会阻止写，但不阻止读</p>
<p>C. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占</p>
<p>D. Lock()操作需要保证有Unlock()或RUnlock()调用与之对应</p>
<p>参考答案：ABC</p>
<h3 id="35、-intermediate-golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）"><a href="#35、-intermediate-golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）" class="headerlink" title="35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）"></a>35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）</h3><p>A. 指针</p>
<p>B. channel</p>
<p>C. complex</p>
<p>D. 函数</p>
<p>参考答案：BCD</p>
<h3 id="36、-intermediate-关于go-vendor，下面说法正确的是（）"><a href="#36、-intermediate-关于go-vendor，下面说法正确的是（）" class="headerlink" title="36、**[intermediate]** 关于go vendor，下面说法正确的是（）"></a>36、**[intermediate]** 关于go vendor，下面说法正确的是（）</h3><p>A. 基本思路是将引用的外部包的源代码放在当前工程的vendor目录下面</p>
<p>B. 编译go代码会优先从vendor目录先寻找依赖包</p>
<p>C. 可以指定引用某个特定版本的外部包</p>
<p>D. 有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH&#x2F;src下都可以通过编译</p>
<p>参考答案：ABD</p>
<h3 id="37、-primary-flag是bool型变量，下面if表达式符合编码规范的是（）"><a href="#37、-primary-flag是bool型变量，下面if表达式符合编码规范的是（）" class="headerlink" title="37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）"></a>37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）</h3><p>A. if flag &#x3D;&#x3D; 1</p>
<p>B. if flag</p>
<p>C. if flag &#x3D;&#x3D; false</p>
<p>D. if !flag</p>
<p>参考答案：BD</p>
<h3 id="38、-primary-value是整型变量，下面if表达式符合编码规范的是（）"><a href="#38、-primary-value是整型变量，下面if表达式符合编码规范的是（）" class="headerlink" title="38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）"></a>38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）</h3><p>A. if value &#x3D;&#x3D; 0</p>
<p>B. if value</p>
<p>C. if value !&#x3D; 0</p>
<p>D. if !value</p>
<p>参考答案：AC</p>
<h3 id="39、-intermediate-关于函数返回值的错误设计，下面说法正确的是（）"><a href="#39、-intermediate-关于函数返回值的错误设计，下面说法正确的是（）" class="headerlink" title="39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）"></a>39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）</h3><p>A. 如果失败原因只有一个，则返回bool</p>
<p>B. 如果失败原因超过一个，则返回error</p>
<p>C. 如果没有失败原因，则不返回bool或error</p>
<p>D. 如果重试几次可以避免失败，则不要立即返回bool或error</p>
<p>参考答案：ABCD</p>
<h3 id="40、-intermediate-关于异常设计，下面说法正确的是（）"><a href="#40、-intermediate-关于异常设计，下面说法正确的是（）" class="headerlink" title="40、**[intermediate]** 关于异常设计，下面说法正确的是（）"></a>40、**[intermediate]** 关于异常设计，下面说法正确的是（）</h3><p>A. 在程序开发阶段，坚持速错，让程序异常崩溃</p>
<p>B. 在程序部署后，应恢复异常避免程序终止</p>
<p>C. 一切皆错误，不用进行异常设计</p>
<p>D. 对于不应该出现的分支，使用异常处理</p>
<p>参考答案：ABD</p>
<h3 id="41、-intermediate-关于slice或map操作，下面正确的是（）"><a href="#41、-intermediate-关于slice或map操作，下面正确的是（）" class="headerlink" title="41、**[intermediate]** 关于slice或map操作，下面正确的是（）"></a>41、**[intermediate]** 关于slice或map操作，下面正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>参考答案：ACD</p>
<h3 id="42、-intermediate-关于channel的特性，下面说法正确的是（）"><a href="#42、-intermediate-关于channel的特性，下面说法正确的是（）" class="headerlink" title="42、**[intermediate]** 关于channel的特性，下面说法正确的是（）"></a>42、**[intermediate]** 关于channel的特性，下面说法正确的是（）</h3><p>A. 给一个 nil channel 发送数据，造成永远阻塞</p>
<p>B. 从一个 nil channel 接收数据，造成永远阻塞</p>
<p>C. 给一个已经关闭的 channel 发送数据，引起 panic</p>
<p>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</p>
<p>参考答案：ABCD</p>
<h3 id="43、-intermediate-关于无缓冲和有冲突的channel，下面说法正确的是（）"><a href="#43、-intermediate-关于无缓冲和有冲突的channel，下面说法正确的是（）" class="headerlink" title="43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）"></a>43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）</h3><p>A. 无缓冲的channel是默认的缓冲为1的channel</p>
<p>B. 无缓冲的channel和有缓冲的channel都是同步的</p>
<p>C. 无缓冲的channel和有缓冲的channel都是非同步的</p>
<p>D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的</p>
<p>参考答案：D</p>
<h3 id="44、-intermediate-关于异常的触发，下面说法正确的是（）"><a href="#44、-intermediate-关于异常的触发，下面说法正确的是（）" class="headerlink" title="44、**[intermediate]** 关于异常的触发，下面说法正确的是（）"></a>44、**[intermediate]** 关于异常的触发，下面说法正确的是（）</h3><p>A. 空指针解析</p>
<p>B. 下标越界</p>
<p>C. 除数为0</p>
<p>D. 调用panic函数</p>
<p>参考答案：ABCD</p>
<h3 id="45、-intermediate-关于cap函数的适用类型，下面说法正确的是（）"><a href="#45、-intermediate-关于cap函数的适用类型，下面说法正确的是（）" class="headerlink" title="45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）"></a>45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）</h3><p>A. array</p>
<p>B. slice</p>
<p>C. map</p>
<p>D. channel</p>
<p>参考答案：ABD</p>
<h3 id="46、-intermediate-关于beego框架，下面说法正确的是（）"><a href="#46、-intermediate-关于beego框架，下面说法正确的是（）" class="headerlink" title="46、**[intermediate]** 关于beego框架，下面说法正确的是（）"></a>46、**[intermediate]** 关于beego框架，下面说法正确的是（）</h3><p>A. beego是一个golang实现的轻量级HTTP框架</p>
<p>B. beego可以通过注释路由、正则路由等多种方式完成url路由注入</p>
<p>C. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译</p>
<p>D. beego框架只提供了对url路由的处理， 而对于MVC架构中的数据库部分未提供框架支持</p>
<p>参考答案：ABC</p>
<h3 id="47、-intermediate-关于goconvey，下面说法正确的是（）"><a href="#47、-intermediate-关于goconvey，下面说法正确的是（）" class="headerlink" title="47、**[intermediate]** 关于goconvey，下面说法正确的是（）"></a>47、**[intermediate]** 关于goconvey，下面说法正确的是（）</h3><p>A. goconvey是一个支持golang的单元测试框架</p>
<p>B. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面</p>
<p>C. goconvey提供了丰富的断言简化测试用例的编写</p>
<p>D. goconvey无法与go test集成</p>
<p>参考答案：ABC</p>
<h3 id="48、-intermediate-关于go-vet，下面说法正确的是（）"><a href="#48、-intermediate-关于go-vet，下面说法正确的是（）" class="headerlink" title="48、**[intermediate]** 关于go vet，下面说法正确的是（）"></a>48、**[intermediate]** 关于go vet，下面说法正确的是（）</h3><p>A. go vet是golang自带工具go tool vet的封装</p>
<p>B. 当执行go vet database时，可以对database所在目录下的所有子文件夹进行递归检测</p>
<p>C. go vet可以使用绝对路径、相对路径或相对GOPATH的路径指定待检测的包</p>
<p>D. go vet可以检测出死代码</p>
<p>参考答案：ACD</p>
<h3 id="49、-intermediate-关于map，下面说法正确的是（）"><a href="#49、-intermediate-关于map，下面说法正确的是（）" class="headerlink" title="49、**[intermediate]** 关于map，下面说法正确的是（）"></a>49、**[intermediate]** 关于map，下面说法正确的是（）</h3><p>A. map反序列化时json.unmarshal的入参必须为map的地址</p>
<p>B. 在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改</p>
<p>C. 在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改</p>
<p>D. 不能使用内置函数delete删除map的元素</p>
<p>参考答案：A</p>
<h3 id="50、-intermediate-关于GoStub，下面说法正确的是（）"><a href="#50、-intermediate-关于GoStub，下面说法正确的是（）" class="headerlink" title="50、**[intermediate]** 关于GoStub，下面说法正确的是（）"></a>50、**[intermediate]** 关于GoStub，下面说法正确的是（）</h3><p>A. GoStub可以对全局变量打桩</p>
<p>B. GoStub可以对函数打桩</p>
<p>C. GoStub可以对类的成员方法打桩</p>
<p>D. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为</p>
<p>参考答案：ABD</p>
<h3 id="51、-primary-关于select机制，下面说法正确的是（）"><a href="#51、-primary-关于select机制，下面说法正确的是（）" class="headerlink" title="51、**[primary]** 关于select机制，下面说法正确的是（）"></a>51、**[primary]** 关于select机制，下面说法正确的是（）</h3><p>A. select机制用来处理异步IO问题</p>
<p>B. select机制最大的一条限制就是每个case语句里必须是一个IO操作</p>
<p>C. golang在语言级别支持select关键字</p>
<p>D. select关键字的用法与switch语句非常类似，后面要带判断条件</p>
<p>参考答案：ABC</p>
<h3 id="52、-primary-关于内存泄露，下面说法正确的是（）"><a href="#52、-primary-关于内存泄露，下面说法正确的是（）" class="headerlink" title="52、**[primary]** 关于内存泄露，下面说法正确的是（）"></a>52、**[primary]** 关于内存泄露，下面说法正确的是（）</h3><p>A. golang有自动垃圾回收，不存在内存泄露</p>
<p>B. golang中检测内存泄露主要依靠的是pprof包</p>
<p>C. 内存泄露可以在编译阶段发现</p>
<p>D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题</p>
<p>参考答案：BD</p>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="1、-primary-声明一个整型变量i"><a href="#1、-primary-声明一个整型变量i" class="headerlink" title="1、**[primary]** 声明一个整型变量i__________"></a>1、**[primary]** 声明一个整型变量i__________</h3><p>参考答案：var i int</p>
<h3 id="2、-primary-声明一个含有10个元素的整型数组a"><a href="#2、-primary-声明一个含有10个元素的整型数组a" class="headerlink" title="2、**[primary]** 声明一个含有10个元素的整型数组a__________"></a>2、**[primary]** 声明一个含有10个元素的整型数组a__________</h3><p>参考答案：var a [10]int</p>
<h3 id="3、-primary-声明一个整型数组切片s"><a href="#3、-primary-声明一个整型数组切片s" class="headerlink" title="3、**[primary]** 声明一个整型数组切片s__________"></a>3、**[primary]** 声明一个整型数组切片s__________</h3><p>参考答案：var s []int</p>
<h3 id="4、-primary-声明一个整型指针变量p"><a href="#4、-primary-声明一个整型指针变量p" class="headerlink" title="4、**[primary]** 声明一个整型指针变量p__________"></a>4、**[primary]** 声明一个整型指针变量p__________</h3><p>参考答案：var p *int</p>
<h3 id="5、-primary-声明一个key为字符串型value为整型的map变量m"><a href="#5、-primary-声明一个key为字符串型value为整型的map变量m" class="headerlink" title="5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________"></a>5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________</h3><p>参考答案：var m map[string]int</p>
<h3 id="6、-primary-声明一个入参和返回值均为整型的函数变量f"><a href="#6、-primary-声明一个入参和返回值均为整型的函数变量f" class="headerlink" title="6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________"></a>6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________</h3><p>参考答案：var f func(a int) int</p>
<h3 id="7、-primary-声明一个只用于读取int数据的单向channel变量ch"><a href="#7、-primary-声明一个只用于读取int数据的单向channel变量ch" class="headerlink" title="7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________"></a>7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________</h3><p>参考答案：var ch &lt;-chan int</p>
<h3 id="8、-primary-假设源文件的命名为slice-go，则测试文件的命名为"><a href="#8、-primary-假设源文件的命名为slice-go，则测试文件的命名为" class="headerlink" title="8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________"></a>8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________</h3><p>参考答案：slice_test.go</p>
<h3 id="9、-primary-go-test要求测试函数的前缀必须命名为"><a href="#9、-primary-go-test要求测试函数的前缀必须命名为" class="headerlink" title="9、**[primary]** go test要求测试函数的前缀必须命名为__________"></a>9、**[primary]** go test要求测试函数的前缀必须命名为__________</h3><p>参考答案：Test</p>
<h3 id="10、-intermediate-下面的程序的运行结果是"><a href="#10、-intermediate-下面的程序的运行结果是" class="headerlink" title="10、**[intermediate]** 下面的程序的运行结果是__________"></a>10、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：4 3 2 1 0</p>
<h3 id="11、-intermediate-下面的程序的运行结果是"><a href="#11、-intermediate-下面的程序的运行结果是" class="headerlink" title="11、**[intermediate]** 下面的程序的运行结果是__________"></a>11、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            x := <span class="number">2</span></span><br><span class="line">            fmt.Print(x)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：21</p>
<h3 id="12、-intermediate-下面的程序的运行结果是"><a href="#12、-intermediate-下面的程序的运行结果是" class="headerlink" title="12、**[intermediate]** 下面的程序的运行结果是__________"></a>12、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        strs := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%s &quot;</span>, s)</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：three three three</p>
<h3 id="13、-intermediate-下面的程序的运行结果是"><a href="#13、-intermediate-下面的程序的运行结果是" class="headerlink" title="13、**[intermediate]** 下面的程序的运行结果是__________"></a>13、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">            fmt.Print(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：012</p>
<h3 id="14、-intermediate-下面的程序的运行结果是"><a href="#14、-intermediate-下面的程序的运行结果是" class="headerlink" title="14、**[intermediate]** 下面的程序的运行结果是__________"></a>14、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">            fmt.Print(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：abc</p>
<h3 id="15、-primary-下面的程序的运行结果是"><a href="#15、-primary-下面的程序的运行结果是" class="headerlink" title="15、**[primary]** 下面的程序的运行结果是__________"></a>15、**[primary]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">       i := <span class="number">1</span></span><br><span class="line">       j := <span class="number">2</span></span><br><span class="line">       i, j = j, i</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%d%d\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：21</p>
<h3 id="16、-primary-下面的程序的运行结果是"><a href="#16、-primary-下面的程序的运行结果是" class="headerlink" title="16、**[primary]** 下面的程序的运行结果是__________"></a>16、**[primary]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        *p++</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        v := <span class="number">1</span></span><br><span class="line">        incr(&amp;v)</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：2</p>
<h3 id="17、-primary-启动一个goroutine的关键字是"><a href="#17、-primary-启动一个goroutine的关键字是" class="headerlink" title="17、**[primary]** 启动一个goroutine的关键字是__________"></a>17、**[primary]** 启动一个goroutine的关键字是__________</h3><p>参考答案：go</p>
<h3 id="18、-intermediate-下面的程序的运行结果是"><a href="#18、-intermediate-下面的程序的运行结果是" class="headerlink" title="18、**[intermediate]** 下面的程序的运行结果是__________"></a>18、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">()</span></span> Slice &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">make</span>(Slice, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s* Slice)</span></span> Add(elem <span class="type">int</span>) *Slice &#123;</span><br><span class="line">         *s = <span class="built_in">append</span>(*s, elem)</span><br><span class="line">         fmt.Print(elem)</span><br><span class="line">         <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">         s := NewSlice()</span><br><span class="line">         <span class="keyword">defer</span> s.Add(<span class="number">1</span>).Add(<span class="number">2</span>)</span><br><span class="line">         s.Add(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：132</p>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><h3 id="1、-primary-数组是一个值类型（）"><a href="#1、-primary-数组是一个值类型（）" class="headerlink" title="1、**[primary]** 数组是一个值类型（）"></a>1、**[primary]** 数组是一个值类型（）</h3><p>参考答案：T</p>
<h3 id="2、-primary-使用map不需要引入任何库（）"><a href="#2、-primary-使用map不需要引入任何库（）" class="headerlink" title="2、**[primary]** 使用map不需要引入任何库（）"></a>2、**[primary]** 使用map不需要引入任何库（）</h3><p>参考答案：T</p>
<h3 id="3、-intermediate-内置函数delete可以删除数组切片内的元素（）"><a href="#3、-intermediate-内置函数delete可以删除数组切片内的元素（）" class="headerlink" title="3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）"></a>3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）</h3><p>参考答案：F</p>
<h3 id="4、-primary-指针是基础类型（）"><a href="#4、-primary-指针是基础类型（）" class="headerlink" title="4、**[primary]** 指针是基础类型（）"></a>4、**[primary]** 指针是基础类型（）</h3><p>参考答案：F</p>
<h3 id="5、-primary-interface-是可以指向任意对象的Any类型（）"><a href="#5、-primary-interface-是可以指向任意对象的Any类型（）" class="headerlink" title="5、**[primary]** interface{}是可以指向任意对象的Any类型（）"></a>5、**[primary]** interface{}是可以指向任意对象的Any类型（）</h3><p>参考答案：T</p>
<h3 id="6、-intermediate-下面关于文件操作的代码可能触发异常（）"><a href="#6、-intermediate-下面关于文件操作的代码可能触发异常（）" class="headerlink" title="6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）"></a>6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;open file failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>参考答案：T</p>
<h3 id="7、-primary-Golang不支持自动垃圾回收（）"><a href="#7、-primary-Golang不支持自动垃圾回收（）" class="headerlink" title="7、**[primary]** Golang不支持自动垃圾回收（）"></a>7、**[primary]** Golang不支持自动垃圾回收（）</h3><p>参考答案：F</p>
<h3 id="8、-primary-Golang支持反射，反射最常见的使用场景是做对象的序列化（）"><a href="#8、-primary-Golang支持反射，反射最常见的使用场景是做对象的序列化（）" class="headerlink" title="8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）"></a>8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）</h3><p>参考答案：T</p>
<h3 id="9、-primary-Golang可以复用C-C-的模块，这个功能叫Cgo（）"><a href="#9、-primary-Golang可以复用C-C-的模块，这个功能叫Cgo（）" class="headerlink" title="9、**[primary]** Golang可以复用C&#x2F;C++的模块，这个功能叫Cgo（）"></a>9、**[primary]** Golang可以复用C&#x2F;C++的模块，这个功能叫Cgo（）</h3><p>参考答案：F</p>
<h3 id="10、-primary-下面代码中两个斜点之间的代码，比如json-x-，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）"><a href="#10、-primary-下面代码中两个斜点之间的代码，比如json-x-，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）" class="headerlink" title="10、**[primary]** 下面代码中两个斜点之间的代码，比如json:&quot;x&quot;，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）"></a>10、**[primary]** 下面代码中两个斜点之间的代码，比如<code>json:&quot;x&quot;</code>，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;</span><br><span class="line">        X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">        Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">        Z <span class="type">int</span> <span class="string">`json:&quot;z&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：T</p>
<h3 id="11、-primary-通过成员变量或函数首字母的大小写来决定其作用域（）"><a href="#11、-primary-通过成员变量或函数首字母的大小写来决定其作用域（）" class="headerlink" title="11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）"></a>11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）</h3><p>参考答案：T</p>
<h3 id="12、-primary-对于常量定义zero-const-zero-0-0-，zero是浮点型常量（）"><a href="#12、-primary-对于常量定义zero-const-zero-0-0-，zero是浮点型常量（）" class="headerlink" title="12、**[primary]** 对于常量定义zero(const zero &#x3D; 0.0)，zero是浮点型常量（）"></a>12、**[primary]** 对于常量定义zero(const zero &#x3D; 0.0)，zero是浮点型常量（）</h3><p>参考答案：F</p>
<h3 id="13、-primary-对变量x的取反操作是-x（）"><a href="#13、-primary-对变量x的取反操作是-x（）" class="headerlink" title="13、**[primary]** 对变量x的取反操作是~x（）"></a>13、**[primary]** 对变量x的取反操作是~x（）</h3><p>参考答案：F</p>
<h3 id="14、-primary-下面的程序的运行结果是xello（）"><a href="#14、-primary-下面的程序的运行结果是xello（）" class="headerlink" title="14、**[primary]** 下面的程序的运行结果是xello（）"></a>14、**[primary]** 下面的程序的运行结果是xello（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">        fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="15、-primary-golang支持goto语句（）"><a href="#15、-primary-golang支持goto语句（）" class="headerlink" title="15、**[primary]** golang支持goto语句（）"></a>15、**[primary]** golang支持goto语句（）</h3><p>参考答案：T</p>
<h3 id="16、-primary-下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）"><a href="#16、-primary-下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）" class="headerlink" title="16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）"></a>16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TimesMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">        base <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimesMatcher</span><span class="params">(base <span class="type">int</span>)</span></span> *TimesMatcher&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TimesMatcher&#123;base:base&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p := NewTimesMatcher(<span class="number">3</span>)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="17、-primary-匿名函数可以直接赋值给一个变量或者直接执行（）"><a href="#17、-primary-匿名函数可以直接赋值给一个变量或者直接执行（）" class="headerlink" title="17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）"></a>17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）</h3><p>参考答案：T</p>
<h3 id="18、-primary-如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“-”来跳过这个返回值，该下划线对应的变量叫匿名变量（）"><a href="#18、-primary-如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“-”来跳过这个返回值，该下划线对应的变量叫匿名变量（）" class="headerlink" title="18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）"></a>18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）</h3><p>参考答案：T</p>
<h3 id="19、-primary-在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）"><a href="#19、-primary-在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）" class="headerlink" title="19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）"></a>19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）</h3><p>参考答案：T</p>
<h3 id="20、-primary-错误是业务过程的一部分，而异常不是（）"><a href="#20、-primary-错误是业务过程的一部分，而异常不是（）" class="headerlink" title="20、**[primary]** 错误是业务过程的一部分，而异常不是（）"></a>20、**[primary]** 错误是业务过程的一部分，而异常不是（）</h3><p>参考答案：T</p>
<h3 id="21、-primary-函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）"><a href="#21、-primary-函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）" class="headerlink" title="21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）"></a>21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）</h3><p>参考答案：F</p>
<h3 id="22、-intermediate-当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）"><a href="#22、-intermediate-当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）" class="headerlink" title="22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）"></a>22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）</h3><p>参考答案：F</p>
<h3 id="23、-primary-同级文件的包名不允许有多个（）"><a href="#23、-primary-同级文件的包名不允许有多个（）" class="headerlink" title="23、**[primary]** 同级文件的包名不允许有多个（）"></a>23、**[primary]** 同级文件的包名不允许有多个（）</h3><p>参考答案：T</p>
<h3 id="24、-intermediate-可以给任意类型添加相应的方法（）"><a href="#24、-intermediate-可以给任意类型添加相应的方法（）" class="headerlink" title="24、**[intermediate]** 可以给任意类型添加相应的方法（）"></a>24、**[intermediate]** 可以给任意类型添加相应的方法（）</h3><p>参考答案：F</p>
<h3 id="25、-primary-golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）"><a href="#25、-primary-golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）" class="headerlink" title="25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）"></a>25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）</h3><p>参考答案：T</p>
<h3 id="26、-primary-使用for-range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）"><a href="#26、-primary-使用for-range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）" class="headerlink" title="26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）"></a>26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）</h3><p>参考答案：T</p>
<h3 id="27、-primary-switch后面可以不跟表达式（）"><a href="#27、-primary-switch后面可以不跟表达式（）" class="headerlink" title="27、**[primary]** switch后面可以不跟表达式（）"></a>27、**[primary]** switch后面可以不跟表达式（）</h3><p>参考答案：T</p>
<h3 id="28、-intermediate-结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）"><a href="#28、-intermediate-结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）" class="headerlink" title="28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）"></a>28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）</h3><p>参考答案：T</p>
<h3 id="29、-primary-golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）"><a href="#29、-primary-golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）" class="headerlink" title="29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）"></a>29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）</h3><p>参考答案：T</p>
<h3 id="30、-intermediate-当函数deferDemo返回失败时，并不能destroy已create成功的资源（）"><a href="#30、-intermediate-当函数deferDemo返回失败时，并不能destroy已create成功的资源（）" class="headerlink" title="30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）"></a>30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        err := createResource1()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                destroyResource1()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        err = createResource2()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                destroyResource2()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        err = createResource3()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="31、-intermediate-channel本身必然是同时支持读写的，所以不存在单向channel（）"><a href="#31、-intermediate-channel本身必然是同时支持读写的，所以不存在单向channel（）" class="headerlink" title="31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）"></a>31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）</h3><p>参考答案：F</p>
<h3 id="32、-primary-import后面的最后一个元素是包名（）"><a href="#32、-primary-import后面的最后一个元素是包名（）" class="headerlink" title="32、**[primary]** import后面的最后一个元素是包名（）"></a>32、**[primary]** import后面的最后一个元素是包名（）</h3><p>参考答案：F</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>UberGo语言编码规范中文版</title>
    <url>/2023/09/04/UberGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%AD%E6%96%87%E7%89%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!--

Editing this document:

- Discuss all changes in GitHub issues first.
- Update the table of contents as new sections are added or removed.
- Use tables for side-by-side code samples. See below.

Code Samples:

Use 2 spaces to indent. Horizontal real estate is important in side-by-side
samples.

For side-by-side code samples, use the following snippet.

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bad&lt;/th&gt;&lt;th&gt;Good&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">BAD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">GOOD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>(You need the empty lines between the <td> and code samples for it to be<br>treated as Markdown.)</p>
<p>If you need to add labels or descriptions below the code samples, add another<br>row before the </tbody></table> line.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;DESCRIBE BAD CODE&lt;/td&gt;</span><br><span class="line">&lt;td&gt;DESCRIBE GOOD CODE&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>



<p>–&gt;</p>
<!--
change.md

# 2019-12-17
- 函数选项：推荐 “Option” 接口的结构实现
- 而不是用闭包捕获值。

# 2019-11-26
- 添加针对全局变量变异的指导。

# 2020-01-11
- 为`open（..）`调用添加缺少的参数。

# 2020-02-03
- 使用 `"time"` 处理时间的建议
- 添加有关在公共结构中嵌入类型的指导。

# 2020-02-25
- 添加有关接口验证是否符合编译时检查的指导。

# 2020-06-05
- 添加避免使用内置名称的指导意见

# 2020-06-10
- 添加 init() 指导意见

# 2020-06-16
- 追加时优先指定切片容量
- 添加有关指针接收器可调用性的说明

# 2020-06-17
- map和切片的联合指导

# 2020-09-15
- Remove main panic

# 2021-03-17
- 结构体初始化

# 2021-04-19
- 程序只能在`main()`中退出，最好最多退出一次

-->

<h2 id="forked-from-uber-go-guide-cn"><a href="#forked-from-uber-go-guide-cn" class="headerlink" title="forked from uber_go_guide_cn"></a>forked from <a href="https://github.com/xxjwxc/uber_go_guide_cn">uber_go_guide_cn</a></h2><h2 id="uber-go-guide-的中文翻译"><a href="#uber-go-guide-的中文翻译" class="headerlink" title="uber-go&#x2F;guide 的中文翻译"></a><a href="https://github.com/uber-go/guide">uber-go&#x2F;guide</a> 的中文翻译</h2><h2 id="English"><a href="#English" class="headerlink" title="English"></a><a href="https://github.com/uber-go/guide/blob/master/style.md">English</a></h2><h2 id="Uber-Go-语言编码规范"><a href="#Uber-Go-语言编码规范" class="headerlink" title="Uber Go 语言编码规范"></a>Uber Go 语言编码规范</h2><p> <a href="https://www.uber.com/">Uber</a> 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 <a href="https://github.com/uber-go/zap">zap</a>、<a href="https://github.com/jaegertracing/jaeger">jaeger</a> 等。2018 年年末 Uber 将内部的 <a href="https://github.com/uber-go/guide">Go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>当前更新版本：2021-07-09 版本地址：<a href="https://github.com/uber-go/guide/commit/b8745282405323881e13cd122d5222316a815349">commit:#130</a></li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#uber-goguide-%E7%9A%84%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91">uber-go&#x2F;guide 的中文翻译</a></li>
<li><a href="#english">English</a></li>
<li><a href="#uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">Uber Go 语言编码规范</a></li>
<li><a href="#%E7%89%88%E6%9C%AC">版本</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">指导原则</a><ul>
<li><a href="#%E6%8C%87%E5%90%91-interface-%E7%9A%84%E6%8C%87%E9%92%88">指向 interface 的指针</a></li>
<li><a href="#interface-%E5%90%88%E7%90%86%E6%80%A7%E9%AA%8C%E8%AF%81">Interface 合理性验证</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E5%99%A8-receiver-%E4%B8%8E%E6%8E%A5%E5%8F%A3">接收器 (receiver) 与接口</a></li>
<li><a href="#%E9%9B%B6%E5%80%BC-mutex-%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84">零值 Mutex 是有效的</a></li>
<li><a href="#%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%8B%B7%E8%B4%9D-slices-%E5%92%8C-maps">在边界处拷贝 Slices 和 Maps</a><ul>
<li><a href="#%E6%8E%A5%E6%94%B6-slices-%E5%92%8C-maps">接收 Slices 和 Maps</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E-slices-%E6%88%96-maps">返回 slices 或 maps</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8-defer-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90">使用 defer 释放资源</a></li>
<li><a href="#channel-%E7%9A%84-size-%E8%A6%81%E4%B9%88%E6%98%AF-1%E8%A6%81%E4%B9%88%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84">Channel 的 size 要么是 1，要么是无缓冲的</a></li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E4%BB%8E-1-%E5%BC%80%E5%A7%8B">枚举从 1 开始</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-time-%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4">使用 time 处理时间</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8-timetime-%E8%A1%A8%E8%BE%BE%E7%9E%AC%E6%97%B6%E6%97%B6%E9%97%B4">使用 <code>time.Time</code> 表达瞬时时间</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-timeduration-%E8%A1%A8%E8%BE%BE%E6%97%B6%E9%97%B4%E6%AE%B5">使用 <code>time.Duration</code> 表达时间段</a></li>
<li><a href="#%E5%AF%B9%E5%A4%96%E9%83%A8%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8-timetime-%E5%92%8C-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">错误类型</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85-error-wrapping">错误包装 (Error Wrapping)</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5">处理类型断言失败</a></li>
<li><a href="#%E4%B8%8D%E8%A6%81-panic">不要 panic</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-gouberorgatomic">使用 go.uber.org&#x2F;atomic</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%8F%AF%E5%8F%98%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F">避免可变全局变量</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B">避免在公共结构中嵌入类型</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%90%8D%E7%A7%B0">避免使用内置名称</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-init">避免使用 <code>init()</code></a></li>
<li><a href="#%E8%BF%BD%E5%8A%A0%E6%97%B6%E4%BC%98%E5%85%88%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F">追加时优先指定切片容量</a></li>
<li><a href="#%E4%B8%BB%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8Fexit">主函数退出方式(Exit)</a><ul>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%80%E5%87%BA">一次性退出</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD">性能</a><ul>
<li><a href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-strconv-%E8%80%8C%E4%B8%8D%E6%98%AF-fmt">优先使用 strconv 而不是 fmt</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E5%AD%97%E8%8A%82%E7%9A%84%E8%BD%AC%E6%8D%A2">避免字符串到字节的转换</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%AE%B9%E9%87%8F">指定容器容量</a><ul>
<li><a href="#%E6%8C%87%E5%AE%9Amap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F">指定切片容量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A7%84%E8%8C%83">规范</a><ul>
<li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a></li>
<li><a href="#%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%A3%B0%E6%98%8E%E6%94%BE%E5%9C%A8%E4%B8%80%E7%BB%84">相似的声明放在一组</a></li>
<li><a href="#import-%E5%88%86%E7%BB%84">import 分组</a></li>
<li><a href="#%E5%8C%85%E5%90%8D">包名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%90%8D">函数名</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E5%88%AB%E5%90%8D">导入别名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%86%E7%BB%84%E4%B8%8E%E9%A1%BA%E5%BA%8F">函数分组与顺序</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a></li>
<li><a href="#%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-else">不必要的 else</a></li>
<li><a href="#%E9%A1%B6%E5%B1%82%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">顶层变量声明</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AA%E5%AF%BC%E5%87%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8_%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80">对于未导出的顶层常量和变量，使用_作为前缀</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%85%A5">结构体中的嵌入</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">使用字段名初始化结构体</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">本地变量声明</a></li>
<li><a href="#nil-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E7%9A%84-slice">nil 是一个有效的 slice</a></li>
<li><a href="#%E7%BC%A9%E5%B0%8F%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">缩小变量作用域</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%8F%82%E6%95%B0%E8%AF%AD%E4%B9%89%E4%B8%8D%E6%98%8E%E7%A1%AEavoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E9%81%BF%E5%85%8D%E8%BD%AC%E4%B9%89">使用原始字符串字面值，避免转义</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93">初始化结构体</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84">使用字段名初始化结构</a></li>
<li><a href="#%E7%9C%81%E7%95%A5%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC%E5%AD%97%E6%AE%B5">省略结构中的零值字段</a></li>
<li><a href="#%E5%AF%B9%E9%9B%B6%E5%80%BC%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8-var">对零值结构使用 <code>var</code></a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-struct-%E5%BC%95%E7%94%A8">初始化 Struct 引用</a></li>
</ul>
</li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96-maps">初始化 Maps</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-string-format">字符串 string format</a></li>
<li><a href="#%E5%91%BD%E5%90%8D-printf-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0">命名 Printf 样式的函数</a></li>
</ul>
</li>
<li><a href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">编程模式</a><ul>
<li><a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a></li>
<li><a href="#%E5%8A%9F%E8%83%BD%E9%80%89%E9%A1%B9">功能选项</a></li>
</ul>
</li>
<li><a href="#linting">Linting</a><ul>
<li><a href="#lint-runners">Lint Runners</a></li>
</ul>
</li>
<li><a href="#stargazers-over-time">Stargazers over time</a></li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。</p>
<p>本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。</p>
<p>该指南最初由 <a href="https://github.com/prashantv">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52">Simon Newton</a> 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。</p>
<p>本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p>
<ol>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CommonMistakes">Go Common Mistakes</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a></li>
</ol>
<p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p>
<ul>
<li>保存时运行 <code>goimports</code></li>
<li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li>
</ul>
<p>您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：<br><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p>
<h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><h3 id="指向-interface-的指针"><a href="#指向-interface-的指针" class="headerlink" title="指向 interface 的指针"></a>指向 interface 的指针</h3><p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ol>
<li>一个指向某些特定类型信息的指针。您可以将其视为”type”。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ol>
<p>如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1.f()无法修改底层数据</span></span><br><span class="line"><span class="comment">// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针</span></span><br><span class="line"><span class="keyword">var</span> f1 F = S1&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f2 F = &amp;S2&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Interface-合理性验证"><a href="#Interface-合理性验证" class="headerlink" title="Interface 合理性验证"></a>Interface 合理性验证</h3><p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口API 的一部分进行检查</li>
<li>实现同一接口的(导出和非导出)类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景,都会终止编译,并通知给用户</li>
</ul>
<p>补充:上面3条是编译器对接口的检查机制,<br>大体意思是错误使用接口会在编译期报错.<br>所以可以利用这个机制让部分问题在编译期暴露.</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果Handler没有实现http.Handler,会在运行时报错</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于触发编译期的接口的合理性检查机制</span></span><br><span class="line"><span class="comment">// 如果Handler没有实现http.Handler,会在编译期报错</span></span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配,<br>那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过.</p>
<p>赋值的右边应该是断言类型的零值。<br>对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；<br>对于结构类型，这是空结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h LogHandler)</span></span> ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收器-receiver-与接口"><a href="#接收器-receiver-与接口" class="headerlink" title="接收器 (receiver) 与接口"></a>接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values">addressable values</a>调用.</p>
<p>例如，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> Read() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span></span> Write(str <span class="type">string</span>) &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="type">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">&quot;A&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你只能通过值调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不能编译通过：</span></span><br><span class="line"><span class="comment">//  sVals[1].Write(&quot;test&quot;)</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="type">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">&quot;A&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span></span> f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure>

<p><a href="https://golang.org/doc/effective_go.html">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values">pointers vs. values</a> 的精彩讲解。</p>
<p>补充:</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集<ul>
<li>值接收器方法集是指针接收器方法集的子集,反之不是</li>
</ul>
</li>
<li>规则<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
<li>接口的匹配(或者叫实现)<ul>
<li>类型实现了接口的所有方法,叫匹配</li>
<li>具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口</li>
</ul>
</li>
</ul>
<p>具体的匹配分两种:</p>
<ul>
<li>值方法集和接口匹配<ul>
<li>给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集</li>
</ul>
</li>
<li>指针方法集和接口匹配<ul>
<li>只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配</li>
<li>如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)</li>
</ul>
</li>
</ul>
<p>为啥 i &#x3D; s2Val 会报错,因为值方法集和接口不匹配.</p>
<h3 id="零值-Mutex-是有效的"><a href="#零值-Mutex-是有效的" class="headerlink" title="零值 Mutex 是有效的"></a>零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果你使用结构体指针，mutex 应该作为结构体的非指针字段。即使该结构体不被导出，也不要直接把 mutex 嵌入到结构体中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p><code>Mutex</code> 字段， <code>Lock</code> 和 <code>Unlock</code> 方法是 <code>SMap</code> 导出的 API 中不刻意说明的一部分。</p>
 </td><td>

<p>mutex 及其方法是 <code>SMap</code> 的实现细节，对其调用者不可见。</p>
 </td></tr>
 </tbody></table>

<h3 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<h4 id="接收-Slices-和-Maps"><a href="#接收-Slices-和-Maps" class="headerlink" title="接收 Slices 和 Maps"></a>接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<table>
<thead><tr><th>Bad</th> <th>Good</th></tr></thead>
<tbody>
<tr>
<td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你是要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure>

</td>
<td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure>

</td>
</tr>

</tbody>
</table>

<h4 id="返回-slices-或-maps"><a href="#返回-slices-或-maps" class="headerlink" title="返回 slices 或 maps"></a>返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="使用-defer-释放资源"><a href="#使用-defer-释放资源" class="headerlink" title="使用 defer 释放资源"></a>使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p>
<h3 id="Channel-的-size-要么是-1，要么是无缓冲的"><a href="#Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="Channel 的 size 要么是 1，要么是无缓冲的"></a>Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应该足以满足任何情况！</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="枚举从-1-开始"><a href="#枚举从-1-开始" class="headerlink" title="枚举从 1 开始"></a>枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-time-处理时间"><a href="#使用-time-处理时间" class="headerlink" title="使用 time 处理时间"></a>使用 time 处理时间</h3><p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p>
<ol>
<li>一天有 24 小时</li>
<li>一小时有 60 分钟</li>
<li>一周有七天</li>
<li>一年 365 天</li>
<li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">还有更多</a></li>
</ol>
<p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<h4 id="使用-time-Time-表达瞬时时间"><a href="#使用-time-Time-表达瞬时时间" class="headerlink" title="使用 time.Time 表达瞬时时间"></a>使用 <code>time.Time</code> 表达瞬时时间</h4><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h4 id="使用-time-Duration-表达时间段"><a href="#使用-time-Duration-表达时间段" class="headerlink" title="使用 time.Duration 表达时间段"></a>使用 <code>time.Duration</code> 表达时间段</h4><p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration"><code>time.Duration</code></a> .</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒?</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate"><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 <a href="https://golang.org/pkg/time/#Time.Add"><code>Time.Add</code></a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">0</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>)</span><br><span class="line">maybeNewDay := t.Add(<span class="number">24</span> * time.Hour)</span><br></pre></td></tr></table></figure>

<h4 id="对外部系统使用-time-Time-和-time-Duration"><a href="#对外部系统使用-time-Time-和-time-Duration" class="headerlink" title="对外部系统使用 time.Time 和 time.Duration"></a>对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p>
<ul>
<li><p>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p>
</li>
<li><p>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</p>
</li>
<li><p>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p>
</li>
<li><p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p>
</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&quot;interval&quot;: 2&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interval <span class="type">int</span> <span class="string">`json:&quot;interval&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&quot;intervalMillis&quot;: 2000&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  IntervalMillis <span class="type">int</span> <span class="string">`json:&quot;intervalMillis&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p>
<p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190">15190</a>）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<!-- TODO: section on String methods for enums -->

<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>Go 中有多种声明错误（Error) 的选项：</p>
<ul>
<li><a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 对于简单静态字符串的错误</li>
<li><a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li>
<li>实现 <code>Error()</code> 方法的自定义类型</li>
<li>用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li>
</ul>
<p>返回错误时，请考虑以下因素以确定最佳选择：</p>
<ul>
<li><p>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 足够了。</p>
</li>
<li><p>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</li>
<li><p>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="#%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85" title="Error-Wrapping">section on error wrapping</a> 部分的内容。</p>
</li>
<li><p>否则 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a> 就可以了。</p>
</li>
</ul>
<p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a>，请使用一个错误变量。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">&quot;could not open&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;file %q not found&quot;</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">&quot;testfile.txt&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;not found&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;file %q not found&quot;</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">&quot;testfile.txt&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;file %q not found&quot;</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">&quot;foo&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- TODO: Exposing the information to callers with accessor functions. -->

<h3 id="错误包装-Error-Wrapping"><a href="#错误包装-Error-Wrapping" class="headerlink" title="错误包装 (Error Wrapping)"></a>错误包装 (Error Wrapping)</h3><p>一个（函数&#x2F;方法）调用失败时，有三种主要的错误传播方式：</p>
<ul>
<li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li>
<li>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</li>
<li>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>。</li>
</ul>
<p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p>
<p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">&quot;failed to create new store: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">&quot;new store: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x: y: new store: the error</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p>
<p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">Don’t just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p>
<h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := i.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, ok := i.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<!-- TODO: There are a few situations where the single assignment form is
fine. -->

<h3 id="不要-panic"><a href="#不要-panic" class="headerlink" title="不要 panic"></a>不要 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure">cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;an argument is required&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;an argument is required&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>panic&#x2F;recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">&quot;name&quot;</span>).Parse(<span class="string">&quot;_statusHTML&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;failed to set up test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">&quot;failed to set up test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<!-- TODO: Explain how to use _test packages. -->

<h3 id="使用-go-uber-org-atomic"><a href="#使用-go-uber-org-atomic" class="headerlink" title="使用 go.uber.org&#x2F;atomic"></a>使用 go.uber.org&#x2F;atomic</h3><p>使用 <a href="https://golang.org/pkg/sync/atomic/">sync&#x2F;atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a href="https://godoc.org/go.uber.org/atomic">go.uber.org&#x2F;atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="type">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span></span> start() &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span></span> isRunning() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span></span> start() &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span></span> isRunning() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="避免可变全局变量"><a href="#避免可变全局变量" class="headerlink" title="避免可变全局变量"></a>避免可变全局变量</h3><p>使用选择依赖注入方式避免改变全局变量。<br>既适用于函数指针又适用于其他值类型</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span></span> *signer &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span></span> Sign(msg <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="避免在公共结构中嵌入类型"><a href="#避免在公共结构中嵌入类型" class="headerlink" title="避免在公共结构中嵌入类型"></a>避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。<br>相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(e Entity) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(e Entity) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding">类型嵌入</a> 作为继承和组合之间的折衷。<br>外部类型获取嵌入类型的方法的隐式副本。<br>默认情况下，这些方法委托给嵌入实例的同一方法。</p>
<p>结构还获得与类型同名的字段。<br>所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<p>很少需要嵌入类型。<br>这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractList 是各种实体列表的通用实现。</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p>
<ul>
<li>向嵌入式接口添加方法是一个破坏性的改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<h3 id="避免使用内置名称"><a href="#避免使用内置名称" class="headerlink" title="避免使用内置名称"></a>避免使用内置名称</h3><p>Go语言规范<a href="https://golang.org/ref/spec">language specification</a> 概述了几个内置的，<br>不应在Go项目中使用的名称标识<a href="https://golang.org/ref/spec#Predeclared_identifiers">predeclared identifiers</a>。</p>
<p>根据上下文的不同，将这些标识符作为名称重复使用，<br>将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。<br>在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">error</span> <span class="type">string</span></span><br><span class="line"><span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(<span class="type">error</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="type">string</span></span><br><span class="line"><span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。</span></span><br><span class="line">    <span class="type">error</span>  <span class="type">error</span></span><br><span class="line">    <span class="type">string</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Error() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// `error` 和 `f.error` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// `string` and `f.string` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `string` 现在是明确的。</span></span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Error() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
</tbody></table>

<p>注意，编译器在使用预先分隔的标识符时不会生成错误，<br>但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<h3 id="避免使用-init"><a href="#避免使用-init" class="headerlink" title="避免使用 init()"></a>避免使用 <code>init()</code></h3><p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，<br>因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数&#x2F;输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方），<br>或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，<br>而不是执行“init magic”</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _defaultFoo Foo</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _defaultFoo = Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _defaultFoo = Foo&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or, 为了更好的可测试性:</span></span><br><span class="line"><span class="keyword">var</span> _defaultFoo = defaultFoo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFoo</span><span class="params">()</span></span> Foo &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _config Config</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 基于当前目录</span></span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line">    <span class="comment">// Bad: I/O</span></span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;config.yaml&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> Config &#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;config.yaml&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li><p>不能表示为单个赋值的复杂表达式。</p>
</li>
<li><p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p>
</li>
<li><p>对<a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations">Google Cloud Functions</a>和其他形式的确定性预计算的优化。</p>
</li>
</ul>
<h3 id="追加时优先指定切片容量"><a href="#追加时优先指定切片容量" class="headerlink" title="追加时优先指定切片容量"></a>追加时优先指定切片容量</h3><p>追加时优先指定切片容量</p>
<p>在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="主函数退出方式-Exit"><a href="#主函数退出方式-Exit" class="headerlink" title="主函数退出方式(Exit)"></a>主函数退出方式(Exit)</h3><p>Go程序使用<a href="https://golang.org/pkg/os/#Exit"><code>os.Exit</code></a> 或者 <a href="https://golang.org/pkg/log/#Fatal"><code>log.Fatal*</code></a> 立即退出 (使用<code>panic</code>不是退出程序的好方法，请 <a href="#%E4%B8%8D%E8%A6%81-panic">don’t panic</a>.)</p>
<p>**仅在<code>main（）</code>**中调用其中一个 <code>os.Exit</code> 或者 <code>log.Fatal*</code>。所有其他函数应将错误返回到信号失败中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body := readFile(path)</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  body, err := readFile(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">string</span>(b), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>原则上：退出的具有多种功能的程序存在一些问题：</p>
<ul>
<li>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</li>
<li>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 <code>go test</code> 尚未运行的其他测试的风险。</li>
<li>跳过清理：当函数退出程序时，会跳过已经进入<code>defer</code>队列里的函数调用。这增加了跳过重要清理任务的风险。</li>
</ul>
<h4 id="一次性退出"><a href="#一次性退出" class="headerlink" title="一次性退出"></a>一次性退出</h4><p>如果可能的话，你的<code>main（）</code>函数中<strong>最多一次</strong> 调用 <code>os.Exit</code>或者<code>log.Fatal</code>。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。<br>这会缩短 <code>main()</code>函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;missing file&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  <span class="comment">// 如果我们调用log.Fatal 在这条线之后</span></span><br><span class="line">  <span class="comment">// f.Close 将会被执行.</span></span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;missing file&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能方面的特定准则只适用于高频场景。</p>
<h3 id="优先使用-strconv-而不是-fmt"><a href="#优先使用-strconv-而不是-fmt" class="headerlink" title="优先使用 strconv 而不是 fmt"></a>优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkFmtSprint-4    143 ns/op    2 allocs/op</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>



<h3 id="避免字符串到字节的转换"><a href="#避免字符串到字节的转换" class="headerlink" title="避免字符串到字节的转换"></a>避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns/op</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns/op</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="指定容器容量"><a href="#指定容器容量" class="headerlink" title="指定容器容量"></a>指定容器容量</h3><p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<h4 id="指定Map容量提示"><a href="#指定Map容量提示" class="headerlink" title="指定Map容量提示"></a>指定Map容量提示</h4><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure>

<p>向<code>make()</code>提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。</p>
<p>注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。<br>因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p>
</td><td>

<p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p>
</td></tr>
</tbody></table>

<h4 id="指定切片容量"><a href="#指定切片容量" class="headerlink" title="指定切片容量"></a>指定切片容量</h4><p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>

<p>与maps不同，slice capacity不是一个提示：编译器将为提供给<code>make()</code>的slice的容量分配足够的内存，<br>这意味着后续的append()&#96;操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p>
<p>但是最重要的是，<strong>保持一致</strong>.</p>
<p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<h3 id="相似的声明放在一组"><a href="#相似的声明放在一组" class="headerlink" title="相似的声明放在一组"></a>相似的声明放在一组</h3><p>Go 语言支持将相似的声明放在一个组内。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="string">&quot;b&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>这同样适用于常量、变量和类型声明：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="type">float64</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="type">float64</span></span><br><span class="line">  Volume <span class="type">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  EnvVar = <span class="string">&quot;MY_ENV&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnvVar = <span class="string">&quot;MY_ENV&quot;</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> red = color.New(<span class="number">0xff0000</span>)</span><br><span class="line">  <span class="keyword">var</span> green = color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">  <span class="keyword">var</span> blue = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff0000</span>)</span><br><span class="line">    green = color.New(<span class="number">0x00ff00</span>)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="import-分组"><a href="#import-分组" class="headerlink" title="import 分组"></a>import 分组</h3><p>导入应该分为两组：</p>
<ul>
<li>标准库</li>
<li>其他库</li>
</ul>
<p>默认情况下，这是 goimports 应用的分组。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;go.uber.org/atomic&quot;</span></span><br><span class="line">  <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;go.uber.org/atomic&quot;</span></span><br><span class="line">  <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>当命名包时，请按下面规则选择一个名称：</p>
<ul>
<li>全部小写。没有大写或下划线。</li>
<li>大多数使用命名导入的情况下，不需要重命名。</li>
<li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li>
<li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li>
<li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li>
</ul>
<p>另请参阅 <a href="https://blog.golang.org/package-names">Package Names</a> 和 <a href="https://rakyll.org/style-packages/">Go 包样式指南</a>.</p>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p>
<h3 id="导入别名"><a href="#导入别名" class="headerlink" title="导入别名"></a>导入别名</h3><p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">&quot;example.com/client-go&quot;</span></span><br><span class="line">  trace <span class="string">&quot;example.com/trace/v2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">&quot;golang.net/x/trace&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">&quot;golang.net/x/trace&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="函数分组与顺序"><a href="#函数分组与顺序" class="headerlink" title="函数分组与顺序"></a>函数分组与顺序</h3><ul>
<li>函数应按粗略的调用顺序排序。</li>
<li>同一文件中的函数应按接收者分组。</li>
</ul>
<p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>&#x2F;<code>NewXYZ()</code> </p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Cost() &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Stop() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span></span> *something &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span></span> *something &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Cost() &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span></span> Stop() &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>代码应通过尽可能先处理错误情况&#x2F;特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="type">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span></span><br><span class="line"><span class="comment">// 还是那种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> myError &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e <span class="type">error</span> = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="对于未导出的顶层常量和变量，使用-作为前缀"><a href="#对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="对于未导出的顶层常量和变量，使用_作为前缀"></a>对于未导出的顶层常量和变量，使用_作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以<code>err</code>开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">&quot;user&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">&quot;Default port&quot;</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">&quot;user&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="结构体中的嵌入"><a href="#结构体中的嵌入" class="headerlink" title="结构体中的嵌入"></a>结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="type">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。<br>它应该在对用户不利影响的情况下完成这项工作（另请参见：<code>避免在公共结构中嵌入类型</code><a href="#avoid-embedding-types-in-public-structs">Avoid Embedding Types in Public Structs</a>）。</p>
<p>嵌入 <strong>不应该</strong>:</p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的API或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p>简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，<br>“是否所有这些导出的内部方法&#x2F;字段都将直接添加到外部类型”<br>如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型-而是使用字段。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: A.Lock() and A.Unlock() 现在可用</span></span><br><span class="line">    <span class="comment">// 不提供任何功能性好处，并允许用户控制有关A的内部细节。</span></span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> countingWriteCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: Write() 在外层提供用于特定目的，</span></span><br><span class="line">    <span class="comment">// 并且委托工作到内部类型的Write()中。</span></span><br><span class="line">    io.WriteCloser</span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *countingWriteCloser)</span></span> Write(bs []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    w.count += <span class="built_in">len</span>(bs)</span><br><span class="line">    <span class="keyword">return</span> w.WriteCloser.Write(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Bad: 指针更改零值的有用性</span></span><br><span class="line">    io.ReadWriter</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.String()   <span class="comment">// panic: nil pointer</span></span><br><span class="line">b.Write(...) <span class="comment">// panic: nil pointer</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Good: 有用的零值</span></span><br><span class="line">    bytes.Buffer</span><br><span class="line">    <span class="comment">// other fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="keyword">var</span> b Book</span><br><span class="line">b.Read(...)  <span class="comment">// ok</span></span><br><span class="line">b.String()   <span class="comment">// ok</span></span><br><span class="line">b.Write(...) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    buf bytes.Buffer</span><br><span class="line">    url url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h3><p>初始化结构体时，应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> 强制执行。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">&quot;add&quot;</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">&quot;subtract&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="本地变量声明"><a href="#本地变量声明" class="headerlink" title="本地变量声明"></a>本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="nil-是一个有效的-slice"><a href="#nil-是一个有效的-slice" class="headerlink" title="nil 是一个有效的 slice"></a>nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p>
<ul>
<li><p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>
</li>
<li><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>
</li>
<li><p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table></li>
</ul>
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
<h3 id="缩小变量作用域"><a href="#缩小变量作用域" class="headerlink" title="缩小变量作用域"></a>缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="避免参数语义不明确-Avoid-Naked-Parameters"><a href="#避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="避免参数语义不明确(Avoid Naked Parameters)"></a>避免参数语义不明确(Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true&#x2F;false）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="type">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用原始字符串字面值，避免转义"><a href="#使用原始字符串字面值，避免转义" class="headerlink" title="使用原始字符串字面值，避免转义"></a>使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit">原始字符串字面值</a>，也就是 “ &#96; “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wantError := <span class="string">&quot;unknown name:\&quot;test\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:&quot;test&quot;`</span></span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h3><h4 id="使用字段名初始化结构"><a href="#使用字段名初始化结构" class="headerlink" title="使用字段名初始化结构"></a>使用字段名初始化结构</h4><p>初始化结构时，几乎应该始终指定字段名。目前由<a href="https://golang.org/cmd/vet/"><code>go vet</code></a>强制执行。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>例外：当有3个或更少的字段时，测试表中的字段名<em>may</em>可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">&quot;add&quot;</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">&quot;subtract&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="省略结构中的零值字段"><a href="#省略结构中的零值字段" class="headerlink" title="省略结构中的零值字段"></a>省略结构中的零值字段</h4><p>初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。<br>也就是，让我们自动将这些设置为零值</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  MiddleName: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  Admin: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  LastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。</p>
<p>在字段名提供有意义上下文的地方包含零值。例如，<a href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95">表驱动测试</a> 中的测试用例可以受益于字段的名称，即使它们是零值的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give <span class="type">string</span></span><br><span class="line">  want <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;give: <span class="string">&quot;0&quot;</span>, want: <span class="number">0</span>&#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对零值结构使用-var"><a href="#对零值结构使用-var" class="headerlink" title="对零值结构使用 var"></a>对零值结构使用 <code>var</code></h4><p>如果在声明中省略了结构的所有字段，请使用 <code>var</code> 声明结构。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>这将零值结构与那些具有类似于为[初始化 Maps]创建的,区别于非零值字段的结构区分开来，<br>并与我们更喜欢的<a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices">declare empty slices</a>方式相匹配。</p>
<h4 id="初始化-Struct-引用"><a href="#初始化-Struct-引用" class="headerlink" title="初始化 Struct 引用"></a>初始化 Struct 引用</h4><p>在初始化结构引用时，请使用<code>&amp;T&#123;&#125;</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">&quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">&quot;bar&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="初始化-Maps"><a href="#初始化-Maps" class="headerlink" title="初始化 Maps"></a>初始化 Maps</h3><p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。<br>这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p>声明和初始化看起来非常相似的。</p>
</td><td>

<p>声明和初始化看起来差别非常大。</p>
</td></tr>
</tbody></table>

<p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#%E6%8C%87%E5%AE%9AMap%E5%AE%B9%E9%87%8F%E6%8F%90%E7%A4%BA">指定Map容量提示</a>。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p>
<h3 id="字符串-string-format"><a href="#字符串-string-format" class="headerlink" title="字符串 string format"></a>字符串 string format</h3><p>如果你在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。</p>
<p>这有助于<code>go vet</code>对格式字符串执行静态分析。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := <span class="string">&quot;unexpected values %v, %v\n&quot;</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">&quot;unexpected values %v, %v\n&quot;</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<h3 id="命名-Printf-样式的函数"><a href="#命名-Printf-样式的函数" class="headerlink" title="命名 Printf 样式的函数"></a>命名 Printf 样式的函数</h3><p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p>
<p>这意味着您应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family">Printf 系列</a>。</p>
<p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure>

<p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/">go vet: Printf family check</a>.</p>
<h2 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h2><h3 id="表驱动测试"><a href="#表驱动测试" class="headerlink" title="表驱动测试"></a>表驱动测试</h3><p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">&quot;192.0.2.0:8000&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">&quot;192.0.2.0:http&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;http&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">&quot;1:8&quot;</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;1&quot;</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">&quot;8&quot;</span>, port)</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="type">string</span></span><br><span class="line">  wantHost <span class="type">string</span></span><br><span class="line">  wantPort <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;192.0.2.0:8000&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;8000&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;192.0.2.0:http&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;:8000&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;8000&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">&quot;1:8&quot;</span>,</span><br><span class="line">    wantHost: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    wantPort: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p>
<p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="type">string</span></span><br><span class="line">  wantHost <span class="type">string</span></span><br><span class="line">  wantPort <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h3><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  addr <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cache <span class="type">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  logger *zap.Logger</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*Connection, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  addr <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  opts ...Option,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*Connection, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</td></tr>
<tr><td>

<p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Open(addr, db.DefaultCache, zap.NewNop())</span><br><span class="line">db.Open(addr, db.DefaultCache, log)</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br></pre></td></tr></table></figure>

</td><td>

<p>只有在需要时才提供选项。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Open(addr)</span><br><span class="line">db.Open(addr, db.WithLogger(log))</span><br><span class="line">db.Open(addr, db.WithCache(<span class="literal">false</span>))</span><br><span class="line">db.Open(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCache(<span class="literal">false</span>),</span><br><span class="line">  db.WithLogger(log),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</td></tr>
</tbody></table>

<p>Our suggested way of implementing this pattern is with an <code>Option</code> interface<br>that holds an unexported method, recording options on an unexported <code>options</code><br>struct.</p>
<p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  cache  <span class="type">bool</span></span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span></span> apply(opts *options) &#123;</span><br><span class="line">  opts.cache = <span class="type">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span></span> apply(opts *options) &#123;</span><br><span class="line">  opts.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;</span><br><span class="line">  <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  addr <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  opts ...Option,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (*Connection, <span class="type">error</span>) &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p>
<p>还可以参考下面资料：</p>
<ul>
<li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">Self-referential functions and the design of options</a></p>
</li>
<li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">Functional options for friendly APIs</a></p>
</li>
</ul>
<!-- TODO: replace this with parameter structs and functional options, when to
use one vs other -->

<h2 id="Linting"><a href="#Linting" class="headerlink" title="Linting"></a>Linting</h2><p>比任何 “blessed” linter 集更重要的是，lint在一个代码库中始终保持一致。</p>
<p>我们建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p>
<ul>
<li><p><a href="https://github.com/kisielk/errcheck">errcheck</a> 以确保错误得到处理</p>
</li>
<li><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a> 格式化代码和管理 imports</p>
</li>
<li><p><a href="https://github.com/golang/lint">golint</a> 指出常见的文体错误</p>
</li>
<li><p><a href="https://golang.org/cmd/vet/">govet</a> 分析代码中的常见错误</p>
</li>
<li><p><a href="https://staticcheck.io/">staticcheck</a> 各种静态分析检查</p>
</li>
</ul>
<h3 id="Lint-Runners"><a href="#Lint-Runners" class="headerlink" title="Lint Runners"></a>Lint Runners</h3><p>我们推荐 <a href="https://github.com/golangci/golangci-lint">golangci-lint</a> 作为go-to lint的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个repo有一个示例配置文件<a href="https://github.com/uber-go/guide/blob/master/.golangci.yml">.golangci.yml</a>和推荐的linter设置。</p>
<p>golangci-lint 有<a href="https://golangci-lint.run/usage/linters/">various-linters</a>可供使用。建议将上述linters作为基本set，我们鼓励团队添加对他们的项目有意义的任何附加linters。</p>
<h2 id="Stargazers-over-time"><a href="#Stargazers-over-time" class="headerlink" title="Stargazers over time"></a>Stargazers over time</h2><p><a href="https://starchart.cc/xxjwxc/uber_go_guide_cn"><img src="https://starchart.cc/xxjwxc/uber_go_guide_cn.svg" alt="Stargazers over time"></a></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>RobPike谈GoogGo</title>
    <url>/2023/09/04/RobPike%E8%B0%88GoogGo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Rob，你创建了Google-Go这门语言。什么是Google-Go？能简明扼要的介绍一下Google-Go吗？"><a href="#1-Rob，你创建了Google-Go这门语言。什么是Google-Go？能简明扼要的介绍一下Google-Go吗？" class="headerlink" title="1. Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？"></a>1. Rob，你创建了Google Go这门语言。什么是Google Go？能简明扼要的介绍一下Google Go吗？</h2><p>我还是讲讲为什么要创建这门语言吧，和你的问题稍有些不同。我在Google做了一个有关编程语言的系列讲座，在Youtube上有，谈及了我早期所写的一个语言，叫做Newsqueak，那是八十年代的事，非常早。在做讲座期间，我开始思考为什么Newsqueak中的一些想法在我现在以C++为主的工作环境中无法使用。而且在Google我们经常要构建非常大的程序，光构建就要花很多时间，对依赖的管理也有问题，由于链接了本来并不需要的东西，二进制程序包变得很大，链接时间很长，编译时间也很长，而且C++的工作方式有点古老，其底层实际上C，C++已经有三十年的历史了，而C则更是有四十年了。用现今的硬件做计算，有很多新东西需要考虑：多核机器、网络化、分布式系统、云计算等等。</p>
<h2 id="2-Go的主要特点是什么？有什么重要功能？"><a href="#2-Go的主要特点是什么？有什么重要功能？" class="headerlink" title="2. Go的主要特点是什么？有什么重要功能？"></a>2. Go的主要特点是什么？有什么重要功能？</h2><p>对于大多数人来说，他们对Go的第一印象是该语言将并发性作为语言原语，这对我们处理分布式计算和多核这类东西来说非常好、也非常重要。我猜许多人会认为Go是一门简单无趣的语言，没有什么特别的东西，因为其构想看起来一目了然。但实际上不能用第一印象来判断Go。很多用过Go的人会发现它是一门非常高产而且有表现力的语言，能够解决我们编写这门语言时期望其所能解决的所有问题。</p>
<p>Go的编译过程很快，二进制程序包又比较小，它管理依赖的方式如同管理语言本身的东西一样。这里还有一个故事呢，但是在这里就不再展开讨论了，但是这门语言的并发性使其能够以非常简单的模式来处理非常复杂的操作及分布式计算环境。我想最重要的功能可能就是并发性了，后面我们可以谈谈该语言的类型系统，其与C++、Java这类传统面向对象类型系统的差异很大。</p>
<h2 id="3-在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？"><a href="#3-在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？" class="headerlink" title="3. 在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？"></a>3. 在我们继续话题之前，能否解释一下为什么Go编译器能达到那么快的编译速度呢？有什么法宝？</h2><p>它之所以快，有两个原因。首先Go有两个编译器——两个单独的实现。一个是按照Plan 9（<a href="http://plan9.bell-labs.com/wiki/plan9/1/%EF%BC%89">http://plan9.bell-labs.com/wiki/plan9/1/）</a> 风格新写的编译器，它有自己独特的工作方式，是个全新的编译器。另一个编译器叫做GCC Go，它拥有GCC前端，这个编译器是Ian Taylor后来写的。所以Go有两个编译器，速度快是二者的共同特点，但是Plan 9风格编译器的速度是GCC Go的5倍，因为它从头到脚都是全新的，没有GCC后端，那些东西会花很多时间来产生真正的好代码。</p>
<p>GCC Go编译器要产生更好的代码，所以速度慢些。不过真正重要的一点是Go编译器的依赖管理特性才是其编译速度快的真正原因。如果你去看一个C或C++程序，便会发现其头文件描述了函数库、对象代码等等东西。语言本身并不强制检查依赖，每一次你都必须分析代码以便清楚你的函数是怎样的。如果你编译过程中想用另一个类的C++程序，你必须先编译它所依赖的类和头文件等等等等。如果你所编译的C++程序有许多类，并且内部相关，你可能会把同一个头文件编译数百次甚至上千次。当然，你可以用预编译头文件及其他技巧来回避之一问题。</p>
<p>但是语言本身并不能帮上你的忙，工具可能会让这一问题得到改善，可是最大的问题是并没有什么能保证你所编译的东西就是程序真正需要的东西。有可能你的程序包含了一个并不真正需要的头文件，但是你没办法知道，因为语言并没有强制检查。而Go有一个更加严格的依赖模型，它有一些叫做包（packages）的东西，你可以把它想象成Java类文件或着类似的东西，或者函数库什么的，虽然他们并不相同，但基本思路是一样的。关键问题是，如果这个东西依赖那个东西，而那个东西又依赖另外一个东西，比如A依赖于B，B又依赖于C，那么你必须首先编译最内层的依赖：即，你先编译C，然后编译B，最后编译A。</p>
<p>但是如果A依赖B，但是A并不直接依赖于C，而是存在依赖传递，那么该怎么办呢？这时所有B需要从C拿到的信息都会被放在B的对象代码里。这样，当我编译A的时候，我不需要再管C了。于是事情就非常简单了：在你编译程序时，你只需将类型信息沿着依赖关系树向上遍历即可，如果你到达树的顶端，则只需编译紧邻的依赖，而不用管其它层级的依赖了。如果你要做算术运算，你会发现在Objective-C或C++或类似的语言里，虽然只包含了一个简单的头文件，但由于依赖传递的存在，你可能会编译数十万行程序。然而在Go中，你打开一个文件，里面或许只有20行，因为其中只描述了公共接口。</p>
<p>如果一个依赖链里只有三个文件，Go的优势可能并不明显，但是如果你有成千上万个文件的时候，Go的速度优势会成指数增长。我们相信，如果用Go的话，我们应该能够在数秒内就编译完数百万行代码。然而如果是等量的用C++编写的程序，由于依赖管理问题，编译的开销会大得多，编译的时间将会长达若干分钟。因此，Go速度快的根源主要归功于对依赖的管理。</p>
<h2 id="4-让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）-那么Go里的类型是什么？"><a href="#4-让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）-那么Go里的类型是什么？" class="headerlink" title="4. 让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）,那么Go里的类型是什么？"></a>4. 让我们开始聊聊Go里的类型系统吧。Go里面有结构（struct）、有类型（type）,那么Go里的类型是什么？</h2><p>Go里的类型与其它传统编程语言里的类型是类似的。Go里的类型有整数、字符串、struct数据结构、以及数组（array），我们称之为切片（slice），它们类似于C的数组，但更易于使用，更加固定一些。你可以声明本地类型并予以命名，然后按照通常的方式来使用。Go和面向对象方式的不同之处在于，类型只是书写数据的一种方式，方法则是一个完全独立的概念。你可以把方法放在struct上，在Go里没有类的概念，取而代之的是结构，以及为此结构声明的一些方法。</p>
<p>结构不能与类混为一谈。但是你也可以把方法放在数组、整数、浮点数或字符串上，实际上任何类型都可以有方法。因此，这里方法的概念比Java的方法更加泛化，在Java里方法是类的一部分，仅此而已。例如，你的整数上可以有方法，听上去似乎没什么用，但是如果你想在一个叫做Tuesday的整数常量上附加上to_string方法来打印出漂亮的星期格式；或者，你想重新格式化字符串使其能够以不同的方式打印出自己，这时你就会意识到它的作用。为什么非要把所有方法或者其它好东西都塞进类里面呢，为什么不让它们提供更广泛的服务呢？</p>
<h2 id="5-那么这些方法只是在包内部可见喽？"><a href="#5-那么这些方法只是在包内部可见喽？" class="headerlink" title="5. 那么这些方法只是在包内部可见喽？"></a>5. 那么这些方法只是在包内部可见喽？</h2><p>非也，实际上是这样，Go只允许你在包内为你所实现的类型定义方法。我不能引入你的类型然后直接把我的方法增加进去，但是我可以使用匿名属性（anonymous field）将其包裹起来，方法可不是你想加到哪就加到哪的，你要定义类型，然后才能把方法放在上面。正因为如此，我们在包里提供了另一种封装——接口（interface），但是如果你不明白谁能为对象增加方法的严格界限，就很难理解接口。</p>
<h2 id="6-你的意思是，我可以给int增加方法，但是必须先使用typedef吗？"><a href="#6-你的意思是，我可以给int增加方法，但是必须先使用typedef吗？" class="headerlink" title="6. 你的意思是，我可以给int增加方法，但是必须先使用typedef吗？"></a>6. 你的意思是，我可以给int增加方法，但是必须先使用typedef吗？</h2><p>你要typedef一个整数类型，起个名字，如果你正在处理一星期中的七天，可以就叫它“Day”，你可以给你所声明的类型——Day增加方法，但是你不能直接给int增加方法。因为整数类型不是你定义的，不在你的包里，它是引入的但并不在你的包中定义，这就意味着你不能给其增加方法。你不能给不在你包里定义的类型增加方法。</p>
<h2 id="7-你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。"><a href="#7-你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。" class="headerlink" title="7. 你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。"></a>7. 你们借鉴了Ruby里开放类的思想，这很有意思。Ruby的开放类实际上是可以修改类并增加新的方法，这是有破坏性的，但是你们的方法本质上是安全的，因为创建了新的东西。</h2><p>它是安全可控的，而且很容易理解。最初我们觉得类型用起来可能不太方便，我们也希望像Ruby那样添加方法，但这又让接口比较难以理解。所以，我们只把方法取出来，而不是放进去，我们想不出有什么更好的办法，于是限制方法只能在本地类型上，不过这种思路确实很容易理解和使用。</p>
<h2 id="8-你还提到了typedef，是叫typedef吧？"><a href="#8-你还提到了typedef，是叫typedef吧？" class="headerlink" title="8. 你还提到了typedef，是叫typedef吧？"></a>8. 你还提到了typedef，是叫typedef吧？</h2><p>应该叫“type”，你所说的类型——Day的定义方式是这样“type Day int”，这样你就有一个新类型了，你可以在其上增加方法、声明变量，但这个类型不同于int，不像C那样，只是同一事物另起了个名字而已，在Go里实际上你创建了一个不同于int的新类型，叫做“Day”，它拥有int的结构特性，但却有自己的方法集。</p>
<h3 id="9-Typedef在C里是一种预处理指令吗？【编辑注-免责申明：C语言里的typedef与预处理无关】"><a href="#9-Typedef在C里是一种预处理指令吗？【编辑注-免责申明：C语言里的typedef与预处理无关】" class="headerlink" title="9. Typedef在C里是一种预处理指令吗？【编辑注&#x2F;免责申明：C语言里的typedef与预处理无关】"></a>9. Typedef在C里是一种预处理指令吗？【编辑注&#x2F;免责申明：C语言里的typedef与预处理无关】</h3><p>那实际上就是个别名，但在Go里不是别名，是新类型。</p>
<h2 id="10-我们从底层说起吧，在Go里最小的类型是什么？"><a href="#10-我们从底层说起吧，在Go里最小的类型是什么？" class="headerlink" title="10. 我们从底层说起吧，在Go里最小的类型是什么？"></a>10. 我们从底层说起吧，在Go里最小的类型是什么？</h2><p>最小的类型应该是布尔类型（bool）吧。bool、int和float，然后是int32、float64之类有尺寸的类型、字符串、复杂类型，可能有遗漏，但这就是基本类型集了。你可以由这些类型构建结构、数组、映射（map），映射在Go里是内建类型不是函数库。然后我想就该是接口了，到了接口，有趣的东西才真正开始。</p>
<h2 id="11-但是，int这样的类型是值类型对吧"><a href="#11-但是，int这样的类型是值类型对吧" class="headerlink" title="11. 但是，int这样的类型是值类型对吧."></a>11. 但是，int这样的类型是值类型对吧.</h2><p>Int是值类型。在Go里，任何类型都是值类型，和C一样，所有东西都是按值调用，但是你也可以用指针。如果你想引用某样东西，可以获取其地址，这样你就有了一个指针。Go也有指针但是比C指针有更多限制，Go里的指针是安全的，因为他们是类型安全的，所以你没法欺骗编译器，而且也没有指针运算，因此，如果你有个指向某物的指针，你无法将其移到对象外，也无法欺骗编译器。</p>
<h2 id="12-它们类似C-的引用吗？"><a href="#12-它们类似C-的引用吗？" class="headerlink" title="12. 它们类似C++的引用吗？"></a>12. 它们类似C++的引用吗？</h2><p>是的，很像引用，但是你可以按照你预期的方式对它们进行写操作。而且你可以使用结构内部（如缓冲区）中间的某个地址，它和Java的引用不一样。在Java中，你必须在旁边分配一个缓冲区，这是额外的开销。在Go中，你实际上把该对象分配为结构的一部分，在同一内存块中，这对性能是非常重要的。</p>
<h2 id="13-它是结构内部一个复合对象。"><a href="#13-它是结构内部一个复合对象。" class="headerlink" title="13. 它是结构内部一个复合对象。"></a>13. 它是结构内部一个复合对象。</h2><p>是的，如果它是值而不是指针的话，是这样。当然你也可以把指针放在结构内部和外部，但是如果你有struct A，而把struct B放在struct A里，那么stuct B就是一块内存，而不像Java那样，这也是Java性能问题的原因之一。</p>
<h2 id="14-你提到过接口比较有趣，那下面咱们就谈谈这一部分。"><a href="#14-你提到过接口比较有趣，那下面咱们就谈谈这一部分。" class="headerlink" title="14. 你提到过接口比较有趣，那下面咱们就谈谈这一部分。"></a>14. 你提到过接口比较有趣，那下面咱们就谈谈这一部分。</h2><p>Go里的接口真的非常、非常地简单。接口指明了两个不同事情：其一，它表明了类型的构思，接口类型是一个罗列了一组方法的类型，因此如果你要抽象一组方法来定义一个行为，那么就定义一个接口并声明这些方法。现在你就有了一个类型，我们就叫它接口类型吧，那么从现在起所有实现了接口中这些方法的类型——包括基本类型、结构、映射（map）或其它什么类型，都隐含符合该接口要求。其二，也是真正有意思的是，和大多数语言中的接口不同的是，Go里面没有“implements”声明。</p>
<p>你无须说明“我的对象实现了这个接口”，只要你定义了接口中的那些方法，它就自动实现了该接口。有些人对此感到非常担忧，依我看他们想说的是：知道自己实现（Implement）了什么接口真的很重要。如果你真想确定自己实现了什么接口，还是有技巧可以做到这一点的。但是我们的想法与此截然不同，我们的想法是你不应该考虑实现什么接口，而是应该写下要做的东西，因为你不必事前就决定要实现哪个接口。可能后来你实际上实现了某个现在你尚不知晓的接口，因为该接口还未设计出来，但是现在你已经在实现它。</p>
<p>后来你可能发现两个原先未曾考虑过相关性的类具有了相关性——我又用了类这个词，我思考Java太多了——两个structs都实现了一些非常有用的小子集中的相关方法，这时有办法能够操作这两个structs中的任意一个就显得非常有用了。这样你就可以声明一个接口，然后什么都不用管了，即使这些方法是在别人的代码中实现的也没问题，虽然你不能编辑这些代码。如果是Java，这些代码必须要声明实现你的接口，在某种意义上，实现是单向的。然而在Go里，实现是双向的。对于接口实际上有不少漂亮而简单的例子。</p>
<p>我最爱用的一个真实例子就是“Reader”，Go里有个包叫做IO，IO包里有个Reader接口，它只有一个方法，该方法是read方法的标准声明，比如从操作系统或文件中读取内容。这个接口可以被系统中任何做read系统调用的东西所实现。显然，文件、网络、缓存、解压器、解密机、管道，甚至任何想访问数据的东西，都可以给其数据提供一个Reader接口，然后想从这些资源中读取数据的任何程序都可以通过该接口达到目的。这有点像我们前面说过的Plan 9，但是用不同的方式泛化的。</p>
<p>与之类似，Writer也是比较好理解的另一个例子，Writer 由那些要做写操作的人来实现。那么在做格式化打印时，fpringf的第一参数不是file了，而是Writer。这样，fprintf可以给任何实现了write方法的东西做IO格式化的工作。有很多很好的例子：比如HTTP，如果你正在实现一个HTTP服务器，你仅须对connection做fprintf，便可将数据传递到客户端，不需要任何花哨的操作。你可以通过压缩器来进行写操作，你可以通过我所提到的任何东西来进行写操作：压缩器、加密机、缓存、网络连接、管道、文件，你都可以通过fprintf直接操作，因为它们都实现了write方法，因此，隐含都隐含符合writer接口要求。</p>
<h2 id="15-某种程度上有点类似结构化类型系统（structural-typing"><a href="#15-某种程度上有点类似结构化类型系统（structural-typing" class="headerlink" title="15. 某种程度上有点类似结构化类型系统（structural typing)"></a>15. 某种程度上有点类似结构化类型系统（structural typing)</h2><p>不考虑它的行为的话，它是有点像结构化类型系统。不过它是完全抽象的，其意并不在拥有什么，而是能做什么。有了结构（struct）之后，就规定了其内存的样子，然后方法说明了结构的行为，再之后，接口则抽象了该结构及其它实现了相同方法的其他结构中的这些方法。这是一种鸭子类型系统（duck typing，一种动态类型系统，<a href="http://en.wikipedia.org/wiki/Duck_typing%EF%BC%89%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E3%80%82">http://en.wikipedia.org/wiki/Duck_typing），而不是结构化类型系统。</a></p>
<h2 id="16-你提到过类，但Go没有类，对吧。"><a href="#16-你提到过类，但Go没有类，对吧。" class="headerlink" title="16. 你提到过类，但Go没有类，对吧。"></a>16. 你提到过类，但Go没有类，对吧。</h2><p>Go没有类。</p>
<h2 id="17-但是没有类怎么去写代码？"><a href="#17-但是没有类怎么去写代码？" class="headerlink" title="17. 但是没有类怎么去写代码？"></a>17. 但是没有类怎么去写代码？</h2><p>带方法的结构（stuct）很像是类。比较有意思的不同之处是，Go没有子类型继承，你必须学习Go的另类写法，Go有更强大、更有表现力的东西。不过Java程序员和C++程序员刚开始使用Go的时候会感到意外，因为他们实际上在用Go去编写Java程序或C++程序，这样的代码工作得并不好，你可以这样做，但这样就略显笨拙了。但是如果你退一步，对自己说“我该怎样用Go去编写这些东西呢？”，你会发现模式其实是不同的，用Go你可以用更短的程序来表达类似的想法，因为你不需要在所有子类里重复实现行为。这是个非常不同的环境，比你第一眼看上去的还要不同。</p>
<h2 id="18-如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？"><a href="#18-如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？" class="headerlink" title="18. 如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？"></a>18. 如果我有一些行为要实现，而且想放在多个structs里，怎么去共享这些行为？</h2><p>有一个叫做匿名域的概念，也就是所谓的嵌入。其工作方式是这样：如果你有一个结构（struct），而又有一些其它东西实现了你想要的行为，你可以把这些东西嵌入到你的结构（struct）里，这样，这个结构（struct）不仅仅可以获得被嵌入者的数据还可以获得它的方法。如果你有一些公共行为，比如某些类型里都有一个name方法，在Java里的话你会认为这是一组子类（继承来的方法），在Go里，你只需拿到一个拥有name方法的类型，放在所有你要实现这个方法的结构里，它们就会自动获得name方法，而不用在每个结构里都去写这个方法。这是个很简单的例子，但有不少有趣的结构化的东西使用到了嵌入。</p>
<p>而且，你还可以把多个东西嵌入到一个单一结构中，你可以把它想象成多重继承，不过这会让人更加迷惑，实际在Go里它是很简单的，它只是一个集合，你可以放任何东西在里面，基本上联合了所有的方法，对每个方法集合，你只需写一行代码就可以拥有其所有行为。</p>
<h2 id="19-如果有多重继承命名冲突的问题该怎么办？"><a href="#19-如果有多重继承命名冲突的问题该怎么办？" class="headerlink" title="19. 如果有多重继承命名冲突的问题该怎么办？"></a>19. 如果有多重继承命名冲突的问题该怎么办？</h2><p>命名冲突实际上并没什么，Go是静态处理这一问题的。其规则是，如果有多层嵌入，则最高层优先；如果同一层有两个相同的名字或相同的方法，Go会给出一个简单的静态错误。你不用自己检查，只需留意这个错误即可。命名冲突是静态检查的，而且规则非常简单，在实践中命名冲突发生的也并不多。</p>
<h2 id="20-因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？"><a href="#20-因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？" class="headerlink" title="20. 因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？"></a>20. 因为系统中没有根对象或根类，如果我想得到一个拥有不同类型的结构的列表，应该怎么办？</h2><p>接口一个有意思的地方是他们只是集合，方法的集合，那么就会有空集合，没有任何方法的接口，我们称之为空接口。系统中任何东西都符合空接口的要求。空接口有点类似于Java的Object，不同之处在于，int、float和string也符合空接口，Go并不需要一个实际的类，因为Go里没有类的概念，所有东西都是统一的，这有点像void<em>，只不过void</em>是针对指针而不是值。</p>
<p>但是一个空接口值可以代表系统中的任何东西，非常具有普遍性。所以，如果创建一个空接口数组，实际上你就有了一个多态性容器，如果你想再把它拿出来，Go里面有类型开关，你可以在解包的时候询问里面的类型，因此可以安全的进行解包操作。</p>
<h2 id="21-Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？"><a href="#21-Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？" class="headerlink" title="21. Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？"></a>21. Go里有叫做Goroutines的东西，它们和coroutines有什么区别？不一样么？</h2><p>Coroutines和Goroutines是不同的，它们的名字反应了这一点。我们给它起了个新名，因为有太多术语了，进程（processes）、线程（threads）、轻量级线程、弦（chords），这些东西有数不清的名字，而Goroutines也并不新鲜，同样的概念在其它系统里已经都有了。但是这个概念和前面那些名字有很大不同，我希望我们自己起名字来命名它们。Goroutine背后的含义是：它是一个coroutine，但是它在阻塞之后会转移到其它coroutine，同一线程上的其它coroutines也会转移，因此它们不会阻塞。</p>
<p>因此，从根本上讲Goroutines是coroutines的一个分支，可在足够多的操作线程上获得多路特性，不会有Goroutines会被其他coroutine阻塞。如果它们只是协作的话，只需一个线程即可。但是如果有很多IO操作的话，就会有许多操作系统动作，也就会有许多许多线程。但是Goroutines还是非常廉价的，它们可以有数十万之众，总体运行良好并只占用合理数量的内存，它们创建起来很廉价并有垃圾回收功能，一切都非常简单。</p>
<h2 id="22-你提到你们使用了m-n线程模型，即m个coroutines映射到n个线程上？"><a href="#22-你提到你们使用了m-n线程模型，即m个coroutines映射到n个线程上？" class="headerlink" title="22. 你提到你们使用了m:n线程模型，即m个coroutines映射到n个线程上？"></a>22. 你提到你们使用了m:n线程模型，即m个coroutines映射到n个线程上？</h2><p>对的，但是coroutines的数量和线程的数量是按照程序所做工作动态决定的。</p>
<h2 id="23-Goroutines有用于通信的通道吗？"><a href="#23-Goroutines有用于通信的通道吗？" class="headerlink" title="23. Goroutines有用于通信的通道吗？"></a>23. Goroutines有用于通信的通道吗？</h2><p>是的，一旦有两个独立执行的功能，如果Goroutine们要相互协作它们就需要相互对话。所以就有了通道这个概念，它实际上是一个类型消息队列，你可以用它来发送值，如果你在Goroutine中持有通道的一端，那么你可以发送类型值给另外一端，那一端则会得到想要的东西。通道有同步和异步之分，我们尽可能使用同步通道，因为同步通道的构思非常好，你可以同时进行同步和通信，所有东西运行起来都步调一致。</p>
<p>但是有时由于效率原因或调度原因，对消息进行缓存也是有意义的。你可以向通道发送整型消息、字符串、结构、指向结构的指针等任何东西，非常有意思的事，你可以在通道上发送另一个通道。这样，我就能够把与他人的通信发送给你，这是非常有意思的概念。</p>
<h2 id="24-你提到你们有缓存的同步通道和异步通道。"><a href="#24-你提到你们有缓存的同步通道和异步通道。" class="headerlink" title="24. 你提到你们有缓存的同步通道和异步通道。"></a>24. 你提到你们有缓存的同步通道和异步通道。</h2><p>不对，同步是没有缓存的；异步和缓存是一个意思，因为有了缓存，我才能把值放在缓存的空间里进行保存。但是如果没有缓存，我必须等着别人把值拿走，因此无缓存和同步是一个意思。</p>
<h2 id="25-每个Goroutine就像是一个小的线程，可以这么给读者解释吧。"><a href="#25-每个Goroutine就像是一个小的线程，可以这么给读者解释吧。" class="headerlink" title="25. 每个Goroutine就像是一个小的线程，可以这么给读者解释吧。"></a>25. 每个Goroutine就像是一个小的线程，可以这么给读者解释吧。</h2><p>对，但是轻量级的。</p>
<h2 id="26-它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？"><a href="#26-它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？" class="headerlink" title="26. 它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？"></a>26. 它们是轻量级的。但是每个线程同样都预分配栈空间，因而它们非常耗费资，Goroutines是怎么处理的呢？</h2><p>没错，Goroutines在被创建的时候，只有非常小的一个栈——4K，可能有点小吧，这个栈是在堆中的，当然，你知道如果在C语言里有这么一个小栈会发生什么，当你调用函数或分配数组之类的东西时，程序会马上溢出。在Go里则不会发生这样的事情，每个函数的开头都会有若干指令以检查栈指针是否达到其界限，如果到达界限，它会链接到其它块上，这种连接的栈叫做分段栈，如果你使用了比刚开始启动时更多的栈，你就有了这种栈块链接串，我们称之为分段栈。</p>
<p> 由于只有若干指令，这种机制非常廉价。当然，你可以分配多个栈块，但是Go编译器更倾向于将大的东西移到堆上，因此实际上典型的用法是，你必须在达到4K边界之前调用几个方法，虽然这并不经常发生。但是有一点很重要：它们创建起来很廉价，因为仅有一次内存分配，而且分配的内存非常小，在创建一个新的Goroutine时你不用指明栈的尺寸，这是很好的一种抽象，你根本不用担心栈的大小问题。之后，栈会随需求增长或缩小，你不用担心递归会有问题，你也不用担心大的缓存或任何对程序员完全不可见的东西，一切由Go语言来打理，这是一门语言的整体构思。</p>
<h2 id="27-我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？"><a href="#27-我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？" class="headerlink" title="27. 我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？"></a>27. 我们再来谈谈自动化方面的东西，最初你们是将Go语言作为系统级语言来推广的，一个有趣的选择是使用了垃圾回收器，但是它速度并不快或者说有垃圾回收间歇问题，如果用它写一个操作系统的话，这是非常烦人的。你们是怎么看这一问题的？</h2><p>我认为这是个非常难的问题，我们也还没有解决它，我们的垃圾回收器可以工作，但是有一些延迟问题，垃圾回收器可能会停顿，但是我们的看法是，我们相信尽管这是一个研究课题，虽还没解决但是我们正在努力。对于现今的并行机，通过把机器内核的一些碎片专门分给作为后台任务的垃圾回收来进行并行回收是可行的。在这一领域有很多工作要做，也取得了不少成功，但这是个很微妙的问题，我不认为而我们会把延迟降为0，但是我相信我们可以让延迟尽可能低，这样对于绝大多数系统软件来讲它不再是个问题。我不保证每个程序都不会有显著延迟，但是我想我们可以获得成功，而且这是Go语言中一个比较活跃的领域。</p>
<h2 id="28-有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。"><a href="#28-有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。" class="headerlink" title="28. 有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。"></a>28. 有没有方法能够避免直面垃圾回收器，比如用一些大容量缓存，我们可以把数据扔进去。</h2><p>Go可以让你深入到内存布局，你可以分配自己的空间，如果你想的话可以自己做内存管理。虽然没有alloc和free方法，但是你可以声明一个缓存把东西放进去，这个技巧可用来避免产生不必要的垃圾。就像在C语言一样，在C里，如果你老是malloc和free，代价很大。因此，你分配一个对象数组并把它们链接在一起，形成一个链表，管理你自己的空间，而且还不用malloc和free，那么速度会很快。你可以做与Go所做相同的事情，因为Go赋予你与底层事物安全打交道的能力，因此不用欺骗类型系统来达到目的，你实际上可以自己来做。</p>
<p> 前面我表达了这样的观点，在Java里，无论何时你在结构里嵌入其它东西，都是通过指针来实现的，但在Go里你可以把它放在一个单一结构中。因此如果你有一些需要若干缓存的数据结构，你可以把缓存放在结构的内存里，这不仅意味着高效（因为你不用间接得到缓存），而且还意味着单一结构可以在一步之内进行内存分配与垃圾回收。这样开销就会减少。因此，如果你考虑一下垃圾回收的实际情况，当你正在设计性能要求不高的东西时，你不应该总是考虑这个问题。但如果是高性能要求的，考虑到内存布局，尽管Go是具有真正垃圾回收特性的语言，它还是给了你工具，让你自己来控制有多少内存和产生了的垃圾。我想这是很多人容易忽略的。</p>
<h2 id="29-最后一个问题：Go是系统级语言还是应用级语言？"><a href="#29-最后一个问题：Go是系统级语言还是应用级语言？" class="headerlink" title="29. 最后一个问题：Go是系统级语言还是应用级语言？"></a>29. 最后一个问题：Go是系统级语言还是应用级语言？</h2><p>我们是把他设计为一种系统级语言，因为我们在Google所做的工作是系统级的，对吧？Web服务器和数据库系统、以及存储系统等，这些都是系统。但不是操作系统，我不知道Go是否能成为一个好的操作系统语言，但是也不能说它不会成为这样的语言。有趣的是由于我们设计语言时所采用的方法，Go最终成为了一个非常好的通用语言，这有点出乎我们意料。我想大多数用户并没有实际从系统观点来考虑过它，尽管很多人做过一点Web服务器或类似东西。</p>
<p>Go用来做很多应用类的东西也非常不错，它将会有更好的函数库，越来越多的工具以及一些Go更有用的东西，Go是一个非常好的通用语言，它是我用过的最高产的语言。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go自带库的使用说明</title>
    <url>/2023/09/04/Go%E8%87%AA%E5%B8%A6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-中的时间操作"><a href="#Go-中的时间操作" class="headerlink" title="Go 中的时间操作"></a>Go 中的时间操作</h1><p>Golang中与时间有关的操作，主要涉及到 time 包，核心数据结构是 <code>time.Time</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    wall <span class="type">uint64</span></span><br><span class="line">    ext  <span class="type">int64</span></span><br><span class="line">    loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、获取时间相关函数"><a href="#1、获取时间相关函数" class="headerlink" title="1、获取时间相关函数"></a>1、获取时间相关函数</h3><h4 id="1-1-获取当前时间"><a href="#1-1-获取当前时间" class="headerlink" title="1.1 获取当前时间"></a>1.1 获取当前时间</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间，注意此时返回的是 time.Time 类型</span></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 当前时间戳</span></span><br><span class="line">fmt.Println(now.Unix())</span><br><span class="line"><span class="comment">// 纳秒级时间戳</span></span><br><span class="line">fmt.Println(now.UnixNano())</span><br><span class="line"><span class="comment">// 时间戳小数部分 单位：纳秒</span></span><br><span class="line">fmt.Println(now.Nanosecond())</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">15.930562</span> +<span class="number">0800</span> CST m=+<span class="number">0.000124449</span></span><br><span class="line"><span class="number">1610261775</span></span><br><span class="line"><span class="number">1610261775930562000</span></span><br><span class="line"><span class="number">930562000</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-返回当前年月日时分秒、星期几、一年中的第几天等操作"><a href="#1-2-返回当前年月日时分秒、星期几、一年中的第几天等操作" class="headerlink" title="1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作"></a>1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 返回日期</span></span><br><span class="line">year, month, day := now.Date()</span><br><span class="line">fmt.Printf(<span class="string">&quot;year:%d, month:%d, day:%d\n&quot;</span>, year, month, day)</span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">fmt.Println(now.Year())</span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">fmt.Println(now.Month())</span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">fmt.Println(now.Day())</span><br><span class="line"><span class="comment">// 时分秒</span></span><br><span class="line">hour, minute, second := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;hour:%d, minute:%d, second:%d\n&quot;</span>, hour, minute, second)</span><br><span class="line"><span class="comment">// 时</span></span><br><span class="line">fmt.Println(now.Hour())</span><br><span class="line"><span class="comment">// 分</span></span><br><span class="line">fmt.Println(now.Minute())</span><br><span class="line"><span class="comment">// 秒</span></span><br><span class="line">fmt.Println(now.Second())</span><br><span class="line"><span class="comment">// 返回星期</span></span><br><span class="line">fmt.Println(now.Weekday())</span><br><span class="line"><span class="comment">//返回一年中对应的第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br><span class="line"><span class="comment">//返回时区</span></span><br><span class="line">fmt.Println(now.Location())</span><br><span class="line"><span class="comment">// 返回一年中第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br></pre></td></tr></table></figure>

<h4 id="1-3-格式化时间"><a href="#1-3-格式化时间" class="headerlink" title="1.3 格式化时间"></a>1.3 格式化时间</h4><p>Go 语言提供了时间类型格式化函数 <code>Format()</code>，需要注意的是 Go 语言格式化时间模板不是常见的 <code>Y-m-d H:i:s</code>，而是 2006-01-02 15:04:05，也很好记忆(2006 1 2 3 4 5)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2、时间戳与日期字符串相互转化"><a href="#2、时间戳与日期字符串相互转化" class="headerlink" title="2、时间戳与日期字符串相互转化"></a>2、时间戳与日期字符串相互转化</h3><p>时间戳转成日期格式，需要先转成将时间戳转成 <code>time.Time</code> 类型再格式化成日期格式。</p>
<h4 id="2-1-根据秒数、纳秒数返回-time-Time-类型"><a href="#2-1-根据秒数、纳秒数返回-time-Time-类型" class="headerlink" title="2.1 根据秒数、纳秒数返回 time.Time 类型"></a>2.1 根据秒数、纳秒数返回 <code>time.Time</code> 类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">t := time.Unix(now.Unix(),<span class="number">0</span>)    <span class="comment">// 参数分别是：秒数,纳秒数</span></span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<h4 id="2-2-根据指定时间返回-time-Time-类型，使用函数-time-Date"><a href="#2-2-根据指定时间返回-time-Time-类型，使用函数-time-Date" class="headerlink" title="2.2 根据指定时间返回 time.Time 类型，使用函数 time.Date()"></a>2.2 根据指定时间返回 <code>time.Time</code> 类型，使用函数 <code>time.Date()</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"><span class="comment">//根据指定时间返回 time.Time 类型</span></span><br><span class="line"><span class="comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span></span><br><span class="line">t := time.Date(<span class="number">2011</span>, time.Month(<span class="number">3</span>), <span class="number">12</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">0</span>, now.Location())</span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-日期字符串解析成-time-Time-类型"><a href="#2-3-日期字符串解析成-time-Time-类型" class="headerlink" title="2.3 日期字符串解析成 time.Time 类型"></a>2.3 日期字符串解析成 <code>time.Time</code> 类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>), time.Local)</span><br><span class="line">fmt.Println(t)  </span><br><span class="line"><span class="comment">// 输出 2021-01-10 17:28:50 +0800 CST</span></span><br><span class="line"><span class="comment">// time.Local 指定本地时间</span></span><br></pre></td></tr></table></figure>

<p>解析的时候需要特别注意时区的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(time.Now())</span><br><span class="line">fmt.Println(time.Now().Location())</span><br><span class="line">t, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2021-01-10 15:01:02&quot;</span>)</span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-10 17:22:10.951904 +0800 CST m=+0.000094166</span><br><span class="line">Local</span><br><span class="line">2021-01-10 15:01:02 +0000 UTC</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>time.Now()</code> 使用的 CST(中国标准时间)，而 <code>time.Parse()</code> 默认的是 UTC(零时区)，它们相差 8 小时。所以解析时常用 <code>time.ParseInLocation()</code>，可以指定时区。<img src="https://cdn.nlark.com/yuque/0/2021/gif/396745/1610587943191-e1905a90-4157-43d7-8623-c98b46969a36.gif" alt="img"></p>
<h3 id="3、计算、比较日期"><a href="#3、计算、比较日期" class="headerlink" title="3、计算、比较日期"></a>3、计算、比较日期</h3><p>讲到日期的计算就不得不提 time 包提供的一种新的类型 <code>Duration</code>，源码是这样定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="type">int64</span></span><br></pre></td></tr></table></figure>

<p>底层类型是 int64，表示一段时间间隔，单位是 纳秒。</p>
<h4 id="3-1-24小时之内的时间计算"><a href="#3-1-24小时之内的时间计算" class="headerlink" title="3.1 24小时之内的时间计算"></a>3.1 24小时之内的时间计算</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 1小时1分1s之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;1h1m1s&quot;</span>)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"><span class="comment">// 1小时1分1s之前</span></span><br><span class="line">t2, _ := time.ParseDuration(<span class="string">&quot;-1h1m1s&quot;</span>)</span><br><span class="line">m2 := now.Add(t2)</span><br><span class="line">fmt.Println(m2)</span><br><span class="line"><span class="comment">// 3小时之前</span></span><br><span class="line">t3, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">m3 := now.Add(t3 * <span class="number">3</span>)</span><br><span class="line">fmt.Println(m3)</span><br><span class="line"><span class="comment">// 10 分钟之后</span></span><br><span class="line">t4, _ := time.ParseDuration(<span class="string">&quot;10m&quot;</span>)</span><br><span class="line">m4 := now.Add(t4)</span><br><span class="line">fmt.Println(m4)</span><br><span class="line"><span class="comment">// Sub 计算两个时间差</span></span><br><span class="line">sub1 := now.Sub(m3)</span><br><span class="line">fmt.Println(sub1.Hours())   <span class="comment">// 相差小时数</span></span><br><span class="line">fmt.Println(sub1.Minutes()) <span class="comment">// 相差分钟数</span></span><br></pre></td></tr></table></figure>

<p>额外再介绍两个函数 <code>time.Since()</code>、<code>time.Until()</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间与 t 的时间差，返回值是 Duration</span></span><br><span class="line">time.Since(t Time) Duration</span><br><span class="line"><span class="comment">// 返回 t 与当前时间的时间差，返回值是 Duration</span></span><br><span class="line">time.Until(t Time) Duration</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line">fmt.Println(time.Since(m1))</span><br><span class="line">fmt.Println(time.Until(m1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-10 20:41:48.668232 +0800 CST m=+0.000095594</span><br><span class="line">2021-01-10 19:41:48.668232 +0800 CST m=-3599.999904406</span><br><span class="line">1h0m0.000199007s</span><br><span class="line">-1h0m0.000203035s</span><br></pre></td></tr></table></figure>

<h4 id="3-2-24小时之外的时间计算"><a href="#3-2-24小时之外的时间计算" class="headerlink" title="3.2 24小时之外的时间计算"></a>3.2 24小时之外的时间计算</h4><p>涉及到一天以外的时间计算，就需要用到 <code>time.AddDate()</code>，函数原型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> AddDate(years <span class="type">int</span>, months <span class="type">int</span>, days <span class="type">int</span>) Time</span><br></pre></td></tr></table></figure>

<p>比如想知道 一年一个月零一天 之后的时间，就可以这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></table></figure>

<p>再比如，想获得 2 天之前时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-2</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-日期比较"><a href="#3-3-日期比较" class="headerlink" title="3.3 日期比较"></a>3.3 日期比较</h4><p>日期的比较总共有三种：之前、之后和相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之后，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br><span class="line"><span class="comment">// 比较时间是否相等，相等返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 1小时之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;1h&quot;</span>)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line">fmt.Println(m1.After(now))</span><br><span class="line">fmt.Println(now.Before(m1))</span><br><span class="line">fmt.Println(now.Equal(m1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-10 21:00:44.409785 +0800 CST m=+0.000186800</span><br><span class="line">2021-01-10 22:00:44.409785 +0800 CST m=+3600.000186800</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="4、常见例子"><a href="#4、常见例子" class="headerlink" title="4、常见例子"></a>4、常见例子</h3><p>下面列举一些常见的例子和函数封装。</p>
<h4 id="4-1-日期格式-转-时间戳"><a href="#4-1-日期格式-转-时间戳" class="headerlink" title="4.1 日期格式 转 时间戳"></a>4.1 日期格式 转 时间戳</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeStr2Time</span><span class="params">(fmtStr,valueStr, locStr <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    loc := time.Local</span><br><span class="line">    <span class="keyword">if</span> locStr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        loc, _ = time.LoadLocation(locStr) <span class="comment">// 设置时区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    t, _ := time.ParseInLocation(fmtStr, valueStr, loc)</span><br><span class="line">    <span class="keyword">return</span> t.Unix()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-获取当前时间日期格式"><a href="#4-2-获取当前时间日期格式" class="headerlink" title="4.2 获取当前时间日期格式"></a>4.2 获取当前时间日期格式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentFormatStr</span><span class="params">(fmtStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Now().Format(fmtStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-时间戳-to-日期格式"><a href="#4-3-时间戳-to-日期格式" class="headerlink" title="4.3 时间戳 to 日期格式"></a>4.3 时间戳 to 日期格式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sec2TimeStr</span><span class="params">(sec <span class="type">int64</span>, fmtStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Unix(sec, <span class="number">0</span>).Format(fmtStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go-regexp正则"><a href="#Go-regexp正则" class="headerlink" title="Go-regexp正则"></a>Go-regexp正则</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;My email is ccmouse@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	compile := regexp.MustCompile(<span class="string">`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`</span>)</span><br><span class="line">	match := compile.FindString(text)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go存储基础-—-文件-IO-操作"><a href="#Go存储基础-—-文件-IO-操作" class="headerlink" title="Go存储基础 — 文件 IO 操作"></a>Go存储基础 — 文件 IO 操作</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059277-22fc4174-ea19-40a1-96a9-dc837804eaff.png" alt="img"></p>
<h2 id="两大-IO-分类"><a href="#两大-IO-分类" class="headerlink" title="两大 IO 分类"></a>两大 IO 分类</h2><p>计算的体系架构，CPU，内存，网络，IO。那么 IO 是什么呢？一般理解成 Input、Output 的缩写，通俗话就是输入输出的意思。</p>
<p>IO 分为网络和存储 IO 两种类型（<strong>其实网络 IO 和磁盘 IO 在 Go 里面有着根本性区别</strong>）。网络 IO 对应的是网络数据传输过程，网络是分布式系统的基石，通过网络把离散的物理节点连接起来，形成一个有机的系统。</p>
<p>存储 IO 对应的就是数据存储到物理介质的过程，通常物理介质对应的是磁盘，磁盘上一般会分个区，然后在上面格式化个文件系统出来，所以普通程序员最常看见的是文件 IO 的形式。</p>
<p>在 Golang 里可以归类出两种读写文件的方式：</p>
<ol>
<li>标准库封装：操作对象 <code>File</code>;</li>
<li>系统调用 ：操作对象 <code>fd</code>;</li>
</ol>
<h2 id="读写数据要素"><a href="#读写数据要素" class="headerlink" title="读写数据要素"></a>读写数据要素</h2><p>文件的读写最核心的要素是什么？</p>
<p>通俗来讲：读文件，就是把磁盘上的文件的<strong>特定位置</strong>的数据读到<strong>内存的 buffer</strong> 。写文件，就是把<strong>内存 buffer</strong> 的数据写到磁盘的文件的<strong>特定位置</strong>。</p>
<p>这里注意到两个关键词：</p>
<ol>
<li>特定位置；</li>
<li>内存 buffer；</li>
</ol>
<p><strong>特定位置怎么理解？怎么指定所谓的</strong><code>特定位置</code><strong>？</strong></p>
<p>很简单，用 <code>[ offset, length ]</code> 这两个参数就能标识一段位置。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059263-970193ad-ab90-4abd-8c62-bf040410e14d.png" alt="img"></p>
<p>也就是 IO 偏移和长度，Offset 和 Length。</p>
<p><strong>内存 buffer 怎么理解？</strong></p>
<p>归根结底，文件的数据和谁直接打交道？<strong>内存</strong>，写的时候是从内存写到磁盘文件的，读的时候是从磁盘文件读到内存的。</p>
<p>本质上，下面的 IO 函数都离不开 Offset，Length，buffer 这三个要素。</p>
<h2 id="标准库封装"><a href="#标准库封装" class="headerlink" title="标准库封装"></a>标准库封装</h2><p>Go 对文件进行读写非常简单，因为 Go 已经封装了一个非常便捷的使用接口，位于标准库 os 中。Go 标准库对文件 IO 的封装也就是 Go 推荐对文件进行 IO 时使用的操作方式。</p>
<h3 id="打开文件（Open）"><a href="#打开文件（Open）" class="headerlink" title="打开文件（Open）"></a>打开文件（Open）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>Open 文件之后，获取到一个句柄，也就是 <code>File</code> 结构，之后对文件的读写都是基于 <code>File</code> 结构之上进行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    *file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件读写只需要针对这个句柄结构体做操作即可。</p>
<p>另外有一点隐藏起来的知识点必须要提一下：<strong>偏移</strong>。也就是最开始强调的读写 3 要素之一的 Offset 。打开（<code>Open</code>）文件的时候，文件当前偏移量默认设置为 0，也就是说 IO 的起始位置就是文件的最开头。举个例子，如果这个时候，写 4K 的数据到文件，那么就是写 [0, 4K] 这个位置的数据，如果之前这上面已经有数据了，那么就会是覆盖写。</p>
<p>除非 <code>Open</code> 文件的时候指定 <code>O_APPEND</code> 选项，偏移量会设置为文件末尾，那么 IO 都是从文件末尾开始。</p>
<h3 id="文件写操作（Write）"><a href="#文件写操作（Write）" class="headerlink" title="文件写操作（Write）"></a>文件写操作（Write）</h3><p>文件 <code>File</code> 句柄对象有两个写方法：</p>
<p>第一种：写一个 buffer 到文件 ，使用文件当前偏移</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该写操作会导致文件偏移量的增加。</strong></p>
<p>第二种：从指定文件偏移，写入 buffer 到文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该写操作不会更新文件偏移量</strong></p>
<h3 id="文件读操作（Read）"><a href="#文件读操作（Read）" class="headerlink" title="文件读操作（Read）"></a>文件读操作（Read）</h3><p>和写对应，文件 <code>File</code> 句柄对象有两个读方法：</p>
<p>第一种：从文件当前偏移读一个 buffer 的数据上来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该读操作会导致文件偏移量的增加。</strong></p>
<p>第二种：从指定文件偏移，读一个 buffer 大小的数据上来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该读操作不会更新文件偏移量</strong></p>
<h3 id="指定偏移量（Seek）"><a href="#指定偏移量（Seek）" class="headerlink" title="指定偏移量（Seek）"></a>指定偏移量（Seek）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>这个句柄方法允许用户指定文件的偏移位置。这个很容易理解，举个例子，文件刚开始是 0 字节，写 1M 的数据下去，大小变成 1M，Offset 往后挪 1M ，默认就是往后挪。</p>
<p>现在 Seek 方法允许把写的偏移定位到任意位置，可以就可以从任意地方覆盖写入数据。</p>
<p>所以在 Go 里面，文件 IO 非常简单，先 Open 一个文件，拿到 <code>File</code> 句柄，然后就可以使用这个句柄 Write ，Read，Seek 就能进行 IO 了。</p>
<h2 id="底层的原理"><a href="#底层的原理" class="headerlink" title="底层的原理"></a>底层的原理</h2><p>Go 的标准库 <code>os</code> 提供了极其方便的封装，深入最原始的本质可以发现最核心的东西：<strong>系统调用</strong>。</p>
<p>Go 标准库的文件存储 IO 就是基于系统调用之上的。可以稍微跟一下 <code>os.OpenFile</code> 的调用：</p>
<p>os 库的 <code>OpenFile</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := openFileNolog(name, flag, perm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微看下 <code>openFileNolog</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openFileNolog</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> e <span class="type">error</span></span><br><span class="line">        r, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;darwin&quot;</span> &amp;&amp; e == syscall.EINTR &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;open&quot;</span>, name, e&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFile(<span class="type">uintptr</span>(r), name, kindOpenFile), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>syscall.Open</code> ，这个函数获取到一个整数，也就是在 c 语言里最常见的 fd 句柄，而 <code>File</code> 结构体则仅仅是基于这个的一层封装而已。</p>
<p><strong>思考下，为什么会有标准库封装这一层存在？</strong></p>
<p><strong>划重点：为了屏蔽操作系统的区别</strong>，使用这个标准库的所有操作都是跨平台的。换句话说，如果是特殊操作系统才有的特性，那么在 os 库里就找不到对应封装的 IO 操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059293-a7135eb0-0608-41ad-8262-cc658863c19d.png" alt="img"></p>
<p>那么怎么使用系统调用？</p>
<p>直接使用 syscall 库，也就是系统调用。从名字也能看出来，系统调用是和操作系统强相关的，因为是操作系统提供的调用接口，所以系统调用会因为操作系统不同而导致不同的特性，不同的接口。</p>
<p>所以，如果直接使用 syscall 库来使用系统调用，那么需要自己来承受系统带来的兼容性问题。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在 syscall 里有一层最基础的封装：</p>
<h3 id="文件-Open"><a href="#文件-Open" class="headerlink" title="文件 Open"></a>文件 Open</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="type">string</span>, mode <span class="type">int</span>, perm <span class="type">uint32</span>)</span></span> (fd <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<h3 id="文件-Read"><a href="#文件-Read" class="headerlink" title="文件 Read"></a>文件 Read</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) <span class="function"><span class="keyword">func</span> <span class="title">Pread</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>, offset <span class="type">int64</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>文件读有两个接口，一个 <code>Read</code> 是从<strong>当前默认偏移</strong>读一个 buffer 数据，<code>Pread</code> 接口则是从指定位置读数据的接口。</p>
<p>思考一个问题：<code>Pread</code> 从效果上来讲等于 <code>Seek</code> 和 <code>Read</code> 组合起来使用，那么是否可以认为 <code>Pread</code> 就可以被 <code>Seek</code> + <code>Read</code> 替代呢？</p>
<p>不行！根本原因在于 <code>Seek</code> + <code>Read</code> 是在用户层就是两步操作，而 <code>Pread</code> 虽然是 <code>Seek</code> + <code>Read</code> 的效果，但是操作系统给到用户的语义是：<code>Pread</code> 是一个原子操作。还有一个重要区别，<code>Pread</code> 不会改变当前文件的偏移量（普通的 <code>Read</code> 调用会更新偏移量）。</p>
<p><strong>所以，总结下，</strong><code>**Pread**</code> <strong>和顺序调用</strong> <code>**Seek**</code> <strong>后调用</strong> <code>**Read**</code>  <strong>有两点重要区别：</strong></p>
<ol>
<li><code>Pread</code> 对用户提供的语义是原子操作，在调用 <code>Pread</code> 时，无法中断 <code>Seek</code> 和 <code>Read</code> 操作；</li>
<li><code>Pread</code> 调用不会更新当前文件偏移量；</li>
</ol>
<h3 id="文件-Write"><a href="#文件-Write" class="headerlink" title="文件 Write"></a>文件 Write</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) <span class="function"><span class="keyword">func</span> <span class="title">Pwrite</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>, offset <span class="type">int64</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>文件写对应也是有两种接口，<code>Wrtie</code> 和 <code>Pwrite</code> 分别是对应 <code>Read</code> 和 <code>Pread</code> 。同样的，<code>Pwrite</code> 作用上也是相当于先调用 <code>Seek</code>  再调用 <code>Write</code> ，但是同样的也有<strong>两点不同</strong>：</p>
<ol>
<li><code>Pwrite</code>  完成 <code>Seek</code> 和 <code>Write</code> 对外是原子操作的语义；</li>
<li><code>Pwrite</code> 调用不会更新当前文件偏移量；</li>
</ol>
<h3 id="文件-Seek"><a href="#文件-Seek" class="headerlink" title="文件 Seek"></a>文件 Seek</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seek</span><span class="params">(fd <span class="type">int</span>, offset <span class="type">int64</span>, whence <span class="type">int</span>)</span></span> (off <span class="type">int64</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>这个函数调用允许用户指定偏移（这个会影响到 <code>Read</code> 和 <code>Write</code> 读写的位置）。一般来说，每个打开文件都有一个相关联的“当前文件偏移量”（ current file offset ）。读（<code>Read</code>）、写（<code>Write</code>）操作都是从<strong>当前文件偏移量处</strong>开始，并且 <code>Read</code> 和 <code>Write</code> 会导致偏移量增加，增加量就是所读写的字节数。</p>
<p><strong>小结一下</strong>：Go核心的 Open，Read，Write，Seek 几个系统调用，可以发现一个明显不同与标准 IO 库的区别：<strong>系统调用操作对象是一个整数句柄</strong>。<code>Open</code> 文件得到一个整数 fd，之后的所有 IO 都是针对这个 fd 来操作的。这个明显和标准库不同，os 标准库 OpenFile 得到的是一个 <code>File</code> 结构体，所有的 IO 也是针对这个结构体的。</p>
<h2 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h2><p>那么究竟封装的层次一般是什么样的呢， Unix 编程里面开篇就有一张如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059414-c1855d9c-8b70-473a-83ac-7889f7e0c8a9.png" alt="img"></p>
<p>这张图就非常形象的讲明白了整个 Unix 体系结构。</p>
<ul>
<li><p>内核是最核心的实现，包括了和 IO 设备，硬件交互等功能。与内核紧密的一层是内核提供给外部调用的系统调用，系统调用提供了用户态到内核态调用的一个通道；</p>
</li>
<li><p>对于系统调用，各个语言的标准库会有一些封装，比如 <strong>C 语言的 libc 库，Go 语言的 os ，syscall 库都是类似的地位，这个就是所谓的公共库</strong>。这层封装的作用最主要是简化普通程序员使用效率，并且屏蔽系统细节，为跨平台提供基础（同样的，为了跨平台的特性，可能会阉割很多不兼容的功能，所以才会有直接调用系统掉调用的需求）；</p>
</li>
<li><p>当然，右上角还看到一个缺口，应用程序除了可以使用公共函数库，<strong>其实是可以直接调用系统调用的，但是由此带来的复杂性又应用自己承担</strong>。这种需求也是很常见的，标准库封装了通用的东西，同样割舍了很多系统调用的功能，这种情况下，只能通过系统调用来获取；</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>IO 大类分为网络 IO 和磁盘 IO，IO 对文件来说就是读写操作，写的时候<strong>数据从内存到磁盘</strong>，读的时候<strong>数据从磁盘到内存</strong>；</p>
</li>
<li><p>Go 文件 IO 最常用的是 os 库，使用 Go 封装的标准库，<code>os.OpenFile</code> 打开，<code>File.Write</code>，<code>File.Read</code> 进行读写，操作对象都是 <code>File</code> 结构体；</p>
</li>
<li><p>Go 标准库对 IO 的封装是为了屏蔽复杂的系统调用，提供跨平台的使用姿势。然后单独提供 <code>syscall</code> 库，让程序员自我决策使用要使用更丰富的系统调用功能，当然后果自负；</p>
</li>
<li><p>Go 标准库 IO 操作对象是 <code>File</code> ，系统调用 IO 操作对象是 fd（非负整数）。</p>
</li>
<li><p><code>Open</code> 文件默认当前偏移量是 0 （文件最开始），加上 <code>O_APPEND</code> 参数之后偏移量会是文件末尾。通过 Seek 调用可以任意指定文件偏移，从而影响文件 IO 的位置；</p>
</li>
<li><p><code>Read</code>，<code>Write</code> 函数只有 buffer （buffer 有长度），偏移则使用当前文件偏移量；</p>
</li>
<li><p><code>Pread</code>，<code>Pwrite</code> 的系统调用效果等同于 <code>Seek</code> 偏移量然后 <code>Read</code>，<code>Write</code>，但是又大有不同。对外语义是原子操作，并且不更新当前文件偏移量；</p>
</li>
</ol>
<h1 id="Go-文件读写操作"><a href="#Go-文件读写操作" class="headerlink" title="Go-文件读写操作"></a>Go-文件读写操作</h1><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容进行追加*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*关闭文件流*/</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">/*读取*/</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*写入文件*/</span></span><br><span class="line">	str := <span class="string">&quot;hello FCC您好！！！\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件内容拷贝至新文件"><a href="#文件内容拷贝至新文件" class="headerlink" title="文件内容拷贝至新文件"></a>文件内容拷贝至新文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件1的内容拷贝到文件2*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file1Path := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file2Path := <span class="string">&quot;D:\\fcofficework\\DNS\\2.txt&quot;</span></span><br><span class="line">	data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read file err=%v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = ioutil.WriteFile(file2Path, data, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;write file err=%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断文件或者目录是否存在"><a href="#判断文件或者目录是否存在" class="headerlink" title="判断文件或者目录是否存在"></a>判断文件或者目录是否存在</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断文件以及目录是否存在*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前文件存在！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前文件不存在！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := <span class="string">&quot;D:\\fcofficework\\2.txt&quot;</span></span><br><span class="line">	PathExists(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件的拷贝*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>, srcFileName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	srcFile, err := os.Open(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	reader := bufio.NewReader(srcFile)</span><br><span class="line"></span><br><span class="line">	dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	writer := bufio.NewWriter(dstFile)</span><br><span class="line">	<span class="keyword">defer</span> dstFile.Close()</span><br><span class="line">	<span class="keyword">return</span> io.Copy(writer, reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;D:\\Photos\\Datapicture\\mmexport1530688562488.jpg&quot;</span></span><br><span class="line">	dstFile := <span class="string">&quot;D:\\Photos\\1.jpg&quot;</span></span><br><span class="line">	_, err := CopyFile(dstFile, srcFile)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝完成！&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝失败，err=&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件并统计文件中字符的个数"><a href="#读取文件并统计文件中字符的个数" class="headerlink" title="读取文件并统计文件中字符的个数"></a>读取文件并统计文件中字符的个数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统计文件的字符个数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/*英文的个数*/</span></span><br><span class="line">	ChCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*数字的个数*/</span></span><br><span class="line">	NumCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*空格的个数*/</span></span><br><span class="line">	SpaceCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*其他字符的个数*/</span></span><br><span class="line">	OtherCount <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">var</span> count CharCount</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">				<span class="keyword">fallthrough</span></span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">				count.ChCount++</span><br><span class="line">			<span class="keyword">case</span> v == <span class="string">&#x27; &#x27;</span> || v == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">				count.SpaceCount++</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">				count.NumCount++</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				count.OtherCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符的个数为：%v 数字的个数为：%v 空格的个数为：%v 其他字符的个数为：%v&quot;</span>,</span><br><span class="line">		count.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种读取文件的方式"><a href="#三种读取文件的方式" class="headerlink" title="三种读取文件的方式"></a>三种读取文件的方式</h3><h4 id="通过os读取"><a href="#通过os读取" class="headerlink" title="通过os读取"></a>通过os读取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;d:\\Photos\\Screenshots\\暗物质\\IMG_20180927_194619.jpg&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v&quot;</span>, file)</span><br><span class="line">	err1 := file.Close()</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;close file err = &quot;</span>, err1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲式读取文件"><a href="#缓冲式读取文件" class="headerlink" title="缓冲式读取文件"></a>缓冲式读取文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*缓冲式读取文件*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;d:\\Photos\\Screenshots\\暗物质\\IMG_20180927_194619.jpg&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件读取结束!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过ioutil读取"><a href="#通过ioutil读取" class="headerlink" title="通过ioutil读取"></a>通过ioutil读取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file := <span class="string">&quot;D:\\fcofficework\\DNS\\authorized_keys&quot;</span></span><br><span class="line">	content, err := ioutil.ReadFile(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read file err=%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, <span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件写入的案例"><a href="#文件写入的案例" class="headerlink" title="文件写入的案例"></a>文件写入的案例</h3><h4 id="在文件写入内容，没有则重新创建"><a href="#在文件写入内容，没有则重新创建" class="headerlink" title="在文件写入内容，没有则重新创建"></a>在文件写入内容，没有则重新创建</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在文件写入内容，没有文件则重新创建*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello world\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在已存在文件清空原有内容重新写入"><a href="#在已存在文件清空原有内容重新写入" class="headerlink" title="在已存在文件清空原有内容重新写入"></a>在已存在文件清空原有内容重新写入</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容重新写入*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello FCC\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在已存在文件清空原有内容进行追加"><a href="#在已存在文件清空原有内容进行追加" class="headerlink" title="在已存在文件清空原有内容进行追加"></a>在已存在文件清空原有内容进行追加</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容进行追加*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello FCC您好！！！\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析命令行参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;命令行参数有：&quot;</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;args[%v]=%v\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析命令行参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名，默认为空&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为空&quot;</span>)</span><br><span class="line">	<span class="comment">/*转换*/</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user=%v pwd=%v host=%v port=%v&quot;</span>, user, pwd, host, port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go-json序列化"><a href="#Go-json序列化" class="headerlink" title="Go-json序列化"></a>Go-json序列化</h1><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>     <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span>  <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">float64</span> <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span>  <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结构体序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMinsterStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	monster := Monster&#123;</span><br><span class="line">		Name:     <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">		Age:      <span class="number">500</span>,</span><br><span class="line">		Birthday: <span class="string">&quot;2011-11-11&quot;</span>,</span><br><span class="line">		Sal:      <span class="number">8000.0</span>,</span><br><span class="line">		Skill:    <span class="string">&quot;如意七十二变&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Map序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Map序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapSerlizer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">	a[<span class="string">&quot;age&quot;</span>] = <span class="number">10</span></span><br><span class="line">	a[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;火云洞&quot;</span></span><br><span class="line">	data, err := json.Marshal(a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;monster序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切片序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceSerlizer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;TGH&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;19&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;FCC&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;18&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;address&quot;</span>] = [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;华府&quot;</span>, <span class="string">&quot;影视帝国&quot;</span>&#125;</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;切片序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本数据类型序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FloatSerlize</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num1 <span class="type">float64</span> = <span class="number">245.56</span></span><br><span class="line">	data, err := json.Marshal(num1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;基本数据类型序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	NewMinsterStruct()</span><br><span class="line">	MapSerlizer()</span><br><span class="line">	SliceSerlizer()</span><br><span class="line">	FloatSerlize()</span><br><span class="line">&#125;</span><br><span class="line">Map序列化后=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">500</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;2011-11-11&quot;</span>,<span class="string">&quot;sal&quot;</span>:<span class="number">8000</span>,<span class="string">&quot;skill&quot;</span>:<span class="string">&quot;如意七十二变&quot;</span>&#125;</span><br><span class="line">monster序列化后=&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;火云洞&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">10</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>&#125;</span><br><span class="line">切片序列化后=[&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;19&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;TGH&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:[<span class="string">&quot;华府&quot;</span>,<span class="string">&quot;影视帝国&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;FCC&quot;</span>&#125;]</span><br><span class="line">基本数据类型序列化后=<span class="number">245.56</span></span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>     <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span>  <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">float64</span> <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span>  <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;孙悟空\&quot;,\&quot;age\&quot;:500,\&quot;birthday\&quot;:\&quot;2011-11-11\&quot;,\&quot;sal\&quot;:8000,\&quot;skill\&quot;:\&quot;如意七十二变\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化后monster：%v\n&quot;</span>, monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshallMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;address\&quot;:\&quot;火云洞\&quot;,\&quot;age\&quot;:10,\&quot;name\&quot;:\&quot;牛魔王\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化Map后：%v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:\&quot;19\&quot;,\&quot;name\&quot;:\&quot;TGH\&quot;&#125;,&quot;</span> +</span><br><span class="line">		<span class="string">&quot;&#123;\&quot;address\&quot;:[\&quot;华府\&quot;,\&quot;影视帝国\&quot;],\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;FCC\&quot;&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化Slice后：%v\n&quot;</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unmarshalStruct()</span><br><span class="line">	unmarshallMap()</span><br><span class="line">	unmarshalSlice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">反序列化后monster：&#123;孙悟空 <span class="number">500</span> <span class="number">2011</span><span class="number">-11</span><span class="number">-11</span> <span class="number">8000</span> 如意七十二变&#125; </span><br><span class="line">反序列化Map后：<span class="keyword">map</span>[address:火云洞 age:<span class="number">10</span> name:牛魔王] </span><br><span class="line">反序列化Slice后：[<span class="keyword">map</span>[address:北京 age:<span class="number">19</span> name:TGH] <span class="keyword">map</span>[address:[华府 影视帝国] age:<span class="number">18</span> name:FCC]]</span><br></pre></td></tr></table></figure>

<h1 id="Go-HTTP包的使用"><a href="#Go-HTTP包的使用" class="headerlink" title="Go-HTTP包的使用"></a>Go-HTTP包的使用</h1><p>Web是基于http协议的一个服务，Go语言里面提供了一个完善的net&#x2F;http包，通过http包可以很方便的搭建起来一个可以运行的Web服务。同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。</p>
<h2 id="http包建立Web服务器"><a href="#http包建立Web服务器" class="headerlink" title="http包建立Web服务器"></a>http包建立Web服务器</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello golang!&quot;</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码，build之后，然后执行web.exe,这个时候其实已经在8080端口监听http链接请求了。</p>
<p>在浏览器输入<code>http://localhost:8080</code></p>
<p>可以看到浏览器页面输出了<code>Hello golang!</code></p>
<p>浏览器输入地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/?url_long=var1&amp;url_long=var2</span><br></pre></td></tr></table></figure>

<p>可以看看浏览器输出的是什么</p>
<p>看到上面的代码，要编写一个Web服务器很简单，只要调用http包的两个函数就可以了。</p>
<h2 id="使用http包请求页面"><a href="#使用http包请求页面" class="headerlink" title="使用http包请求页面"></a>使用http包请求页面</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httputil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	request, err := http.NewRequest(http.MethodGet, <span class="string">&quot;http://www.imooc.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Redirect:&quot;</span>, req)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="comment">//resp, err := http.DefaultClient.Do(request)</span></span><br><span class="line">	<span class="comment">//resp, err := http.Get(&quot;http://www.imooc.com&quot;)</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行打印出HTML内容</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1603443525745-bf6b18f4-8ee9-45a8-8e21-67531abdf88b.png" alt="img"></p>
<h1 id="net-http包的坑——i-o-timeout"><a href="#net-http包的坑——i-o-timeout" class="headerlink" title="net&#x2F;http包的坑——i&#x2F;o timeout"></a>net&#x2F;http包的坑——i&#x2F;o timeout</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>来看一段日常代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr = &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">        Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">            conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body := bytes.NewReader(data)</span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">    req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Transport: tr,</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做的事情，比较简单，就是循环去请求<a href="http://www.baidu.com/">http://www.baidu.com/</a>, 然后等待响应。</p>
<p>看上去貌似没啥问题吧。</p>
<p>代码跑起来，也确实能正常收发消息。</p>
<p>但是这段代码跑一段时间，就会出现i&#x2F;o timeout的报错。</p>
<p>这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，这边对代码做了简化。</p>
<p>实际生产中发生的现象是，golang服务在发起http调用时，虽然<code>http.Transport</code>设置了3s超时，会偶发出现i&#x2F;o timeout的报错。</p>
<p>但是查看下游服务的时候，发现下游服务其实100ms就已经返回了。</p>
<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351380664-f90f9eac-6fcd-4446-8a4e-d08df02ab269.png" alt="img"></p>
<p>五层网络协议对应的消息体变化分析</p>
<p>就很奇怪了，明明服务端显示处理耗时才100ms，且客户端超时设的是3s, 怎么就出现超时报错i&#x2F;o timeout呢？</p>
<p>这里推测有两个可能。</p>
<ul>
<li>因为服务端打印的日志其实只是服务端应用层打印的日志。但客户端应用层发出数据后，中间还经过客户端的传输层，网络层，数据链路层和物理层，再经过服务端的物理层，数据链路层，网络层，传输层到服务端的应用层。服务端应用层处耗时100ms，再原路返回。那剩下的3s-100ms可能是耗在了整个流程里的各个层上。比如网络不好的情况下，传输层TCP使劲丢包重传之类的原因。</li>
<li>网络没问题，客户端到服务端链路整个收发流程大概耗时就是100ms左右。客户端处理逻辑问题导致超时。</li>
</ul>
<p>一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了，不死心就抓个包看下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351368734-c0656d47-9e8b-41c1-bdbb-115362ceebe8.png" alt="img"></p>
<p>抓包结果</p>
<p>分析下，从刚开始三次握手（画了红框的地方）。</p>
<p>到最后出现超时报错i&#x2F;o timeout（画了蓝框的地方）。</p>
<p>从time那一列从7到10，确实间隔3s。而且看右下角的蓝框，是51169端口发到80端口的一次Reset连接。</p>
<p>80端口是服务端的端口。换句话说就是客户端3s超时主动断开链接的。</p>
<p>但是再仔细看下第一行三次握手到最后客户端超时主动断开连接的中间，其实有非常多次HTTP请求。</p>
<p>回去看代码设置超时的方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">    Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">        conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这里的3s超时，其实是在建立连接之后开始算的，而不是单次调用开始算的超时。</p>
<p>看注释里写的是</p>
<p>SetDeadline sets the read and write deadlines associated with theconnection.</p>
<h3 id="超时原因"><a href="#超时原因" class="headerlink" title="超时原因"></a>超时原因</h3><p>大家知道HTTP是应用层协议，传输层用的是TCP协议。</p>
<p>HTTP协议从1.0以前，默认用的是短连接，每次发起请求都会建立TCP连接。收发数据。然后断开连接。</p>
<p>TCP连接每次都是三次握手。每次断开都要四次挥手。</p>
<p>其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。</p>
<p>于是乎，HTTP协议从1.1之后就默认使用长连接。具体相关信息可以看之前的<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484204&idx=1&sn=0e83aabb2a48570b5bec563a777f4d26&scene=21#wechat_redirect">这篇文章</a>。</p>
<p>那么golang标准库里也兼容这种实现。</p>
<p>通过建立一个连接池，针对每个域名建立一个TCP长连接，比如<a href="http://baidu.com和http//golang.com%E5%B0%B1%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9F%9F%E5%90%8D%E3%80%82">http://baidu.com和http://golang.com就是两个不同的域名。</a></p>
<p>第一次访问<a href="http://baidu.com域名的时候会建立一个连接,用完之后放到空闲连接池里,下次再要访问http//baidu.com%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E9%87%8D%E6%96%B0%E4%BB%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%87%8C%E6%8A%8A%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%8D%9E%E5%87%BA%E6%9D%A5%E5%A4%8D%E7%94%A8%E3%80%82">http://baidu.com域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问http://baidu.com的时候会重新从连接池里把这个连接捞出来复用。</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351347346-43a1b64f-2a30-46d4-8fbb-0e201084f4bd.png" alt="img"></p>
<p>复用长连接</p>
<p>为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应一个读goroutine和一个写goroutine。正因为是同一个域名，所以最后才会泄漏3个goroutine，如果不同域名的话，那就会泄漏1+2*N个协程，N就是域名数。</p>
<p>假设第一次请求要100ms，每次请求完<a href="http://baidu.com后都放入连接池中,下次继续复用,重复29次,耗时2900ms./">http://baidu.com后都放入连接池中，下次继续复用，重复29次，耗时2900ms。</a></p>
<p>第30次请求的时候，连接从建立开始到服务返回前就已经用了3000ms，刚好到设置的3s超时阈值，那么此时客户端就会报超时i&#x2F;o timeout。</p>
<p>虽然这时候服务端其实才花了100ms，但耐不住前面29次加起来的耗时已经很长。</p>
<p>也就是说只要通过<code>http.Transport</code>设置了<code>err = conn.SetDeadline(time.Now().Add(time.Second * 3))</code>，并且用了长连接，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，程序会报超时错误。</p>
<h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。</p>
<p>另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。</p>
<p>基于这两点，改一下代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr = &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">        <span class="comment">// 下面的代码被干掉了</span></span><br><span class="line">        <span class="comment">//Dial: func(netw, addr string) (net.Conn, error) &#123;</span></span><br><span class="line">        <span class="comment">//  conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时</span></span><br><span class="line">        <span class="comment">//  if err != nil &#123;</span></span><br><span class="line">        <span class="comment">//      return nil, err</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时</span></span><br><span class="line">        <span class="comment">//  if err != nil &#123;</span></span><br><span class="line">        <span class="comment">//      return nil, err</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  return conn, nil</span></span><br><span class="line">        <span class="comment">//&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body := bytes.NewReader(data)</span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">    req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Transport: tr,</span><br><span class="line">        Timeout: <span class="number">3</span>*time.Second,  <span class="comment">// 超时加在这里，是每次调用的超时</span></span><br><span class="line">    &#125;</span><br><span class="line">    res, err := client.Do(req) </span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释会发现，改动的点有两个</p>
<ul>
<li><code>http.Transport</code>里的建立连接时的一些超时设置干掉了。</li>
<li>在发起http请求的时候会场景<code>http.Client</code>，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Timeout specifies a time limit forrequestsmade by this Client.</span><br></pre></td></tr></table></figure>

<p>到这里，代码就改好了，实际生产中问题也就解决了。</p>
<p>实例代码里，如果拿去跑的话，其实还会下面的错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get http://www.baidu.com/: EOF</span><br></pre></td></tr></table></figure>

<p>这个是因为调用得太猛了，<a href="http://www.baidu.com那边主动断开的连接,可以理解为一个限流措施,目的是为了保护服务器,毕竟每个人都像这么搞,服务器是会炸的.../">http://www.baidu.com那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，毕竟每个人都像这么搞，服务器是会炸的。。。</a></p>
<p>解决方案很简单，每次HTTP调用中间加个sleep间隔时间就好。</p>
<p>到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>用的go版本是1.12.7。</p>
<p>从发起一个网络请求开始跟。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> do(req *Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里进入 RoundTrip 逻辑</span></span><br><span class="line">/src/net/http/roundtrip.<span class="keyword">go</span>: <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试去获取一个空闲连接，用于发起 http 连接</span></span><br><span class="line">    pconn, err := t.getConn(treq, cm)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点关注这个函数，返回是一个长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (*persistConn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略了大量逻辑，只关注下面两点</span></span><br><span class="line">    <span class="comment">// 有空闲连接就返回</span></span><br><span class="line">    pc := &lt;-t.getIdleConnCh(cm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有创建连接</span></span><br><span class="line">    pc, err := t.dialConn(ctx, cm)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。</p>
<p>最后一个上面的代码里有个<code>getConn</code>方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。</p>
<ul>
<li>如果有空闲连接，就拿空闲连接</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:810</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getIdleConnCh(cm connectMethod) <span class="keyword">chan</span> *persistConn &#123;</span><br><span class="line">    <span class="comment">// 返回放空闲连接的chan</span></span><br><span class="line">    ch, ok := t.idleConnCh[key]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有空闲连接，就创建长连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:1357</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">  <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次发起一个http请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个读goroutine和一个写goroutine。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351204844-99fdc650-2c23-4dae-ba04-ba54b561202a.png" alt="img"></p>
<p>读写协程</p>
<p>注意上面代码里的<code>t.dial(ctx, &quot;tcp&quot;, cm.addr())</code>，如果像文章开头那样设置了<code>http.Transport</code>的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>那么这里就会在下面的dial里被执行到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dial(ctx context.Context, network, addr <span class="type">string</span>) (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c, err := t.Dial(network, addr)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用的设置超时，会执行到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> SetDeadline(t time.Time) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.fd.SetDeadline(t)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDeadlineImpl</span><span class="params">(fd *FD, t time.Time, mode <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="type">int64</span>, mode <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置一个定时器事件</span></span><br><span class="line">    rtf = netpollDeadline</span><br><span class="line">    <span class="comment">// 并将事件注册到定时器里</span></span><br><span class="line">    modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个定时器事件，假设时间设了3s，那么这个事件会在3s后发生，然后执行注册事件的逻辑。而这个注册事件就是<code>netpollDeadline</code>。注意这个<code>netpollDeadline</code>，待会会提到。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351188250-1127f116-5af1-4a96-ae6f-c326b52761f5.png" alt="img"></p>
<p>读写协程定时器事件</p>
<p>设置了超时事件，且超时事件是3s后之后，发生。再次期间正常收发数据。一切如常。</p>
<p>直到3s过后，这时候看读goroutine，会等待网络数据返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:1642</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        _, err := pc.br.Peek(<span class="number">1</span>)  <span class="comment">// 阻塞读取服务端返回的数据</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是一直跟代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src/bufio/bufio.<span class="keyword">go</span>: <span class="number">129</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b.fill() </span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> fill() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err := b.rd.Read(b.buf[b.w:])</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/net/http/transport.<span class="keyword">go</span>: <span class="number">1517</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err = pc.conn.Read(p)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /src/net/net.go: 173</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err := c.fd.Read(b)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    n, err = fd.pfd.Read(p)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/internal/poll/fd_unix.<span class="keyword">go</span>: </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> waitRead(isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pd.wait(<span class="string">&#x27;r&#x27;</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> wait(mode <span class="type">int</span>, isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">    <span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到跟到<code>runtime_pollWait</code>，这个可以简单认为是等待服务端数据返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.如果网络正常返回数据就跳出</span></span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.如果有出错情况也跳出</span></span><br><span class="line">        err = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整条链路跟下来，就是会一直等待数据，等待的结果只有两个</p>
<ul>
<li>有可以读的数据</li>
<li>出现报错</li>
</ul>
<p>这里面的报错，又有那么两种</p>
<ul>
<li>连接关闭</li>
<li>超时</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// errClosing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中提到的超时，就是指这里面返回的<code>数字2</code>，会通过下面的函数，转化为<code>ErrTimeout</code>， 而<code>ErrTimeout.Error()</code>其实就是i&#x2F;o timeout。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertErr</span><span class="params">(res <span class="type">int</span>, isFile <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> res &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> errClosing(isFile)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> ErrTimeout <span class="comment">// ErrTimeout.Error() 就是 &quot;i/o timeout&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;unreachable: &quot;</span>, res)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了。上面返回的超时错误，也就是返回2的时候的条件是怎么满足的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得刚刚提到的netpollDeadline吗？</p>
<p>这里面放了定时器3s到点时执行的逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计时器到设定时间点了，触发之前注册函数</span></span><br><span class="line">    f(arg, seq) <span class="comment">// 之前注册的是 netpollDeadline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/runtime/netpoll.<span class="keyword">go</span>: <span class="number">428</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> read &#123;</span><br><span class="line">        pd.rd = <span class="number">-1</span></span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会设置<code>pd.rd=-1</code>，是指<code>poller descriptor.read deadline</code>，含义网络轮询器文件描述符的读超时时间， 在linux里万物皆文件，这里的文件其实是指这次网络通讯中使用到的socket。</p>
<p>这时候再回去看发生超时的条件就是<code>if (mode == &#39;r&#39; &amp;&amp; pd.rd &lt; 0)</code>。</p>
<p>至此。代码里就收到了io timeout的报错。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>不要在<code>http.Transport</code>中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名io timeout报错。</li>
<li>请求的超时在创建<code>client</code>里设置。</li>
</ul>
<h1 id="Go中Unicode相关包"><a href="#Go中Unicode相关包" class="headerlink" title="Go中Unicode相关包"></a>Go中Unicode相关包</h1><h3 id="Go中Unicode相关包-1"><a href="#Go中Unicode相关包-1" class="headerlink" title="Go中Unicode相关包"></a>Go中Unicode相关包</h3><p>Go 语言让复杂的编码问题变得简单很多，极大的减轻了程序员的心智负担。为了方便对 unicode 字符串进行处理，Go 语言标准库提供三个包：unicode、unicode&#x2F;utf8 和 unicode&#x2F;utf16。</p>
<p>这里简单介绍下三个包的功能：</p>
<ul>
<li><p>unicode：unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。</p>
</li>
<li><p>unicode&#x2F;utf8：用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。</p>
</li>
<li><p>unicode&#x2F;utf16：函数比较少，主要是 UTF-16 序列的编码和解码。</p>
</li>
</ul>
<p>Go 中字符串的写法。</p>
<p>在 Go 语言中，字符串字面值有 4 种写法，比如「徐新华」可以这么写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;徐新华&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;\u5F90\u65B0\u534E&quot;</span></span><br><span class="line">s3 := <span class="string">&quot;\U00005F90\U000065B0\U0000534E&quot;</span></span><br><span class="line">s4 := <span class="string">&quot;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&quot;</span></span><br></pre></td></tr></table></figure>

<p>简单来生活就是 \u 紧跟四个十六进制数，\U 紧跟八个十六进制数。其中 \u 或 \U 代表后面是 Unicode 码点。而 \x 紧跟两个十六进制数，这些十六进制不是 Unicode 码点，而是 UTF-8 编码。</p>
<p>下面的代码有利于理解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">`徐新华`</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        buf = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>)</span><br><span class="line">        n   <span class="type">int</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(<span class="string">&quot;字符\tUnicode码点\tUTF-8编码十六进制\tUTF-8编码二进制&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        n = utf8.EncodeRune(buf, r)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q\t%U\t\t%X\t\t%b\n&quot;</span>, r, r, buf[:n], buf[:n])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;\u5F90\u65B0\u534E&quot;</span></span><br><span class="line">    s3 := <span class="string">&quot;\U00005F90\U000065B0\U0000534E&quot;</span></span><br><span class="line">    s4 := <span class="string">&quot;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">    fmt.Println(s4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">字符 Unicode码点 UTF<span class="number">-8</span>编码十六进制 UTF<span class="number">-8</span>编码二进制</span><br><span class="line"><span class="string">&#x27;徐&#x27;</span> U+<span class="number">5</span>F90  E5BE90  [<span class="number">11100101</span> <span class="number">10111110</span> <span class="number">10010000</span>]</span><br><span class="line"><span class="string">&#x27;新&#x27;</span> U+<span class="number">65</span>B0  E696B0  [<span class="number">11100110</span> <span class="number">10010110</span> <span class="number">10110000</span>]</span><br><span class="line"><span class="string">&#x27;华&#x27;</span> U+<span class="number">534</span>E  E58D8E  [<span class="number">11100101</span> <span class="number">10001101</span> <span class="number">10001110</span>]</span><br><span class="line">徐新华</span><br><span class="line">徐新华</span><br><span class="line">徐新华</span><br></pre></td></tr></table></figure>

<p>此外，关于字符串其他方面的处理，比如编码转换等，可以到 <a href="https://pkg.go.dev/golang.org/x/text">https://pkg.go.dev/golang.org/x/text</a> 里找。</p>
<h3 id="大小端问题（Little-endian-和-Big-endian）"><a href="#大小端问题（Little-endian-和-Big-endian）" class="headerlink" title="大小端问题（Little endian 和 Big endian）"></a>大小端问题（Little endian 和 Big endian）</h3><p>一个字符使用多字节存储时，涉及到哪个在前哪个在后。以汉字「徐」为例，Unicode 码点是 5F90，需要用两个字节存储，一个字节是<code>5F</code>，另一个字节是<code>90</code>。存储的时候，<code>5F</code>在前，<code>90</code> 在后，这就是 Big endian 方式；<code>90</code>在前，<code>5F</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头（Big-endian）敲开还是从小头（Little-endian）敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大端方式”（Big endian），第二个字节在前就是”小端方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大1。</p>
<p>如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式；如果头两个字节是 FF FE，就表示该文件采用小端方式。</p>
<p>但从上面关于 UTF-8 编码的说明可以看出，虽然 UTF-8 存在多字节表示一个字符的情况，但顺序是固定的，没有字节序的问题。Unix 系统下，UTF-8 没有任何前置字符，但 Windows 下记事本保存的 UTF-8 文件会带上 BOM（Byte Order Mark），即 EF BB BF 这三个字节。关于这一点，Unicode 之父 Rob Pike 明确说 UTF-8 不需要 BOM，所以一开始 Go 源文件是不允许有 BOM 的，否则编译不通过，不过现在已经可以有了。但建议还是别带 BOM。</p>
<blockquote>
<p>UTF-8 带 BOM 说不是为了区分字节序，而是为了更方便的知晓这是一个 UTF-8 文件。</p>
</blockquote>
<h1 id="Go-标准库之-unsafe-包"><a href="#Go-标准库之-unsafe-包" class="headerlink" title="Go 标准库之 unsafe 包"></a>Go 标准库之 unsafe 包</h1><h2 id="1-unsafe包"><a href="#1-unsafe包" class="headerlink" title="1.  unsafe包"></a>1.  unsafe包</h2><h2 id="1-1-ArbitraryType"><a href="#1-1-ArbitraryType" class="headerlink" title="1.1.  ArbitraryType"></a>1.1.  <code>ArbitraryType</code></h2><p><code>unsafe</code>包下定义了一个<code>ArbitratyType</code>类型，代表了任意的Go表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-Pointer"><a href="#1-2-Pointer" class="headerlink" title="1.2.  Pointer"></a>1.2.  <code>Pointer</code></h2><p><code>Pointer</code>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p><code>Pointer</code>代表了一个指向任意类型的指针，有四种只适用对<code>Pointer</code>而不适用于其他类型的操作。</p>
<ul>
<li><p>任意类型的指针值可以被转换为一个<code>Pointer</code></p>
</li>
<li><p>一个<code>Pointer</code>可以被转换为任意类型的指针值</p>
</li>
<li><p>一个<code>uintptr</code>可以被转换为一个<code>Pointer</code></p>
</li>
<li><p>一个<code>Pointer</code>也可以被转换为一个<code>uintptr</code></p>
</li>
</ul>
<p>因此，<code>Pointer</code>可以跳过类型系统而直接指向任意类型。所以需要十分小心的使用。</p>
<p>关于使用<code>Pointer</code>的规则，不使用这些规则的代码是不可用的，或者在未来是不可用的。</p>
<h3 id="1-2-1-使用Pointer作为中间者将-T1转换为-T2"><a href="#1-2-1-使用Pointer作为中间者将-T1转换为-T2" class="headerlink" title="1.2.1.  使用Pointer作为中间者将*T1转换为*T2"></a>1.2.1.  使用<code>Pointer</code>作为中间者将<code>*T1</code>转换为<code>*T2</code></h3><p>前提是T2的大小不超过T1，而且两者的内存分布相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="type">float64</span>)</span></span> <span class="type">uint64</span> &#123;  <span class="keyword">return</span> *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f))&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-把Pointer转换为uintptr"><a href="#1-2-2-把Pointer转换为uintptr" class="headerlink" title="1.2.2.  把Pointer转换为uintptr"></a>1.2.2.  把<code>Pointer</code>转换为<code>uintptr</code></h3><p>把<code>Pointer</code>转换为<code>uintptr</code>将产生一个指向类型值的<code>int</code>变量。常用来打印一个<code>uintptr</code>。</p>
<p>将<code>uintptr</code>转换为<code>Pointer</code>是不可用的。</p>
<p>因为<code>uintptr</code>是一个整数值，而不是引用。就是说<code>uintptr</code>和指针没有任何关系。可以说是将<code>Pointer</code>指向的地址的值返回给<code>uintptr</code>，即使<code>uintptr</code>中的值对应的地址的对象更新了或者删除了，<code>uintptr</code>也不会改变。</p>
<h3 id="1-2-3-把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算"><a href="#1-2-3-把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算" class="headerlink" title="1.2.3.  把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算"></a>1.2.3.  把<code>Pointer</code>转为<code>uintptr</code>再转换回<code>Pointer</code>，其中带有<code>uintptr</code>数值运算</h3><p>如果<code>Pointer</code>指向一个分配的对象，那么如下转换可以把<code>Pointer</code>指针向后移动。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p = unsafe.Pointer(<span class="type">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure>

<p>最常用的是指向结构体中不同字段或者数组中的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// equivalent to f := unsafe.Pointer(&amp;s.f)</span></span><br><span class="line"> f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line"> <span class="comment">// equivalent to e := unsafe.Pointer(&amp;x[i])</span></span><br><span class="line"> e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x[<span class="number">0</span>])) + i*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>这可以用来向前或向后移动指针，通过加或者减<code>offset</code>。指针移动之后，也应该指向该内存范围中。</p>
<p>将<code>Pointer</code>移动超过其对象的原始内存分配范围是不可用的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: end points outside allocated space.</span></span><br><span class="line"> <span class="keyword">var</span> s thing</span><br><span class="line"> end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// INVALID: end points outside allocated space.</span></span><br><span class="line"> b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line"> end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<p>当然如下代码也是错误的，因为<code>uintptr</code>不可以储存在变量中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">// before conversion back to Pointer.</span></span><br><span class="line">u := <span class="type">uintptr</span>(p)</span><br><span class="line">p = unsafe.Pointer(u + offset)</span><br><span class="line">Pointer<span class="string">`必须指向一个已经分配好的对象，而不能是`</span><span class="literal">nil</span></span><br><span class="line"><span class="comment">// INVALID: conversion of nil pointer</span></span><br><span class="line">u := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">p := unsafe.Pointer(<span class="type">uintptr</span>(u) + offset)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-当调用syscall-Syscall时，需要把Poiner转换为uintptr"><a href="#1-2-4-当调用syscall-Syscall时，需要把Poiner转换为uintptr" class="headerlink" title="1.2.4.  当调用syscall.Syscall时，需要把Poiner转换为uintptr"></a>1.2.4.  当调用<code>syscall.Syscall</code>时，需要把<code>Poiner</code>转换为<code>uintptr</code></h3><p><code>syscall</code>包下的<code>Syscall</code>函数把<code>uintptr</code>参数传递给操作系统，然后根据调用的相关信息，把相应的<code>uintptr</code>再转换为指针。</p>
<p>如果一个指针参数必须被转换为<code>uintptr</code>作为参数的话，这个转换只能在调用函数中的参数表达式完成，因为<code>uintptr</code>是不能储存在变量中的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(p)), <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<p>编译器处理函数调用中的指针时，该指针所指向的对象会被保留到函数调用结束，即使该对象在函数调用时并不使用。</p>
<p>如下是错误的代码，因为<code>uintptr</code>不能保存在变量中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">// before implicit conversion back to Pointer during system call.</span></span><br><span class="line">u := <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), u, <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-将reflect-Value-Pointer或者reflect-Value-UnsafeAddr的结果从uintptr转换为Pointer"><a href="#1-2-5-将reflect-Value-Pointer或者reflect-Value-UnsafeAddr的结果从uintptr转换为Pointer" class="headerlink" title="1.2.5.  将reflect.Value.Pointer或者reflect.Value.UnsafeAddr的结果从uintptr转换为Pointer"></a>1.2.5.  将<code>reflect.Value.Pointer</code>或者<code>reflect.Value.UnsafeAddr</code>的结果从<code>uintptr</code>转换为<code>Pointer</code></h3><p>包<code>reflect</code>下<code>Value</code>的<code>Pointer</code>方法和<code>UnsafeAddr</code>方法返回的是<code>uintptr</code>而不是<code>Pointer</code>类型，以便于调用者不使用<code>usafe</code>包就可以转换为任意类型。这也意味着，这两个方法的返回值必须使用<code>Pointer</code>进行转换才可以使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer()))</span><br></pre></td></tr></table></figure>

<p>因为这两个函数调用的返回值是<code>uintptr</code>，所以也是不可以变量储存的。</p>
<h3 id="1-2-6-reflect-SliceHeader或者reflect-StringHeader的Data字段同Pointer的相互转换"><a href="#1-2-6-reflect-SliceHeader或者reflect-StringHeader的Data字段同Pointer的相互转换" class="headerlink" title="1.2.6.  reflect.SliceHeader或者reflect.StringHeader的Data字段同Pointer的相互转换"></a>1.2.6.  <code>reflect.SliceHeader</code>或者<code>reflect.StringHeader</code>的<code>Data</code>字段同<code>Pointer</code>的相互转换</h3><p>前面说过，返回<code>uintptr</code>是为了调用者可以直接进行不同类型的转换，而不用导入<code>unsafe</code>包。这意味着，只有当指针解析为切片或者字符串时<code>SliceHeader</code>和<code>StringHeader</code>才可以被使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="comment">// case 1</span></span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))              <span class="comment">// case 6 (this case)</span></span><br><span class="line">hdr.Len = n</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>SliceHeader</code>和<code>StringHeader</code>只能作为<code>*SliceHeader</code>和<code>*StringHeader</code>使用，而不可以使用其结构体形式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INVALID: a directly-declared header will not hold Data as a reference.</span></span><br><span class="line"><span class="keyword">var</span> hdr reflect.StringHeader</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;hdr)) <span class="comment">// p possibly already lost</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-Sizeof函数"><a href="#1-3-Sizeof函数" class="headerlink" title="1.3 Sizeof函数"></a>1.3 <code>Sizeof</code>函数</h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p>直接复制标准文档中的内容，下同。</p>
<p><code>Sizeof</code>返回类型v本身数据所占用的字节数。返回值是“顶层”的数据占有的字节数。例如，若v是一个切片，它会返回该切片描述符的大小，而非该切片底层引用的内存的大小。</p>
<h2 id="1-4-Alignof"><a href="#1-4-Alignof" class="headerlink" title="1.4 Alignof"></a>1.4 <code>Alignof</code></h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(v ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p><code>Alignof</code>返回类型v的对齐方式（即类型v在内存中占用的字节数）；若是结构体类型的字段的形式，它会返回字段f在该结构体中的对齐方式。</p>
<h2 id="1-5-Offsetof"><a href="#1-5-Offsetof" class="headerlink" title="1.5 Offsetof"></a>1.5 <code>Offsetof</code></h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(v ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p><code>Offsetof</code>返回类型v所代表的结构体字段在结构体中的偏移量，它必须为结构体类型的字段的形式。换句话说，它返回该结构起始处与该字段起始处之间的字节数。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1.2中的<code>Pointer</code>和<code>uintptr</code>的区别：</p>
<p>假设在内存中有一个变量<code>a := 1</code></p>
<p>那么<code>p := Pointer(&amp;a)</code>中，p包含的就是a的实际地址，假设为<code>1000</code>，当a在内存中移动时，p中的地址值也会实时更新。</p>
<p>而<code>uintprt(p)</code>只是<code>1000</code>，就是a的地址值，但是当a在内存中移动时，原来获取的<code>uintptr</code>值并不会发生变化，一直都是1000。</p>
<p>也是因为这个原因，<code>syscall.Syscall</code>传入的<code>uintptr</code>如果代表一个对象的指针，那么该对象在内存中是一直被保留的，而且不能移动，否则的话<code>uintptr</code>指向的就不是原来的对象了，容易内存泄漏。</p>
<p>还有一个就是<code>uintptr</code>不能保存在变量中，只能使用<code>Pointer</code>进行转换然后才能保存。</p>
<h1 id="编码分析"><a href="#编码分析" class="headerlink" title="编码分析"></a>编码分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>HTTP 协议基于文本传输，字符编码将文本变为二进制，二进制编码将二进制变为文本。TCP 协议基于二进制传输，数据读取时需要处理字节序。本文将介绍常见的字符编码、二进制编码及字节序，并一探 Golang 中的实现。</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>引言：如何把“Hello world”变成字节？</p>
<ul>
<li><p>Step1：得到要表示的全量字符（字符表）</p>
</li>
<li><p>Step2：为每个字符指定一个整数编号（编码字符集）</p>
</li>
<li><p>Step3：将编号映射成有限长度比特值（字符编码表）</p>
</li>
</ul>
<p>字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。全世界共使用 5651 种语言，其中使用人数超过 5000 万的语言有 13 种，每种语言有自己的字符。汉语中，一个汉字就是一个字符。英语中，一个字母就是一个字符。甚至看不见的也可以是字符（如控制字符）。<strong>字符的集合即为字符表</strong>，如英文字母表，阿拉伯数字表。ASCII 码表中一共有 128 个字符。</p>
<h2 id="编码字符集（CCS-Coded-Character-Set）"><a href="#编码字符集（CCS-Coded-Character-Set）" class="headerlink" title="编码字符集（CCS:Coded Character Set）"></a>编码字符集（CCS:Coded Character Set）</h2><p>为字符表中的每个字符指定一个编号（<strong>码点，Code Point</strong>），即得到编码字符集。常见有 ASCII 字符集、Unicode 字符集、GB2312 字符集、BIG5 字符集、 GB18030 字符集等。ASCII 字符集中一共有 128 个字符，包括了 94 个可打印字符（英文大小写字母 52 个、阿拉伯数字 10 个、西文符号 32 个）和 34 个控制符或通信专用字符，码点值范围为[0, 128)，如下图所示。Unicode 字符集是一个很大的集合，现有容量将近 2^21 个字符，码点值范围为[0, 2^20+2^16)。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502988-ada45336-1730-4863-a573-2b9db2127675.webp" alt="img"></p>
<p>ASCII字符编码表</p>
<h2 id="字符编码表（CEF-Character-Encoding-Form）"><a href="#字符编码表（CEF-Character-Encoding-Form）" class="headerlink" title="字符编码表（CEF:Character Encoding Form）"></a>字符编码表（CEF:Character Encoding Form）</h2><p><strong>编码字符集只定义了字符与码点的映射</strong>，并没有规定码点的字节表示方式。由于 1 个字节可以表示 256 个编号，足以容纳 ASCII 字符集，因此<strong>ASCII 编码的规则很简单：直接将码点值用 uint8 表示即可</strong>。对于 Unicode 字符集，容纳 2^21 至少需要 3 字节。可以采用类似 ASCII 的编码规则：<strong>直接将编码点值用 uint32 表示即可，这正是 UTF-32 编码</strong>。</p>
<p>这种一刀切的定长编码方式虽然简单粗暴，弊端也很明显：<strong>对于纯英文文本，UTF-32 编码空间占用将是 ACSII 编码的 4 倍</strong>，造成极大的空间浪费，几乎没什么人用。有没有更优雅的解决方案？当然，这就是 UTF-8 和 UTF-16，两种当前比较流行的 Unicode 编码方式。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>历史的经验，成功的设计往往具有包容性。UTF-8 是一个典型，漂亮的实现了<strong>对 ASCII 码的向后兼容</strong>，以保证可以被大众接受。UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长，随码点变换长度（从 1 字节到 4 字节）。text</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502972-eb8483f5-fb58-4b55-a2b8-a1f52f4d9914.webp" alt="img"></p>
<p>大道至简，优雅的设计一定是简单的，UTF-8 的编码规则也诠释了这一点。编码规则如下：</p>
<ol>
<li>&lt;&#x3D;127（U+7F）的码点采用单字节编码，与 ASCII 保持一致；</li>
<li>&gt;127（U+7F）的码点采用 N 字节（N 属于 2，3，4）编码，首字节的前 N 位为 1，第 N+1 位为 0，剩余 N-1 个字节的前两位都为 10，剩下的二进制位使用字符的码点来填充。</li>
</ol>
<p>其中(U+7F)表示 Unicode 的十六进制码点值，即 127。如果觉得编码规则抽象，结合下表更加清晰：</p>
<table>
<thead>
<tr>
<th>Unicode  码点范围</th>
<th>码点数量</th>
<th>UTF-8 编码格式</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000 ~ 0000 007F</td>
<td>2^7</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 ~ 0000 07FF</td>
<td>2^11 - 2^7</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 ~ 0000 FFFF</td>
<td>2^16 - 2^11</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 ~ 0010 FFFF</td>
<td>2^20</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>举个例子，如“汉”的 Unicode 码点是 U+6C49（110 1100 0100 1001），根据上表可得需要 3 字节编码，填充码点值后得到 0xE6 0xB7 0x89（11100110 10110001 10001001）。</p>
<p>根据编码规则，解码也很简单，关键是如何判断连续的字节数：<strong>首字节连续 1 的个数即为字节数</strong>。</p>
<p>需要一提的是，<strong>在 MySQL 中，utf8 是“虚假的 utf8”</strong>，最大只支持 3 个字节，如果建表时选择 CHARSET&#x3D;utf8，会导致很多特殊字符和 emoji 表情都无法插入。<strong>utf8mb4 才是“真正的 utf8”</strong>，mb4 即most bytes 4。为什么 MySQL 中 utf8 最大只支持 3 字节？历史原因，在 MySQL 刚开发那会儿，Unicode 空间只有 2^16，Unicode 委员会还在做 “65535 个字符足够全世界用了”的美梦呢。</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>在 C&#x2F;C++ 中遇到的wchar_t类型或 Java 中的char类型，这些类型占内存两个字节，因为 Unicode 中常用的字符都处于[U+0, U+FFFF]（基本平面）的范围之内，因此<strong>两个字节几乎可以覆盖大部分的常用字符</strong>，这正是 UTF-16 编码的一个前提。</p>
<p>相比 UTF-32 与 UTF-8，<strong>UTF-16 编码是一个折中：小于（U+FFFF）2^16 的码点（基本平面）使用 2 字节编码，大于（U+FFFF）2^16 的码点（辅助码点）使用 4 字节编码</strong>。由于基础平面空间会占用 2 字节的所有比特位，无法像 UTF-8 那样留有“10”前缀。那么问题来了：<strong>当遇到两个节时，如何判断是 2 字节编码还是 4 字节编码？</strong></p>
<p>UTF-16 的编码的另一个前提：<strong>在基本平面内，</strong>**[U+D800, U+DFFF]**<strong>是一个空段（空间大小为 2^11）</strong>，这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>辅助平面容量为 2^20，至少需要 20 个二进制位，UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 2^10），称为<strong>高位</strong>（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 2^10），称为<strong>低位</strong>（L）。</p>
<p>映射方式采用线性映射。Unicode3.0 中给出了辅助平面字符的转换公式：</p>
<p>H &#x3D; Math.floor((c-0x10000) &#x2F; 0x400) + 0xD800</p>
<p>L &#x3D; (c - 0x10000) % 0x400 + 0xDC00</p>
<p>也就是说，一个辅助平面的码点，被拆成两个基本平面的空段码点表示。如果双字节的值在[U+D800, U+DBFF]中，则要和后续相邻的双字节一同解码。具体编码规则为：</p>
<ol>
<li>&lt;&#x3D; (U+FFFF)的码点采用双字节编码，直接将码点使用 uint16 表示；</li>
<li>&gt; (U+FFFF)的码点采用 4 字节编码，作差计算码点溢出值，将溢出值用 uint20 表示后，前 10 位映射到[U+D800, U+DBFF]，后 10 位映射到[U+DC00, U+DFFF];</li>
</ol>
<p>小结: 定长编码的优点是转换规则简单直观，查找效率高，缺点是空间浪费，以及不可扩展。如果 Unicode 字符集进一步扩充，UTF-16 和 UTF-32 都将不可用，而 UTF-8 具有更强的可扩展性。</p>
<h2 id="Golang-中字符编码"><a href="#Golang-中字符编码" class="headerlink" title="Golang 中字符编码"></a>Golang 中字符编码</h2><p>不像 C++、Java 等语言支持五花八门的字符编码，Golang 遵从“大道至简”的原则：<strong>全用 UTF-8</strong>。所以 go 程序员再也不用担心乱码问题，甚至可以用汉字和表情包写代码，string 与字节数组转换也是直接转换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemp</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    来自打工人的问候()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> 来自打工人的问候<span class="params">()</span></span> &#123;</span><br><span class="line">    问候语 := <span class="string">&quot;早安，打工人😁&quot;</span></span><br><span class="line">    fmt.Println(问候语)</span><br><span class="line">    bytes := []<span class="type">byte</span>(问候语)</span><br><span class="line">    fmt.Println(hex.EncodeToString(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 执行结果–&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">早安，打工人😁</span><br><span class="line">e697a9e5ae89efbc8ce68993e5b7a5e4babaf09f9881</span><br></pre></td></tr></table></figure>

<p>值得一提的是，Golang 中 string 的底层模型就是字节数组，所以类型转换过程中无需编解码。也因此，<strong>Golang 中 string 的底层模型是字节数组，其长度并非字符数，而是对应字节数</strong>。如果要取字符数，需要先将字符串转换为字符数组。<strong>字符类型（rune）实际上是 int32 的别名，即用 UTF-32 编码表示字符</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemp</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;早&quot;</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>([]<span class="type">byte</span>(<span class="string">&quot;早&quot;</span>))) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;早&quot;</span>)) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>再看一下 go 中 utf-8 编码的具体实现。首先获取字符的码点值，然后根据范围判断字节数，根据对应格式生成编码值。如果是无效的码点值，或码点值位于空段，则返回U+FFFD(即 �)。解码过程不再赘述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(p []<span class="type">byte</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// Negative values are erroneous. Making it unsigned addresses the problem.</span></span><br><span class="line">    <span class="keyword">switch</span> i := <span class="type">uint32</span>(r); &#123;</span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune1Max:</span><br><span class="line">        p[<span class="number">0</span>] = <span class="type">byte</span>(r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune2Max:</span><br><span class="line">        _ = p[<span class="number">1</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t2 | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> i &gt; MaxRune, surrogateMin &lt;= i &amp;&amp; i &lt;= surrogateMax:</span><br><span class="line">        r = RuneError</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune3Max:</span><br><span class="line">        _ = p[<span class="number">2</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t3 | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _ = p[<span class="number">3</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t4 | <span class="type">byte</span>(r&gt;&gt;<span class="number">18</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">3</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    t1 = <span class="number">0</span>b00000000</span><br><span class="line">    tx = <span class="number">0</span>b10000000</span><br><span class="line">    t2 = <span class="number">0</span>b11000000</span><br><span class="line">    t3 = <span class="number">0</span>b11100000</span><br><span class="line">    t4 = <span class="number">0</span>b11110000</span><br><span class="line">    t5 = <span class="number">0</span>b11111000</span><br><span class="line">    maskx = <span class="number">0</span>b00111111</span><br><span class="line">    mask2 = <span class="number">0</span>b00011111</span><br><span class="line">    mask3 = <span class="number">0</span>b00001111</span><br><span class="line">    mask4 = <span class="number">0</span>b00000111</span><br><span class="line">    rune1Max = <span class="number">1</span>&lt;&lt;<span class="number">7</span> - <span class="number">1</span></span><br><span class="line">    rune2Max = <span class="number">1</span>&lt;&lt;<span class="number">11</span> - <span class="number">1</span></span><br><span class="line">    rune3Max = <span class="number">1</span>&lt;&lt;<span class="number">16</span> - <span class="number">1</span></span><br><span class="line">    RuneError = <span class="string">&#x27;\uFFFD&#x27;</span> <span class="comment">// the &quot;error&quot; Rune or &quot;Unicode replacement character&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code points in the surrogate range are not valid for UTF-8.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    surrogateMin = <span class="number">0xD800</span></span><br><span class="line">    surrogateMax = <span class="number">0xDFFF</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>引言：HTTP 是怎么传输二进制数据的？</p>
<ul>
<li><p>Step1：定义字符集；</p>
</li>
<li><p>Step2：将二进制数据分组；</p>
</li>
<li><p>Step3：将每组映射为字符；</p>
</li>
</ul>
<p>字符编码是「文本」变为「二进制」的过程，那如何将任意「二进制」变为「文本」？答案是进行二进制编码，常见有 Hex 编码与 Base64 编码。</p>
<p>显然<strong>不能按字符编码直接解码</strong>，因为字符编码的结果二进制是满足编码规律的，而非「任意」的，非法格式进行字符解码会出现乱码（比如对0b11xxxxxx进行 UTF-8 解码）。</p>
<h2 id="Hex-编码"><a href="#Hex-编码" class="headerlink" title="Hex 编码"></a>Hex 编码</h2><p>Hex 编码是最直观的二进制编码方式，所见即所得。上文中的十六进制表示就是用的 Hex 编码。规则如下：</p>
<ol>
<li><p>Hex 字符集为0123456789abcdef；</p>
</li>
<li><p>每 4bit 为 1 组(2^4&#x3D;16)；</p>
</li>
<li><p>每组映射为一个 Hex 字符；</p>
</li>
</ol>
<p>计算机中二进制数据都是以字节为单位存储的，1 个字节 8bit，不会出现无法被 4 整除的情况。</p>
<p>每个字节编码为 2 个 Hex 字符，即编码后的字符数是原始数据字节数的 2 倍。<strong>在 ASCII 或 UTF-8 编码下，存储 Hex 结果字符串需要的空间是原始数据的 2 倍，存储效率为 50%。</strong></p>
<h2 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h2><p>Base64 编码，顾名思义，是基于 64 个字符进行编码。规则如下：</p>
<ol>
<li>Base64 字符集（以标准 Base64 为例, 26 大写, 26 小写, 10 数字, 以及+、&#x2F;）为ABC…YZabc…yz012…89+&#x2F;；</li>
<li>每 6bit 为一组（2^6&#x3D;64），即<strong>每 3 个字节为 4 组</strong>；</li>
<li>每组映射为一个 Base64 字符；</li>
</ol>
<p>如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？**标准编码(StdEncoding)**会先在末尾用 0x00 补齐再分组，并将最后 2 个或 1 个 6bit 分组（全为 0 填充）映射为’&#x3D;’，表示补齐的 0 字节数量。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503267-8b0246bc-28ee-459b-8ad3-1d75de4e3f9d.webp" alt="img"></p>
<p>举个例子，以0x12 34 ab cd编码为标准 base64 为例：</p>
<ol>
<li>不足 3 的倍数，先用两个 0 字节补齐 –&gt;0x12 34 ab cd 00 00</li>
<li>0x12 34 ab编码为EjSr</li>
<li>0xcd 00 00二进制为0b1100 1101 0000 0000 0000 0000，分为 4 组后为110011 010000 000000 000000，编码结果为zQ&#x3D;&#x3D;</li>
<li>最终编码结果为EjSrzQ&#x3D;&#x3D;</li>
</ol>
<p>解码过程注意末尾字节的处理即可，此处不再赘述。</p>
<ol>
<li>EjSrzQ&#x3D;&#x3D;–&gt;0x12 34 ab cd 00 00–&gt;0x12 34 ab cd</li>
</ol>
<p><strong>标准编码中编码结果字符长度一定是 4 的倍数，且是原始数据字节数的 4&#x2F;3 倍</strong>，因为会将字节数据补齐至 3 的倍数，每 3 个字节编码为 4 个字符。**在 ASCII 或 UTF-8 编码下，存储结果字符串需要的空间是原始数据的 4&#x2F;3 倍，存储效率为 75%**。</p>
<p>根据字符集的不同，Base64 编码有几个变种，除了标准编码（StdEncoding），常见的还有 URL 编码（URLEncoding）、原始标准编码（RawStdEncoding）以及原始 URL 编码（RawUrlEncoded）。</p>
<p>简单来说，Raw 指的是无 Padding，URL 指的是用-和_取代编码结果中包含的 url 关键字+和&#x2F;。不妨参考 Golang 中encoding&#x2F;base64包中的描述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StdEncoding is the standard base64 encoding, as defined in</span></span><br><span class="line"><span class="comment">// RFC 4648.</span></span><br><span class="line"><span class="keyword">var</span> StdEncoding = NewEncoding(*encodeStd*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// URLEncoding is the alternate base64 encoding defined in RFC 4648.</span></span><br><span class="line"><span class="comment">// It is typically used in URLs and file names.</span></span><br><span class="line"><span class="keyword">var</span> URLEncoding = NewEncoding(*encodeURL*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RawStdEncoding is the standard raw, unpadded base64 encoding,</span></span><br><span class="line"><span class="comment">// as defined in RFC 4648 section 3.2.</span></span><br><span class="line"><span class="comment">// This is the same as StdEncoding but omits padding characters.</span></span><br><span class="line"><span class="keyword">var</span> RawStdEncoding = StdEncoding.WithPadding(*NoPadding*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.</span></span><br><span class="line"><span class="comment">// It is typically used in URLs and file names.</span></span><br><span class="line"><span class="comment">// This is the same as URLEncoding but omits padding characters.</span></span><br><span class="line"><span class="keyword">var</span> RawURLEncoding = URLEncoding.WithPadding(*NoPadding*)</span><br></pre></td></tr></table></figure>

<p>与标准编码不同的是，<strong>原始编码中，字节数不足 3 的倍数时不会补齐字节数</strong>，采用如下方案：</p>
<ol>
<li>如果剩余 1 字节，则左移 4bit 后转换为 2 字符；</li>
<li>如果剩余 2 字节，则左移 2bit 后转化为 3 字符；</li>
</ol>
<p>即<strong>原始编码方案中，结果字符串长度可以不是 4 的倍数</strong>。</p>
<p>Hex 编码可以看成“Base16 编码”。随着字符数量的增加，存储效率也随之增加。如果有“Base256”编码，存储效率岂不就 100%了？很遗憾，主流字符编码中，单字节能表示的可打印字符只有 92 个。通过扩充多字节字符，或用组合字符实现 base256 意义不大。</p>
<h2 id="Golang-中的二进制编码"><a href="#Golang-中的二进制编码" class="headerlink" title="Golang 中的二进制编码"></a>Golang 中的二进制编码</h2><p>看一下 Golang 中 Base64 编码的实现。首先通过EncodedLen方法确定结果长度，生成输出buf，然后通过Encode方法将编码结果填充到buf并返回结果字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EncodeToString returns the base64 encoding of src.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodeToString(src []<span class="type">byte</span>) <span class="type">string</span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, enc.EncodedLen(<span class="built_in">len</span>(src)))</span><br><span class="line">    enc.Encode(buf, src)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前述，标准编码和原始编码（无 Padding）的结果长度不同：如果需要 Padding，直接根据字节数计算即可，反之则需要根据 bit 数计算。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EncodedLen returns the length in bytes of the base64 encoding</span></span><br><span class="line"><span class="comment">// of an input buffer of length n.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodedLen(n <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enc.padChar == *NoPadding* &#123;</span><br><span class="line">        <span class="keyword">return</span> (n*<span class="number">8</span> + <span class="number">5</span>) / <span class="number">6</span> <span class="comment">// minimum # chars at 6 bits per char</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">2</span>) / <span class="number">3</span> * <span class="number">4</span> <span class="comment">// minimum # 4-char quanta, 3 bytes each</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Encode方法实现了编码细节。首先遍历字节数组，将每 3 个字节编码为 4 个字符。最后处理剩余的 1 或 2 个字节（如有）：首先使用移位运算进行 0bit 填充，然后进行字符转换。如前述，无 Padding 时，剩下 1 字节对应 2 字符，剩下 2 字节对应 3 字符，即至少会有 2 字符。最后在switch代码段中，根据剩余字节数填充第 3 个字符和 Padding 字符（如有）即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> Encode(dst, src []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(src) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// enc is a pointer receiver, so the use of enc.encode within the hot</span></span><br><span class="line">    <span class="comment">// loop below means a nil check at every operation. Lift that nil check</span></span><br><span class="line">    <span class="comment">// outside of the loop to speed up the encoder.</span></span><br><span class="line">    _ = enc.encode</span><br><span class="line">    di, si := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    n := (<span class="built_in">len</span>(src) / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> si &lt; n &#123;</span><br><span class="line">        <span class="comment">// Convert 3x 8bit source bytes into 4 bytes</span></span><br><span class="line">        val := <span class="type">uint</span>(src[si+<span class="number">0</span>])&lt;&lt;<span class="number">16</span> | <span class="type">uint</span>(src[si+<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="type">uint</span>(src[si+<span class="number">2</span>])</span><br><span class="line">        dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">3</span>] = enc.encode[val&amp;<span class="number">0x3F</span>]</span><br><span class="line">        si += <span class="number">3</span></span><br><span class="line">        di += <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    remain := <span class="built_in">len</span>(src) - si</span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add the remaining small block</span></span><br><span class="line">    val := <span class="type">uint</span>(src[si+<span class="number">0</span>]) &lt;&lt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">2</span> &#123;</span><br><span class="line">        val |= <span class="type">uint</span>(src[si+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">    dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">    <span class="keyword">switch</span> remain &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        <span class="keyword">if</span> enc.padChar != *NoPadding* &#123;</span><br><span class="line">            dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> enc.padChar != *NoPadding* &#123;</span><br><span class="line">            dst[di+<span class="number">2</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">            dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>引言：拿到两个字节，如何解析为整形？</p>
<ul>
<li>Step1：明确字节高低位顺序</li>
<li>Step2：按高低位权重计算结果</li>
</ul>
<p>上述二进制编码主要用于文本传输，能不能不进行编码，直接传输二进制？当然可以，基于二进制传输协议，如 TCP 协议。那么什么是文本传输，什么是二进制传输？简单来说，文本传输，内容为文本，自带描述信息（参数名），如 HTTP 中的字段都以 KV 形式存在。二进制传输，内容为二进制，<strong>以预先定义好的格式拼在一起</strong>，如 TCP 协议报文格式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503068-102c03a4-c199-46de-89b9-c782f90e6276.webp" alt="img"></p>
<h3 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h3><p>聊到二进制传输，一个避不开的话题是<strong>字节序</strong>。什么是字节序？假设读取到一个两字节的 uint16 0x04 0x00，如果从左往右（从高位往低位）解码，得到的是 1024，反过来（从低位往高位）解码则是 4，这就是字节序。<strong>符合人类阅读习惯的（从高位往低位）是大端（BigEndian），反之为小端（LittleEndian）。</strong></p>
<p>另一种大小端的定义：LittleEndian 将低序字节存储在低地址，BigEndian 将高序字节存储在低地址。理解起来有些抽象，本质上是一致的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503204-018229fe-0d8f-4474-a462-71454212094c.webp" alt="img"></p>
<p>为什么会有小端字节序，统一都用大端不好么？</p>
<p>计算机不这么想，因为计算机中计算都是从低位开始的，电路先处理低位字节效率比较高。但是，人类还是习惯读写大端字节序。所以，<strong>除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</strong></p>
<p>那什么时候程序员需要进行字节序处理呢？当多字节整形（uint16，uint32，uint64）需要和字节数组互相转换时。<strong>字节数组是无字节序的，客户端写入啥，服务端就读取啥，不会出现逆序，写入和读取无需考虑字节序，这点大可放心</strong>。<strong>只有当多字节整形和字节数组互转时必须指明字节序。</strong></p>
<h2 id="Golang-中的字节序"><a href="#Golang-中的字节序" class="headerlink" title="Golang 中的字节序"></a>Golang 中的字节序</h2><p>以 uint16 与字节数组互转为例，看一下 Golang 中 encoding&#x2F;binary 包中的字节序处理与实现。可见实现并不复杂，注意字节顺序即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEndian</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    bytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.LittleEndian.PutUint16(bytes, <span class="number">1024</span>) <span class="comment">// 小端写 --&gt; 0x0004</span></span><br><span class="line">    binary.BigEndian.PutUint16(bytes, <span class="number">1024</span>) <span class="comment">// 大端写 --&gt; 0x0400</span></span><br><span class="line">    binary.LittleEndian.Uint16(bytes) <span class="comment">// 小端读 --&gt; 4</span></span><br><span class="line">    binary.BigEndian.Uint16(bytes) <span class="comment">// 大端读 --&gt; 1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(littleEndian)</span></span> PutUint16(b []<span class="type">byte</span>, v <span class="type">uint16</span>) &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// early bounds check to guarantee safety of writes below</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="type">byte</span>(v)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="type">byte</span>(v &gt;&gt; <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bigEndian)</span></span> PutUint16(b []<span class="type">byte</span>, v <span class="type">uint16</span>) &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// early bounds check to guarantee safety of writes below</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="type">byte</span>(v &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="type">byte</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(littleEndian)</span></span> Uint16(b []<span class="type">byte</span>) <span class="type">uint16</span> &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// bounds check hint to compiler; see golang.org/issue/14808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint16</span>(b[<span class="number">0</span>]) | <span class="type">uint16</span>(b[<span class="number">1</span>])&lt;&lt;<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bigEndian)</span></span> Uint16(b []<span class="type">byte</span>) <span class="type">uint16</span> &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// bounds check hint to compiler; see golang.org/issue/14808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint16</span>(b[<span class="number">1</span>]) | <span class="type">uint16</span>(b[<span class="number">0</span>])&lt;&lt;<span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战：加解密中的编码与字节序"><a href="#实战：加解密中的编码与字节序" class="headerlink" title="实战：加解密中的编码与字节序"></a>实战：加解密中的编码与字节序</h2><p>在加解密场景中，通常会对<strong>明文</strong>加密得到<strong>密文</strong>，对密文解密得到明文。比如对密码”123456”（明文）进行<strong>对称加密</strong>（如 SM4）得到”G7EeTPnuvSU41T68qsuc_g”（密文）。<strong>明文和密文都是由可打印字符构成的文本</strong>，通常明文人类可直接阅读其含义（不考虑二次加密），密文需要解密后才能理解含义。</p>
<p>那么上述明文变成密文，期间经历了哪些编码过程呢？以加密为例：</p>
<ol>
<li>将明文”123456”进行字符解码（如 UTF-8），得到<strong>明文字节序列</strong>0x31 32 33 34 35 36;</li>
<li>将明文字节序列输入 SM4 加密算法，输出<strong>密文字节序列</strong>0x1b b1 1e 4c f9 ee bd 25 38 d5 3e bc aa cb 9c fe；</li>
<li>将密文字节序列进行二进制编码（如 RawURLBase64），得到密文”G7EeTPnuvSU41T68qsuc_g”；</li>
</ol>
<p>同理，将”G7EeTPnuvSU41T68qsuc_g”解密成”123456”过程中，应与加密过程的编码方式对应：先进行 RawRULBase64 解码，再解密，最后再进行 UTF-8 编码。</p>
<p>加解密算法的输入输出都是字节序列，所以要将明文、密文与字节序列进行转换。有两点需要注意：</p>
<ol>
<li><strong>明文解码为明文字节序列，解码方式因场景而定</strong>。对于多次加密场景（如对“G7EeTPnuvSU41T68qsuc_g”再次加密），明文是 Base64 编码得到的，建议采用一致的方式解码。虽然也可以直接进行 UTF-8 解码，但会使加解密流程设计变得复杂。</li>
<li><strong>密文字节序列编码为密文，必须用二进制编码，不能用字符编码</strong>。使用字符编码会产生乱码（意味着数据丢失，无法逆向解码出原始数据）。上述密文序列密文序列进行 UTF-8 编码的结果是 �L���%8�&gt;��˜�。</li>
</ol>
<p>合规要求，加解密场景中应使用<strong>硬件加密机</strong>。通常硬件加密机提供<strong>基于 TCP 的字节流通信方式</strong>，比如约定每次通信数据中的前 2 字节为数据长度，后面的为真实数据。发送时，需要将真实数据长度转为 2 字节拼在前面，接收时，需要先读取前两字节得到真实数据长度 N，再读取 N 字节得到真实数据。其中<strong>长度与字节序列的转换需要关注字节序：发送方和接收方的字节序处理保持一致</strong>即可，比如全用大端。下面给出了数据发送的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *EncryptMachine)</span></span> sendData(conn net.Conn, data []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// add length</span></span><br><span class="line">    newData := m.addLength(data)</span><br><span class="line">    <span class="comment">// send new data</span></span><br><span class="line">    <span class="keyword">return</span> util.SocketWriteData(conn, newData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *EncryptMachine)</span></span> addLength(data []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">    lengthBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.BigEndian.PutUint16(lengthBytes, <span class="type">uint16</span>(<span class="built_in">len</span>(data)))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(lengthBytes, data...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>编码虽然基础，但却容易出错，切莫眼高手低。希望本文能帮助大家进一步了解字符编码、二进制编码与字节序，避免踩坑。</p>
<p><strong>未完，待续</strong></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言参考手册</title>
    <url>/2023/09/04/Go%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一个 Go 语言的参考手册，你也可以访问<a href="https://golang.org/">golang.org</a>获取更多信息和其他文档。</p>
<p>Go 是在设计时考虑了系统编程的通用型编程语言。它是强类型，有垃圾回收机制并原生支持并发编程。Go 程序由一个或多个 package 组成，这样可以高效的管理依赖。</p>
<p>Go 的语法简洁且有规则，这让自动化工具可以很容易的分析代码，例如：集成开发环境。</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>语法采用扩展巴科斯范式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Production  = production_name <span class="string">&quot;=&quot;</span> [ Expression ] <span class="string">&quot;.&quot;</span> .</span><br><span class="line">Expression  = Alternative &#123; <span class="string">&quot;|&quot;</span> Alternative &#125; .</span><br><span class="line">Alternative = Term &#123; Term &#125; .</span><br><span class="line">Term        = production_name | token [ <span class="string">&quot;…&quot;</span> token ] | Group | Option | Repetition .</span><br><span class="line">Group       = <span class="string">&quot;(&quot;</span> Expression <span class="string">&quot;)&quot;</span> .</span><br><span class="line">Option      = <span class="string">&quot;[&quot;</span> Expression <span class="string">&quot;]&quot;</span> .</span><br><span class="line">Repetition  = <span class="string">&quot;&#123;&quot;</span> Expression <span class="string">&quot;&#125;&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>产生式是由词法单元和以下操作符构成的表达式（优先级依次递增）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">|   或</span><br><span class="line">()  分组</span><br><span class="line">[]  可选 (出现 <span class="number">0</span> 或 <span class="number">1</span> 次)</span><br><span class="line">&#123;&#125;  可重复 (出现 <span class="number">0</span> 到 n 次)</span><br></pre></td></tr></table></figure>



<p>小写的产生式名称用来与词法单元区分。非终结符采用驼峰式。词法单元由双引号或反引号组成。</p>
<p><code>a...b</code> 表示从 <code>a</code> 到 <code>b</code> 之间的任意字符。省略号 <code>...</code> 也可以在规范中表示对更详细的枚举和代码片段的省略。字符 <code>...</code> 不是 Go 语言的词法单元。</p>
<h2 id="源码表示法"><a href="#源码表示法" class="headerlink" title="源码表示法"></a>源码表示法</h2><p>Go 的源代码使用 UTF-8 编码的 Unicode 文本。不过它并不是完全规范化的，单重音的代码点与由相同字符和音标组成的代码点是不同的；前者我们认为它是两个代码点。简单来讲，文档会在源代码文本中使用非规范的术语字符来表示一个 Unicode 代码点。</p>
<p>每个代码点都是不同的；相同字符的大写和小写形式表示不同的字符。</p>
<p>实现限制：为了兼容其他工具，编译器不允许出现 Utf-8 编码的源文本中的 NUL 字符（U+0000）。</p>
<p>实现限制：为了兼容其他工具，如果源文本中是以Utf-8 编码的字节序标记（U+FEFF）为起始代码点。编译器会忽略它。字节序标记不应出现在源文本的任何位置。</p>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>这些单词表示 Unicode 字符的类别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newline        = <span class="comment">/* Unicode 代码点 U+000A */</span> .</span><br><span class="line">unicode_char   = <span class="comment">/* 排除换行以外的任意 Unicode 代码点 */</span> .</span><br><span class="line">unicode_letter = <span class="comment">/* 一个字母（&quot;Letter&quot;）类型的 Unicode 代码点  */</span> .</span><br><span class="line">unicode_digit  = <span class="comment">/* 一个数字（&quot;Number, decimal digit&quot;）类型的 Unicode 代码点  */</span> .</span><br></pre></td></tr></table></figure>



<p>在 Unicode8.0 标准中，第 4.5 章节 “一般类别” 中定义了字符的类别。Go 能够处理任何字符集，包括 Lu，Li，Lt，Lm 或 Lo 作为 Unicode 字母，还可以把数字字符集 Nd 当作 Unicode 数字处理。</p>
<h4 id="字母和数字"><a href="#字母和数字" class="headerlink" title="字母和数字"></a>字母和数字</h4><p>我们认为下划线 <code>_</code> （U+005F）是一个字母：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">letter        = unicode_letter | <span class="string">&quot;_&quot;</span> .</span><br><span class="line">decimal_digit = <span class="string">&quot;0&quot;</span> … <span class="string">&quot;9&quot;</span> .</span><br><span class="line">octal_digit   = <span class="string">&quot;0&quot;</span> … <span class="string">&quot;7&quot;</span> .</span><br><span class="line">hex_digit     = <span class="string">&quot;0&quot;</span> … <span class="string">&quot;9&quot;</span> | <span class="string">&quot;A&quot;</span> … <span class="string">&quot;F&quot;</span> | <span class="string">&quot;a&quot;</span> … <span class="string">&quot;f&quot;</span> .</span><br></pre></td></tr></table></figure>



<h2 id="词汇元素"><a href="#词汇元素" class="headerlink" title="词汇元素"></a>词汇元素</h2><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释是程序的说明文档。在 Go 中有两种形式：</p>
<ul>
<li>单行注释从 <code>//</code> 开始直到行末结束。</li>
<li>通用注释从 <code>/*</code> 开始直到 <code>*/</code> 结束。</li>
</ul>
<p>注释不能嵌套在其他注释、字符串和 rune 的字面值中。不包含换行符的通用注释之间通过空格符连接，其他情况下每段注释都会另起一行。</p>
<h4 id="词汇元素-1"><a href="#词汇元素-1" class="headerlink" title="词汇元素"></a>词汇元素</h4><p>词汇元素构成了 Go 语言的词汇表。它有四种类型：标识符、关键字、操作符&#x2F;标点符号、字面值。空白符可以是空格（U+0020）、水平制表符（U+0009）、换行符（U+000D）或换行符（U+000A）。它本身会被忽略，一般用来区分不同的词汇元素。换行符或文件终止符（EOF）还可能触发编译程序在源代码的行末或文件末尾追加分号。在分解源代码的词汇元素的过程中，会把当前可以形成有效词汇元素的最长字符序列作为下一个词汇元素。</p>
<h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>正规语法在很多产生式中使用分号 “;” 作为终结符。Go 程序中遵循下面两条规则省略了大部分的分号：</p>
<ol>
<li>当某行的最后一个词汇元素是以下元素时自动补全分号：</li>
</ol>
<ul>
<li><p>一个标识符。</p>
</li>
<li><p>一个整数，浮点数，虚数，rune 或字符串字面值。</p>
</li>
<li><p>关键字 <code>break</code>、<code>continue</code>、<code>fallthrough</code> 和 <code>return</code> 其中之一。</p>
</li>
<li><p>操作符&#x2F;标点符号 <code>++</code>，<code>--</code>，<code>)</code>，<code>]</code> 和 <code>&#125;</code> 其中之一。</p>
</li>
</ul>
<ol>
<li>为了支持独占一行的复杂语句，会省略与 “)” 或 “}” 相邻的分号。</li>
</ol>
<p>为了反应惯用用途，本篇文档的所有例子都基于以上规则省略分号。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符表示程序实体单元，例如：变量、类型。一个标识符由一个或多个字母和数字组成。标识符的首字符必须为字母。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">identifier = letter &#123; letter | unicode_digit &#125; .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">_x9</span><br><span class="line">ThisVariableIsExported</span><br><span class="line">αβ</span><br></pre></td></tr></table></figure>



<p>Go 已经预定义了一些标识符。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>以下关键字是预留的，它们不能作为标识符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>



<h4 id="操作符和标点符号"><a href="#操作符和标点符号" class="headerlink" title="操作符和标点符号"></a>操作符和标点符号</h4><p>以下字符序列用于表示操作符（包括赋值运算符）和标点符号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )</span><br><span class="line">-    |     -=    |=     ||    &lt;     &lt;=    [    ]</span><br><span class="line">*    ^     *=    ^=     &lt;-    &gt;     &gt;=    &#123;    &#125;</span><br><span class="line">/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;</span><br><span class="line">%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :</span><br><span class="line">     &amp;^          &amp;^=</span><br></pre></td></tr></table></figure>



<h4 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h4><p>整型字面值是一个数字序列，相当于整型常量。可以使用前缀指定非小数进制：0 表示八进制，0x&#x2F;0X 表示十六进制。在十六进制字面值中，字母 a-f 和 A-F 都表示数字 10-15。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">int_lit     = decimal_lit | octal_lit | hex_lit .</span><br><span class="line">decimal_lit = ( <span class="string">&quot;1&quot;</span> … <span class="string">&quot;9&quot;</span> ) &#123; decimal_digit &#125; .</span><br><span class="line">octal_lit   = <span class="string">&quot;0&quot;</span> &#123; octal_digit &#125; .</span><br><span class="line">hex_lit     = <span class="string">&quot;0&quot;</span> ( <span class="string">&quot;x&quot;</span> | <span class="string">&quot;X&quot;</span> ) hex_digit &#123; hex_digit &#125; .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">0600</span></span><br><span class="line"><span class="number">0xBadFace</span></span><br><span class="line"><span class="number">170141183460469231731687303715884105727</span></span><br></pre></td></tr></table></figure>



<h4 id="浮点字面值"><a href="#浮点字面值" class="headerlink" title="浮点字面值"></a>浮点字面值</h4><p>浮点字面值是一个小数，相当于浮点数常量。它由整数部分，小数点，小数部分和指数部分构成。整数部分和小数部分用小数点链接；指数部分由  <code>e</code> &#x2F; <code>E</code> 字符后接一个有符号指数构成。整数部分和小数部分可以省略其一；小数点和指数部分可以省略其一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">float_lit = decimals <span class="string">&quot;.&quot;</span> [ decimals ] [ exponent ] |</span><br><span class="line">            decimals exponent |</span><br><span class="line">            <span class="string">&quot;.&quot;</span> decimals [ exponent ] .</span><br><span class="line">decimals  = decimal_digit &#123; decimal_digit &#125; .</span><br><span class="line">exponent  = ( <span class="string">&quot;e&quot;</span> | <span class="string">&quot;E&quot;</span> ) [ <span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span> ] decimals .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0.</span></span><br><span class="line"><span class="number">72.40</span></span><br><span class="line"><span class="number">072.40</span>  <span class="comment">// == 72.40</span></span><br><span class="line"><span class="number">2.71828</span></span><br><span class="line"><span class="number">1.e+0</span></span><br><span class="line"><span class="number">6.67428e-11</span></span><br><span class="line"><span class="number">1E6</span></span><br><span class="line"><span class="number">.25</span></span><br><span class="line"><span class="number">.12345E+5</span></span><br></pre></td></tr></table></figure>



<h4 id="虚数字面值"><a href="#虚数字面值" class="headerlink" title="虚数字面值"></a>虚数字面值</h4><p>虚数字面值是一个小数，相当于复数常量中的虚数部分。它由浮点数或者整数后接小写字母 i 构成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">imaginary_lit = (decimals | float_lit) <span class="string">&quot;i&quot;</span> .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0i</span></span><br><span class="line"><span class="number">011i</span>  <span class="comment">// == 11i</span></span><br><span class="line"><span class="number">0.i</span></span><br><span class="line"><span class="number">2.71828i</span></span><br><span class="line"><span class="number">1.e+0i</span></span><br><span class="line"><span class="number">6.67428e-11i</span></span><br><span class="line"><span class="number">1E6i</span></span><br><span class="line"><span class="number">.25i</span></span><br><span class="line"><span class="number">.12345E+5i</span></span><br></pre></td></tr></table></figure>



<h4 id="Rune-字面值"><a href="#Rune-字面值" class="headerlink" title="Rune 字面值"></a>Rune 字面值</h4><p>rune 类型字面值相当于一个 rune 常量。它是一个表示 Unicode 代码点的整数。rune 类型字面值表示为用单引号包裹的一个或多个字符，像 ‘x’ 或 ‘\n’。在单引号中除了换行符和未转义的单引号其他的字符都可以直接显示。单引号包裹的字符的值和字符在 Unicode 编码中的值相等，而以反斜线开头的多字符序列会把值翻译成多种格式。</p>
<p>使用引号表示单字符是最简单的方式；因为 Go 的源文本是 UTF-8 编码，一个整数可能代表多个 UTF-8 字节。例如， ‘a’ 可以使用单字节表示字符 a，Unicode 编码 U+0061，值 0x61，而 ‘ä’ 是两字节表示分音符的 a，Unicode 编码 U+00E4，值 0xe4。</p>
<p>反斜线能将任意值编码成 ASCII 文本。有四种方式将整数值表示为数字常量：<code>\x</code> 后接两个十六进制数；<code>\u</code> 后接四个十六进制数；<code>\U</code> 后接八个十六进制数。 <code>\</code> 后接三个八进制数。每种情况下都使用相应进制来表示字面量的整数值。</p>
<p>虽然这四种方式都以整数表示，但它们的有效区间并不相同。八进制只能表示 0 - 255 以内的整数。十六进制满可以满足需求。<code>\u</code> 和 <code>\U</code>  都可以表示 Unicode 代码点，不过其中的一些值是无效的，特别是 0x10FFFF 以上的值。</p>
<p>反斜线结合以下字符具有特殊含义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">\a   U+<span class="number">0007</span> alert or bell</span><br><span class="line">\b   U+<span class="number">0008</span> 退格符</span><br><span class="line">\f   U+<span class="number">000</span>C form feed</span><br><span class="line">\n   U+<span class="number">000</span>A line feed or newline</span><br><span class="line">\r   U+<span class="number">000</span>D carriage <span class="keyword">return</span></span><br><span class="line">\t   U+<span class="number">0009</span> 水平制表符</span><br><span class="line">\v   U+<span class="number">000</span>b 垂直制表符</span><br><span class="line">\\   U+<span class="number">005</span>c 反斜线</span><br><span class="line">\<span class="string">&#x27;   U+0027 单引号  (只在 rune 字面值中有效)</span></span><br><span class="line"><span class="string">\&quot;   U+0022 双引号  (只在字符串字面值中有效)</span></span><br></pre></td></tr></table></figure>



<p>其他所有以反斜线开头的序列在 rune 的规则中都是非法的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rune_lit         = <span class="string">&quot;&#x27;&quot;</span> ( unicode_value | byte_value ) <span class="string">&quot;&#x27;&quot;</span> .</span><br><span class="line">unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .</span><br><span class="line">byte_value       = octal_byte_value | hex_byte_value .</span><br><span class="line">octal_byte_value = <span class="string">`\`</span> octal_digit octal_digit octal_digit .</span><br><span class="line">hex_byte_value   = <span class="string">`\`</span> <span class="string">&quot;x&quot;</span> hex_digit hex_digit .</span><br><span class="line">little_u_value   = <span class="string">`\`</span> <span class="string">&quot;u&quot;</span> hex_digit hex_digit hex_digit hex_digit .</span><br><span class="line">big_u_value      = <span class="string">`\`</span> <span class="string">&quot;U&quot;</span> hex_digit hex_digit hex_digit hex_digit</span><br><span class="line">                           hex_digit hex_digit hex_digit hex_digit .</span><br><span class="line">escaped_char     = <span class="string">`\`</span> ( <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;f&quot;</span> | <span class="string">&quot;n&quot;</span> | <span class="string">&quot;r&quot;</span> | <span class="string">&quot;t&quot;</span> | <span class="string">&quot;v&quot;</span> | <span class="string">`\`</span> | <span class="string">&quot;&#x27;&quot;</span> | <span class="string">`&quot;`</span> ) .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="string">&#x27;ä&#x27;</span></span><br><span class="line"><span class="string">&#x27;本&#x27;</span></span><br><span class="line"><span class="string">&#x27;\t&#x27;</span></span><br><span class="line"><span class="string">&#x27;\000&#x27;</span></span><br><span class="line"><span class="string">&#x27;\007&#x27;</span></span><br><span class="line"><span class="string">&#x27;\377&#x27;</span></span><br><span class="line"><span class="string">&#x27;\x07&#x27;</span></span><br><span class="line"><span class="string">&#x27;\xff&#x27;</span></span><br><span class="line"><span class="string">&#x27;\u12e4&#x27;</span></span><br><span class="line"><span class="string">&#x27;\U00101234&#x27;</span></span><br><span class="line"><span class="string">&#x27;\&#x27;&#x27;</span>         <span class="comment">// 包含单引号的 rune 字面值</span></span><br><span class="line"><span class="string">&#x27;aa&#x27;</span>         <span class="comment">// 无效: 太多字符</span></span><br><span class="line"><span class="string">&#x27;\xa&#x27;</span>        <span class="comment">// 无效: 缺少十六进制数</span></span><br><span class="line"><span class="string">&#x27;\0&#x27;</span>         <span class="comment">// 无效: 缺少八进制数</span></span><br><span class="line"><span class="string">&#x27;\uDFFF&#x27;</span>     <span class="comment">// 无效: surrogate half</span></span><br><span class="line"><span class="string">&#x27;\U00110000&#x27;</span> <span class="comment">// 无效: 非法的 Unicode 代码点</span></span><br></pre></td></tr></table></figure>



<h4 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h4><p>字符串字面量表示从字符序列中获取的字符串常量。它有两种格式：原始字符串字面量和解释型字符串字面量。</p>
<p>原始字符串是由反引号包裹（<code>foo</code>）。字符串中除反引号以外的其他字符都会显示出来。原生字符串由反引号之间的（默认 UTF-8 编码）的字符组成。它的值为引号内未经解释（默认 UTF-8 编码）所有字符；尤其是，反斜线再字符串中没有特殊意义并且字符串中保留换行符。在原始字符串的值中会丢弃回车键返回 ‘\r’ 字符。</p>
<p>解释型字符串由双引号之间的字符组成（”bar”）。除了换行符和双引号其他字符都会显示出来。双引号之间的文本组成字面量的值。反斜线的转义规则与 rune 字面量基本相同（不同的是 \’ 非法，而 &quot; 合法）。三位八进制数（\nnn）和两位十六进制数（\xnn）换码符的值表示相应字符串的字节。其他的换码符都表示字符各自的 UTF-8 编码（可能是多字节）。因此字符串 \377 和 \xFF 都表示值为 0xFF&#x3D;255 的单个字节，而  <code>ÿ</code>, <code>\u00FF</code>, <code>\U000000FF</code> 和 <code>\xc3\xbf</code> 表示 UTF-8 编码字符 U+00FF 的两个字节 0xc3 0xbf。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">string_lit             = raw_string_lit | interpreted_string_lit .</span><br><span class="line">raw_string_lit         = <span class="string">&quot;`&quot;</span> &#123; unicode_char | newline &#125; <span class="string">&quot;`&quot;</span> .</span><br><span class="line">interpreted_string_lit = <span class="string">`&quot;`</span> &#123; unicode_value | byte_value &#125; <span class="string">`&quot;`</span> .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`abc`</span>                <span class="comment">// 等价于 &quot;abc&quot;</span></span><br><span class="line"><span class="string">`\n</span></span><br><span class="line"><span class="string">\n`</span>                  <span class="comment">// 等价于 &quot;\\n\n\\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;\&quot;&quot;</span>                 <span class="comment">// 等价于 `&quot;`</span></span><br><span class="line"><span class="string">&quot;Hello, world!\n&quot;</span></span><br><span class="line"><span class="string">&quot;日本語&quot;</span></span><br><span class="line"><span class="string">&quot;\u65e5本\U00008a9e&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\u00FF&quot;</span></span><br><span class="line"><span class="string">&quot;\uD800&quot;</span>             <span class="comment">// 无效: surrogate half</span></span><br><span class="line"><span class="string">&quot;\U00110000&quot;</span>         <span class="comment">// 无效: 无效的 Unicode 代码点</span></span><br></pre></td></tr></table></figure>



<p>这些例子都表示相同的字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;日本語&quot;</span>                                 <span class="comment">// UTF-8 文本</span></span><br><span class="line"><span class="string">`日本語`</span>                                 <span class="comment">// UTF-8 文本作为原生字面值</span></span><br><span class="line"><span class="string">&quot;\u65e5\u672c\u8a9e&quot;</span>                    <span class="comment">// 确定的 Unicode 代码点 </span></span><br><span class="line"><span class="string">&quot;\U000065e5\U0000672c\U00008a9e&quot;</span>        <span class="comment">// 确定的 Unicode 代码点</span></span><br><span class="line"><span class="string">&quot;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&quot;</span>  <span class="comment">// 确定的 UTF-8 字节</span></span><br></pre></td></tr></table></figure>



<p>如果源代码中使用两个代码点表示一个字符，例如带音标的字母，把它放在 rune 中会报错（它不是单代码点）。并且在字符串中会显示两个代码点。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量分为：布尔型，rune型，整型，浮点型，复数型，字符串型。其中 rune，整型，浮点型，复数型统称为数字常量。</p>
<p>常量的值可以表示为一个 rune字面量，整数字面量，浮点数字面量，虚数字面量，字符串字面量，表示常量的标识符，常量表达式，一个转换结果为常量的类型转换，和一些返回值为常量的内置函数(接受任何值的<code>unsafe.Sizeof</code>，接受部分表达式的<code>cap</code> 或 <code>len</code>，接受虚数常量的<code>real</code> 和 <code>imag</code>，接受数字常量的 <code>complex</code>)。布尔类型的值为预定义常量 <code>true</code> 或 <code>false</code>，预定义的标识符 <code>iota</code> 表示一个整型常量。</p>
<p>一般情况下复数常量是常量表达式的一种形式。会在常量表达式章节详细讨论。</p>
<p>数字常量可以表示任意精度的确定值而且不会溢出。因此，没有常量可以表示非 0，无穷大和非数字值。</p>
<p>常量可以指定类型也可以不指定类型。字面值常量，<code>true</code>，<code>false</code>，<code>iota</code>，和只包含无类型常量操作的常量表达式是无类型的。</p>
<p>常量可以通过常量声明和转换时显式的指定具体类型，也可以隐式的在变量声明、赋值或作为表达式操作元时隐式的指定具体类型。如果常量的值和他的类型不匹配，会报错。</p>
<p>无类型常量由一个默认的类型，这个类型会根据使用常量时的上下文进行隐式转换。例如：短变量声明 <code>i := 0</code> 没有指定 i 的类型。无类型常量的默认类型可以是：<code>bool</code>，<code>rune</code>，<code>int</code>，<code>float64</code>，<code>complex128</code> 或者 <code>string</code>，具体选择哪种类型由常量的值决定。</p>
<p>实现限制：虽然数字常量在 Go 中是任意精度，不过编译器在实现时会在内部限制精度。这意味着每个编译器实现都要：</p>
<ul>
<li><p>至少保证整形常量有 256 位</p>
</li>
<li><p>浮点数常量（包括复数常量）都要保证至少 256 位的主体部分和至少 16 位的有符号指数部分</p>
</li>
<li><p>如果不能表示给定整数的精度抛出错误</p>
</li>
<li><p>如果浮点数或复数溢出抛出错误</p>
</li>
<li><p>如果由于精度限制不能表示浮点数或者复数进行舍入</p>
</li>
</ul>
<p>这些要求同时作用于字面量常量额和常量表达式的结果。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个用来储存值的位置。根据不同的变量类型，可以保存不同的值。</p>
<p>变量声明，函数参数和返回值，声明的函数签名，函数字面值都会为命名变量预留储存空间。调用内置的  <code>new</code>  函数或获取复合字面值的地址都会在运行时为变量分配存储空间。这种匿名变量是通过（可能是隐式的）指针间接引用的。</p>
<p>像数组，切片和结构体类型的变量，它们内部都包含很多元素或字段，而且这些元素和字段都可以直接被访问。数组和切片中的每个元素的行为和单独的变量基本相同。</p>
<p>变量的静态类型可以通过变量声明、提供给 <code>new</code> 的类型、复合字面值、结构体变量声明的元素类型以上几种方式确定。通过new或者类型初始化。接口类型的变量也有一个明确的动态类型，这个动态类型是在运行时赋值给变量的具体值类型（特例：预声明的 nil 是无类型的）。动态类型在程序的执行过程中可能并不相同，但是接口变量的值是可以分配给相同静态类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// x 的静态类型为 interface&#123;&#125; 值为 nil</span></span><br><span class="line"><span class="keyword">var</span> v *T           <span class="comment">// v 的静态类型为 *T 值为 nil</span></span><br><span class="line">x = <span class="number">42</span>             <span class="comment">// x 的动态类型为 int 值为 42</span></span><br><span class="line">x = v              <span class="comment">// x 动态类型为 *T 值为 (*T)(nil)</span></span><br></pre></td></tr></table></figure>



<p>在表达式中使用变量可以取出变量的值；这个值就是变量最近一次被赋予的值。如果没有对变量赋过值，那么他的值是该类型的零值。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>类型是一个集合，集合包括值和针对值的操作&amp;方法。一个类型可以使用类型名来表示。类型有多种表现形式：如果存在类型名，可以使用类型名表示，或者也可以使用根据已有类型组合成的类型字面值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type      = TypeName | TypeLit | <span class="string">&quot;(&quot;</span> Type <span class="string">&quot;)&quot;</span> .</span><br><span class="line">TypeName  = identifier | QualifiedIdent .</span><br><span class="line">TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |</span><br><span class="line">	    SliceType | MapType | ChannelType .</span><br></pre></td></tr></table></figure>



<p>Go 已经预先声明了某些类型的名称。并引入了类型声明。复合类型（数组、结构体、指针、函数、接口、切片、map、channel）可以使用他们的类型字面值。</p>
<p>每个类型T都有一个底层类型。如果T是预定义类型或者类型字面值。那么底层类型就是他自身。否则，T的底层类型就是它再类型声明时引用到的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	A1 = <span class="type">string</span></span><br><span class="line">	A2 = A1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	B1 <span class="type">string</span></span><br><span class="line">	B2 B1</span><br><span class="line">	B3 []B1</span><br><span class="line">	B4 B3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p><code>string</code>，<code>A1</code>，<code>A2</code>，<code>B1</code>，<code>B2</code> 的底层类型是 <code>string</code>。<code>[]B1</code>，<code>B3</code>，<code>B4</code> 的下游类型是[]B1。</p>
<h4 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h4><p>类型可能会有一个与之关联的方法集。接口类型的方法集就可以使用自身表示。对于其他类型，类型 T 的方法集由所有接收者类型为 T 的方法组成。而对应指针类型 *T 的方法集由所有接收者类型为 T 或 *T 的方法组成。如果是结构体类型且含有嵌入字段，那么方法集中可能还会包含更多的方法，具体请看结构体类型章节。其他类型的方法集都为空。方法集中的每个方法都有唯一且不为空的方法名。</p>
<p>类型的方法集用来确定类型实现的接口和以类型作为接收者能够调用的方法。</p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>布尔类型表示预定义常量 <code>true</code> 和 <code>false</code> 表示布尔真实值的集合。预定义的布尔类型为 <code>bool</code>；它是通过类型声明创建的。</p>
<h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>一个数字类型相当于整型和浮点型的所有值的集合。预定义的数字类型包括：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8</span>       <span class="number">8</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">255</span>)</span><br><span class="line"><span class="type">uint16</span>      <span class="number">16</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">65535</span>)</span><br><span class="line"><span class="type">uint32</span>      <span class="number">32</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">4294967295</span>)</span><br><span class="line"><span class="type">uint64</span>      <span class="number">64</span> 位无符号整数集合 (<span class="number">0</span> to <span class="number">18446744073709551615</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int8</span>        <span class="number">8</span> 位有符号整数集合 (<span class="number">-128</span> to <span class="number">127</span>)</span><br><span class="line"><span class="type">int16</span>       <span class="number">16</span> 位有符号整数集合 (<span class="number">-32768</span> to <span class="number">32767</span>)</span><br><span class="line"><span class="type">int32</span>       <span class="number">32</span> 位有符号整数集合 (<span class="number">-2147483648</span> to <span class="number">2147483647</span>)</span><br><span class="line"><span class="type">int64</span>       <span class="number">64</span> 位有符号整数集合 (<span class="number">-9223372036854775808</span> to <span class="number">9223372036854775807</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">float32</span>     IEEE<span class="number">-754</span> <span class="number">32</span> 位浮点数集合</span><br><span class="line"><span class="type">float64</span>     IEEE<span class="number">-754</span> <span class="number">64</span> 位浮点数集合</span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span>   实部虚部都为 <span class="type">float32</span> 的复数集合</span><br><span class="line"><span class="type">complex128</span>  实部虚部都为 <span class="type">float64</span> 的复数集合</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>        <span class="type">uint8</span> 的别名</span><br><span class="line"><span class="type">rune</span>        <span class="type">int32</span> 的别名</span><br></pre></td></tr></table></figure>



<p>n 位整数的值具有 n 比特的宽度并用补码表示。</p>
<p>以下几种预定义类型由具体平台实现指定长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint</span>     <span class="number">32</span> 或 <span class="number">64</span> 位</span><br><span class="line"><span class="type">int</span>      和 <span class="type">uint</span> 位数相同</span><br><span class="line"><span class="type">uintptr</span>  能够容纳指针值的无符号整数</span><br></pre></td></tr></table></figure>



<p>为了避免移植性问题，除了被 uint8 的别名 byte 和 int32 的别名 rune，其他所有的数字类型都是通过类型声明定义。当在表达式中使用不同的数字类型需要进行类型转换。例如：int32 和 int 不是相同的类型，即使他们在指定的平台上是相等的。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串类型表示字符串的值类型。字符串的值是一个字节序列（有可能为空）。字符串一旦创建就无法修改它的值。预定义的字符串类型是 <code>string</code>，它是通过类型声明定义的。</p>
<p>可以使用内置函数 <code>len</code> 获取字符串长度。如果字符串是常量那么它的长度在编译时也为常量。可以通过数字下标 0～len(s)-1 访问字符串字节。获取字符串的地址是非法操作；如果 <code>s[i]</code> 是字符串的第 i 个字节，那么 <code>&amp;s[i]</code> 是无效的。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组是一定数量的单一类型元素序列，而这个单一类型叫做元素类型。元素的个数表示元素的长度，它永远不是负数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ArrayType   = <span class="string">&quot;[&quot;</span> ArrayLength <span class="string">&quot;]&quot;</span> ElementType .</span><br><span class="line">ArrayLength = Expression .</span><br><span class="line">ElementType = Type .</span><br></pre></td></tr></table></figure>



<p>长度是数组类型的一部分；它是一个类型为 int 的非负常量。可以用内置函数 <code>len</code> 获取数组的长度。元素可以通过下标 <code>0～len(a)-1</code> 访问。数组一般都是一维的，不过也可以是多维的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">[<span class="number">2</span>*N] <span class="keyword">struct</span> &#123; x, y <span class="type">int32</span> &#125;</span><br><span class="line">[<span class="number">1000</span>]*<span class="type">float64</span></span><br><span class="line">[<span class="number">3</span>][<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>]<span class="type">float64</span>  <span class="comment">// same as [2]([2]([2]float64))</span></span><br></pre></td></tr></table></figure>



<h4 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h4><p>切片描述了底层数组的一个连续片段并提供对连续片段内元素的访问。切片类型表示元素类型的数组的所有切片的集合。没有被初始化的切片用 nil 表示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SliceType = <span class="string">&quot;[&quot;</span> <span class="string">&quot;]&quot;</span> ElementType .</span><br></pre></td></tr></table></figure>



<p>与数组一样，切片的可以使用索引访问并且有长度，切片的长度可以通过内置的 <code>len</code> 函数获取；与数组不同的是它的长度在运行时是可以变化的。我们可以通过下标 <code>0～len(s)-1</code> 来访问切片内的元素。切片的索引可能会小于相同元素再底层数组的索引。</p>
<p>切片一旦初始化，那么就有一个与之对应的底层数组保存切片中的元素。切片和底层的数组还有其他指向该数组的切片共享相同的储存空间；而不同的数组总是有着不同的存储空间。</p>
<p>切片的底层数组可能会延伸到切片末尾以外，切片的容积等于切片现在的长度加上数组中切片还没使用的长度；可以从原始切片中切出一个长度与容量相等的切片。切片的容量可以通过内置的 <code>cap(a)</code> 函数来获取。可以通过函数<code>make</code>来创建一个T类型的新切片。</p>
<p>使用内置函数 <code>make</code> 可以出实话给定元素类型 T 的切片。<code>make</code> 函数接收三个参数：切片类型、切片长度、切片容积，其中切片容积是可选参数。<code>make</code> 创建的切片会在底层分配一个切片所引用的新数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>



<p><code>make</code> 的作用就是创建新数组并切分它，所以下面两种写法是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">new</span>([<span class="number">100</span>]<span class="type">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br></pre></td></tr></table></figure>



<p>与数组相同，切片一般是一维的，不过也可以复合成多维。数组中的数组都必须是相同的长度，但是切片中的切片长度是动态变化的，不过切片中的切片需要单独初始化。</p>
<h4 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h4><p>结构体是一个命名元素序列，命名元素也叫做字段，每个字段都对应一个名称和类型，字段的名字可以是显式指定的（标识符列表）也可以是隐式的（嵌入字段）。在结构体中非空字段具有唯一性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">StructType    = <span class="string">&quot;struct&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; FieldDecl <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .</span><br><span class="line">EmbeddedField = [ <span class="string">&quot;*&quot;</span> ] TypeName .</span><br><span class="line">Tag           = string_lit .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空结构体.</span></span><br><span class="line"><span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6个字段的结构体.</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="type">int</span></span><br><span class="line">	u <span class="type">float32</span></span><br><span class="line">	_ <span class="type">float32</span>  <span class="comment">// padding</span></span><br><span class="line">	A *[]<span class="type">int</span></span><br><span class="line">	F <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个指定了类型而没有指定名称的字段叫做嵌入字段，嵌入字段必须指定类型名 T 或指向非接口类型的指针类型 *T，其中 T 不能为指针类型。或者一个非接口类型的指针。并且T本身不能为指针类型。这种情况下会把类型名作为字段的名字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个包含 4 个嵌入字段 T1, *T2, P.T3 和 *P.T4 的结构体</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	T1        <span class="comment">// 字段名为 T1</span></span><br><span class="line">	*T2       <span class="comment">// 字段名为 T2</span></span><br><span class="line">	P.T3      <span class="comment">// 字段名为 T3</span></span><br><span class="line">	*P.T4     <span class="comment">// 字段名为 T4</span></span><br><span class="line">	x, y <span class="type">int</span>  <span class="comment">// 字段名为 x 和 y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以下声明是错误的因为字段名称必须唯一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	T     <span class="comment">// 嵌入字段 *T 与 *P.T 冲突</span></span><br><span class="line">	*T    <span class="comment">// 嵌入字段 T 与 *P.T 冲突</span></span><br><span class="line">	*P.T  <span class="comment">// 嵌入字段 T 与 *T 冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果 <code>x.f</code> 是表示该字段或方法 <code>f</code> 的合法选择器，则会调用结构 <code>x</code> 中嵌入字段的字段或方法 <code>f</code>。</p>
<p>从嵌入字段组合来的字段与结构体原来的字段行为基本相同，只是不能在结构体的复合字面值中直接使用。</p>
<p>给定一个结构体 S 和一个类型 T，依据以下规则生成组合后的方法集：</p>
<ul>
<li>如果 S 包含嵌入字段 T，则 S 和 *S 的方法集包括接收者为 T 的方法集，而 *S 包括 接收者为 *T 的方法集。</li>
<li>如果 S 包含字段 <em>T。那么S和</em>S均包含接收者为 T 和 *T 的所有方法集。</li>
</ul>
<p>声明字段时可以给该字段添加一个字符串的 tag。这个 tag 将会成为它所对应字段的一个属性。空 tag 和缺省 tag 是相同的。tag 的值可以通过反射的接口获取，可以作为类型结构体的类型定义的一部分，也可以忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="type">float64</span> <span class="string">&quot;&quot;</span>  <span class="comment">// 空 tag 和缺省 tag 相同</span></span><br><span class="line">	name <span class="type">string</span>  <span class="string">&quot;any string is permitted as a tag&quot;</span></span><br><span class="line">	_    [<span class="number">4</span>]<span class="type">byte</span> <span class="string">&quot;ceci n&#x27;est pas un champ de structure&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体对应一个 TimeStamp 的 protocol buffer.</span></span><br><span class="line"><span class="comment">// tag 字符串中定义了 protocol buffer 字段对应的数字;</span></span><br><span class="line"><span class="comment">// 一般使用 reflect 包读取他们.</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	microsec  <span class="type">uint64</span> <span class="string">`protobuf:&quot;1&quot;`</span></span><br><span class="line">	serverIP6 <span class="type">uint64</span> <span class="string">`protobuf:&quot;2&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>指针类型表示所有指向给定类型变量的指针集合。这个指定的类型叫做指针的基础类型。没有初始化的指针值为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PointerType = <span class="string">&quot;*&quot;</span> BaseType .</span><br><span class="line">BaseType    = Type .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*Point</span><br><span class="line">*[<span class="number">4</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>



<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>函数类型可以表示所有具有相同参数类型和返回值类型的函数。未初始化的函数类型值为 nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FunctionType   = <span class="string">&quot;func&quot;</span> Signature .</span><br><span class="line">Signature      = Parameters [ Result ] .</span><br><span class="line">Result         = Parameters | Type .</span><br><span class="line">Parameters     = <span class="string">&quot;(&quot;</span> [ ParameterList [ <span class="string">&quot;,&quot;</span> ] ] <span class="string">&quot;)&quot;</span> .</span><br><span class="line">ParameterList  = ParameterDecl &#123; <span class="string">&quot;,&quot;</span> ParameterDecl &#125; .</span><br><span class="line">ParameterDecl  = [ IdentifierList ] [ <span class="string">&quot;...&quot;</span> ] Type .</span><br></pre></td></tr></table></figure>



<p>在参数和返回值列表中，标识符列表必须同时存在或缺省。如果存在，那么每个名字都表示指定类型的一个参数&#x2F;返回值，这些标识符必须非空并且不能重复。如果缺省，指定类型的参数&#x2F;返回值使用对应的类型表示。参数列表和返回值列表一般都是需要加括号，不过在只有一个缺省返回值时，它可以不使用括号。</p>
<p>函数的最后一个参数可以添加前缀 <code>...</code>。包含这种参数的函数叫做变参函数，它可以接收零个或多个参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, _ <span class="type">int</span>, z <span class="type">float32</span>)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>, z <span class="type">float32</span>)</span></span> (<span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(prefix <span class="type">string</span>, values ...<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>, z <span class="type">float64</span>, opt ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (success <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, *[]<span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(p *T)</span></span></span><br></pre></td></tr></table></figure>



<h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><p>接口类型指定了一个方法集。一个接口类型变量可以保存任何方法集是该接口超集的类型。我们可以认为类型实现了接口。没有初始化的接口类型值为 nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">InterfaceType      = <span class="string">&quot;interface&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; MethodSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">MethodSpec         = MethodName Signature | InterfaceTypeName .</span><br><span class="line">MethodName         = identifier .</span><br><span class="line">InterfaceTypeName  = TypeName .</span><br></pre></td></tr></table></figure>



<p>在接口类型的方法集中，每个方法的名称必须是非空且唯一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple File interface</span></span><br><span class="line"><span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(b Buffer) <span class="type">bool</span></span><br><span class="line">	Write(b Buffer) <span class="type">bool</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口可以由多个类型实现，例如：类型 <code>S1</code> 和类型 <code>S2</code> 都有以下方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Read(b Buffer) <span class="type">bool</span> &#123; <span class="keyword">return</span> … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Write(b Buffer) <span class="type">bool</span> &#123; <span class="keyword">return</span> … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Close() &#123; … &#125;</span><br></pre></td></tr></table></figure>



<p>（这里的类型 T 可以表示 <code>S1</code> 也可以表示 <code>S2</code> ） <code>S1</code> 和 <code>S2</code> 都实现了接口 <code>File</code>，而不用管类型是否还有其他方法。</p>
<p>一个类型实现了任何方法集的为其子集的接口。因此它可能实现了多个不同接口。例如：所有的类型都实现了空接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>与之相似，思考下面这个定义为 <code>Locker</code> 的接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lock()</span><br><span class="line">	Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果 <code>S1</code> 和 <code>S2</code> 也实现了它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Lock() &#123; … &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p T)</span></span> Unlock() &#123; … &#125;</span><br></pre></td></tr></table></figure>



<p>那它们就实现了两个接口 <code>Locker</code> 和 <code>File</code>。</p>
<p>一个接口 T 可以使用另一个接口 E 来指定方法。这种方式叫做将接口 E 嵌入进接口 T。它把 E 中所有的方法（包括导出和未导出的方法）全部添加进接口 T。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(b Buffer) <span class="type">bool</span></span><br><span class="line">	Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadWriter  <span class="comment">// 与添加 ReadWriter 接口中的方法是等价的</span></span><br><span class="line">	Locker      <span class="comment">// 与添加 Locker 接口中的方法是等价的 </span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LockedFile <span class="keyword">interface</span> &#123;</span><br><span class="line">	Locker</span><br><span class="line">	File        <span class="comment">// 无效: Lock, Unlock 不是唯一的</span></span><br><span class="line">	Lock()      <span class="comment">// 无效: Lock 不是唯一的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口 T 不能递归的嵌入进自己或已经嵌入过它的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无效: Bad 不能嵌入它自己</span></span><br><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bad</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效: Bad1 不能嵌入已经引用它的 Bad2</span></span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bad2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Bad1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><p>map 类型是一种以唯一值作为键的无序集合。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MapType     = <span class="string">&quot;map&quot;</span> <span class="string">&quot;[&quot;</span> KeyType <span class="string">&quot;]&quot;</span> ElementType .</span><br><span class="line">KeyType     = Type .</span><br></pre></td></tr></table></figure>



<p>map的键类型必须能使用比较运算符 <code>==</code> 和 <code>!=</code> 进行比较。因此它的键类型不能是函数，map，或者切片。如果键是接口类型，那么比较运算符必须能比较他的动态值。如果不能会抛出一个运行时错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">map</span>[*T]<span class="keyword">struct</span>&#123; x, y <span class="type">float64</span> &#125;</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>map中元素的个数叫做它的长度。对于一个map <code>m</code>。它的长度可以通过内置函数 <code>len</code> 获得，而且它的长度可能再运行时发生变化。map 可以再运行时添加和取回元素，页可以使用内置函数 <code>delete</code>移除元素。</p>
<p>可以使用内置函数 <code>make</code> 初始化一个新的且为空的 map。它能指定 map 的类型和预留的空间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>



<p>map 的预留空间不会固定住 map 的长度；它可以通过添加一定数量的元素来增加自己的长度（nil map 不能添加元素）。nil map 和空 map 是相等的，只是 nil map 不能添加元素。</p>
<h4 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h4><p>channel提供一种手段在并发执行的函数间发送和接收指定类型的值。没有初始化的 channel 是nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ChannelType = ( <span class="string">&quot;chan&quot;</span> | <span class="string">&quot;chan&quot;</span> <span class="string">&quot;&lt;-&quot;</span> | <span class="string">&quot;&lt;-&quot;</span> <span class="string">&quot;chan&quot;</span> ) ElementType .</span><br></pre></td></tr></table></figure>



<p>操作符 <code>&lt;-</code> 可以指定 channel 的数据流动方向。如果没有指定方向，channel 默认是双向的。channel 可以通过转换和赋值来限制只读和只写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送 T 类型的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">float64</span>  <span class="comment">// 只能发送 float64 类型的值</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span>      <span class="comment">// 只能接收</span></span><br></pre></td></tr></table></figure>



<p><code>&lt;-</code> 与最左侧的 <code>chan</code> 关联：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">chan</span> <span class="type">int</span>    <span class="comment">// 等价于 chan&lt;- (chan int)</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- &lt;-<span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">// 等价于 chan&lt;- (&lt;-chan int)</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">// 等价于 &lt;-chan (&lt;-chan int)</span></span><br><span class="line"><span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>



<p>可以通过内置的 <code>make</code> 函数初始化 channel。<code>make</code> 函数可以指定channel的类型和容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>



<p>容量是设置了最大能缓存元素的数量。如果没有设置容量或值为 0，channel 就是没有缓存的，这时只有当发送者和接收者都准备好后才会传输数据。而带缓存的 channel 在缓存没有满的时候依然可以成功发送数据，当缓存不为空的时候可以成功接收到数据，值为 nil 的 channel 不能传输数据。</p>
<p>可以通过内置函数 <code>close</code> 关闭 channel。在接收端的第二个返回值可以用来提示接收者在关闭的 channel 是否还包含数据。</p>
<p>channel 可以在发送语句，接收操作中使用。可以不考虑同步性直接在多个 goroutine 中对 channel 调用内置函数 <code>len</code> 和 <code>cap</code> 。channel 的行为和 FIFO 队列相同。举个例子，一个 goruntine 发送数据，另一个 goruntine 接收他们，接收数据的顺序和发送数据的顺序是相同的。</p>
<h2 id="类型的属性和值"><a href="#类型的属性和值" class="headerlink" title="类型的属性和值"></a>类型的属性和值</h2><h4 id="类型标识"><a href="#类型标识" class="headerlink" title="类型标识"></a>类型标识</h4><p>两个类型可能相同也可能不同。</p>
<p>定义的类型都是不同类型。如果两个类型的底层类型在结构上是相同的，那它们也是相等的。总的来说：</p>
<ul>
<li><p>2 个数组的长度和元素类型相同，那么它们就是相同类型。</p>
</li>
<li><p>如果两个切片的元素类型相同那么它们就是相同类型。</p>
</li>
<li><p>如果两个结构体字段顺序相同，并且字段名称、字段类型和 tag 都相同那么它们就是相等的。非导出字段的字段名在不同的包中总是不同的。</p>
</li>
<li><p>如果两个指针的基础类型相同那么他们具有相同类型。</p>
</li>
<li><p>如果两个函数具有相同的参数和返回值列表，并且他们的类型相同那么他们就是相同的，参数的名称不一定要相同。</p>
</li>
<li><p>如果两个接口的方法集完全相同（方法的顺序）。</p>
</li>
<li><p>如果两个 map 类型的键类型和值类型相同那它们就是相等的。</p>
</li>
<li><p>如果两个 channel 类型包含的对象类型和 channel 的方向都是相同的那它们就是相同的。</p>
</li>
</ul>
<p>给出下列声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	A0 = []<span class="type">string</span></span><br><span class="line">	A1 = A0</span><br><span class="line">	A2 = <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125;</span><br><span class="line">	A3 = <span class="type">int</span></span><br><span class="line">	A4 = <span class="function"><span class="keyword">func</span><span class="params">(A3, <span class="type">float64</span>)</span></span> *A0</span><br><span class="line">	A5 = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, _ <span class="type">float64</span>)</span></span> *[]<span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	B0 A0</span><br><span class="line">	B1 []<span class="type">string</span></span><br><span class="line">	B2 <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125;</span><br><span class="line">	B3 <span class="keyword">struct</span>&#123; a, c <span class="type">int</span> &#125;</span><br><span class="line">	B4 <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">float64</span>)</span></span> *B0</span><br><span class="line">	B5 <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">float64</span>)</span></span> *A1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>	C0 = B0</span><br></pre></td></tr></table></figure>



<p>这些类型是相等的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A0, A1, and []<span class="type">string</span></span><br><span class="line">A2 and <span class="keyword">struct</span>&#123; a, b <span class="type">int</span> &#125;</span><br><span class="line">A3 and <span class="type">int</span></span><br><span class="line">A4, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">float64</span>)</span></span> *[]<span class="type">string</span>, and A5</span><br><span class="line"></span><br><span class="line">B0, B0, and C0</span><br><span class="line">[]<span class="type">int</span> and []<span class="type">int</span></span><br><span class="line"><span class="keyword">struct</span>&#123; a, b *T5 &#125; and <span class="keyword">struct</span>&#123; a, b *T5 &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">float64</span>)</span></span> *[]<span class="type">string</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">float64</span>)</span></span> (result *[]<span class="type">string</span>), and A5</span><br></pre></td></tr></table></figure>



<p>B0 和 B1 不是一种类型因为它们是通过类型定义方式分别定义的；<code>func(int, float64) *B0</code> 和 <code>func(x int, y float64) *[]string</code> 是不同的，因为 B0 和 []string 不是相同类型。</p>
<h4 id="可分配性"><a href="#可分配性" class="headerlink" title="可分配性"></a>可分配性</h4><p>在以下情况下，可以将 x 分配给类型为 T 的变量（把 x 分配给 T）：</p>
<ul>
<li><p>x 的类型为 T</p>
</li>
<li><p>x 的类型 V 和 T 有相同的底层类型并且类型 T 或 V 至少一个定义的类型</p>
</li>
<li><p>T 是一个接口类型并且 x 实现了 T</p>
</li>
<li><p>x 是一个 channel，并且 T 是channel类型，类型V和类型T有相同的元素类型，并且 2 种类型至少有一种不是定义的类型</p>
</li>
<li><p>x 等于 nil 并且 T 是一个指针，函数，切片，map，channel 或接口类型</p>
</li>
<li><p>x 是一个可以表示 T 类型值的无类型常量</p>
</li>
</ul>
<h4 id="代表性"><a href="#代表性" class="headerlink" title="代表性"></a>代表性</h4><p>满足以下条件时可以用 T 类型的值表示常量 x：</p>
<ul>
<li><p>T 值的集合包括 x</p>
</li>
<li><p>T 是浮点型，而 x 在没有溢出的情况下能够近似成 T 类型。近似规则使用 <code>IEEE 754 round-to-even</code>，负零和无符号的零相同。需要注意的是，常量的值不会为负零，NaN，或无限值。</p>
</li>
<li><p>T 为复数类型，并且 x 的 <code>real(x)</code> 和 <code>imag(x)</code> 部分由复数类型对应的浮点类型（<code>float32</code> 或 <code>float64</code> ）组成。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x                   T           x 可以表示 T 的值，因为：</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>                 <span class="type">byte</span>        <span class="number">97</span> 在 <span class="type">byte</span> 类型值的集合中</span><br><span class="line"><span class="number">97</span>                  <span class="type">rune</span>        <span class="type">rune</span> 是 <span class="type">int32</span> 的别名，<span class="number">97</span> 在 <span class="number">32</span> 位整型值的集合中</span><br><span class="line"><span class="string">&quot;foo&quot;</span>               <span class="type">string</span>      <span class="string">&quot;foo&quot;</span> 在字符串值的集合中</span><br><span class="line"><span class="number">1024</span>                <span class="type">int16</span>       <span class="number">1024</span> 在 <span class="number">16</span> 位整型值的集合中</span><br><span class="line"><span class="number">42.0</span>                <span class="type">byte</span>        <span class="number">42</span> 在 <span class="number">8</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">1e10</span>                <span class="type">uint64</span>      <span class="number">10000000000</span> 在 <span class="number">64</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">2.718281828459045</span>   <span class="type">float32</span>     <span class="number">2.718281828459045</span> 的近似值 <span class="number">2.7182817</span> 在 <span class="type">float32</span> 类型值的集合中</span><br><span class="line"><span class="number">-1e-1000</span>            <span class="type">float64</span>     <span class="number">-1e-1000</span> 的近视值 IEEE <span class="number">-0.0</span>，等于 <span class="number">0</span> </span><br><span class="line"><span class="number">0i</span>                  <span class="type">int</span>         <span class="number">0</span> 是整型值</span><br><span class="line">(<span class="number">42</span> + <span class="number">0i</span>)           <span class="type">float32</span>     <span class="number">42.0</span> (<span class="number">0</span> 虚部) 在 <span class="type">float32</span> 类型值的集合中</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x                   T           x 不能表示 T 的值，因为：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>                   <span class="type">bool</span>        <span class="number">0</span> 不在布尔值的集合中</span><br><span class="line"><span class="string">&#x27;a&#x27;</span>                 <span class="type">string</span>      <span class="string">&#x27;a&#x27;</span> 是 <span class="type">rune</span> 类型, 它不在字符串类型的值集合中</span><br><span class="line"><span class="number">1024</span>                <span class="type">byte</span>        <span class="number">1024</span> 不在 <span class="number">8</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">-1</span>                  <span class="type">uint16</span>      <span class="number">-1</span> 不在 <span class="number">16</span> 位无符号整型值的集合中</span><br><span class="line"><span class="number">1.1</span>                 <span class="type">int</span>         <span class="number">1.1</span> 不是整型值</span><br><span class="line"><span class="number">42i</span>                 <span class="type">float32</span>     (<span class="number">0</span> + <span class="number">42i</span>) 不在 <span class="type">float32</span> 类型值的集合中</span><br><span class="line"><span class="number">1e1000</span>              <span class="type">float64</span>     <span class="number">1e1000</span> 取近似值时会溢出成 IEEE</span><br></pre></td></tr></table></figure>



<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块是用大括号括起来的声明和语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Block = <span class="string">&quot;&#123;&quot;</span> StatementList <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">StatementList = &#123; Statement <span class="string">&quot;;&quot;</span> &#125; .</span><br></pre></td></tr></table></figure>



<p>除了源码中显式的代码块，也有一些隐式的代码块。</p>
<ul>
<li><p>包含所有的Go代码的全局代码块。</p>
</li>
<li><p>包含所有包的代码的包代码块。</p>
</li>
<li><p>包含文件内的所有代码的文件代码块。</p>
</li>
<li><p>每个 if，switch和 for 的范围都会形成隐式的块。</p>
</li>
<li><p>每个 switch 和 select 条件都有自己的代码块。</p>
</li>
</ul>
<p>代码块可以嵌套并且影响作用域。</p>
<h2 id="声明和作用域"><a href="#声明和作用域" class="headerlink" title="声明和作用域"></a>声明和作用域</h2><p>一段声明可以给常量，类型，变量，函数，标签，和包绑定标识符。程序中每个标识符都需要声明。相同标识符不能在同一个代码块中声明2次。并且相同标识符不能同时在文件和 package 代码块中声明。</p>
<p>空标识符可以和其他标识符一样在声明中使用。不过它不绑定标识符，等于没有声明。在 package 代码块中 <code>init</code> 标识符只能用做 <code>init</code> 函数的标识符，就像空标识符一样，它不会引入新的绑定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Declaration   = ConstDecl | TypeDecl | VarDecl .</span><br><span class="line">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span><br></pre></td></tr></table></figure>



<p>声明过的标识符的作用域就是声明标识符所在的作用域。</p>
<p>go使用块来规定词汇的方位：</p>
<ul>
<li><p>预定义的标识符具有全局作用域。</p>
</li>
<li><p>所有定义的顶级标识符具有包作用域。</p>
</li>
<li><p>import进来的包的名字标识符具有文件作用域。</p>
</li>
<li><p>方法的接收者，函数参数，返回值变量具有函数作用域。</p>
</li>
<li><p>函数内定义的参量和变量标识符的作用域是标识符被声明到容纳他的块结束。</p>
</li>
</ul>
<p>一个代码块中声明的标识符可以在它内部的代码块中重新声明。在内部代码块的作用域中标识符表示在内部代码块中声明的实体。</p>
<p>pakcage 语句不属于声明。包名不会出现在任何的作用域中。它的作用只是用来标识属于相同包的多个文件并在导入时指定默认包名。</p>
<h4 id="标签的作用域"><a href="#标签的作用域" class="headerlink" title="标签的作用域"></a>标签的作用域</h4><p>可以使用标签语句来声明标签，并且可以在 <code>break</code>，<code>continue</code>，<code>goto</code> 语法中使用。如果只声明但没有使用标签时非法的。标签的作用域只有定义时的函数体，早递归函数体中没有作用。</p>
<h4 id="空标识符"><a href="#空标识符" class="headerlink" title="空标识符"></a>空标识符</h4><p>空标识符使用下划线 <code>_</code> 代表。与一般的非空标识符不同，它作为匿名标识符在声明，运算元和赋值语句中都有特殊含义。</p>
<h4 id="预定义的标识符"><a href="#预定义的标识符" class="headerlink" title="预定义的标识符"></a>预定义的标识符</h4><p>以下标识符已经在全局作用域中预先声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Types:</span><br><span class="line">	<span class="type">bool</span> <span class="type">byte</span> <span class="type">complex64</span> <span class="type">complex128</span> <span class="type">error</span> <span class="type">float32</span> <span class="type">float64</span></span><br><span class="line">	<span class="type">int</span> <span class="type">int8</span> <span class="type">int16</span> <span class="type">int32</span> <span class="type">int64</span> <span class="type">rune</span> <span class="type">string</span></span><br><span class="line">	<span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">Constants:</span><br><span class="line">	<span class="literal">true</span> <span class="literal">false</span> <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">Zero value:</span><br><span class="line">	<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Functions:</span><br><span class="line">	<span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">close</span> <span class="built_in">complex</span> <span class="built_in">copy</span> <span class="built_in">delete</span> <span class="built_in">imag</span> <span class="built_in">len</span></span><br><span class="line">	<span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">panic</span> <span class="built_in">print</span> <span class="built_in">println</span> <span class="built_in">real</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>



<h4 id="导出标识符"><a href="#导出标识符" class="headerlink" title="导出标识符"></a>导出标识符</h4><p>标识符可以导出供其他包使用。在以下两种情况同时满足时标识符是导出的：</p>
<ul>
<li>标识符的首字母是大写（Unicode 的 <code>Lu</code> 类）</li>
<li>标识符声明在包作用域或者它是字段名&#x2F;方法名。</li>
</ul>
<p>其他任何标识符都不是导出的。</p>
<h4 id="标识符的唯一性"><a href="#标识符的唯一性" class="headerlink" title="标识符的唯一性"></a>标识符的唯一性</h4><p>给定一个标识符集合，一个标识符与集合中的每个标识符都不相同，那就认为这个标识符是唯一的。假设有两个标识符，如果它们的拼写不同，或者它们在不同的包中并没有导出，那它们就是不同标识符。相反，其他情况下都认为标识符是相同的。</p>
<h4 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h4><p>常量声明使用常量表达式绑定一系列标识符。标识符的数量必须等于表达式的数量。左侧第 n 个标识符绑定右侧第 n 个表达式的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ConstDecl      = <span class="string">&quot;const&quot;</span> ( ConstSpec | <span class="string">&quot;(&quot;</span> &#123; ConstSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;)&quot;</span> ) .</span><br><span class="line">ConstSpec      = IdentifierList [ [ Type ] <span class="string">&quot;=&quot;</span> ExpressionList ] .</span><br><span class="line"></span><br><span class="line">IdentifierList = identifier &#123; <span class="string">&quot;,&quot;</span> identifier &#125; .</span><br><span class="line">ExpressionList = Expression &#123; <span class="string">&quot;,&quot;</span> Expression &#125; .</span><br></pre></td></tr></table></figure>



<p>如果给定类型，常量会指定类型，并且表达式的值必须能对这个类型进行赋值。</p>
<p>如果没有给定类型。常量会转换成相应的表达式类型。如果表达式的值是无类型常量，那么声明的常量也是无类型的，并且常量的标识符代表常量的值。例如：即使小数部分是 0，只要表达式是浮点数字面值，常量标识符也表示为浮点数常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span>         <span class="comment">// 无类型浮点数常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">	eof        = <span class="number">-1</span>  <span class="comment">// 无类型整型常量</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span>  <span class="comment">// a = 3, b = 4, c = &quot;foo&quot;, 无类型整型和字符串常量</span></span><br><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span>    <span class="comment">// u = 0.0, v = 3.0</span></span><br></pre></td></tr></table></figure>



<p>括号内的常量声明列表的表达式除了第一个必须声明其他表达式可以不写。空的表达式列表的值和类型都和前面的非空表达式相同。缺省的表达式列表等价于重复之前的表达式。标识符的数量必须等于表达式的数量。<code>iota</code>常量生成器是一个可以快速生成序列值的机制。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Sunday = <span class="literal">iota</span></span><br><span class="line">	Monday</span><br><span class="line">	Tuesday</span><br><span class="line">	Wednesday</span><br><span class="line">	Thursday</span><br><span class="line">	Friday</span><br><span class="line">	Partyday</span><br><span class="line">	numberOfDays  <span class="comment">// 非导出常量</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="Iota"><a href="#Iota" class="headerlink" title="Iota"></a>Iota</h4><p>在常量声明中，预定义的标识符 <code>iota</code> 表示连续的无类型整型常量。它的值为常量声明中每个常量定义的位置（从零开始）。它能够用来生成一个关联常量集合：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></span><br><span class="line">	c0 = <span class="literal">iota</span>  <span class="comment">// c0 == 0</span></span><br><span class="line">	c1 = <span class="literal">iota</span>  <span class="comment">// c1 == 1</span></span><br><span class="line">	c2 = <span class="literal">iota</span>  <span class="comment">// c2 == 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></span><br><span class="line">	a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// a == 1</span></span><br><span class="line">	b = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// b == 2</span></span><br><span class="line">	c = <span class="number">3</span>          <span class="comment">// c == 3  (没有使用 iota 不过它的值依然递增)</span></span><br><span class="line">	d = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// d == 8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// iota is reset to 0</span></span><br><span class="line">	u         = <span class="literal">iota</span> * <span class="number">42</span>  <span class="comment">// u == 0     (无类型整型常量)</span></span><br><span class="line">	v <span class="type">float64</span> = <span class="literal">iota</span> * <span class="number">42</span>  <span class="comment">// v == 42.0  (float64 类型常量)</span></span><br><span class="line">	w         = <span class="literal">iota</span> * <span class="number">42</span>  <span class="comment">// w == 84    (无类型整型常量)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="literal">iota</span>  <span class="comment">// x == 0  (iota 被重置)</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="literal">iota</span>  <span class="comment">// y == 0  (iota 被重置)</span></span><br></pre></td></tr></table></figure>



<p>根据定义，在同一个常量定义中多次使用 <code>iota</code> 会得到相同的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	bit0, mask0 = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>, <span class="number">1</span>&lt;&lt;<span class="literal">iota</span> - <span class="number">1</span>  <span class="comment">// bit0 == 1, mask0 == 0  (iota == 0)</span></span><br><span class="line">	bit1, mask1                           <span class="comment">// bit1 == 2, mask1 == 1  (iota == 1)</span></span><br><span class="line">	_, _                                  <span class="comment">//                        (iota == 2, unused)</span></span><br><span class="line">	bit3, mask3                           <span class="comment">// bit3 == 8, mask3 == 7  (iota == 3)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>最后一个例子利用了最后一个非空表达式列表的隐式重复。</p>
<h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><p>类型声明为类型绑定一个标识符。类型声明有2种方式：类型声明和别名声明。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TypeDecl = <span class="string">&quot;type&quot;</span> ( TypeSpec | <span class="string">&quot;(&quot;</span> &#123; TypeSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;)&quot;</span> ) .</span><br><span class="line">TypeSpec = AliasDecl | TypeDef .</span><br></pre></td></tr></table></figure>



<h5 id="Alias声明"><a href="#Alias声明" class="headerlink" title="Alias声明"></a>Alias声明</h5><p>别名声明给指定类型绑定一个标识符名称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">AliasDecl = identifier <span class="string">&quot;=&quot;</span> Type .</span><br></pre></td></tr></table></figure>



<p>在标识符作用域内，它作为类型的别名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	nodeList = []*Node  <span class="comment">// nodeList 和 []*Node 是相同类型</span></span><br><span class="line">	Polar    = polar    <span class="comment">// Polar 和 polar 表示相同类型</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="Type-定义"><a href="#Type-定义" class="headerlink" title="Type 定义"></a>Type 定义</h5><p>类型定义会创建一个新类型并绑定一个标识符，新类型与给定类型具有相同的底层类型和操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TypeDef = identifier Type .</span><br></pre></td></tr></table></figure>



<p>这个类型叫做定义类型，它和其他所有类型都不相同，包括创建它的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Point <span class="keyword">struct</span>&#123; x, y <span class="type">float64</span> &#125;  <span class="comment">// Point 和 struct&#123; x, y float64 &#125; 是不同类型</span></span><br><span class="line">	polar Point                   <span class="comment">// polar 和 Point 表示不同类型</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	left, right *TreeNode</span><br><span class="line">	value *Comparable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">	BlockSize() <span class="type">int</span></span><br><span class="line">	Encrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">	Decrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义类型可以关联该类型的方法。它不会继承原来类型的任何方法。但是接口类型的方法集和类型的结构没有改变。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mutex 是一个拥有 Lock 和 Unlock 两个方法的数据类型。</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span>         &#123; <span class="comment">/* Mutex fields */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock()    &#123; <span class="comment">/* Lock implementation */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()  &#123; <span class="comment">/* Unlock implementation */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMutex 与 Mutex 结构相同不过方法集为空。</span></span><br><span class="line"><span class="keyword">type</span> NewMutex Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrMutex 的底层类型 *Mutex 的方法集没有改变，</span></span><br><span class="line"><span class="comment">// 但是 PtrMutex 的方法集为空。</span></span><br><span class="line"><span class="keyword">type</span> PtrMutex *Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// *PrintableMutex 包含嵌入字段 Mutex 的 Lock 和 Unlock 方法。</span></span><br><span class="line"><span class="keyword">type</span> PrintableMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBlock 是与 Block 有相同方法集的接口类型</span></span><br><span class="line"><span class="keyword">type</span> MyBlock Block</span><br></pre></td></tr></table></figure>



<p>类型定义可以定义方法集不同的布尔值、数字和字符串类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TimeZone <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	EST TimeZone = -(<span class="number">5</span> + <span class="literal">iota</span>)</span><br><span class="line">	CST</span><br><span class="line">	MST</span><br><span class="line">	PST</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tz TimeZone)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;GMT%+dh&quot;</span>, tz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>变量声明可以创建一个或多个变量，并绑定对应的标识符、指定类型和初始值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">VarDecl     = <span class="string">&quot;var&quot;</span> ( VarSpec | <span class="string">&quot;(&quot;</span> &#123; VarSpec <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;)&quot;</span> ) .</span><br><span class="line">VarSpec     = IdentifierList ( Type [ <span class="string">&quot;=&quot;</span> ExpressionList ] | <span class="string">&quot;=&quot;</span> ExpressionList ) .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> U, V, W <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">float32</span> = <span class="number">-1</span>, <span class="number">-2</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	i       <span class="type">int</span></span><br><span class="line">	u, v, s = <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="string">&quot;bar&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> re, im = complexSqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">var</span> _, found = entries[name]  <span class="comment">// map lookup; only interested in &quot;found&quot;</span></span><br></pre></td></tr></table></figure>



<p>如果给定一个表达式列表。变量会根据赋值规则使用表达式进行初始化。否则，每个变量都会初始化成变量类型的零值。</p>
<p>如果指定类型，变量会为指定类型。如果没有指定类型，变量会使用分配的初始值类型。如果初始值为无类型常量，它会转换成初始值的默认类型。如果是一个无类型布尔值，那么变量的类型就是 <code>bool</code>。值 <code>nil</code> 不能给没有指定类型的变量赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = math.Sin(<span class="number">0.5</span>)  <span class="comment">// d is float64</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">42</span>             <span class="comment">// i is int</span></span><br><span class="line"><span class="keyword">var</span> t, ok = x.(T)      <span class="comment">// t is T, ok is bool</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">nil</span>            <span class="comment">// illegal</span></span><br></pre></td></tr></table></figure>



<p>实现的限制：在函数体内声明的变量如果没有使用过编译器需要报错。</p>
<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>短变量声明的语法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ShortVarDecl = IdentifierList <span class="string">&quot;:=&quot;</span> ExpressionList .</span><br></pre></td></tr></table></figure>



<p>它比正常使用初始化表达式进行变量声明的方式要短，而且不指定类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;var&quot;</span> IdentifierList = ExpressionList .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, j := <span class="number">0</span>, <span class="number">10</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">7</span> &#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">r, w := os.Pipe(fd)  <span class="comment">// os.Pipe() 返回两个值</span></span><br><span class="line">_, y, _ := coord(p)  <span class="comment">// coord() 返回三个值，我们只关注 y</span></span><br></pre></td></tr></table></figure>



<p>和常规变量声明不同，即使之前在相同代码块中声明过的变量，也可以在短变量重新声明相同类型的变量，并且保证至少会有一个新的非空变量。总之，只应该在多变量短声明的时候重新声明变量，重新声明并不会使用新的变量，而是给变量分配新值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">field1, offset := nextField(str, <span class="number">0</span>)</span><br><span class="line">field2, offset := nextField(str, offset)  <span class="comment">// 重新声明 offset</span></span><br><span class="line">a, a := <span class="number">1</span>, <span class="number">2</span>                              <span class="comment">// 非法：声明了 a 两次并且没有新的变量</span></span><br></pre></td></tr></table></figure>



<p>短变量声明只能在函数中使用，例如在 <code>if</code>、<code>for</code>、<code>switch</code>语句的上下文中声明临时变量。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明为函数绑定标识符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FunctionDecl = <span class="string">&quot;func&quot;</span> FunctionName Signature [ FunctionBody ] .</span><br><span class="line">FunctionName = identifier .</span><br><span class="line">FunctionBody = Block .</span><br></pre></td></tr></table></figure>



<p>如果函数指定了返回参数。函数体的语句必须以终止语句结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="type">string</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">   	<span class="keyword">if</span> c == r &#123;</span><br><span class="line">   		<span class="keyword">return</span> i</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 无效：缺少 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数声明可以没有函数体。这样的声明提供一个函数声明，并由其他外部实现，例如汇编脚本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flushICache</span><span class="params">(begin, end <span class="type">uintptr</span>)</span></span>  <span class="comment">// 由外部实现</span></span><br></pre></td></tr></table></figure>



<h4 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h4><p>方法是一个带接收者的函数，方法声明为方法绑定标识符作为方法名并指定方法对应的接收者类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MethodDecl = <span class="string">&quot;func&quot;</span> Receiver MethodName Signature [ FunctionBody ] .</span><br><span class="line">Receiver   = Parameters .</span><br></pre></td></tr></table></figure>



<p>接收者通过在方法增加一个额外的参数来指定。这个参数必须是一个非可变参数。它的类型必须是 T 或者 T 的指针（可能包含括号）。T 被称作接收者的基础类型；它不能是指针或接口类型，并且只能在同一个包中定义方法。声明后，我们认为方法绑定了基础类型，并且可以通过 T 或 *T 选择器访问方法名。</p>
<p>非空的接收者标识符在方法签名中必须是唯一的。如果接收者的值没有在该方法中使用，那么接收者标识符可以省略。函数和方法的参数也是一样。</p>
<p>对于一个基础类型。绑定的非空的方法名必须是唯一的。如果基础类型是一个结构体，非空的方法名也不能与结构体字段重复。</p>
<p>给定一个<code>Point</code>类型。声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> Length() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(p.x * p.x + p.y * p.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> Scale(factor <span class="type">float64</span>) &#123;</span><br><span class="line">	p.x *= factor</span><br><span class="line">	p.y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为类型 <code>*Point</code>绑定了2个方法 <code>Length</code> 和 <code>Scale</code>。</p>
<p>方法的类型就是以接收者作为第一个参数的函数类型，例如 <code>Scale</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Point, factor <span class="type">float64</span>)</span></span></span><br></pre></td></tr></table></figure>



<p>但是以这种方式声明的函数并不是方法。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式通过针对运算元使用运算符和函数来获取计算值。</p>
<h4 id="运算元"><a href="#运算元" class="headerlink" title="运算元"></a>运算元</h4><p>运算元代表表达式中的一个简单的。运算元可以是字面值，非空标识符。或括号表达式。</p>
<p>空标识符只能出现在赋值声明的左侧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Operand     = Literal | OperandName | MethodExpr | <span class="string">&quot;(&quot;</span> Expression <span class="string">&quot;)&quot;</span> .</span><br><span class="line">Literal     = BasicLit | CompositeLit | FunctionLit .</span><br><span class="line">BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .</span><br><span class="line">OperandName = identifier | QualifiedIdent.</span><br></pre></td></tr></table></figure>



<h4 id="修饰标识符"><a href="#修饰标识符" class="headerlink" title="修饰标识符"></a>修饰标识符</h4><p>修饰标识符是以包名作为前缀修饰的标识符。包名和标识符都不能为空。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">QualifiedIdent = PackageName <span class="string">&quot;.&quot;</span> identifier .</span><br></pre></td></tr></table></figure>



<p>修饰标识符可以用来访问不同包（需要先导入）中的标识符。标识符必须是导出的并在包级代码块声明才能够被访问。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">math.Sin	<span class="comment">// 表示 math 包中的 Sin 函数</span></span><br></pre></td></tr></table></figure>



<h4 id="复合字面值"><a href="#复合字面值" class="headerlink" title="复合字面值"></a>复合字面值</h4><p>复合字面值能为结构体、数组、切片和 map 初始化值。它每次只能创建一个值。字面值由一个字面值类型和使用括号括起来的元素列表组成。元素前也可以声明元素对应的键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">CompositeLit  = LiteralType LiteralValue .</span><br><span class="line">LiteralType   = StructType | ArrayType | <span class="string">&quot;[&quot;</span> <span class="string">&quot;...&quot;</span> <span class="string">&quot;]&quot;</span> ElementType |</span><br><span class="line">                SliceType | MapType | TypeName .</span><br><span class="line">LiteralValue  = <span class="string">&quot;&#123;&quot;</span> [ ElementList [ <span class="string">&quot;,&quot;</span> ] ] <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">ElementList   = KeyedElement &#123; <span class="string">&quot;,&quot;</span> KeyedElement &#125; .</span><br><span class="line">KeyedElement  = [ Key <span class="string">&quot;:&quot;</span> ] Element .</span><br><span class="line">Key           = FieldName | Expression | LiteralValue .</span><br><span class="line">FieldName     = identifier .</span><br><span class="line">Element       = Expression | LiteralValue .</span><br></pre></td></tr></table></figure>



<p>字面值类型的底层类型必须是一个结构体，数组，切片或 map 类型（如果没有指定类型名就会强制执行这个约束）。元素的类型和键都必须能够分配给相应的字段的元素和键类型；没有额外的类型转换。键可以表示结构体的字段名，切片和数组的索引，map 类型的键。对于 map 字面值，所有的元素都必须有键。如果相同字段名或常量值的键对应多个元素就会报错。如果 map 类型的键为非常量类型，请看求值顺序章节。</p>
<p>结构体字面值遵循以下规则：</p>
<ul>
<li><p>在结构体中，键必须是它的字段名。</p>
</li>
<li><p>不包含任何键的元素列表的顺序需要与结构体字段的声明顺序相同。</p>
</li>
<li><p>如果一个元素指定了键，那么所有的元素都必须指定键。</p>
</li>
<li><p>包含键的元素列表不需要指定结构体的每个字字段，缺省字段会使用字段类型的零值。</p>
</li>
<li><p>字面值可以不指定元素；这样的字面值等于该类型的零值。</p>
</li>
<li><p>指定非本包的非导出字段会报错。</p>
</li>
</ul>
<p>给定声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point3D <span class="keyword">struct</span> &#123; x, y, z <span class="type">float64</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Line <span class="keyword">struct</span> &#123; p, q Point3D &#125;</span><br></pre></td></tr></table></figure>



<p>我们可以使用这种写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">origin := Point3D&#123;&#125;                            <span class="comment">// Point3D 的零值</span></span><br><span class="line">line := Line&#123;origin, Point3D&#123;y: <span class="number">-4</span>, z: <span class="number">12.3</span>&#125;&#125;  <span class="comment">// line.q.x 的零值</span></span><br></pre></td></tr></table></figure>



<p>数组和切片遵循以下规则：</p>
<ul>
<li><p>每个元素都关联一个数字索引标记元素再数组中的位置。</p>
</li>
<li><p>给元素指定的键会作为它的索引。键必须是能够表示非负的 <code>int</code> 类型值的常量；如果是指定类型的常量，那么常量必须是整型。</p>
</li>
<li><p>元素没有指定键时会使用之前的索引加一。如果第一个元素没有指定键，它的索引为零。</p>
</li>
</ul>
<p>对复合字面值取址会生成指向由字面量初始化的变量的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pointer *Point3D = &amp;Point3D&#123;y: <span class="number">1000</span>&#125;</span><br></pre></td></tr></table></figure>



<p>数组字面值需要在类型中指定数组的长度。如果提供的元素少于数组的长度，那么缺少元素的位置将会使用元素类型的零值替代。如果索引超过数组的长度会报错。<code>…</code> 表示数组的长度等于最大元素索引加一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">buffer := [<span class="number">10</span>]<span class="type">string</span>&#123;&#125;             <span class="comment">// len(buffer) == 10</span></span><br><span class="line">intSet := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;       <span class="comment">// len(intSet) == 6</span></span><br><span class="line">days := [...]<span class="type">string</span>&#123;<span class="string">&quot;Sat&quot;</span>, <span class="string">&quot;Sun&quot;</span>&#125;  <span class="comment">// len(days) == 2</span></span><br></pre></td></tr></table></figure>



<p>切片字面值底层其实就是数组字面值。因此它的长度和容量都是元素的最大索引加一。切片字面值的格式为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]T&#123;x1, x2, … xn&#125;</span><br></pre></td></tr></table></figure>



<p>可以在数组上进行切片操作从而获得切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tmp := [n]T&#123;x1, x2, … xn&#125;</span><br><span class="line">tmp[<span class="number">0</span> : n]</span><br></pre></td></tr></table></figure>



<p>在一个数组、切片或 map 类型 T 中。元素或者 map 的键可能有自己的字面值类型，如果字面值类型和元素或者键类型相同，那么对应的类型标识符可以省略。与之类似，如果元素或键的类型为 <code>*T</code>，那么它们的 <code>&amp;T</code> 也可以省略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[...]Point&#123;&#123;<span class="number">1.5</span>, <span class="number">-3.5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;     <span class="comment">// same as [...]Point&#123;Point&#123;1.5, -3.5&#125;, Point&#123;0, 0&#125;&#125;</span></span><br><span class="line">[][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;&#125;          <span class="comment">// same as [][]int&#123;[]int&#123;1, 2, 3&#125;, []int&#123;4, 5&#125;&#125;</span></span><br><span class="line">[][]Point&#123;&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;&#125;         <span class="comment">// same as [][]Point&#123;[]Point&#123;Point&#123;0, 1&#125;, Point&#123;1, 2&#125;&#125;&#125;</span></span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]Point&#123;<span class="string">&quot;orig&quot;</span>: &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;    <span class="comment">// same as map[string]Point&#123;&quot;orig&quot;: Point&#123;0, 0&#125;&#125;</span></span><br><span class="line"><span class="keyword">map</span>[Point]<span class="type">string</span>&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;: <span class="string">&quot;orig&quot;</span>&#125;    <span class="comment">// same as map[Point]string&#123;Point&#123;0, 0&#125;: &quot;orig&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PPoint *Point</span><br><span class="line">[<span class="number">2</span>]*Point&#123;&#123;<span class="number">1.5</span>, <span class="number">-3.5</span>&#125;, &#123;&#125;&#125;          <span class="comment">// same as [2]*Point&#123;&amp;Point&#123;1.5, -3.5&#125;, &amp;Point&#123;&#125;&#125;</span></span><br><span class="line">[<span class="number">2</span>]PPoint&#123;&#123;<span class="number">1.5</span>, <span class="number">-3.5</span>&#125;, &#123;&#125;&#125;          <span class="comment">// same as [2]PPoint&#123;PPoint(&amp;Point&#123;1.5, -3.5&#125;), PPoint(&amp;Point&#123;&#125;)&#125;</span></span><br></pre></td></tr></table></figure>



<p>当复合字面值使用字面值类型的类型名格式出现在 <code>if</code>、<code>for</code> 或 <code>switch</code> 语句的关键字和括号之间并且没有使用圆括号包裹的时候，会引发语法歧义。在这种特殊的情况下字面值的括号会被认为是语句的代码块。为了避免歧义，复合字面值必须用括号括起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == (T&#123;a,b,c&#125;[i]) &#123; … &#125;</span><br><span class="line"><span class="keyword">if</span> (x == T&#123;a,b,c&#125;[i]) &#123; … &#125;</span><br></pre></td></tr></table></figure>



<p>下面是合法的数组、切片和 map 的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list of prime numbers</span></span><br><span class="line">primes := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2147483647</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vowels[ch] is true if ch is a vowel</span></span><br><span class="line">vowels := [<span class="number">128</span>]<span class="type">bool</span>&#123;<span class="string">&#x27;a&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;e&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;i&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;o&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;u&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;y&#x27;</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the array [10]float32&#123;-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1&#125;</span></span><br><span class="line">filter := [<span class="number">10</span>]<span class="type">float32</span>&#123;<span class="number">-1</span>, <span class="number">4</span>: <span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">9</span>: <span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frequencies in Hz for equal-tempered scale (A4 = 440Hz)</span></span><br><span class="line">noteFrequency := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;</span><br><span class="line">	<span class="string">&quot;C0&quot;</span>: <span class="number">16.35</span>, <span class="string">&quot;D0&quot;</span>: <span class="number">18.35</span>, <span class="string">&quot;E0&quot;</span>: <span class="number">20.60</span>, <span class="string">&quot;F0&quot;</span>: <span class="number">21.83</span>,</span><br><span class="line">	<span class="string">&quot;G0&quot;</span>: <span class="number">24.50</span>, <span class="string">&quot;A0&quot;</span>: <span class="number">27.50</span>, <span class="string">&quot;B0&quot;</span>: <span class="number">30.87</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数字面值"><a href="#函数字面值" class="headerlink" title="函数字面值"></a>函数字面值</h4><p>函数字面值表示一个匿名函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FunctionLit = <span class="string">&quot;func&quot;</span> Function .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>, z <span class="type">float64</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> a*b &lt; <span class="type">int</span>(z) &#125;</span><br></pre></td></tr></table></figure>



<p>函数字面值能分配给变量或直接调用。</p>
<p>函数字面值是一个闭包。它可以引用包裹函数中的变量，这些变量在包裹函数和函数字面值之间是共享的。并且它会一直存在直到生命周期结束。</p>
<h4 id="主要表达式"><a href="#主要表达式" class="headerlink" title="主要表达式"></a>主要表达式</h4><p>主要表达式是一元和二元表达式的运算元。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PrimaryExpr =</span><br><span class="line">	Operand |</span><br><span class="line">	Conversion |</span><br><span class="line">	PrimaryExpr Selector |</span><br><span class="line">	PrimaryExpr Index |</span><br><span class="line">	PrimaryExpr Slice |</span><br><span class="line">	PrimaryExpr TypeAssertion |</span><br><span class="line">	PrimaryExpr Arguments .</span><br><span class="line"></span><br><span class="line">Selector       = <span class="string">&quot;.&quot;</span> identifier .</span><br><span class="line">Index          = <span class="string">&quot;[&quot;</span> Expression <span class="string">&quot;]&quot;</span> .</span><br><span class="line">Slice          = <span class="string">&quot;[&quot;</span> [ Expression ] <span class="string">&quot;:&quot;</span> [ Expression ] <span class="string">&quot;]&quot;</span> |</span><br><span class="line">                 <span class="string">&quot;[&quot;</span> [ Expression ] <span class="string">&quot;:&quot;</span> Expression <span class="string">&quot;:&quot;</span> Expression <span class="string">&quot;]&quot;</span> .</span><br><span class="line">TypeAssertion  = <span class="string">&quot;.&quot;</span> <span class="string">&quot;(&quot;</span> Type <span class="string">&quot;)&quot;</span> .</span><br><span class="line">Arguments      = <span class="string">&quot;(&quot;</span> [ ( ExpressionList | Type [ <span class="string">&quot;,&quot;</span> ExpressionList ] ) [ <span class="string">&quot;...&quot;</span> ] [ <span class="string">&quot;,&quot;</span> ] ] <span class="string">&quot;)&quot;</span> .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x</span><br><span class="line"><span class="number">2</span></span><br><span class="line">(s + <span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">f(<span class="number">3.1415</span>, <span class="literal">true</span>)</span><br><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">m[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">s[i : j + <span class="number">1</span>]</span><br><span class="line">obj.color</span><br><span class="line">f.p[i].x()</span><br></pre></td></tr></table></figure>



<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>对于一个 x 不是包名的主要表达式，选择器表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.f</span><br></pre></td></tr></table></figure>



<p>表示 x 的字段或方法 f（有时为 *x）。标识符 f 叫做（字段&#x2F;方法）选择器。它不能是空标识符。选择器表达式的类型就是 f 的类型。如果 x 是包名。请参考修饰标识符。</p>
<p>选择器 f 可以表示类型 T 的方法或字段 f。也可以表示类型 T 的嵌入方法或字段 f。访问 f 所需穿过的嵌套层数叫做它在类型 T 中的深度。声明在 T 中的字段或方法的深度为 0。声明在 T 的嵌入字段 A 中的方法或字段的深度等于 f 在 A 中的深度加一。</p>
<p>选择器遵循以下原则：</p>
<ul>
<li><p>对于非指针&#x2F;接口类型 T&#x2F;*T 的值 x，x.f 表示第一层的方法&#x2F;字段。如果在第一层没有对应的 f，选择器表达式就是非法的。</p>
</li>
<li><p>对于接口类型 I 的值 x，<code>x.f</code>表示动态值 x 的方法名 f。如果接口 I 的方法集中没有 f 方法，选择器就是非法的。</p>
</li>
<li><p>作为例外，如果 x 是一个指针类型并且 (*x).f 是合法的选择器表达式（只能表示字段，不能表示方法）。那么(*x).f 可以简写成 x.f。</p>
</li>
<li><p>在其他情况下，x.f 都是非法的。</p>
</li>
<li><p>如果x是指针类型，并且值为 nil，其中 f 为结构体字段。赋值或取值 x.f 会引起运行时恐慌。</p>
</li>
<li><p>如果x是接口类型，并且值为 nil。调用 x.f  会引起运行时恐慌。</p>
</li>
</ul>
<p>例如给定声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T0)</span></span> M0()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T1)</span></span> M1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	z <span class="type">int</span></span><br><span class="line">	T1</span><br><span class="line">	*T0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*T2)</span></span> M2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Q *T2</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T2     <span class="comment">// with t.T0 != nil</span></span><br><span class="line"><span class="keyword">var</span> p *T2    <span class="comment">// with p != nil and (*p).T0 != nil</span></span><br><span class="line"><span class="keyword">var</span> q Q = p</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.z          <span class="comment">// t.z</span></span><br><span class="line">t.y          <span class="comment">// t.T1.y</span></span><br><span class="line">t.x          <span class="comment">// (*t.T0).x</span></span><br><span class="line"></span><br><span class="line">p.z          <span class="comment">// (*p).z</span></span><br><span class="line">p.y          <span class="comment">// (*p).T1.y</span></span><br><span class="line">p.x          <span class="comment">// (*(*p).T0).x</span></span><br><span class="line"></span><br><span class="line">q.x          <span class="comment">// (*(*q).T0).x        (*q).x is a valid field selector</span></span><br><span class="line"></span><br><span class="line">p.M0()       <span class="comment">// ((*p).T0).M0()      M0 expects *T0 receiver</span></span><br><span class="line">p.M1()       <span class="comment">// ((*p).T1).M1()      M1 expects T1 receiver</span></span><br><span class="line">p.M2()       <span class="comment">// p.M2()              M2 expects *T2 receiver</span></span><br><span class="line">t.M2()       <span class="comment">// (&amp;t).M2()           M2 expects *T2 receiver, see section on Calls</span></span><br></pre></td></tr></table></figure>



<p>但是下面这种方式是不合法的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">q.M0()       <span class="comment">// (*q).M0 is valid but not a field selector</span></span><br></pre></td></tr></table></figure>



<h4 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h4><p>如果 M 在类型 T 的方法集中。那么 T.M 就是能够正常调用的函数。使用与 M 相同的参数只是在参数列表的最前面增加了接收者参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MethodExpr    = ReceiverType <span class="string">&quot;.&quot;</span> MethodName .</span><br><span class="line">ReceiverType  = TypeName | <span class="string">&quot;(&quot;</span> <span class="string">&quot;*&quot;</span> TypeName <span class="string">&quot;)&quot;</span> | <span class="string">&quot;(&quot;</span> ReceiverType <span class="string">&quot;)&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>假设结构体 T 有两个方法。接收者类型为 T 的 Mv 方法和接收者类型为 *T 的 Mp 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tv  T)</span></span> Mv(a <span class="type">int</span>) <span class="type">int</span>         &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;  <span class="comment">// value receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *T)</span></span> Mp(f <span class="type">float32</span>) <span class="type">float32</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;  <span class="comment">// pointer receiver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br></pre></td></tr></table></figure>



<p>表达式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">T.Mv</span><br></pre></td></tr></table></figure>



<p>将会生成一个等价于 Mv 方法只是第一个参数显式声明接受者的函数。它的签名为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tv T, a <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>这个函数能够通过接收者正常调用，以下5种方式是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Mv(<span class="number">7</span>)</span><br><span class="line">T.Mv(t, <span class="number">7</span>)</span><br><span class="line">(T).Mv(t, <span class="number">7</span>)</span><br><span class="line">f1 := T.Mv; f1(t, <span class="number">7</span>)</span><br><span class="line">f2 := (T).Mv; f2(t, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>



<p>与之类似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*T).Mp</span><br></pre></td></tr></table></figure>



<p>生成表示 Mp 的函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tp *T, f <span class="type">float32</span>)</span></span> <span class="type">float32</span></span><br></pre></td></tr></table></figure>



<p>对于一个把值作为接收者的方法，我们可以显式的从指针接收者获得函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*T).Mv</span><br></pre></td></tr></table></figure>



<p>生成表示 Mv 的函数签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tv *T, a <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>这样的函数会通过接收者间接的创建一个值作为接收者传入底层方法中。方法内不能修改接收者的值，因为它的地址是在函数的调用栈里面。</p>
<p>最后一个例子。把值作为接收者函数当做指针作为接收者的方法是非法的，因为指针接收者的方法集中不包含值类型的方法集。</p>
<p>通过函数调用语法从方法中获取函数的值。接收者作为调用函数的第一个参数。给定  <code>f :=T.Mv</code>，f 作为<code>f(t,7)</code> 进行调用而不是 <code>t.f(7)</code>。想创建一个绑定接收者的函数可以使用函数字面值或者方法值。</p>
<p>在接口类型中定义函数获取函数值是合法的。最终的函数调用会使用接口类型作为接收者。</p>
<h4 id="方法值"><a href="#方法值" class="headerlink" title="方法值"></a>方法值</h4><p>如果表达式 x 拥有静态类型 T 并且 M 在类型 T 的方法集中。x.M 叫做方法值。方法值 <code>x.M</code> 是一个函数值，这个函数和 x.M 拥有相同的参数列表。表达式 x 在计算方法值时会被保存和计算，这个拷贝的副本会作为任何接下来调用的接收者。</p>
<p>类型 T 可能是接口类型也可能不是接口类型。</p>
<p>与方法表达式中讲过的一样，假设类型 T 有两个方法：接收者类型为 T 的 Mv 和接受者类型为 *T 的 Mp ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tv  T)</span></span> Mv(a <span class="type">int</span>) <span class="type">int</span>         &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;  <span class="comment">// value receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *T)</span></span> Mp(f <span class="type">float32</span>) <span class="type">float32</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;  <span class="comment">// pointer receiver</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line"><span class="keyword">var</span> pt *T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeT</span><span class="params">()</span></span> T</span><br></pre></td></tr></table></figure>



<p>表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Mv</span><br></pre></td></tr></table></figure>



<p>生成一个类型的函数值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>以下两种调用是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Mv(<span class="number">7</span>)</span><br><span class="line">f := t.Mv; f(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>



<p>相似的，表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pt.Mp</span><br></pre></td></tr></table></figure>



<p>生成一个类型的函数值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="type">float32</span>)</span></span> <span class="type">float32</span></span><br></pre></td></tr></table></figure>



<p>与选择器相同，使用指针调用以值作为接收者的非接口方法会自动将指针解引用：<code>pt.Mv</code> 等价于 <code>(*pt).Mv</code>。</p>
<p>与方法调用相同，使用值调用以指针作为接收者的非接口方法会自动对值取址：<code>pt.Mv</code> 等价于 <code>(&amp;pt).Mv</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := t.Mv; f(<span class="number">7</span>)   <span class="comment">// like t.Mv(7)</span></span><br><span class="line">f := pt.Mp; f(<span class="number">7</span>)  <span class="comment">// like pt.Mp(7)</span></span><br><span class="line">f := pt.Mv; f(<span class="number">7</span>)  <span class="comment">// like (*pt).Mv(7)</span></span><br><span class="line">f := t.Mp; f(<span class="number">7</span>)   <span class="comment">// like (&amp;t).Mp(7)</span></span><br><span class="line">f := makeT().Mp   <span class="comment">// invalid: result of makeT() is not addressable</span></span><br></pre></td></tr></table></figure>



<p>尽管上面使用的都是非接口类型的例子，不过对于接口类型同样适用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span> &#123; M(<span class="type">int</span>) &#125; = myVal</span><br><span class="line">f := i.M; f(<span class="number">7</span>)  <span class="comment">// like i.M(7)</span></span><br></pre></td></tr></table></figure>



<h4 id="index表达式"><a href="#index表达式" class="headerlink" title="index表达式"></a>index表达式</h4><p>主要表达式格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[x]</span><br></pre></td></tr></table></figure>



<p>可以表示数组元素、数组的指针、切片、字符串或 map 类型 a 索引 x 对应的值。x 称作索引或者 map 的键。遵循以下规则：</p>
<p>如果a不是 map 类型：</p>
<ul>
<li><p>索引 x 必须是整型或无类型常量。</p>
</li>
<li><p>常量索引必须是非负数且可以使用 int 类型表示。</p>
</li>
<li><p>无类型的常量索引会作为 int 型的值。</p>
</li>
<li><p>索引 x 的范围在 <code>0&lt;=x&lt;len(a)</code> 内，否则就是越界。</p>
</li>
</ul>
<p>对于数组类型 A：</p>
<ul>
<li><p>常量索引必须在合法范围内。</p>
</li>
<li><p>如果 x 在运行时越界会引起运行时恐慌。</p>
</li>
<li><p><code>a[x]</code> 表示数组在索引 x 处的元素。<code>a[x]</code> 的类型就是 A 的元素类型。</p>
</li>
</ul>
<p>对于数组的指针类型：</p>
<ul>
<li>可以使用 <code>a[x]</code> 表示 <code>(*a)[x]</code>。</li>
</ul>
<p>对于切片类型 S：</p>
<ul>
<li>如果 x 在运行时越界会引起运行时恐慌。</li>
<li><code>a[x]</code> 表示切片在索引 x 处的元素。<code>a[x]</code> 的类型就是 S 的元素类型。</li>
</ul>
<p>对于字符串类型：</p>
<ul>
<li><p>如果字符串 a 为常量，那么常量索引必须在合法范围内。</p>
</li>
<li><p>如果 x 在运行时越界会引起运行时恐慌。</p>
</li>
<li><p>a[x] 表示索引 x 处的非常量字节，它是byte类型。</p>
</li>
<li><p>不能对 a[x] 分配值。</p>
</li>
</ul>
<p>对于 map 类型 M：</p>
<ul>
<li><p>必须保证 x 的类型能够给 M 的键分配值。</p>
</li>
<li><p>如果map包含键为 x 的值，a[x] 就是 map 中键 x 对应的值，它的类型就是 M 的元素类型。</p>
</li>
<li><p>如果 map 值为 nil 或不包含这个实体，那么 a[x] 为 M 元素类型的零值。</p>
</li>
</ul>
<p>否则 a[x] 就是非法的。</p>
<p>基于 <code>map[K]V</code> 类型  a 的索引表达式可以使用特殊格式的赋值和初始化语法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok = a[x]</span><br><span class="line">v, ok := a[x]</span><br><span class="line"><span class="keyword">var</span> v, ok = a[x]</span><br></pre></td></tr></table></figure>



<p>它会额外生成一个无类型的布尔值。如果 ok 是 true，那么代表在map中有该键，如果没有 ok 为 false。</p>
<p>给一个值为 nil 的 map 类型变量赋值会导致运行时恐慌。</p>
<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式可以基于字符串、数组、数组指针、切片创建字符串子串或切片。它有两种变体，一种是简单的格式是指定开始和结束位置，完全格式的语法还可以指定容量。</p>
<p>####### 简单切片表达式</p>
<p>对于数组、字符串、指针数组、切片 a，主要表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[low:high]</span><br></pre></td></tr></table></figure>



<p>可以构造字符串子串或切片。索引 <code>low</code> 和 <code>high</code> 决定结果切片中的元素。结果切片的索引从 0 开始，长度为 <code>high - low</code>。从数组切分出的切片 s 拥有类型 <code>[]int</code>，长度为 3 ，容积为 4。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] == <span class="number">2</span></span><br><span class="line">s[<span class="number">1</span>] == <span class="number">3</span></span><br><span class="line">s[<span class="number">2</span>] == <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>为了方便起见，索引值都可以缺省。当 low 缺省时默认从 0 开始。当缺 high 缺省时默认的取切片的长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// same as a[2 : len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// same as a[0 : 3]</span></span><br><span class="line">a[:]   <span class="comment">// same as a[0 : len(a)]</span></span><br></pre></td></tr></table></figure>



<p>如果 a 是一个数组指针，那么 <code>a[low:high]</code> 可以表示 <code>(*a)[low : high]</code>。</p>
<p>对于数组或者字符串，索引的范围是<code>0&lt;=low&lt;=high&lt;=len(a)</code>。对于切片，最大的索引值可以为切片的容量，而不是切片的长度。常量索引必须为非负数，且能够转换成 int 类型。对于数组或者常量字符串。常量索引值必须在合法范围内。如果2个索引都是常量。low 必须小于 high。如果索引在运行时访问了非法内存，程序会发生运行时恐慌。</p>
<p>除了无类型字符串，对于切片和字符串的操作结果是非常量类型的值，它的类型与运算元相同。如果运算元为无类型字符串，那么结果类型会为 string。如果把数组作为运算元，它必须是可寻址的，并且获得的切片和原数组具有同一元素类型。</p>
<p>如果切片运算元为 nil，那么结果也是 nil。否则结果切片会和运算元共享相同的底层无类型数组。</p>
<h6 id="完全切片表达式"><a href="#完全切片表达式" class="headerlink" title="完全切片表达式"></a>完全切片表达式</h6><p>对于数组，数组指针或非字符串切片，主要表达式为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure>



<p>它会构造一个同类型切片，并具有与简单切片表达式的 <code>a[low:high]</code> 相同的长度和元素。另外，它还可以把切片的容量设置为 <code>max - low</code>。这时只有第一个索引可以为缺省值，默认为零。从数组中获得切片以后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>



<p>切片 t 为 []int 类型，长度为 2，容量为 4，并且元素为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t[<span class="number">0</span>] == <span class="number">2</span></span><br><span class="line">t[<span class="number">1</span>] == <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>和简单切片表达式一样，如果 a 是数组指针 ，那么 <code>a[low:high:max]</code> 可以简写为 <code>(*a)[low:high:max]</code>。如果切分操作元是数组，那么这个数组必须是可以寻址的。</p>
<p>如果索引必须在 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code> 范围内。常量索引不能是负数并且能够使用 <code>int</code> 类型表示；对于数组，索引必须在合法范围内。如果有多个索引都是常量的，那么所有索引都需要在合法范围内。如果索引是非法的，会引起运行时恐慌。</p>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>对于接口类型 x 和类型 T，主要表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure>



<p>可以断言 x 不是 nil  且 x 的值是 T 类型。标记 x.(T) 叫做类型断言。</p>
<p>更确切的说，如果 T 不是接口类型，那么 x.(T) 将会断言动态类型 x 的类型是不是 T。</p>
<p>这时，T 必须实现了 x 的（接口）类型。否则断言会是非法的因为 x 不能保存 T 类型的值。如果 T 是接口类型，那么可以断言动态类型 x 是否实现了 T 接口。</p>
<p>如果类型断言成功，表达式的值为 x 的值，但它的类型是T。如果断言失败，将会导致运行时恐慌。换句话说，即使 x 是运行时确定的，x.(T) 也必须是编程时就确认存在的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">7</span>          <span class="comment">// x 拥有动态类型 int 值为 7</span></span><br><span class="line">i := x.(<span class="type">int</span>)                   <span class="comment">// i 为 int 类型值为 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123; m() &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(y I)</span></span> &#123;</span><br><span class="line">   s := y.(<span class="type">string</span>)        <span class="comment">// 非法: 字符串没有实现接口 I （缺少 m 方法）</span></span><br><span class="line">   r := y.(io.Reader)     <span class="comment">// r 拥有接口 io.Reader 所以 y 的动态类型必须同时实现 I 和 io.Reader</span></span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类型断言可以使用特定格式的赋值和初始化语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok = x.(T)</span><br><span class="line">v, ok := x.(T)</span><br><span class="line"><span class="keyword">var</span> v, ok = x.(T)</span><br><span class="line"><span class="keyword">var</span> v, ok T1 = x.(T)</span><br></pre></td></tr></table></figure>



<p>这时将会额外生成一个无类型的布尔值。如果断言成功，ok返回 <code>true</code>，否则是 <code>false</code>。并且 v 会是 T 类型的零值。这时不会有恐慌发生。</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>给定函数类型为 F 的表达式 f：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f(a1, a2, … an)</span><br></pre></td></tr></table></figure>



<p>可以使用 a1,a2…an 来调用函数 f。除一种特殊情况之外，函数参数必须是对应 F 函数参数类型的单值表达式，且在函数调用前就已经完成求值。表达式的结果类型是 f 的结果类型。函数调用和方法调用相似，只是方法额外需要一个接收者类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">math.Atan2(x, y)  <span class="comment">// function call</span></span><br><span class="line"><span class="keyword">var</span> pt *Point</span><br><span class="line">pt.Scale(<span class="number">3.5</span>)     <span class="comment">// method call with receiver pt</span></span><br></pre></td></tr></table></figure>



<p>在函数调用中，函数的值和参数是按照顺序求值的。在计算之后作为参数会传进函数，函数开始执行。当函数执行完成后返回的参数将会返回给函数的调用者。</p>
<p>调用值为 nil 的函数会导致运行时恐慌。</p>
<p>作为特例，如果函数或者方法的返回值等于参数列表的个数，那么会嵌套调用。这将把返回值直接赋值给下一次调用函数的参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s <span class="type">string</span>, pos <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> s[<span class="number">0</span>:pos], s[pos:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s + t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Join(Split(value, <span class="built_in">len</span>(value)/<span class="number">2</span>)) != value &#123;</span><br><span class="line">	log.Panic(<span class="string">&quot;test fails&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果 x 的方法集中包含 m 那么 <code>x.m()</code> 是合法的。并且参数列表和 m 的参数列表相同。如果x是可寻址的，那么那么x指针的方法集<code>(&amp;x).m()</code>可以简写成<code>x.m()</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p Point</span><br><span class="line">p.Scale(<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>



<p>没有方法类型，也没有方法字面值。</p>
<h4 id="通过-来传递参数"><a href="#通过-来传递参数" class="headerlink" title="通过 ... 来传递参数"></a>通过 <code>...</code> 来传递参数</h4><p>如果 f 的最后一个参数 p 的类型是 <code>...T</code>。那么在函数内部 p 参数的类型就是 <code>[]T</code>。如果 f 调用时没有传入 p 对应的参数，那么p为 nil。否则这些参数会以切片方式传入，在新的底层切片中。切片中的类型都是能赋值给类型 T 的值。这个切片的长度和容量在不同的调用中有所不同。</p>
<p>给定函数调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greeting</span><span class="params">(prefix <span class="type">string</span>, who ...<span class="type">string</span>)</span></span></span><br><span class="line">Greeting(<span class="string">&quot;nobody&quot;</span>)</span><br><span class="line">Greeting(<span class="string">&quot;hello:&quot;</span>, <span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Eileen&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>在 <code>Greeting</code> 中，第一次调用时，<code>who</code>是 nil 类型。而在第二次调用时是<code>[]string&#123;&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;&#125;</code>。</p>
<p>如果在调用的时候的最后一个参数是[]T，那么我们可以使用<code>...</code>来将切片中的值依次赋值给参数列表。</p>
<p>给定切片s并且调用:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Jasmine&quot;</span>&#125;</span><br><span class="line">Greeting(<span class="string">&quot;goodbye:&quot;</span>, s...)</span><br></pre></td></tr></table></figure>



<p>z 在 <code>Greeting</code>。中 <code>who</code> 会和切片 s 共享相同的底层数组。</p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>操作符用来连接运算元。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Expression = UnaryExpr | Expression binary_op Expression .</span><br><span class="line">UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .</span><br><span class="line"></span><br><span class="line">binary_op  = <span class="string">&quot;||&quot;</span> | <span class="string">&quot;&amp;&amp;&quot;</span> | rel_op | add_op | mul_op .</span><br><span class="line">rel_op     = <span class="string">&quot;==&quot;</span> | <span class="string">&quot;!=&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> .</span><br><span class="line">add_op     = <span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span> | <span class="string">&quot;|&quot;</span> | <span class="string">&quot;^&quot;</span> .</span><br><span class="line">mul_op     = <span class="string">&quot;*&quot;</span> | <span class="string">&quot;/&quot;</span> | <span class="string">&quot;%&quot;</span> | <span class="string">&quot;&lt;&lt;&quot;</span> | <span class="string">&quot;&gt;&gt;&quot;</span> | <span class="string">&quot;&amp;&quot;</span> | <span class="string">&quot;&amp;^&quot;</span> .</span><br><span class="line"></span><br><span class="line">unary_op   = <span class="string">&quot;+&quot;</span> | <span class="string">&quot;-&quot;</span> | <span class="string">&quot;!&quot;</span> | <span class="string">&quot;^&quot;</span> | <span class="string">&quot;*&quot;</span> | <span class="string">&quot;&amp;&quot;</span> | <span class="string">&quot;&lt;-&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>比较运算符在此处讨论。对于其他二元操作符，两个操作元的类型必须是相同的，除了位移和无类型常量。针对常量的操作，请看常量表达式章节。</p>
<p>除了位移操作，如果其中一个操作符是无类型常量，而另个不是，那么无类型的常量会转换成另一个运算元的类型。</p>
<p>在右移表达式中的运算元必须是无符号的整数或者可以转换成 uint 的无类型的常量。如果左移一个无类型常量那么结果依然是无类型的。他首先会转换成指定类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">uint</span> = <span class="number">33</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>&lt;&lt;s           <span class="comment">// 1 has type int</span></span><br><span class="line"><span class="keyword">var</span> j <span class="type">int32</span> = <span class="number">1</span>&lt;&lt;s     <span class="comment">// 1 has type int32; j == 0</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="type">uint64</span>(<span class="number">1</span>&lt;&lt;s)   <span class="comment">// 1 has type uint64; k == 1&lt;&lt;33</span></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span> = <span class="number">1.0</span>&lt;&lt;s     <span class="comment">// 1.0 has type int; m == 0 if ints are 32bits in size</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1.0</span>&lt;&lt;s == j    <span class="comment">// 1.0 has type int32; n == true</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="number">1</span>&lt;&lt;s == <span class="number">2</span>&lt;&lt;s   <span class="comment">// 1 and 2 have type int; o == true if ints are 32bits in size</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="number">1</span>&lt;&lt;s == <span class="number">1</span>&lt;&lt;<span class="number">33</span>  <span class="comment">// illegal if ints are 32bits in size: 1 has type int, but 1&lt;&lt;33 overflows int</span></span><br><span class="line"><span class="keyword">var</span> u = <span class="number">1.0</span>&lt;&lt;s         <span class="comment">// illegal: 1.0 has type float64, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> u1 = <span class="number">1.0</span>&lt;&lt;s != <span class="number">0</span>   <span class="comment">// illegal: 1.0 has type float64, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> u2 = <span class="number">1</span>&lt;&lt;s != <span class="number">1.0</span>   <span class="comment">// illegal: 1 has type float64, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> v <span class="type">float32</span> = <span class="number">1</span>&lt;&lt;s   <span class="comment">// illegal: 1 has type float32, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> w <span class="type">int64</span> = <span class="number">1.0</span>&lt;&lt;<span class="number">33</span>  <span class="comment">// 1.0&lt;&lt;33 is a constant shift expression</span></span><br></pre></td></tr></table></figure>



<h6 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h6><p>一元运算符拥有最高优先级。++ 和 – 是语句而不是表达式，他们在运算符的优先级之外。所以 (*p)++ 和 *p++ 是一样的。</p>
<p>二元运算符有 5 个优先级。乘法运算符在最高级，紧接着是加法运算符。比较运算符，&amp;&amp; 运算符，最后是 ||。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>



<p>相同优先级的二元运算符的执行顺序是由左到右。例如 <code>x/y*z</code>和<code>(x/y)*z</code> 是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+x</span><br><span class="line"><span class="number">23</span> + <span class="number">3</span>*x[i]</span><br><span class="line">x &lt;= f()</span><br><span class="line">^a &gt;&gt; b</span><br><span class="line">f() || g()</span><br><span class="line">x == y+<span class="number">1</span> &amp;&amp; &lt;-chanPtr &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算数运算符应用在 2 个数字值之间，别切生成一个相同类型的值作为第一个运算元。四种算数运算符(+,-,*,&#x2F;)应用在数字，浮点，复合类型之中。+ 也可以用于字符串。位运算和位移运算只适用于整数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+    sum                    integers, floats, <span class="built_in">complex</span> values, strings</span><br><span class="line">-    difference             integers, floats, <span class="built_in">complex</span> values</span><br><span class="line">*    product                integers, floats, <span class="built_in">complex</span> values</span><br><span class="line">/    quotient               integers, floats, <span class="built_in">complex</span> values</span><br><span class="line">%    remainder              integers</span><br><span class="line"></span><br><span class="line">&amp;    bitwise AND            integers</span><br><span class="line">|    bitwise OR             integers</span><br><span class="line">^    bitwise XOR            integers</span><br><span class="line">&amp;^   bit clear (AND NOT)    integers</span><br><span class="line"></span><br><span class="line">&lt;&lt;   left shift             integer &lt;&lt; unsigned integer</span><br><span class="line">&gt;&gt;   right shift            integer &gt;&gt; unsigned integer</span><br></pre></td></tr></table></figure>



<h6 id="数字运算符"><a href="#数字运算符" class="headerlink" title="数字运算符"></a>数字运算符</h6><p>对于两个整数 x 和 y。整数商 <code>q=x/y</code> 和余数 <code>r=x%y</code> 遵循以下规律。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = q*y + r  and  |r| &lt; |y|</span><br></pre></td></tr></table></figure>



<p><code>x/y</code> 截断为 0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x     y     x / y     x % y</span><br><span class="line"> <span class="number">5</span>     <span class="number">3</span>       <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">-5</span>     <span class="number">3</span>      <span class="number">-1</span>        <span class="number">-2</span></span><br><span class="line"> <span class="number">5</span>    <span class="number">-3</span>      <span class="number">-1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">-5</span>    <span class="number">-3</span>       <span class="number">1</span>        <span class="number">-2</span></span><br></pre></td></tr></table></figure>



<p>作为这个规则的例外情况，如果 x 非常大，那么 <code>q=x/-1</code> 等于 x。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, q</span><br><span class="line"><span class="type">int8</span>                     <span class="number">-128</span></span><br><span class="line"><span class="type">int16</span>                  <span class="number">-32768</span></span><br><span class="line"><span class="type">int32</span>             <span class="number">-2147483648</span></span><br><span class="line"><span class="type">int64</span>    <span class="number">-9223372036854775808</span></span><br></pre></td></tr></table></figure>



<p>如果除数是一个常量。那么它不能是 0，如果除数在运行时为 0，会导致运行时恐慌。如果除数是负数并且除数是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x     x / <span class="number">4</span>     x % <span class="number">4</span>     x &gt;&gt; <span class="number">2</span>     x &amp; <span class="number">3</span></span><br><span class="line"> <span class="number">11</span>      <span class="number">2</span>         <span class="number">3</span>         <span class="number">2</span>          <span class="number">3</span></span><br><span class="line"><span class="number">-11</span>     <span class="number">-2</span>        <span class="number">-3</span>        <span class="number">-3</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>位移运算符移动左侧运算元右侧元算元指定的位数。如果左侧是有符号整型，那它就实现了位移运算，如果是无符号整数使用逻辑位移。位移运算没有上限，位移操作让左边运算元位移 n 个 1。<code>x&lt;&lt;1</code> 和 <code>x*2</code> 是相等的。并且 <code>x&gt;&gt;1</code> 和 <code>x/2</code> 是相同的。</p>
<p>对于整数运算元，一元运算符+-^定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+x                          is <span class="number">0</span> + x</span><br><span class="line">-x    negation              is <span class="number">0</span> - x</span><br><span class="line">^x    bitwise complement    is m ^ x  with m = <span class="string">&quot;all bits set to 1&quot;</span> <span class="keyword">for</span> unsigned x</span><br><span class="line">                                      and  m = <span class="number">-1</span> <span class="keyword">for</span> signed x</span><br></pre></td></tr></table></figure>



<h6 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h6><p>对于无符号的值，运算符+-*和&lt;&lt;都是2禁止运算。这里的n是无符号类型的宽度，无符号整型将会丢弃溢出的位，并且程序将会返回<code>wrap around</code>。</p>
<p>对于有符号的整数，操作符+&#x3D;*&lt;&lt;都会溢出并且值存在，并且代表相应的有符号的值。在运算时不会抛出异常。标一起不会报错。所以不是所有情况下x&lt;x+1都成立。</p>
<h6 id="浮点数运算符"><a href="#浮点数运算符" class="headerlink" title="浮点数运算符"></a>浮点数运算符</h6><p>对于浮点数和其他复杂数字，+x和x是一样的，-x是x的对立面。除了IEEE-754还没有指定浮点数除0或者复数的结果。是否抛出异常将会依赖其具体实现。</p>
<p>一种实现可以合并多个浮点操作进一个操作，有可能是夸语句的，并且他的结果可能和依次单独执行的结果不一样。1个浮点数类型将会转变成目标的精度，防止四舍五入的融合。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FMA allowed for computing r, because x*y is not explicitly rounded:</span></span><br><span class="line">r  = x*y + z</span><br><span class="line">r  = z;   r += x*y</span><br><span class="line">t  = x*y; r = t + z</span><br><span class="line">*p = x*y; r = *p + z</span><br><span class="line">r  = x*y + <span class="type">float64</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FMA disallowed for computing r, because it would omit rounding of x*y:</span></span><br><span class="line">r  = <span class="type">float64</span>(x*y) + z</span><br><span class="line">r  = z; r += <span class="type">float64</span>(x*y)</span><br><span class="line">t  = <span class="type">float64</span>(x*y); r = t + z</span><br></pre></td></tr></table></figure>



<h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>字符串可以使用+和+&#x3D;操作符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hi&quot;</span> + <span class="type">string</span>(c)</span><br><span class="line">s += <span class="string">&quot; and good bye&quot;</span></span><br></pre></td></tr></table></figure>



<p>字符串想家将会创建一个新的字符串。</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符比较连个运算元，并且生成一个无类型的布尔值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">==    equal</span><br><span class="line">!=    not equal</span><br><span class="line">&lt;     less</span><br><span class="line">&lt;=    less or equal</span><br><span class="line">&gt;     greater</span><br><span class="line">&gt;=    greater or equal</span><br></pre></td></tr></table></figure>



<p>在任何比较运算元中2种类型必须是可以分配的。</p>
<p>使用等于运算符<code>==</code>和<code>!=</code>的运算元必须是可比较的。使用顺序运算符<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>和<code>&gt;=</code>必须是可比较的。这些限制导致比较运算符被定义成以下的方式。</p>
<ul>
<li><p>布尔值是可比较的，两个布尔值当他们同为<code>true</code>或者false的使用是相等的</p>
</li>
<li><p>整数值是可比较和排序的</p>
</li>
<li><p>浮点数是可比较和排序的，具体定义在IEEE-754标准中。</p>
</li>
<li><p>复数是可比较的，2个复数当实部和虚部都相等时就是相等的。</p>
</li>
<li><p>字符串是可以比较和排序的。是按照字节顺序排序。</p>
</li>
<li><p>指针式可以排序的，连个指针当指向相同变量时是相同的，或者他们2个都是nil。指向一个为非配的变量的结果是未定义的。</p>
</li>
<li><p>channel是可比较的。当两个管道是用同一个make出来的，或者都是nil时时相等的。</p>
</li>
<li><p>接口值时可以比较的，2个接口值时相等的如果2个标识符的动态类型是一样的或者他们都是nil。</p>
</li>
<li><p>一个非接口类型的值x和一个接口类型的值T在非接口类型是可以比较的并且非接口类型实现了接口是是可以比较的。当他们的动态类型类型相同时时相等的。</p>
</li>
<li><p>当结构体内的所有字段都是可以比较的时候，他是可以比较的。连个结构体的值当非空字段都相等时他们是相等的。</p>
</li>
<li><p>数组类型的值时可比较的，如果数组的原属时可以比较的，那么当数组的所有值是相等的时候他们就是相等的。</p>
</li>
</ul>
<p>使用两个动态类型的标识符来比较接口的值。如果这个类型的值时不可比较的，那么将会引起一个panic。这个行为不仅仅时接口，数组结构体接口字段都有这个问题。</p>
<p>切片，map，和函数值都是不可比较的，然而，作为一个特殊的例子，切片，map和函数的值的nil时可以比较的，指针，channel和接口的值nil也是可以比较的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">3</span> &lt; <span class="number">4</span>            <span class="comment">// c is the untyped boolean constant true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyBool <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// The result of a comparison is an untyped boolean.</span></span><br><span class="line">	<span class="comment">// The usual assignment rules apply.</span></span><br><span class="line">	b3        = x == y <span class="comment">// b3 has type bool</span></span><br><span class="line">	b4 <span class="type">bool</span>   = x == y <span class="comment">// b4 has type bool</span></span><br><span class="line">	b5 MyBool = x == y <span class="comment">// b5 has type MyBool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h4><p>逻辑运算符使用布尔值值，并且生成一个相同类型的结果值作为操作元。右面的操作元计算是有条件的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;&amp;    conditional AND    p &amp;&amp; q  is  <span class="string">&quot;if p then q else false&quot;</span></span><br><span class="line">||    conditional OR     p || q  is  <span class="string">&quot;if p then true else q&quot;</span></span><br><span class="line">!     NOT                !p      is  <span class="string">&quot;not p&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="地址操作符"><a href="#地址操作符" class="headerlink" title="地址操作符"></a>地址操作符</h4><p>以类型 T 的 x 作为运算元，取址操作 <code>&amp;x</code> 会生成一个类型为 <code>*T</code> 并指向 x 的指针。运算元必须是能够取址的，它可以是一个变量，指针，切片的取值操作；或是一个可取址结构体的字段选择器；或是对于可取址数组的索引取值操作。作为寻址能力的例外，x 可能是一个复合字面值。如果对 x 进行取址操作将会 panic，<code>&amp;x</code> 也会 panic。</p>
<p>对于一个 <code>*T</code> 类型的运算元 x，指针解引用 <code>*x</code> 表示 x 指向的 T 类型。如果 x 为 nil，那么解引用 <code>*x</code> 会 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;x</span><br><span class="line">&amp;a[f(<span class="number">2</span>)]</span><br><span class="line">&amp;Point&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">*p</span><br><span class="line">*pf(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">*x   <span class="comment">// causes a run-time panic</span></span><br><span class="line">&amp;*x  <span class="comment">// causes a run-time panic</span></span><br></pre></td></tr></table></figure>



<h4 id="接收操作符"><a href="#接收操作符" class="headerlink" title="接收操作符"></a>接收操作符</h4><p>对于管道类型的运算元 <code>ch</code>，接收操作 <code>&lt;-ch</code> 返回值是管道 <code>ch</code> 接收到的值。带方向的管道需要有接受权限，接收操作的类型也是通道的元素类型。表达式会一直阻塞直到接收到返回值。从 nil 通道接收值会一直阻塞。从一个已经关闭的通道接收数据会在其他数据都被接收以后生成该通道元素类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v1 := &lt;-ch</span><br><span class="line">v2 = &lt;-ch</span><br><span class="line">f(&lt;-ch)</span><br><span class="line">&lt;-strobe  <span class="comment">// wait until clock pulse and discard received value</span></span><br></pre></td></tr></table></figure>



<p>接收数据的表达式可以使用赋值表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, ok = &lt;-ch</span><br><span class="line">x, ok := &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok = &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok T = &lt;-ch</span><br></pre></td></tr></table></figure>



<p>它还可以生成一个额外的无类型布尔值来表示通道是否关闭。如果 ok 为 <code>true</code> 说明获取到的是发送到通道内的数据，而 <code>false</code> 它就返回一个零值因为通道内没有元素且已经关闭。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换表达式 <code>T(x)</code> 其中 T 代表类型，x 代表可以转换成 T 类型的表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Conversion = Type <span class="string">&quot;(&quot;</span> Expression [ <span class="string">&quot;,&quot;</span> ] <span class="string">&quot;)&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>如果类型是以 <code>*</code> 或 <code>&lt;-</code> 开头，或以关键字 <code>func</code> 开头并且没有返回值列表，那么它必须用括号括起来避免歧义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*Point(p)        <span class="comment">// same as *(Point(p))</span></span><br><span class="line">(*Point)(p)      <span class="comment">// p is converted to *Point</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span>(c)    <span class="comment">// same as &lt;-(chan int(c))</span></span><br><span class="line">(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)(c)  <span class="comment">// c is converted to &lt;-chan int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>(x)        <span class="comment">// function signature func() x</span></span><br><span class="line">(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)(x)      <span class="comment">// x is converted to func()</span></span><br><span class="line">(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>)(x)  <span class="comment">// x is converted to func() int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>(x)    <span class="comment">// x is converted to func() int (unambiguous)</span></span><br></pre></td></tr></table></figure>



<p>常量 x 可以在可以用类型 T 表示时自动转换。作为一个特例，整数常量 x 可以转换成字符串类型就和非常量 x 一样。</p>
<p>对常量的转换会生成一个指定类型的常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint</span>(<span class="literal">iota</span>)               <span class="comment">// iota value of type uint</span></span><br><span class="line"><span class="type">float32</span>(<span class="number">2.718281828</span>)     <span class="comment">// 2.718281828 of type float32</span></span><br><span class="line"><span class="type">complex128</span>(<span class="number">1</span>)            <span class="comment">// 1.0 + 0.0i of type complex128</span></span><br><span class="line"><span class="type">float32</span>(<span class="number">0.49999999</span>)      <span class="comment">// 0.5 of type float32</span></span><br><span class="line"><span class="type">float64</span>(<span class="number">-1e-1000</span>)        <span class="comment">// 0.0 of type float64</span></span><br><span class="line"><span class="type">string</span>(<span class="string">&#x27;x&#x27;</span>)              <span class="comment">// &quot;x&quot; of type string</span></span><br><span class="line"><span class="type">string</span>(<span class="number">0x266c</span>)           <span class="comment">// &quot;♬&quot; of type string</span></span><br><span class="line">MyString(<span class="string">&quot;foo&quot;</span> + <span class="string">&quot;bar&quot;</span>)  <span class="comment">// &quot;foobar&quot; of type MyString</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>&#125;)      <span class="comment">// not a constant: []byte&#123;&#x27;a&#x27;&#125; is not a constant</span></span><br><span class="line">(*<span class="type">int</span>)(<span class="literal">nil</span>)              <span class="comment">// not a constant: nil is not a constant, *int is not a boolean, numeric, or string type</span></span><br><span class="line"><span class="type">int</span>(<span class="number">1.2</span>)                 <span class="comment">// illegal: 1.2 cannot be represented as an int</span></span><br><span class="line"><span class="type">string</span>(<span class="number">65.0</span>)             <span class="comment">// illegal: 65.0 is not an integer constant</span></span><br></pre></td></tr></table></figure>



<p>非常量 x 可以在以下情况下转换成类型 T：</p>
<ul>
<li><p>x 可以给类型 T 赋值</p>
</li>
<li><p>忽略的结构体标签，x 的类型和 T 具有相同的底层类型</p>
</li>
<li><p>忽略的结构体标签，x 的类型和 T 都是指针类型，并且指针所指的类型具有相同的底层类型</p>
</li>
<li><p>x 的类型和 T 都是整数或者浮点数类型</p>
</li>
<li><p>x 的类型和 T 都是复数类型</p>
</li>
<li><p>x 是一个字符串而 T 时字节切片或者 rune 切片</p>
</li>
</ul>
<p>在比较两个结构体类型的时候会忽略结构体标签：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Address *<span class="keyword">struct</span> &#123;</span><br><span class="line">		Street <span class="type">string</span></span><br><span class="line">		City   <span class="type">string</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data *<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Address *<span class="keyword">struct</span> &#123;</span><br><span class="line">		Street <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">		City   <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = (*Person)(data)  <span class="comment">// ignoring tags, the underlying types are identical</span></span><br></pre></td></tr></table></figure>



<p>这个规则也适用于数字类型与字符串类型间的相互转换。这个转换可能会改变 x 的值并且会增加运行时消耗。包 unsafe 实现了这个功能底层的限制。</p>
<h6 id="数字之间的转换"><a href="#数字之间的转换" class="headerlink" title="数字之间的转换"></a>数字之间的转换</h6><p>对于非常量的数字转换，需要遵守以下规则：</p>
<ul>
<li><p>在转换整型数字时，如果是一个有符号整型，它是继承有符号的无限精度；否则就不用继承符号。转换时会截断数字以适应类型的大小。例如：如果 <code>v:=uint16(0x10F0)</code>，然后 &#96;&#96;uint32(int8(v)) &#x3D;&#x3D; 0xFFFFFFF0 。类型转换总是生成有效值，并且永远不会溢出。</p>
</li>
<li><p>如果要将浮点数转换成整型，会丢弃小数部分（截断为零）。</p>
</li>
<li><p>如果要将整型或浮点型转换成浮点数类型，或或者一个复数转换成其他复数类型，结果会四舍五入成指定精度。例如： 可以使用超出IEEE-754 32位数的附加精度来存储float32类型的变量x的值，但float32（x）表示将x的值舍入为32位精度的结果。x + 0.1 会使用超过 32 位的精度，而 <code>float32(x+0.1)</code> 不会。</p>
</li>
</ul>
<p>在所有浮点数和复数的非常量转换中，如果结构类型不能成功表示数据，那么结果将会依赖于具体平台实现。</p>
<h6 id="字符串的类型转换"><a href="#字符串的类型转换" class="headerlink" title="字符串的类型转换"></a>字符串的类型转换</h6><ol>
<li>转换一个有符号或者无符号的整型值会转换成对应的 UTF-8 表示整型值。不在范围内的 Unicode 代码点会转换成 “\uFFFD”。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>(<span class="string">&#x27;a&#x27;</span>)       <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">-1</span>)        <span class="comment">// &quot;\ufffd&quot; == &quot;\xef\xbf\xbd&quot;</span></span><br><span class="line"><span class="type">string</span>(<span class="number">0xf8</span>)      <span class="comment">// &quot;\u00f8&quot; == &quot;ø&quot; == &quot;\xc3\xb8&quot;</span></span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line">MyString(<span class="number">0x65e5</span>)  <span class="comment">// &quot;\u65e5&quot; == &quot;日&quot; == &quot;\xe6\x97\xa5&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将字节切片转换成字符串类型会生成一个由切片元素组成的字符串</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;\xc3&#x27;</span>, <span class="string">&#x27;\xb8&#x27;</span>&#125;)   <span class="comment">// &quot;hellø&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">byte</span>&#123;&#125;)                                     <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">byte</span>(<span class="literal">nil</span>))                                  <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyBytes []<span class="type">byte</span></span><br><span class="line"><span class="type">string</span>(MyBytes&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;\xc3&#x27;</span>, <span class="string">&#x27;\xb8&#x27;</span>&#125;)  <span class="comment">// &quot;hellø&quot;</span></span><br></pre></td></tr></table></figure>



<ol>
<li>将 rune 切片转换成字符串类型会生成一个由切片元素组成的字符串</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>([]<span class="type">rune</span>&#123;<span class="number">0x767d</span>, <span class="number">0x9d6c</span>, <span class="number">0x7fd4</span>&#125;)   <span class="comment">// &quot;\u767d\u9d6c\u7fd4&quot; == &quot;白鵬翔&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">rune</span>&#123;&#125;)                         <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="type">string</span>([]<span class="type">rune</span>(<span class="literal">nil</span>))                      <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyRunes []<span class="type">rune</span></span><br><span class="line"><span class="type">string</span>(MyRunes&#123;<span class="number">0x767d</span>, <span class="number">0x9d6c</span>, <span class="number">0x7fd4</span>&#125;)  <span class="comment">// &quot;\u767d\u9d6c\u7fd4&quot; == &quot;白鵬翔&quot;</span></span><br></pre></td></tr></table></figure>



<ol>
<li>将字符串转换成字节切片会生成由字符串中每个字节组成的切片</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="type">byte</span>(<span class="string">&quot;hellø&quot;</span>)   <span class="comment">// []byte&#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;\xc3&#x27;, &#x27;\xb8&#x27;&#125;</span></span><br><span class="line">[]<span class="type">byte</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// []byte&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">MyBytes(<span class="string">&quot;hellø&quot;</span>)  <span class="comment">// []byte&#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;\xc3&#x27;, &#x27;\xb8&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>将字符串转换成 rune 切片会生成由字符串中每个 Unicode 代码点组成的切片</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="type">rune</span>(MyString(<span class="string">&quot;白鵬翔&quot;</span>))  <span class="comment">// []rune&#123;0x767d, 0x9d6c, 0x7fd4&#125;</span></span><br><span class="line">[]<span class="type">rune</span>(<span class="string">&quot;&quot;</span>)                 <span class="comment">// []rune&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">MyRunes(<span class="string">&quot;白鵬翔&quot;</span>)           <span class="comment">// []rune&#123;0x767d, 0x9d6c, 0x7fd4&#125;</span></span><br></pre></td></tr></table></figure>



<h6 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h6><p>常量表达式只包含常量运算元并且在编译程序时就已经计算完成。</p>
<p>无类型布尔值，数值和字符串常量都可以当作运算元。除了位置操作符，如果二元运算符石不同类型的常量，操作元，和非布尔值，和即将在接下来出现的：整型，rune，浮点数和复数类型。例如：一个无类型整型常量减去无类型复数常量，结果为复数常量。</p>
<p>一个常量的比较运算会生成无类型的布尔常量。如果左移运算是一个无类型常量，结果会是一个整型常量。它会和原来常量为相同类型。其他与无类型常量的运算都会生成相同类型的结果（布尔值，整型，浮点数，复数，字符串常量）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span> + <span class="number">3.0</span>          <span class="comment">// a == 5.0   (untyped floating-point constant)</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15</span> / <span class="number">4</span>           <span class="comment">// b == 3     (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">15</span> / <span class="number">4.0</span>         <span class="comment">// c == 3.75  (untyped floating-point constant)</span></span><br><span class="line"><span class="keyword">const</span> Θ <span class="type">float64</span> = <span class="number">3</span>/<span class="number">2</span>      <span class="comment">// Θ == 1.0   (type float64, 3/2 is integer division)</span></span><br><span class="line"><span class="keyword">const</span> Π <span class="type">float64</span> = <span class="number">3</span>/<span class="number">2.</span>     <span class="comment">// Π == 1.5   (type float64, 3/2. is float division)</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">1</span> &lt;&lt; <span class="number">3.0</span>         <span class="comment">// d == 8     (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">1.0</span> &lt;&lt; <span class="number">3</span>         <span class="comment">// e == 8     (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="type">int32</span>(<span class="number">1</span>) &lt;&lt; <span class="number">33</span>   <span class="comment">// illegal    (constant 8589934592 overflows int32)</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="type">float64</span>(<span class="number">2</span>) &gt;&gt; <span class="number">1</span>  <span class="comment">// illegal    (float64(2) is a typed floating-point constant)</span></span><br><span class="line"><span class="keyword">const</span> h = <span class="string">&quot;foo&quot;</span> &gt; <span class="string">&quot;bar&quot;</span>    <span class="comment">// h == true  (untyped boolean constant)</span></span><br><span class="line"><span class="keyword">const</span> j = <span class="literal">true</span>             <span class="comment">// j == true  (untyped boolean constant)</span></span><br><span class="line"><span class="keyword">const</span> k = <span class="string">&#x27;w&#x27;</span> + <span class="number">1</span>          <span class="comment">// k == &#x27;x&#x27;   (untyped rune constant)</span></span><br><span class="line"><span class="keyword">const</span> l = <span class="string">&quot;hi&quot;</span>             <span class="comment">// l == &quot;hi&quot;  (untyped string constant)</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="type">string</span>(k)        <span class="comment">// m == &quot;x&quot;   (type string)</span></span><br><span class="line"><span class="keyword">const</span> Σ = <span class="number">1</span> - <span class="number">0.707i</span>       <span class="comment">//            (untyped complex constant)</span></span><br><span class="line"><span class="keyword">const</span> Δ = Σ + <span class="number">2.0e-4</span>       <span class="comment">//            (untyped complex constant)</span></span><br><span class="line"><span class="keyword">const</span> Φ = <span class="literal">iota</span>*<span class="number">1i</span> - <span class="number">1</span>/<span class="number">1i</span>   <span class="comment">//            (untyped complex constant)</span></span><br></pre></td></tr></table></figure>



<p>对一个无类型整数，rune，或浮点数应用内置的 <code>complex</code> 函数会生成无类型的复数常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ic = <span class="built_in">complex</span>(<span class="number">0</span>, c)   <span class="comment">// ic == 3.75i  (untyped complex constant)</span></span><br><span class="line"><span class="keyword">const</span> iΘ = <span class="built_in">complex</span>(<span class="number">0</span>, Θ)   <span class="comment">// iΘ == 1i     (type complex128)</span></span><br></pre></td></tr></table></figure>



<p>常量表达式总是一个明确的值；中间值和常量自己可以比语言所支持的精度更高，下面的声明是合法的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Huge = <span class="number">1</span> &lt;&lt; <span class="number">100</span>         <span class="comment">// Huge == 1267650600228229401496703205376  (untyped integer constant)</span></span><br><span class="line"><span class="keyword">const</span> Four <span class="type">int8</span> = Huge &gt;&gt; <span class="number">98</span>  <span class="comment">// Four == 4                                (type int8)</span></span><br></pre></td></tr></table></figure>



<p>常量的除法的除数不能为 0:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span> / <span class="number">0.0</span>   <span class="comment">// illegal: division by zero</span></span><br></pre></td></tr></table></figure>



<p>定义了类型的常量的精度必须根据常量类型定义。所以下面的常量表达式是非法的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint</span>(<span class="number">-1</span>)     <span class="comment">// -1 cannot be represented as a uint</span></span><br><span class="line"><span class="type">int</span>(<span class="number">3.14</span>)    <span class="comment">// 3.14 cannot be represented as an int</span></span><br><span class="line"><span class="type">int64</span>(Huge)  <span class="comment">// 1267650600228229401496703205376 cannot be represented as an int64</span></span><br><span class="line">Four * <span class="number">300</span>   <span class="comment">// operand 300 cannot be represented as an int8 (type of Four)</span></span><br><span class="line">Four * <span class="number">100</span>   <span class="comment">// product 400 cannot be represented as an int8 (type of Four)</span></span><br></pre></td></tr></table></figure>



<p>补码使用的一元操作符 ^ 对于非常量的匹配模式：补码对于无符号常量为 1，对于有符号和无类型常量为 -1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">^<span class="number">1</span>         <span class="comment">// untyped integer constant, equal to -2</span></span><br><span class="line"><span class="type">uint8</span>(^<span class="number">1</span>)  <span class="comment">// illegal: same as uint8(-2), -2 cannot be represented as a uint8</span></span><br><span class="line">^<span class="type">uint8</span>(<span class="number">1</span>)  <span class="comment">// typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)</span></span><br><span class="line"><span class="type">int8</span>(^<span class="number">1</span>)   <span class="comment">// same as int8(-2)</span></span><br><span class="line">^<span class="type">int8</span>(<span class="number">1</span>)   <span class="comment">// same as -1 ^ int8(1) = -2</span></span><br></pre></td></tr></table></figure>



<p>实现限制：编译器在处理无类型浮点数和复数时会取近似值；具体请看常量章节。这个取近似值的操作在浮点数在整数上下文时会产生无效值，即使在计算过后是一个整型。</p>
<h4 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h4><p>在包级别，初始化的依赖性由变量声明的初始化表达式顺序决定。否则，当计算表达式内的操作数时，赋值，返回语句，所有函数调用，方法调用，和通信操作都会由左向右计算。</p>
<p>例如，在函数作用域中的赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()</span><br></pre></td></tr></table></figure>



<p>函数调用和通信的发生顺序为：<code>f()</code>，<code>h()</code>，<code>i()</code>，<code>j()</code>，<code>&lt;-c</code>，<code>g()</code> 和 <code>k()</code>。但是对 y 和 x 的取值操作没有指定。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; a++; <span class="keyword">return</span> a &#125;</span><br><span class="line">x := []<span class="type">int</span>&#123;a, f()&#125;            <span class="comment">// x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;a: <span class="number">1</span>, a: <span class="number">2</span>&#125;  <span class="comment">// m may be &#123;2: 1&#125; or &#123;2: 2&#125;: evaluation order between the two map assignments is not specified</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;a: f()&#125;      <span class="comment">// n may be &#123;2: 3&#125; or &#123;3: 3&#125;: evaluation order between the key and the value is not specified</span></span><br></pre></td></tr></table></figure>



<p>在包级别，依赖的初始化顺序会覆盖这个从左向右的规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c = f() + v(), g(), sqr(u()) + v()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">int</span>        &#123; <span class="keyword">return</span> c &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> <span class="type">int</span>        &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqr</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*x &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// functions u and v are independent of all other variables and functions</span></span><br></pre></td></tr></table></figure>



<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句控制程序的执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Statement =</span><br><span class="line">	Declaration | LabeledStmt | SimpleStmt |</span><br><span class="line">	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span><br><span class="line">	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span><br><span class="line">	DeferStmt .</span><br><span class="line"></span><br><span class="line">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span><br></pre></td></tr></table></figure>



<h4 id="终止语句"><a href="#终止语句" class="headerlink" title="终止语句"></a>终止语句</h4><p>终止语句会阻止相同代码块中下面所有语句的执行。以下语句属于终止语句：</p>
<ol>
<li><p><code>return</code> 和 <code>goto</code> 语句</p>
</li>
<li><p>对内置 <code>panic</code> 函数的调用</p>
</li>
<li><p>代码块结束</p>
</li>
<li><p><code>if</code> 语句中：</p>
</li>
<li><p>else 分支</p>
</li>
<li><p>所有分支末尾</p>
</li>
<li><p><code>for</code>语句中：</p>
</li>
<li><p><code>break</code> 语句和循环结束</p>
</li>
<li><p><code>switch</code> 语句：</p>
</li>
<li><p>在 <code>switch</code> 语句中没有 <code>break</code> 语句，</p>
</li>
<li><p>有一个默认的 case</p>
</li>
<li><p>语句列表中的每个 case 语句和有可能存在的 <code>fallthrough</code> 语句</p>
</li>
<li><p><code>select</code> 语句中：</p>
</li>
<li><p>没有 break 语句</p>
</li>
<li><p>每个 case 中的语句列表，如果包含默认 case</p>
</li>
</ol>
<p>所有其他语句都不是中断语句。</p>
<p>如果语句序列不为空并且最后一个非空语句是终止语句，那么语句序列就以终结语句结尾。</p>
<h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h4><p>空语句不做任何事情。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">EmptyStmt = .</span><br></pre></td></tr></table></figure>



<h4 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h4><p>标签语句可以作为 <code>goto</code>，<code>break</code> 和 <code>continue</code> 语句的目标。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">LabeledStmt = Label <span class="string">&quot;:&quot;</span> Statement .</span><br><span class="line">Label       = identifier .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Error: log.Panic(<span class="string">&quot;error encountered&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h4><p>除了特定的内置函数，一般的函数、方法和接收操作都可以出现在表达式语句的上下文中。这些语句可以使用括号括起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ExpressionStmt = Expression .</span><br></pre></td></tr></table></figure>



<p>下面的内置函数不允许出现在语句的上下文中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">append</span> <span class="built_in">cap</span> <span class="built_in">complex</span> <span class="built_in">imag</span> <span class="built_in">len</span> <span class="built_in">make</span> <span class="built_in">new</span> <span class="built_in">real</span></span><br><span class="line">unsafe.Alignof unsafe.Offsetof unsafe.Sizeof</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h(x+y)</span><br><span class="line">f.Close()</span><br><span class="line">&lt;-ch</span><br><span class="line">(&lt;-ch)</span><br><span class="line"><span class="built_in">len</span>(<span class="string">&quot;foo&quot;</span>)  <span class="comment">// illegal if len is the built-in function</span></span><br></pre></td></tr></table></figure>



<h4 id="发送语句"><a href="#发送语句" class="headerlink" title="发送语句"></a>发送语句</h4><p>发送语句可以向通道发送一个值。通道表达式必须是通道类型，通道方向必须允许发送操作，并且值类型是可以分配给通道元素通道类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SendStmt = Channel <span class="string">&quot;&lt;-&quot;</span> Expression .</span><br><span class="line">Channel  = Expression .</span><br></pre></td></tr></table></figure>



<p>通道类型和值表达式会在发送之前求值。发送操作会一致阻塞，直到可以进行发送操作。如果接收者已经准备好向没有缓存的通道发送值可以立即执行。如果通道内还有缓存空间，向通道内发送值也会立即执行。向关闭的通道发送数据会导致运行时恐慌。像值为 nil 的通道发送数据会一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">3</span>  <span class="comment">// send value 3 to channel ch</span></span><br></pre></td></tr></table></figure>



<h4 id="递增-递减语句"><a href="#递增-递减语句" class="headerlink" title="递增&#x2F;递减语句"></a>递增&#x2F;递减语句</h4><p>“++” 和 “–” 语句可以递增或者递减运算元一个无类型常量 1。作为一个赋值语句，运算元必须是可寻址的或者 map 的索引表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">IncDecStmt = Expression ( <span class="string">&quot;++&quot;</span> | <span class="string">&quot;--&quot;</span> ) .</span><br></pre></td></tr></table></figure>



<p>下面的赋值语句在语义上是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">IncDec statement    Assignment</span><br><span class="line">x++                 x += <span class="number">1</span></span><br><span class="line">x--                 x -= <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Assignment = ExpressionList assign_op ExpressionList .</span><br><span class="line"></span><br><span class="line">assign_op = [ add_op | mul_op ] <span class="string">&quot;=&quot;</span> .</span><br></pre></td></tr></table></figure>



<p>所有左侧运算元都必须是可寻址的、map 索引表达式或空标识符其中之一。运算元可以用括号括起来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">*p = f()</span><br><span class="line">a[i] = <span class="number">23</span></span><br><span class="line">(k) = &lt;-ch  <span class="comment">// same as: k = &lt;-ch</span></span><br></pre></td></tr></table></figure>



<p>对于赋值操作 <code>x op= y</code> 其中 <code>op</code> 为二元运算符，它和 <code>x=x op (y)</code> 是等价的，不过它只计算一次 x。<code>op=</code> 是单独的一个词汇单元，在赋值操作中左侧表达式和右侧表达式必须都是单值表达式，并且左侧表达式不能是空白标识符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[i] &lt;&lt;= <span class="number">2</span></span><br><span class="line">i &amp;^= <span class="number">1</span>&lt;&lt;n</span><br></pre></td></tr></table></figure>



<p>元祖赋值语句会把运算返回的多个值分别分配给变量列表。它有两种格式，第一种：它是返回多值的表达式，例如函数调用、通道和 map 运算、类型断言。左侧运算元的数量必须等于返回值的数量。如果函数返回两个值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y = f()</span><br></pre></td></tr></table></figure>



<p>它会将第一个返回值分配给 x ，把第二个返回值分配给 y。第二种格式中，左侧运算元的数量必须等于右侧运算元的数量。每个表达式都只能返回单一值，右侧第 n 个值会赋值给左侧第 n 个变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">one, two, three = <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span></span><br></pre></td></tr></table></figure>



<p>空标识符可以在分配时忽略一个右面位置的表达式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = x       <span class="comment">// evaluate x but ignore it</span></span><br><span class="line">x, _ = f()  <span class="comment">// evaluate f() but ignore second result value</span></span><br></pre></td></tr></table></figure>



<p>赋值分为两个阶段。首先会计算左侧运算元的索引表达式和指针的解引用工作并以一定顺序计算右侧表达式的值。</p>
<p>然后依次对左侧运算元赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b = b, a  <span class="comment">// exchange a and b</span></span><br><span class="line"></span><br><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">i, x[i] = <span class="number">1</span>, <span class="number">2</span>  <span class="comment">// set i = 1, x[0] = 2</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">x[i], i = <span class="number">2</span>, <span class="number">1</span>  <span class="comment">// set x[0] = 2, i = 1</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>], x[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">2</span>  <span class="comment">// set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">1</span>], x[<span class="number">3</span>] = <span class="number">4</span>, <span class="number">5</span>  <span class="comment">// set x[1] = 4, then panic setting x[3] = 5.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123; x, y <span class="type">int</span> &#125;</span><br><span class="line"><span class="keyword">var</span> p *Point</span><br><span class="line">x[<span class="number">2</span>], p.x = <span class="number">6</span>, <span class="number">7</span>  <span class="comment">// set x[2] = 6, then panic setting p.x = 7</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">x = []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, x[i] = <span class="keyword">range</span> x &#123;  <span class="comment">// set i, x[2] = 0, x[0]</span></span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after this loop, i == 0 and x == []int&#123;3, 5, 3&#125;</span></span><br></pre></td></tr></table></figure>



<p>在赋值语句中每个值都必须能分配给左侧指定类型的值。除了以下特例：</p>
<ol>
<li><p>任何类型都能分配给空标识符。</p>
</li>
<li><p>如果把无类型常量分配给接口类型或者空标识符，它会转换成默认类型。</p>
</li>
<li><p>如果无类型的布尔值分配给了接口类型或者空标识符，它会先转换成 <code>bool</code> 类型。</p>
</li>
</ol>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p><code>if</code> 语句根据布尔值表达式的值来决定执行条件分支的代码。如果表达式为真，就执行 <code>if</code> 分支内的代码，否则执行 <code>else</code> 分支的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">IfStmt = <span class="string">&quot;if&quot;</span> [ SimpleStmt <span class="string">&quot;;&quot;</span> ] Expression Block [ <span class="string">&quot;else&quot;</span> ( IfStmt | Block ) ] .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; max &#123;</span><br><span class="line">	x = max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>表达式可能先于普通语句，它会在表达式求值之前发生。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x := f(); x &lt; y &#123;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; z &#123;</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>for 语句可以用来重复执行一段代码。它有三种格式：迭代器可以是单一条件、for 分句或者 range 语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ForStmt = <span class="string">&quot;for&quot;</span> [ Condition | ForClause | RangeClause ] Block .</span><br><span class="line">Condition = Expression .</span><br></pre></td></tr></table></figure>



<h6 id="单一条件的-for-语句"><a href="#单一条件的-for-语句" class="headerlink" title="单一条件的 for 语句"></a>单一条件的 for 语句</h6><p>这种情况下 for 会在条件为 true 时一直重复。条件会在每次迭代时都重新计算。如果没有指定条件，默认一直为 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a &lt; b &#123;</span><br><span class="line">	a *= <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="带分句的-for-语句"><a href="#带分句的-for-语句" class="headerlink" title="带分句的 for 语句"></a>带分句的 for 语句</h6><p>带分句的 for 语句也是由条件控制，只是它有一个初始化和寄送的过程。例如赋值、递增或者递减语句。初始化语句可以是短变量声明，但是寄送语句不能。在初始化语句中声明的变量可以在迭代过程中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ForClause = [ InitStmt ] <span class="string">&quot;;&quot;</span> [ Condition ] <span class="string">&quot;;&quot;</span> [ PostStmt ] .</span><br><span class="line">InitStmt = SimpleStmt .</span><br><span class="line">PostStmt = SimpleStmt .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	f(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果初始化语句非空，它会在进入迭代前执行一次；post 语句在每次循环后都会执行一次。在只有条件的情况下可以省略分号。如果缺省条件语句，默认为 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cond &#123; S() &#125;    is the same as    <span class="keyword">for</span> ; cond ; &#123; S() &#125;</span><br><span class="line"><span class="keyword">for</span>      &#123; S() &#125;    is the same as    <span class="keyword">for</span> <span class="literal">true</span>     &#123; S() &#125;</span><br></pre></td></tr></table></figure>



<h6 id="带-range-分句的-for-语句"><a href="#带-range-分句的-for-语句" class="headerlink" title="带 range 分句的 for 语句"></a>带 range 分句的 for 语句</h6><p>带 range 分句的 for 语句可以访问数组、切片、字符串、map 的所有元素，还可以从通道中接收值。迭代获得元素分配给了相应的迭代变量并执行代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">RangeClause = [ ExpressionList <span class="string">&quot;=&quot;</span> | IdentifierList <span class="string">&quot;:=&quot;</span> ] <span class="string">&quot;range&quot;</span> Expression .</span><br></pre></td></tr></table></figure>



<p>右侧的 range 分句表达式叫做 range 表达式，它可能是数组、数组的指针、切片、字符串、map 或通道接收者类型。在分配时，左侧运算元必须是可寻址的或者 map 的索引表达式；它们作为迭代变量。如果 range 表达式是一个通道类型，至少需要有一个变量，它也可以有两个变量。如果迭代变量是空标识符，就代表在分句中不存在该标识符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Range expression                          <span class="number">1</span>st value          <span class="number">2</span>nd value</span><br><span class="line"></span><br><span class="line">array or slice  a  [n]E, *[n]E, or []E    index    i  <span class="type">int</span>    a[i]       E</span><br><span class="line"><span class="type">string</span>          s  <span class="type">string</span> <span class="keyword">type</span>            index    i  <span class="type">int</span>    see below  <span class="type">rune</span></span><br><span class="line"><span class="keyword">map</span>             m  <span class="keyword">map</span>[K]V                key      k  K      m[k]       V</span><br><span class="line">channel         c  <span class="keyword">chan</span> E, &lt;-<span class="keyword">chan</span> E       element  e  E</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testdata *<span class="keyword">struct</span> &#123;</span><br><span class="line">	a *[<span class="number">7</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> testdata.a &#123;</span><br><span class="line">	<span class="comment">// testdata.a is never evaluated; len(testdata.a) is constant</span></span><br><span class="line">	<span class="comment">// i ranges from 0 to 6</span></span><br><span class="line">	f(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i, s := <span class="keyword">range</span> a &#123;</span><br><span class="line">	<span class="comment">// type of i is int</span></span><br><span class="line">	<span class="comment">// type of s is string</span></span><br><span class="line">	<span class="comment">// s == a[i]</span></span><br><span class="line">	g(i, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> val <span class="keyword">interface</span> &#123;&#125;  <span class="comment">// element type of m is assignable to val</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;mon&quot;</span>:<span class="number">0</span>, <span class="string">&quot;tue&quot;</span>:<span class="number">1</span>, <span class="string">&quot;wed&quot;</span>:<span class="number">2</span>, <span class="string">&quot;thu&quot;</span>:<span class="number">3</span>, <span class="string">&quot;fri&quot;</span>:<span class="number">4</span>, <span class="string">&quot;sat&quot;</span>:<span class="number">5</span>, <span class="string">&quot;sun&quot;</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, val = <span class="keyword">range</span> m &#123;</span><br><span class="line">	h(key, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key == last map key encountered in iteration</span></span><br><span class="line"><span class="comment">// val == map[key]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> Work = producer()</span><br><span class="line"><span class="keyword">for</span> w := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	doWork(w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty a channel</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ch &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Go-语句"><a href="#Go-语句" class="headerlink" title="Go 语句"></a>Go 语句</h4><p><code>go</code> 语句会开始在相同地址空间中的单独 goroutine 中调用函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GoStmt = <span class="string">&quot;go&quot;</span> Expression .</span><br></pre></td></tr></table></figure>



<p>表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数有表达式语句的限制。</p>
<p>函数的值和参数会按顺序在调用的 goroutine 中求值。不像普通的函数调用，程序不会等待函数调用完成，而是直接开启一个新的 goroutine 执行函数。函数退出时，goroutine 也会退出。函数的任何返回值都会被丢弃。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> Server()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">bool</span>)</span></span> &#123; <span class="keyword">for</span> &#123; sleep(<span class="number">10</span>); ch &lt;- <span class="literal">true</span> &#125;&#125; (c)</span><br></pre></td></tr></table></figure>



<h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><p>select 语句会在接收&#x2F;发送操作集中选择一个执行。它看起来和 switch 很像，只不过是专门针对通信操作的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SelectStmt = <span class="string">&quot;select&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123; CommClause &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">CommClause = CommCase <span class="string">&quot;:&quot;</span> StatementList .</span><br><span class="line">CommCase   = <span class="string">&quot;case&quot;</span> ( SendStmt | RecvStmt ) | <span class="string">&quot;default&quot;</span> .</span><br><span class="line">RecvStmt   = [ ExpressionList <span class="string">&quot;=&quot;</span> | IdentifierList <span class="string">&quot;:=&quot;</span> ] RecvExpr .</span><br><span class="line">RecvExpr   = Expression .</span><br></pre></td></tr></table></figure>



<p>接收表达式可以将接收表达式的值分配给一个或两个变量。接收表达式必须是一个接收运算元（可以使用括号括起来）。它最多允许有一个 default 语句。</p>
<p>select 语句执行以下几个步骤：</p>
<ol>
<li><p>对于 select 语句的所有分句，接收操作的通道运算元、通道、发送语句的右侧表达式都会执行一次操作。</p>
</li>
<li><p>如果一个或多个通信同时发生，它会通过一致性随机选择一个执行。如果没有 default 语句，select 语句会一直阻塞。</p>
</li>
<li><p>除了 default 分句，其他分句只有在开始进行通信的时候才会执行。</p>
</li>
<li><p>如果 select 分句是一个接收语句，它可以给变量分配值。</p>
</li>
<li><p>执行 select 分句内的内容。</p>
</li>
</ol>
<p>如果向 nil 通道发送信息在没有 default 分句的情况下会一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</span><br><span class="line">	<span class="comment">// same as:</span></span><br><span class="line">	<span class="comment">// case t := &lt;-c4</span></span><br><span class="line">	<span class="comment">//	a[f()] = t</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;  <span class="comment">// send random sequence of bits to c</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> c &lt;- <span class="number">0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></span><br><span class="line">	<span class="keyword">case</span> c &lt;- <span class="number">1</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;  <span class="comment">// block forever</span></span><br></pre></td></tr></table></figure>



<h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><p><code>return</code> 语句会终止函数 F 的执行并可选的返回一个或多个返回值。所有的滞后函数都会在 F 返回到它的调用者之前执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ReturnStmt = <span class="string">&quot;return&quot;</span> [ ExpressionList ] .</span><br></pre></td></tr></table></figure>



<p>如果函数没有返回值类型，return 不能返回任何值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noResult</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有三种方式能够返回指定类型的值：</p>
<ol>
<li>返回值可以直接在 return 语句中列出。每个表达式都必须返回一个值并且能够分配给相应的返回值类型。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleF</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complexF1</span><span class="params">()</span></span> (re <span class="type">float64</span>, im <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-7.0</span>, <span class="number">-4.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>return 语句的表达式列表可以是一个返回多值的函数调用。这时会使用临时变量来获取函数调用的返回值并直接将其作为 return 语句的表达式列表。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complexF2</span><span class="params">()</span></span> (re <span class="type">float64</span>, im <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> complexF1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果制定了返回值的标识符那么 return 的表达式列表可以为空。返回值参数会作为普通的本地变量按需分配。return 语句会直接返回它们。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complexF3</span><span class="params">()</span></span> (re <span class="type">float64</span>, im <span class="type">float64</span>) &#123;</span><br><span class="line">	re = <span class="number">7.0</span></span><br><span class="line">	im = <span class="number">4.0</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(devnull)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, _ <span class="type">error</span>) &#123;</span><br><span class="line">	n = <span class="built_in">len</span>(p)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不管如何声明，所有的返回值都会在进入函数前提前初始化成类型的零值。return 语句会在所有 defer 函数之前指定返回值。</p>
<p>实现限制：编译器不允许在覆盖了命名返回值的作用域中直接返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="type">int</span>)</span></span> (res <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := f(n<span class="number">-1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="comment">// invalid return statement: err is shadowed</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><p><code>break</code> 语句会在 <code>for</code>、<code>switch</code> 或 <code>select</code> 语句内部退出到相同函数的某个位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BreakStmt = <span class="string">&quot;break&quot;</span> [ Label ] .</span><br></pre></td></tr></table></figure>



<p>如果想指定标签，它必须出现在它所中止的 <code>for</code>、<code>switch</code> 或 <code>select</code> 语句旁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">			<span class="keyword">switch</span> a[i][j] &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">				state = Error</span><br><span class="line">				<span class="keyword">break</span> OuterLoop</span><br><span class="line">			<span class="keyword">case</span> item:</span><br><span class="line">				state = Found</span><br><span class="line">				<span class="keyword">break</span> OuterLoop</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p><code>continue</code> 语句会提前 <code>for</code> 语句的下一次迭代。<code>for</code> 语句必须和 <code>continue</code> 在相同函数中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">RowLoop:</span><br><span class="line">	<span class="keyword">for</span> y, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">		<span class="keyword">for</span> x, data := <span class="keyword">range</span> row &#123;</span><br><span class="line">			<span class="keyword">if</span> data == endOfRow &#123;</span><br><span class="line">				<span class="keyword">continue</span> RowLoop</span><br><span class="line">			&#125;</span><br><span class="line">			row[x] = data + bias(x, y)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><p><code>goto</code> 会将程序跳转到相同函数的指定标签处。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GotoStmt = <span class="string">&quot;goto&quot;</span> Label .</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> Error</span><br></pre></td></tr></table></figure>



<p>goto 语句不允许跳过作用域内程序变量的初始化工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> L  <span class="comment">// BAD</span></span><br><span class="line">	v := <span class="number">3</span></span><br><span class="line">L:</span><br></pre></td></tr></table></figure>



<p>上面的程序是错误的，因为它跳过了变量 v 的初始化过程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">	<span class="keyword">goto</span> L1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">	f()</span><br><span class="line">	n--</span><br><span class="line">L1:</span><br><span class="line">	f()</span><br><span class="line">	n--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>标签作用域外的 goto 语句不能跳转到标签处，所以上面的代码是错误的。</p>
<h4 id="Fallthrough-语句"><a href="#Fallthrough-语句" class="headerlink" title="Fallthrough 语句"></a>Fallthrough 语句</h4><p><code>fallthrough</code> 语句会跳转到 <code>switch</code> 语句中的下一个 case 分句中。它应该只在最后一个非空分句中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FallthroughStmt = <span class="string">&quot;fallthrough&quot;</span> .</span><br></pre></td></tr></table></figure>



<h4 id="Defer-语句"><a href="#Defer-语句" class="headerlink" title="Defer 语句"></a>Defer 语句</h4><p><code>defer</code> 语句会在包裹函数返回后触发函数调用。这里的返回泛指函数因为 return 语句终止、到达函数末尾或者当前 goroutine 触发运行时恐慌。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">DeferStmt = <span class="string">&quot;defer&quot;</span> Expression .</span><br></pre></td></tr></table></figure>



<p>表达式必须是函数或者方法调用；它不能使用括号括起来，调用内置函数会有一些限制。</p>
<p>每次执行 defer 语句执行时都会计算函数的参数和值，但是并不会调用函数。相反，函数的调用是在包裹函数返回后进行，它们的执行顺序与声明顺序正好相反。如果 defer 对应的函数值为 nil，会在调用函数的时候导致运行时恐慌而不是声明 defer 语句的时候。</p>
<p>例如：当 defer 函数为函数字面值且包裹函数具有命名结果值，此时，我们在defer 函数中可以访问和修改命名的结果值。defer 函数的所有返回值都会被忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lock(l)</span><br><span class="line"><span class="keyword">defer</span> unlock(l)  <span class="comment">// unlocking happens before surrounding function returns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prints 3 2 1 0 before surrounding function returns</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f returns 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		result++</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>内置函数是预定义的。调用他们和其他函数一样只是他们接受一个类型而不是一个表达式。</p>
<p>内置函数没有标准的 Go 类型，所以他们只能作为调用表达式；而不能作为函数的值。</p>
<h6 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h6><p>对于管道类型 c，内置函数 <code>close(c)</code> 意味着不在有数据插入到管道中。如果 <code>c</code> 是一个只接收数据的管道，会发生错误。向已经关闭的发送数据或者重复关闭已经关闭的管道会导致运行时恐慌。关闭 nil 管道会引起运行时恐慌。调用 close 后所有之前发送的数据都能接收到，并且在最后不会阻塞而返回零值。多值的接收操作能够返回接收到的数据和表示管道是否关闭的布尔值。</p>
<h6 id="长度和容积"><a href="#长度和容积" class="headerlink" title="长度和容积"></a>长度和容积</h6><p>内置函数 <code>len</code> 和 <code>cap</code> 可以接收多种类型的参数，并且返回一个 int 类型结果值。函数的实现能够确保结果值不会溢出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Call      Argument <span class="keyword">type</span>    Result</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(s)    <span class="type">string</span> <span class="keyword">type</span>      <span class="type">string</span> length in bytes</span><br><span class="line">          [n]T, *[n]T      array length (== n)</span><br><span class="line">          []T              slice length</span><br><span class="line">          <span class="keyword">map</span>[K]T          <span class="keyword">map</span> length (number of defined keys)</span><br><span class="line">          <span class="keyword">chan</span> T           number of elements queued in channel buffer</span><br><span class="line"></span><br><span class="line"><span class="built_in">cap</span>(s)    [n]T, *[n]T      array length (== n)</span><br><span class="line">          []T              slice capacity</span><br><span class="line">          <span class="keyword">chan</span> T           channel buffer capacity</span><br></pre></td></tr></table></figure>



<p>切片的容积底层数组包含的元素个数。在任何情况下都有以下关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= <span class="built_in">len</span>(s) &lt;= <span class="built_in">cap</span>(s)</span><br></pre></td></tr></table></figure>



<p><code>nil</code> 切片，map，或者 channel 的长度都为 0。<code>nil</code> 切片，管道的容积都为 0。</p>
<p>表达式 <code>len(x)</code> 在 <code>s</code> 是字符串常量时也为常量。如果 <code>s</code> 为数组或者指向数组的指针并且表达式 s 不包含 <code>channel</code> 接收器或者函数调用那么 <code>len(s)</code> 和 <code>cap(s)</code> 也是常量；在这个情况下 s 时不能求值的。其他情况下 <code>len</code> 和 <code>cap</code> 不是常量并且 <code>s</code> 是可以求值的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	c1 = <span class="built_in">imag</span>(<span class="number">2i</span>)                    <span class="comment">// imag(2i) = 2.0 is a constant</span></span><br><span class="line">	c2 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;<span class="number">2</span>&#125;)         <span class="comment">// [10]float64&#123;2&#125; contains no function calls</span></span><br><span class="line">	c3 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;c1&#125;)        <span class="comment">// [10]float64&#123;c1&#125; contains no function calls</span></span><br><span class="line">	c4 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;<span class="built_in">imag</span>(<span class="number">2i</span>)&#125;)  <span class="comment">// imag(2i) is a constant and no function call is issued</span></span><br><span class="line">	c5 = <span class="built_in">len</span>([<span class="number">10</span>]<span class="type">float64</span>&#123;<span class="built_in">imag</span>(z)&#125;)   <span class="comment">// invalid: imag(z) is a (non-constant) function call</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span></span><br></pre></td></tr></table></figure>



<h6 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h6><p>内置函数 <code>new</code> 接收一个类型 T，它会在运行时给变量分配内存，并且返回一个指向类型 <code>T</code> 的 <code>*T</code> 类型指针。变量的初始化在初始化值章节中介绍。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123; a <span class="type">int</span>; b <span class="type">float64</span> &#125;</span><br><span class="line"><span class="built_in">new</span>(S)</span><br></pre></td></tr></table></figure>



<p>给 S 类型的变量分配空间，并初始化它（<code>a=0</code>，<code>b=0.0</code>），并且返回一个 <code>*S</code> 类型值保存变量所在的位置。</p>
<h6 id="创建切片，map-和-管道"><a href="#创建切片，map-和-管道" class="headerlink" title="创建切片，map 和 管道"></a>创建切片，map 和 管道</h6><p>内置函数 <code>make</code> 以一个类型作为参数，它必须是一个切片，map 或者管道类型，它返回一个 T 类型的值，而不是（*T）类型，它会按初始化值章节描述的方式进行初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Call             Type T     Result</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(T, n)       slice      slice of <span class="keyword">type</span> T with length n and capacity n</span><br><span class="line"><span class="built_in">make</span>(T, n, m)    slice      slice of <span class="keyword">type</span> T with length n and capacity m</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(T)          <span class="keyword">map</span>        <span class="keyword">map</span> of <span class="keyword">type</span> T</span><br><span class="line"><span class="built_in">make</span>(T, n)       <span class="keyword">map</span>        <span class="keyword">map</span> of <span class="keyword">type</span> T with initial space <span class="keyword">for</span> approximately n elements</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(T)          channel    unbuffered channel of <span class="keyword">type</span> T</span><br><span class="line"><span class="built_in">make</span>(T, n)       channel    buffered channel of <span class="keyword">type</span> T, buffer size n</span><br></pre></td></tr></table></figure>



<p>n 和 m 必须是整数类型或者无类型常量。一个常量参数不能为负数并且该值在 <code>int</code> 类型的范围内；如果它是无类型常量，会被转换成 <code>int</code> 类型。如果 n 和 m 都是常量，那么 n 必须大于 m。如果 n 是负数或者大于 m 会引发运行时 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">100</span>)       <span class="comment">// slice with len(s) == 10, cap(s) == 100</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1e3</span>)           <span class="comment">// slice with len(s) == cap(s) == 1000</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>&lt;&lt;<span class="number">63</span>)         <span class="comment">// illegal: len(s) is not representable by a value of type int</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">0</span>)         <span class="comment">// illegal: len(s) &gt; cap(s)</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)         <span class="comment">// channel with a buffer size of 10</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>)  <span class="comment">// map with initial space for approximately 100 elements</span></span><br></pre></td></tr></table></figure>



<p>使用 make 来指定大小初始化 map 类型将会创建一个预留 n 个元素空间的 map 类型。更详细的行为依赖于具体实现。</p>
<h6 id="追加或者拷贝切片"><a href="#追加或者拷贝切片" class="headerlink" title="追加或者拷贝切片"></a>追加或者拷贝切片</h6><p>内置函数 <code>append</code> 和 <code>copy</code> 可以进行切片的通用操作。对于这两个函数，一个是拷贝内存，一个是引用内存。</p>
<p>可变参数的函数 <code>append</code> 可以向切片 s 中追加一个或多个 x 值，并返回这个切片。传进 <code>...T</code> 的值会根据参数传值。作为特例，<code>append</code> 在 s 为 <code>[]byte</code> 切片时，可以使用字符串后面跟 <code>...</code> 作为参数。</p>
<p>如果 s 的容积容纳不下这些元素，那么 <code>append</code> 会分配一个新的足够大的数组。否则会使用原来的底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s0 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">s1 := <span class="built_in">append</span>(s0, <span class="number">2</span>)                <span class="comment">// append a single element     s1 == []int&#123;0, 0, 2&#125;</span></span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)          <span class="comment">// append multiple elements    s2 == []int&#123;0, 0, 2, 3, 5, 7&#125;</span></span><br><span class="line">s3 := <span class="built_in">append</span>(s2, s0...)            <span class="comment">// append a slice              s3 == []int&#123;0, 0, 2, 3, 5, 7, 0, 0&#125;</span></span><br><span class="line">s4 := <span class="built_in">append</span>(s3[<span class="number">3</span>:<span class="number">6</span>], s3[<span class="number">2</span>:]...)   <span class="comment">// append overlapping slice    s4 == []int&#123;3, 5, 7, 2, 3, 5, 7, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = <span class="built_in">append</span>(t, <span class="number">42</span>, <span class="number">3.1415</span>, <span class="string">&quot;foo&quot;</span>)   <span class="comment">//                             t == []interface&#123;&#125;&#123;42, 3.1415, &quot;foo&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">&quot;bar&quot;</span>...)            <span class="comment">// append string contents      b == []byte&#123;&#x27;b&#x27;, &#x27;a&#x27;, &#x27;r&#x27; &#125;</span></span><br></pre></td></tr></table></figure>



<p><code>copy</code> 函数从 <code>src</code> 拷贝原属到 <code>dst</code> 并且返回拷贝元素的个数。参数中所有的元素类型必须是 T 类型或者能转换成 T 的类型。拷贝元素的数量是 <code>len(src)</code> 和 <code>len(dst)</code> 中的较小值。作为特例，<code>copy</code> 可以从 string 类型拷贝元素到 <code>[]byte</code> 类型。这会把字符串中的元素拷贝到字节切片中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dst, src []T) <span class="type">int</span></span><br><span class="line"><span class="built_in">copy</span>(dst []<span class="type">byte</span>, src <span class="type">string</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">n1 := <span class="built_in">copy</span>(s, a[<span class="number">0</span>:])            <span class="comment">// n1 == 6, s == []int&#123;0, 1, 2, 3, 4, 5&#125;</span></span><br><span class="line">n2 := <span class="built_in">copy</span>(s, s[<span class="number">2</span>:])            <span class="comment">// n2 == 4, s == []int&#123;2, 3, 4, 5, 4, 5&#125;</span></span><br><span class="line">n3 := <span class="built_in">copy</span>(b, <span class="string">&quot;Hello, World!&quot;</span>)  <span class="comment">// n3 == 5, b == []byte(&quot;Hello&quot;)</span></span><br></pre></td></tr></table></figure>



<h6 id="删除-map-中的元素"><a href="#删除-map-中的元素" class="headerlink" title="删除 map 中的元素"></a>删除 map 中的元素</h6><p>内置函数 <code>delete</code> 移除 map 类型 m 中的键值 k。k 的类型必须是能够转换成 m 键类型的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, k)  <span class="comment">// remove element m[k] from map m</span></span><br></pre></td></tr></table></figure>



<p>如果 map 类型 m 是 nil 或者 m[k] 不存在，那么 <code>delete</code> 函数不做任何事情。</p>
<h6 id="操作复数"><a href="#操作复数" class="headerlink" title="操作复数"></a>操作复数</h6><p>有三个函数可以组装或者分解复数。内置函数 <code>complex</code> 会构造一个复数，<code>real</code> 和 <code>imag</code> 会分解出复数的实部和虚部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>(realPart, imaginaryPart floatT) complexT</span><br><span class="line"><span class="built_in">real</span>(complexT) floatT</span><br><span class="line"><span class="built_in">imag</span>(complexT) floatT</span><br></pre></td></tr></table></figure>



<p>参数的类型和返回值类型是对应的。对于 <code>complex</code>，两个参数必须是相同的浮点类型，并返回由相同浮点数组成的复数类型。<code>complex64</code> 是 <code>float32</code> 对应的类型，<code>complex128</code> 是 <code>float64</code> 对应的参数类型。如果参数是一个无类型常量，它会转换成另一个参数的类型。如果两个参数都是无类型常量，他们必须实数或者虚数部分为零，并且它会返回一个无类型的复数常量。</p>
<p><code>real</code> 和 <code>imag</code> 函数和 <code>complex</code> 正好相反的，所以对于一个值复数类型 Z 的值 z，<code>z==Z(complex(real(z),imag(z)))</code>。</p>
<p>如果这么操作都是常量，那么返回的值也是常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">complex</span>(<span class="number">2</span>, <span class="number">-2</span>)             <span class="comment">// complex128</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">complex</span>(<span class="number">1.0</span>, <span class="number">-1.4</span>)       <span class="comment">// untyped complex constant 1 - 1.4i</span></span><br><span class="line">x := <span class="type">float32</span>(math.Cos(math.Pi/<span class="number">2</span>))  <span class="comment">// float32</span></span><br><span class="line"><span class="keyword">var</span> c64 = <span class="built_in">complex</span>(<span class="number">5</span>, -x)           <span class="comment">// complex64</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">uint</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">0</span>)         <span class="comment">// untyped complex constant 1 + 0i can be converted to uint</span></span><br><span class="line">_ = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>&lt;&lt;s)               <span class="comment">// illegal: 2 assumes floating-point type, cannot shift</span></span><br><span class="line"><span class="keyword">var</span> rl = <span class="built_in">real</span>(c64)                 <span class="comment">// float32</span></span><br><span class="line"><span class="keyword">var</span> im = <span class="built_in">imag</span>(a)                   <span class="comment">// float64</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">imag</span>(b)                  <span class="comment">// untyped constant -1.4</span></span><br><span class="line">_ = <span class="built_in">imag</span>(<span class="number">3</span> &lt;&lt; s)                   <span class="comment">// illegal: 3 assumes complex type, cannot shift</span></span><br></pre></td></tr></table></figure>



<h6 id="处理-panic"><a href="#处理-panic" class="headerlink" title="处理 panic"></a>处理 panic</h6><p>两个内置函数 <code>panic</code> 和 <code>recover</code>，可以抛出和处理运行时 <code>panic</code> 和程序的错误条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>当执行 F 函数时，显式的调用 <code>panic</code>或者运行时 panic 都会中断 F 的执行。但是 F 中的延迟函数还会执行。接下来调用 F 函数处的延迟函数也会执行，一直到顶级的延迟函数。鉴于这点，程序关闭并且错误条件可以抛出。包括 <code>panic</code> 中的值。这个顺序叫做 <code>panicking</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="number">42</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(Error(<span class="string">&quot;cannot parse&quot;</span>))</span><br></pre></td></tr></table></figure>



<p><code>recover</code> 函数允许程序从一个 panicking 中恢复执行。假设函数 G 延迟执行函数 D ，在 D 中调用 <code>recover</code> 这时如果在 G 执行时发生 panic 会在 D 中恢复。当函数执行到 D，<code>recover</code> 的返回值会返回 <code>panic</code> 对应的错误，并且终止 <code>panicking</code> 。在这个情况下 G 函数和 <code>panic</code> 之间的代码不会执行。任何在 D 中 G 之前的延迟函数会返回到调用者。</p>
<p>在下面两种情况下 <code>recover</code> 会返回 nil：</p>
<ul>
<li><p>panic 的参数为 nil</p>
</li>
<li><p>携程里没有发生 panic</p>
</li>
<li><p>recover 不是在延迟函数中执行</p>
</li>
</ul>
<p>本例中的 <code>protect</code> 函数会在 g 发生 panic 的时候恢复执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;done&quot;</span>)  <span class="comment">// Println executes normally even if there is a panic</span></span><br><span class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;run time panic: %v&quot;</span>, x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	log.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>这个实现提供了多个内置函数来帮助进行初始化。这些函数用来输出信息但是不确定会一直存在于语言中，他们都没有返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Function   Behavior</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>      prints all arguments; formatting of arguments is implementation-specific</span><br><span class="line"><span class="built_in">println</span>    like <span class="built_in">print</span> but prints spaces between arguments and a newline at the end</span><br></pre></td></tr></table></figure>



<p>实现限制：<code>print</code> 和 <code>println</code> 不接受除了布尔值，数字，字符串以外的其他类型。</p>
<h4 id="程序的初始化和执行"><a href="#程序的初始化和执行" class="headerlink" title="程序的初始化和执行"></a>程序的初始化和执行</h4><h6 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h6><p>当为变量分配内存空间时，不管是声明还是调用 <code>new</code> 或者使用字面值和 <code>make</code> 初始化，只要创建了一个新值变量都会有一个默认值。这样的元素和值会使用它类型的零值：<code>false</code> 是布尔值的零值，0 为数值类型零值，”” 为字符串零值，nil 为指针，函数，接口，切片，频道，字典。初始化会递归完成，所以结构体里的数组中的元素也都会有它自己的零值。</p>
<p>下面两个声明时相等的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>请看下面的声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; i <span class="type">int</span>; f <span class="type">float64</span>; next *T &#125;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line">t.i == <span class="number">0</span></span><br><span class="line">t.f == <span class="number">0.0</span></span><br><span class="line">t.next == <span class="literal">nil</span></span><br></pre></td></tr></table></figure>



<p>这和下面的声明时同等效果的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t T</span><br></pre></td></tr></table></figure>



<h6 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h6><p>保级变量会按声明的顺序进行初始化，如果依赖其他变量，则会在其他变量之后进行初始化。</p>
<p>更确切的说，如果包级变量还没初始化并且没有初始化表达式或者表达式中不包含对其他未初始化变量的依赖，那么会认为它正在等待初始化。初始化过程会从最早声明的变量开始向下一个包级变量重复，直到没有需要初始化的变量。</p>
<p>如果在初始化过程完成后还有未初始化的变量，那么这些变量可能是循环初始化了，这事程序不是合法的。</p>
<p>在多个文件中变量的声明顺序会依据编译时文件出现的顺序：声明在第一个文件中的变量优先于第二个文件中声明的变量，依此类推。</p>
<p>对依赖关系的分析不会根据变量的具体值，它只分析在源码中是否引用了其他变量。例如，如果变量 x 的初始化表达式引用了变量 y 那么 x 就依赖于 y：</p>
<ul>
<li><p>引用一个变量或者函数中用到了一个变量</p>
</li>
<li><p>引用了一个方法值 <code>m</code> 或者方法表达式 <code>t.m</code> (这里的静态类型 <code>t</code> 不是借口类型，并且方法 <code>m</code> 是 <code>t</code> 方法集中的方法)。<code>t.m</code> 的返回值不会在此时影响。</p>
</li>
<li><p>变量，函数，或者方法 x 依赖变量 y</p>
</li>
</ul>
<p>依赖分析会在每个包中执行；他只考虑当前包中的析变量，函数，和方法。</p>
<p>例如，给定声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a = c + b</span><br><span class="line">	b = f()</span><br><span class="line">	c = f()</span><br><span class="line">	d = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	d++</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化顺序为 d，b，c，a。</p>
<p>变量可以在包中声明的初始化函数 <code>init</code> 中进行初始化，它没有参数和返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>可以为每个包定义多个该函数，甚至在一个文件中也可以。并且不会声明该该标识符。因此 init 函数不能在程序中调用。</p>
<p>还未导入的包会先初始化包级的变量然后按照 <code>init</code> 函数在源码中的顺序调用，它可能在包的多个文件中。如果需要导入一个包，它会在初始化自己之前先初始化这个需要导入的包。如果导入一个包多次，那这个包只会初始化一次。导入的包不能存在循环引用。</p>
<p>包的初始化——变量初始化和对 init 函数的调用会按顺序发生在同一个 goroutine 中。 <code>init</code> 函数可能会启动其他 goroutine。不过一般 <code>init</code> 函数都是按序进行初始化的：它只在上一步已经执行完成时才会调用下一个步骤。</p>
<p>确保初始化行为是可以复现的，构建系统鼓励在同一个包中包含多个文件这些文件在编译器中会以字母排序。</p>
<h6 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h6><p>一个完整的程序由一个 <code>main</code> 包导入所有需要的包。<code>main</code> 包必须以 <code>main</code> 作为包名并且声明一个没有参数和返回值的 <code>main</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>程序先初始化 <code>main</code> 包然后调用 <code>main</code> 函数。当 <code>main</code> 函数返回时，程序就会退出。它不会等待其他 goroutines 完成。</p>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>预定义的错误类型为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它是表示错误信息的常规接口，nil 代表没有发生错误。例如，在文件中读取数据可以定义为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(f *File, b []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h4 id="运行时恐慌"><a href="#运行时恐慌" class="headerlink" title="运行时恐慌"></a>运行时恐慌</h4><p>运行时错误（例如数组的越界访问）会造成运行时恐慌，它和以 <code>runtime.Error</code> 接口实现调用内置的 <code>panic</code> 函数一样。<code>runtime.Error</code> 满足预定义的 <code>error</code> 接口。不同的错误值代表不同的运行时错误条件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> runtime</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="type">error</span></span><br><span class="line">	<span class="comment">// and perhaps other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h4><h6 id="unsafe-包"><a href="#unsafe-包" class="headerlink" title="unsafe 包"></a>unsafe 包</h6><p><code>unsafe</code> 是编译器已知的内置包，可以通过导入路径 <code>unsafe</code> 访问包内容，提供 <code>unsafe</code> 包目的是支持底层编程（包括操作非 Go 类型的数据结构）。使用 <code>unsafe</code> 包必须自己保证类型安全而且它有可能破坏程序的移植性。<code>unsafe</code> 包提供了以下接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span>  <span class="comment">// 任意一个 Go 类型；它不是一个具体的类型。</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(variable ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(selector ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(variable ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>



<p><code>Pointer</code> 是一个指针类型，但是不能解引用 <code>Pointer</code> 的值。所有底层类型 <code>uintptr</code> 的指针和值都能转换成 <code>Pointer</code> 类型，反之亦然。<code>Pointer</code> 和  <code>uintptr</code> 之间的转换效果由具体实现定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br><span class="line">bits = *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f))</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ptr unsafe.Pointer</span><br><span class="line">bits = *(*<span class="type">uint64</span>)(ptr(&amp;f))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p ptr = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>



<p>假设变量 v 由 <code>var v = x</code> 定义。<code>Alignof</code> 以表达式 x 作为参数并返回 x 的对齐字节数。<code>Sizeof</code> 以表达式 x 作为参数并返回 x 的大小。</p>
<p>函数 <code>Offsetof</code> 以选择器 <code>s.f</code>（ s 或者 *s 结构体中的 f 字段）作为参数，返回字段相对结构体首地址的位置。如果 f 是一个嵌入字段，那 f 必须可以直接访问（不能通过指针进行间接访问）。对于结构体 s 的 f 字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == <span class="type">uintptr</span>(unsafe.Pointer(&amp;s.f))</span><br></pre></td></tr></table></figure>



<p>计算机的体系结构要求对齐内存地址（对于一个变量的地址有多种因素影响对齐）。<code>Alignof</code> 函数获取一个人和类型的表达式并返回变量对齐的字节数。对于变量 x：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr</span>(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>编译时 <code>uintptr</code> 类型常量表达式会调用 <code>Alignof</code>，<code>Offsetof</code>，和 <code>Sizeof</code>。</p>
<h6 id="确定的大小和对齐字节数"><a href="#确定的大小和对齐字节数" class="headerlink" title="确定的大小和对齐字节数"></a>确定的大小和对齐字节数</h6><p>对于数字类型，确定有以下尺寸：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>                                 size in bytes</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>, <span class="type">uint8</span>, <span class="type">int8</span>                     <span class="number">1</span></span><br><span class="line"><span class="type">uint16</span>, <span class="type">int16</span>                         <span class="number">2</span></span><br><span class="line"><span class="type">uint32</span>, <span class="type">int32</span>, <span class="type">float32</span>                <span class="number">4</span></span><br><span class="line"><span class="type">uint64</span>, <span class="type">int64</span>, <span class="type">float64</span>, <span class="type">complex64</span>     <span class="number">8</span></span><br><span class="line"><span class="type">complex128</span>                           <span class="number">16</span></span><br></pre></td></tr></table></figure>



<p>Go 中规定的最小对齐特性：</p>
<ol>
<li><p>对于任意变量类型 x：<code>unsafe.Alignof(x)</code> 至少为 1。</p>
</li>
<li><p>对于结构体类型：<code>unsafe.Alignof(x)</code> 是所有内部字段 <code>unsafe.Alignof(x.f)</code> 的最大值，并且至少为 1。</p>
</li>
<li><p>对于数组类型：<code>unsafe.Alignof(x)</code> 和数组元素类型的 alignment 相同。</p>
</li>
</ol>
<p>结构体（数组）在内部没有字段（元素）的时候大小为 0。两个所占空间大小为 0 的不同变量可能在内存中拥有相同地址。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础教程</title>
    <url>/2023/09/02/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>原文来自：<a href="https://github.com/GrindGold/CppGuide">https://github.com/GrindGold/CppGuide</a></strong></p>
<h1 id="C-教程"><a href="#C-教程" class="headerlink" title="C++ 教程"></a>C++ 教程</h1><p><img src="https://edu.aliyun.com/files/course/2017/09-24/1539291c8853274278.png"></p>
<p>C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。</p>
<p>本教程通过通俗易懂的语言来讲解 C++ 编程语言。</p>
<p><strong>现在开始学习 C++ 编程！</strong></p>
<h2 id="谁适合阅读本教程？"><a href="#谁适合阅读本教程？" class="headerlink" title="谁适合阅读本教程？"></a>谁适合阅读本教程？</h2><p>本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。</p>
<h2 id="阅读本教程前，您需要了解的知识："><a href="#阅读本教程前，您需要了解的知识：" class="headerlink" title="阅读本教程前，您需要了解的知识："></a>阅读本教程前，您需要了解的知识：</h2><p>在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。</p>
<h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译&#x2F;执行 C++ 程序"></a>编译&#x2F;执行 C++ 程序</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>你可以用 “\n” 代替以上代码里的 “endl”。</p>
<h1 id="C-简介"><a href="#C-简介" class="headerlink" title="C++ 简介"></a>C++ 简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>
<p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p>
<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p>
<p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p>
<p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p>
<ul>
<li>封装</li>
<li>抽象</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>标准的 C++ 由三个重要部分组成：</p>
<ul>
<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>
<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>
<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>
</ul>
<h2 id="ANSI-标准"><a href="#ANSI-标准" class="headerlink" title="ANSI 标准"></a>ANSI 标准</h2><p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>
<p>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p>
<h2 id="学习-C"><a href="#学习-C" class="headerlink" title="学习 C++"></a>学习 C++</h2><p>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</p>
<p>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</p>
<p>C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。</p>
<h2 id="C-的使用"><a href="#C-的使用" class="headerlink" title="C++ 的使用"></a>C++ 的使用</h2><p>基本上每个应用程序领域的程序员都有使用 C++。</p>
<p>C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。</p>
<p>C++ 广泛用于教学和研究。</p>
<p>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</p>
<hr>
<h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><table>
<thead>
<tr>
<th align="left">发布时间</th>
<th align="left">文档</th>
<th align="left">通称</th>
<th align="left">备注</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">2015</td>
<td align="left">ISO&#x2F;IEC TS 19570:2015</td>
<td align="left">-</td>
<td align="left">用于并行计算的扩展</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2015</td>
<td align="left">ISO&#x2F;IEC TS 18822:2015</td>
<td align="left">-</td>
<td align="left">文件系统</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2014</td>
<td align="left">ISO&#x2F;IEC 14882:2014</td>
<td align="left">C++14</td>
<td align="left">第四个C++标准</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2011</td>
<td align="left">ISO&#x2F;IEC TR 24733:2011</td>
<td align="left">-</td>
<td align="left">十进制浮点数扩展</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2011</td>
<td align="left">ISO&#x2F;IEC 14882:2011</td>
<td align="left">C++11</td>
<td align="left">第三个C++标准</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2010</td>
<td align="left">ISO&#x2F;IEC TR 29124:2010</td>
<td align="left">-</td>
<td align="left">数学函数扩展</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2007</td>
<td align="left">ISO&#x2F;IEC TR 19768:2007</td>
<td align="left">C++TR1</td>
<td align="left">C++技术报告：库扩展</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2006</td>
<td align="left">ISO&#x2F;IEC TR 18015:2006</td>
<td align="left">-</td>
<td align="left">C++性能技术报告</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2003</td>
<td align="left">ISO&#x2F;IEC 14882:2003</td>
<td align="left">C++03</td>
<td align="left">第二个C++标准</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1998</td>
<td align="left">ISO&#x2F;IEC 14882:1998</td>
<td align="left">C++98</td>
<td align="left">第一个C++标准</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="C-环境设置"><a href="#C-环境设置" class="headerlink" title="C++ 环境设置"></a>C++ 环境设置</h1><h2 id="本地环境设置"><a href="#本地环境设置" class="headerlink" title="本地环境设置"></a>本地环境设置</h2><p>如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。</p>
<h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><p>这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim&#x2F;vi。</p>
<p>文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim&#x2F;vi 可用于 Windows 和 Linux&#x2F;UNIX 操作系统上。</p>
<p>通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>
<p>在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。</p>
<h2 id="C-编译器"><a href="#C-编译器" class="headerlink" title="C++ 编译器"></a>C++ 编译器</h2><p>写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>
<p>C++ 编译器用于把源代码编译成最终的可执行程序。</p>
<p>大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>
<p>最常用的免费可用的编译器是 GNU 的 C&#x2F;C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>
<p>以下部分将指导您如何在不同的操作系统上安装 GNU 的 C&#x2F;C++ 编译器。这里同时提到 C&#x2F;C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。</p>
<h2 id="安装-GNU-的-C-C-编译器"><a href="#安装-GNU-的-C-C-编译器" class="headerlink" title="安装 GNU 的 C&#x2F;C++ 编译器"></a>安装 GNU 的 C&#x2F;C++ 编译器</h2><h3 id="UNIX-Linux-上的安装"><a href="#UNIX-Linux-上的安装" class="headerlink" title="UNIX&#x2F;Linux 上的安装"></a>UNIX&#x2F;Linux 上的安装</h3><p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ -v</span><br></pre></td></tr></table></figure>

<p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Using built-in specs.Target: i386-redhat-linuxConfigured with: ../configure --prefix=/usr .......Thread model: posix</span><br><span class="line">gcc version <span class="number">4.1</span><span class="number">.2</span> <span class="number">20080704</span> (Red Hat <span class="number">4.1</span><span class="number">.2</span><span class="number">-46</span>)</span><br></pre></td></tr></table></figure>

<p>如果未安装 GCC，那么请按照 <a href="http://gcc.gnu.org/install/">http://gcc.gnu.org/install/</a> 上的详细说明安装 GCC。</p>
<h3 id="Mac-OS-X-上的安装"><a href="#Mac-OS-X-上的安装" class="headerlink" title="Mac OS X 上的安装"></a>Mac OS X 上的安装</h3><p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p>
<p>Xcode 目前可从 developer.apple.com&#x2F;technologies&#x2F;tools&#x2F; 上下载。</p>
<h3 id="Windows-上的安装"><a href="#Windows-上的安装" class="headerlink" title="Windows 上的安装"></a>Windows 上的安装</h3><p>为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 <a href="http://www.mingw.org,进入/">www.mingw.org，进入</a> MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p>
<p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p>
<p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p>
<p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p>
<hr>
<h2 id="使用-Visual-Studio-Graphical-Interface-编译"><a href="#使用-Visual-Studio-Graphical-Interface-编译" class="headerlink" title="使用 Visual Studio (Graphical Interface) 编译"></a>使用 Visual Studio (Graphical Interface) 编译</h2><p>1、下载及安装 Visual Studio Community 2015。</p>
<p>2、打开 Visual Studio Community</p>
<p>3、点击 File -&gt; New -&gt; Project</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/154425967c4e731874.png" alt="img"></p>
<p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/154430e60ee9018384.png" alt="img"></p>
<p>5、点击 OK。</p>
<p>6、在以下窗口中点击 Next</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/15444190dd2e989801.png" alt="img"></p>
<p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：</p>
<p>8、右击文件夹 Source File 并点击 Add –&gt; New Item… :</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/15445135154c170829.png" alt="img"></p>
<p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/154459b03a55098499.png" alt="img"></p>
<p>10、拷贝以下代码到 main.cpp 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>int main()&#123;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>界面如下所示：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/15450518149e040143.png" alt="img"></p>
<p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/154511746480630632.png" alt="img"></p>
<p>12、完成以上操作后，你可以看到以下输出：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/154519fb938f394280.png" alt="img"></p>
<hr>
<h2 id="g-应用说明"><a href="#g-应用说明" class="headerlink" title="g++ 应用说明"></a>g++ 应用说明</h2><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ gcc main.cpp -lstdc++ -o main</span><br></pre></td></tr></table></figure>

<p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的编译方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure>

<p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ./a.outHello, world!</span><br></pre></td></tr></table></figure>

<p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>

<p>执行 helloworld:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ./helloworldHello, world!</span><br></pre></td></tr></table></figure>

<p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ runoob1.cpp cpp、runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure>

<p>生成一个 runoob 可执行文件。</p>
<p>g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ -g -Wall -std=c++<span class="number">11</span> main.cpp</span><br></pre></td></tr></table></figure>

<h3 id="g-常用命令选项"><a href="#g-常用命令选项" class="headerlink" title="g++ 常用命令选项"></a>g++ 常用命令选项</h3><table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-ansi</td>
<td align="left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">只编译并生成目标文件。</td>
</tr>
<tr>
<td align="left">-DMACRO</td>
<td align="left">以字符串”1”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-DMACRO&#x3D;DEFN</td>
<td align="left">以字符串”DEFN”定义 MACRO 宏。</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left">只运行 C 预编译器。</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td align="left">-IDIRECTORY</td>
<td align="left">指定额外的头文件搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-LDIRECTORY</td>
<td align="left">指定额外的函数库搜索路径DIRECTORY。</td>
</tr>
<tr>
<td align="left">-lLIBRARY</td>
<td align="left">连接时搜索指定的函数库LIBRARY。</td>
</tr>
<tr>
<td align="left">-m486</td>
<td align="left">针对 486 进行代码优化。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">FILE 生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td align="left">-O0</td>
<td align="left">不进行优化处理。</td>
</tr>
<tr>
<td align="left">-O</td>
<td align="left">或 -O1 优化生成代码。</td>
</tr>
<tr>
<td align="left">-O2</td>
<td align="left">进一步优化。</td>
</tr>
<tr>
<td align="left">-O3</td>
<td align="left">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td align="left">-shared</td>
<td align="left">生成共享目标文件。通常用在建立共享库时。</td>
</tr>
<tr>
<td align="left">-static</td>
<td align="left">禁止使用共享连接。</td>
</tr>
<tr>
<td align="left">-UMACRO</td>
<td align="left">取消对 MACRO 宏的定义。</td>
</tr>
<tr>
<td align="left">-w</td>
<td align="left">不生成任何警告信息。</td>
</tr>
<tr>
<td align="left">-Wall</td>
<td align="left">生成所有警告信息。</td>
</tr>
</tbody></table>
<h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++ 基本语法"></a>C++ 基本语法</h1><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>
<ul>
<li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>
<li><strong>类 -</strong> 类可以定义为描述对象行为&#x2F;状态的模板&#x2F;蓝图。</li>
<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>
<li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>
</ul>
<h2 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h2><p>让我们看一段简单的代码，可以输出单词 <em>Hello World</em>。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; <span class="comment">// main() 是程序开始执行的地方 </span></span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World   return 0;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们讲解一下上面这段程序：</p>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。</li>
<li>行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 <strong>&#x2F;&#x2F; main() 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 &#x2F;&#x2F; 开头，在行末结束。</li>
<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>
<li>下一行 <strong>cout &lt;&lt; “Hello World”;</strong> 会在屏幕上显示消息 “Hello World”。</li>
<li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
<h2 id="编译-执行-C-程序-1"><a href="#编译-执行-C-程序-1" class="headerlink" title="编译 &amp; 执行 C++ 程序"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>
<ul>
<li>打开一个文本编辑器，添加上述代码。</li>
<li>保存文件为 hello.cpp。</li>
<li>打开命令提示符，进入到保存文件所在的目录。</li>
<li>键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li>
<li>现在，键入 ‘ a.out’ 来运行程序。</li>
<li>您可以看到屏幕上显示 ‘ Hello World ‘。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ hello.cpp$ ./a.outHello World</span><br></pre></td></tr></table></figure>

<p>请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。</p>
<p>您也可以使用 makefile 来编译 C&#x2F;C++ 程序。</p>
<h2 id="C-中的分号-块"><a href="#C-中的分号-块" class="headerlink" title="C++ 中的分号 &amp; 块"></a>C++ 中的分号 &amp; 块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>
<p>例如，下面是三个不同的语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y;y = y+<span class="number">1</span>;<span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure>

<p>块是一组使用大括号括起来的按逻辑连接的语句。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World   return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y;y = y+<span class="number">1</span>;<span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = y; y = y+<span class="number">1</span>; <span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure>

<h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h2><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p>
<p>下面列出几个有效的标识符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure>

<h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++ 关键字"></a>C++ 关键字</h2><p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>else</th>
<th>new</th>
<th>this</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>enum</td>
<td>operator</td>
<td>throw</td>
</tr>
<tr>
<td>bool</td>
<td>explicit</td>
<td>private</td>
<td>true</td>
</tr>
<tr>
<td>break</td>
<td>export</td>
<td>protected</td>
<td>try</td>
</tr>
<tr>
<td>case</td>
<td>extern</td>
<td>public</td>
<td>typedef</td>
</tr>
<tr>
<td>catch</td>
<td>false</td>
<td>register</td>
<td>typeid</td>
</tr>
<tr>
<td>char</td>
<td>float</td>
<td>reinterpret_cast</td>
<td>typename</td>
</tr>
<tr>
<td>class</td>
<td>for</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>const</td>
<td>friend</td>
<td>short</td>
<td>unsigned</td>
</tr>
<tr>
<td>const_cast</td>
<td>goto</td>
<td>signed</td>
<td>using</td>
</tr>
<tr>
<td>continue</td>
<td>if</td>
<td>sizeof</td>
<td>virtual</td>
</tr>
<tr>
<td>default</td>
<td>inline</td>
<td>static</td>
<td>void</td>
</tr>
<tr>
<td>delete</td>
<td>int</td>
<td>static_cast</td>
<td>volatile</td>
</tr>
<tr>
<td>do</td>
<td>long</td>
<td>struct</td>
<td>wchar_t</td>
</tr>
<tr>
<td>double</td>
<td>mutable</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>namespace</td>
<td>template</td>
<td></td>
</tr>
</tbody></table>
<h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p>
<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</p>
<p>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>下面列出了最常用的三字符序列：</p>
<table>
<thead>
<tr>
<th align="left">三字符组</th>
<th align="left">替换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">??&#x3D;</td>
<td align="left">#</td>
</tr>
<tr>
<td align="left">??&#x2F;</td>
<td align="left">\</td>
</tr>
<tr>
<td align="left">??’</td>
<td align="left">^</td>
</tr>
<tr>
<td align="left">??(</td>
<td align="left">[</td>
</tr>
<tr>
<td align="left">??)</td>
<td align="left">]</td>
</tr>
<tr>
<td align="left">??!</td>
<td align="left">|</td>
</tr>
<tr>
<td align="left">??&lt;</td>
<td align="left">{</td>
</tr>
<tr>
<td align="left">??&gt;</td>
<td align="left">}</td>
</tr>
<tr>
<td align="left">??-</td>
<td align="left">~</td>
</tr>
</tbody></table>
<p>如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：”…?””?…”或者转义序列：”…??…”。</p>
<p>从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项&#x2F;Zc:trigraphs</p>
<p>g++仍默认支持三字符组，但会给出编译警告。</p>
<h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++ 中的空格"></a>C++ 中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>
<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br></pre></td></tr></table></figure>

<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fruit = apples + oranges;   <span class="comment">// 获取水果的总数</span></span><br></pre></td></tr></table></figure>

<p>fruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>
<h1 id="C-注释"><a href="#C-注释" class="headerlink" title="C++ 注释"></a>C++ 注释</h1><p>程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。</p>
<p>C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。</p>
<p>C++ 注释以 &#x2F;* 开始，以 *&#x2F; 终止。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是注释 */</span><span class="comment">/* C++ 注释也可以</span></span><br><span class="line"><span class="comment"> * 跨行</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>注释也能以 &#x2F;&#x2F; 开始，直到行末为止。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;main()&#123;</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译时，编译器会忽略 <strong>&#x2F;&#x2F; 输出 Hello World</strong>，最后会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>在 &#x2F;* 和 <em>&#x2F; 注释内部，&#x2F;&#x2F; 字符没有特殊的含义。在 &#x2F;&#x2F; 注释内，&#x2F;</em> 和 *&#x2F; 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">/* 用于输出 Hello World 的注释</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++ 数据类型"></a>C++ 数据类型</h1><p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</p>
<p>您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。</p>
<h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">布尔型</td>
<td align="left">bool</td>
</tr>
<tr>
<td align="left">字符型</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">整型</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">浮点型</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">双浮点型</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">无类型</td>
<td align="left">void</td>
</tr>
<tr>
<td align="left">宽字符型</td>
<td align="left">wchar_t</td>
</tr>
</tbody></table>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 to 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">+&#x2F;- 3.4e +&#x2F;- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">8 个字节</td>
<td align="left">+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
<p>从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。</p>
<p>下面实例会输出您电脑上各种数据类型的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main()&#123;   </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of char : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of int : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of short int : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) &lt;&lt; endl;  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of long int : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">int</span>) &lt;&lt; endl;   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of float : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of double : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of wchar_t : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) &lt;&lt; endl;   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本实例使用了 <strong>endl</strong>，这将在每一行后插入一个换行符，&lt;&lt; 运算符用于向屏幕传多个值。我们也使用 <strong>sizeof()</strong> 函数来获取各种数据类型的大小。</p>
<p>当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Size of <span class="type">char</span> : <span class="number">1</span>Size of <span class="type">int</span> : <span class="number">4</span>Size of <span class="type">short</span> <span class="type">int</span> : <span class="number">2</span>Size of <span class="type">long</span> <span class="type">int</span> : <span class="number">8</span>Size of <span class="type">float</span> : <span class="number">4</span>Size of <span class="type">double</span> : <span class="number">8</span>Size of <span class="type">wchar_t</span> : <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type newname;</span><br></pre></td></tr></table></figure>

<p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> feet;</span><br></pre></td></tr></table></figure>

<p>现在，下面的声明是完全合法的，它创建了一个整型变量 distance：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">feet distance;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">enum</span>-name &#123; list of names &#125; var-list;</span><br></pre></td></tr></table></figure>

<p>在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125; c;c = blue;</span><br></pre></td></tr></table></figure>

<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green=<span class="number">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。</p>
<h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++ 变量类型"></a>C++ 变量类型</h1><p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。</p>
<p>基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">存储值 true 或 false。</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">通常是一个八位字节（一个字节）。这是一个整数类型。</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">对机器而言，整数的最自然的大小。</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点值。</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点值。</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">表示类型的缺失。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">宽字符类型。</td>
</tr>
</tbody></table>
<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解。</p>
<p>下面我们将讲解如何定义、声明和使用各种类型的变量。</p>
<h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++ 中的变量定义"></a>C++ 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    i, j, k;<span class="type">char</span>   c, ch;<span class="type">float</span>  f, salary;<span class="type">double</span> d;</span><br></pre></td></tr></table></figure>

<p>行 <strong>int i, j, k;</strong> 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。</p>
<p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type variable_name = value;</span><br></pre></td></tr></table></figure>

<p>下面列举几个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;   </span><br><span class="line">	<span class="comment">// d 和 f 的声明 int d = 3, f = 5;          </span></span><br><span class="line">	<span class="comment">// 定义并初始化 d 和 fbyte z = 22;               </span></span><br><span class="line">	<span class="comment">// 定义并初始化 zchar x = &#x27;x&#x27;;              </span></span><br><span class="line">	<span class="comment">// 变量 x 的值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++ 中的变量声明"></a>C++ 中的变量声明</h2><p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;<span class="comment">// 变量声明extern int a, b;extern int c;extern float f;</span></span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 变量定义</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 实际初始化</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl ;</span><br><span class="line"></span><br><span class="line">  f = <span class="number">70.0</span>/<span class="number">3.0</span>;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl ;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3023.3333</span></span><br></pre></td></tr></table></figure>

<p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明int func();int main()&#123;</span></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">func</span>();&#125;<span class="comment">// 函数定义int func()&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues）"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>C++ 中有两种类型的表达式：</p>
<ul>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h1 id="C-变量作用域"><a href="#C-变量作用域" class="headerlink" title="C++ 变量作用域"></a>C++ 变量作用域</h1><p>作用域是程序的一个区域，一般来说有三个地方可以声明变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量。</li>
</ul>
<p>我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 局部变量声明</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 实际初始化</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; c;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="comment">// 全局变量声明int g;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 局部变量声明</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 实际初始化</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; g;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="comment">// 全局变量声明int g = 20;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 局部变量声明</span></span><br><span class="line">  <span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; g;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h2><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。</p>
<h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C++ 常量"></a>C++ 常量</h1><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>
<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
<h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>下面列举几个整数常量的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">// 合法的215u        // 合法的0xFeeL      // 合法的078         // 非法的：8 不是八进制的数字032UU       // 非法的：不能重复后缀</span></span><br></pre></td></tr></table></figure>

<p>以下是各种类型的整数常量的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制0213       // 八进制 0x4b       // 十六进制 30         // 整数 30u        // 无符号整数 30l        // 长整数 30ul       // 无符号长整数</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的 314159E-5L    // 合法的 510E          // 非法的：不完整的指数210f          // 非法的：没有小数或指数.e55          // 非法的：缺少整数或分数</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h2><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">\ 字符</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">‘ 字符</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">“ 字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">? 字符</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">警报铃声</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<p>下面的实例显示了一些转义序列字符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main()&#123;   cout &lt;&lt; <span class="string">&quot;Hello\tWorld\n\n&quot;</span>;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure>

<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;quot;hello, dear&quot;</span><span class="string">&quot;hello, \dear&quot;</span><span class="string">&quot;hello, &quot;</span> <span class="string">&quot;d&quot;</span> <span class="string">&quot;ear&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<h2 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h2><p>下面是使用 #define 预处理器定义常量的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> identifier value</span></span><br></pre></td></tr></table></figure>

<p>具体请看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;#<span class="keyword">define</span> LENGTH 10   #<span class="keyword">define</span> WIDTH  5#<span class="keyword">define</span> NEWLINE <span class="string">&#x27;\n&#x27;</span>int main()&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   cout &lt;&lt; area;</span><br><span class="line">   cout &lt;&lt; NEWLINE;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<h2 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h2><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> type variable = value;</span><br></pre></td></tr></table></figure>

<p>具体请看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main()&#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>  LENGTH = <span class="number">10</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>  WIDTH  = <span class="number">5</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="type">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   cout &lt;&lt; area;</span><br><span class="line">   cout &lt;&lt; NEWLINE;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>请注意，把常量定义为大写字母形式，是一个很好的编程实践。</p>
<h1 id="C-修饰符类型"><a href="#C-修饰符类型" class="headerlink" title="C++ 修饰符类型"></a>C++ 修饰符类型</h1><p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>下面列出了数据类型修饰符：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>unsigned、long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> y;</span><br></pre></td></tr></table></figure>

<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 这个程序演示了有符号整数和无符号整数之间的差别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">short</span> <span class="type">int</span> i;           <span class="comment">// 有符号短整数</span></span><br><span class="line">   <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> j;  <span class="comment">// 无符号短整数</span></span><br><span class="line"></span><br><span class="line">   j = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">   i = j;</span><br><span class="line">   cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的程序运行时，会输出下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-15536</span> <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>
<h2 id="C-中的类型限定符"><a href="#C-中的类型限定符" class="headerlink" title="C++ 中的类型限定符"></a>C++ 中的类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>
<table>
<thead>
<tr>
<th align="left">限定符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const</td>
<td align="left"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">修饰符 <strong>volatile</strong> 告诉编译器，变量的值可能以程序未明确指定的方式被改变。</td>
</tr>
<tr>
<td align="left">restrict</td>
<td align="left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody></table>
<h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++ 存储类"></a>C++ 存储类</h1><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p>自 C++ 11 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>
<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。</p>
<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>
<p>auto f&#x3D;3.14;    &#x2F;&#x2F;doubleauto s(“hello”);  &#x2F;&#x2F;const char<em>auto z &#x3D; new auto(9); &#x2F;&#x2F; int</em>auto x1 &#x3D; 5, x2 &#x3D; 5.0, x3&#x3D;’r’;&#x2F;&#x2F;错误，必须是初始化为同一类型</p>
<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<p>{  register int miles;}</p>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="comment">// 函数声明 void func(void); </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">10</span>; <span class="comment">/* 全局变量 */</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">func</span>();    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">// 函数定义void func( void )&#123;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">5</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    i++;    std::cout &lt;&lt; <span class="string">&quot;变量 i 为 &quot;</span> &lt;&lt; i ;    std::cout &lt;&lt; <span class="string">&quot; , 变量 count 为 &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">变量 i 为 <span class="number">6</span> , 变量 count 为 <span class="number">9</span>变量 i 为 <span class="number">7</span> , 变量 count 为 <span class="number">8</span>变量 i 为 <span class="number">8</span> , 变量 count 为 <span class="number">7</span>变量 i 为 <span class="number">9</span> , 变量 count 为 <span class="number">6</span>变量 i 为 <span class="number">10</span> , 变量 count 为 <span class="number">5</span>变量 i 为 <span class="number">11</span> , 变量 count 为 <span class="number">4</span>变量 i 为 <span class="number">12</span> , 变量 count 为 <span class="number">3</span>变量 i 为 <span class="number">13</span> , 变量 count 为 <span class="number">2</span>变量 i 为 <span class="number">14</span> , 变量 count 为 <span class="number">1</span>变量 i 为 <span class="number">15</span> , 变量 count 为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>第一个文件：main.cpp</p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="type">int</span> count ;<span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">write_extern</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;   <span class="built_in">write_extern</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>第二个文件：support.cpp</p>
<h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">extern</span> <span class="type">int</span> count; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_extern</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ main.cpp support.cpp -o write</span><br></pre></td></tr></table></figure>

<p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ./writeCount is <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h2><p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h2 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h2><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> x;  <span class="comment">// 命名空间下的全局变量class X&#123;</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> std::string s; <span class="comment">// 类的static成员变量&#125;;static thread_local std::string X::s;  // X::s 是需要定义的</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 本地变量&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++ 运算符"></a>C++ 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<p>本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表显示了 C++ 支持的算术运算符。</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">把两个操作数相加</td>
<td align="left">A + B 将得到 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">从第一个操作数中减去第二个操作数</td>
<td align="left">A - B 将得到 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">把两个操作数相乘</td>
<td align="left">A * B 将得到 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">分子除以分母</td>
<td align="left">B &#x2F; A 将得到 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模运算符，整除后的余数</td>
<td align="left">B % A 将得到 0</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html">自增运算符</a>，整数值增加 1</td>
<td align="left">A++ 将得到 11</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-increment-decrement-operators.html">自减运算符</a>，整数值减少 1</td>
<td align="left">A– 将得到 9</td>
</tr>
</tbody></table>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的算术运算符。</p>
<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>
<h2 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">21</span>;   <span class="type">int</span> b = <span class="number">10</span>;   <span class="type">int</span> c ; </span><br><span class="line">   c = a + b;   cout &lt;&lt; <span class="string">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a - b;   cout &lt;&lt; <span class="string">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a * b;   cout &lt;&lt; <span class="string">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a / b;   cout &lt;&lt; <span class="string">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   c = a % b;   cout &lt;&lt; <span class="string">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   <span class="type">int</span> d = <span class="number">10</span>;   <span class="comment">//  测试自增、自减</span></span><br><span class="line">   c = d++;   cout &lt;&lt; <span class="string">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   d = <span class="number">10</span>;    <span class="comment">// 重新赋值</span></span><br><span class="line">   c = d--;   cout &lt;&lt; <span class="string">&quot;Line 7 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ;   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Line <span class="number">1</span> - c 的值是 <span class="number">31L</span>ine <span class="number">2</span> - c 的值是 <span class="number">11L</span>ine <span class="number">3</span> - c 的值是 <span class="number">210L</span>ine <span class="number">4</span> - c 的值是 <span class="number">2L</span>ine <span class="number">5</span> - c 的值是 <span class="number">1L</span>ine <span class="number">6</span> - c 的值是 <span class="number">10L</span>ine <span class="number">7</span> - c 的值是 <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表显示了 C++ 支持的关系运算符。</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">(A &#x3D;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td align="left">!&#x3D;</td>
<td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td align="left">(A !&#x3D; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt; B) 不为真。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt;&#x3D; B) 为真。</td>
</tr>
</tbody></table>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的关系运算符。</p>
<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>
<h2 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">21</span>;   <span class="type">int</span> b = <span class="number">10</span>;   <span class="type">int</span> c ; </span><br><span class="line">   <span class="keyword">if</span>( a == b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 1 - a 等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 1 - a 不等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a &lt; b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 2 - a 小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 2 - a 不小于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a &gt; b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 3 - a 大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 3 - a 不大于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">   a = <span class="number">5</span>;   b = <span class="number">20</span>;   <span class="keyword">if</span> ( a &lt;= b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 4 - a 小于或等于 b&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( b &gt;= a )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 5 - b 大于或等于 a&quot;</span> &lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Line <span class="number">1</span> - a 不等于 bLine <span class="number">2</span> - a 不小于 bLine <span class="number">3</span> - a 大于 bLine <span class="number">4</span> - a 小于或等于 bLine <span class="number">5</span> - b 大于或等于 a</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表显示了 C++ 支持的关系逻辑运算符。</p>
<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td align="left">(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td align="left">(A || B) 为真。</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td align="left">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的逻辑运算符。</p>
<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>
<h2 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">5</span>;   <span class="type">int</span> b = <span class="number">20</span>;   <span class="type">int</span> c ; </span><br><span class="line">   <span class="keyword">if</span> ( a &amp;&amp; b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 1 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a || b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 2 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">   a = <span class="number">0</span>;   b = <span class="number">10</span>;   <span class="keyword">if</span> ( a &amp;&amp; b )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 3 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 4 - 条件不为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( !(a &amp;&amp; b) )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Line 5 - 条件为真&quot;</span>&lt;&lt; endl ;   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Line <span class="number">1</span> - 条件为真Line <span class="number">2</span> - 条件为真Line <span class="number">4</span> - 条件不为真Line <span class="number">5</span> - 条件为真</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">q</th>
<th align="left">p &amp; q</th>
<th align="left">p | q</th>
<th align="left">p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p>
<p>A &#x3D; 0011 1100</p>
<p>B &#x3D; 0000 1101</p>
<p>-—————-</p>
<p>A&amp;B &#x3D; 0000 1100</p>
<p>A|B &#x3D; 0011 1101</p>
<p>A^B &#x3D; 0011 0001</p>
<p>~A &#x3D; 1100 0011</p>
<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td align="left">(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
<td align="left">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>
<td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的位运算符。</p>
<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>
<h2 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;      <span class="comment">// 60 = 0011 1100  </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;      <span class="comment">// 13 = 0000 1101</span></span><br><span class="line">   <span class="type">int</span> c = <span class="number">0</span>;           </span><br><span class="line"> </span><br><span class="line">   c = a &amp; b;             <span class="comment">// 12 = 0000 1100</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Line 1 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   c = a | b;             <span class="comment">// 61 = 0011 1101</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Line 2 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   c = a ^ b;             <span class="comment">// 49 = 0011 0001</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Line 3 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   c = ~a;                <span class="comment">// -61 = 1100 0011</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Line 4 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   c = a &lt;&lt; <span class="number">2</span>;            <span class="comment">// 240 = 1111 0000</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Line 5 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   c = a &gt;&gt; <span class="number">2</span>;            <span class="comment">// 15 = 0000 1111</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Line 6 - c 的值是 &quot;</span> &lt;&lt; c &lt;&lt; endl ; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">Line 1 - c 的值是 12Line 2 - c 的值是 61Line 3 - c 的值是 49Line 4 - c 的值是 -61Line 5 - c 的值是 240Line 6 - c 的值是 15</span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了 C++ 支持的赋值运算符：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td align="left">C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td align="left">+&#x3D;</td>
<td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td align="left">C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td align="left">-&#x3D;</td>
<td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td align="left">C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td align="left">*&#x3D;</td>
<td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td align="left">C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td align="left">&#x2F;&#x3D;</td>
<td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td align="left">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td align="left">%&#x3D;</td>
<td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td align="left">C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;</td>
<td align="left">左移且赋值运算符</td>
<td align="left">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;&#x3D;</td>
<td align="left">右移且赋值运算符</td>
<td align="left">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&amp;&#x3D;</td>
<td align="left">按位与且赋值运算符</td>
<td align="left">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td align="left">^&#x3D;</td>
<td align="left">按位异或且赋值运算符</td>
<td align="left">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td align="left">|&#x3D;</td>
<td align="left">按位或且赋值运算符</td>
<td align="left">C |&#x3D; 2 等同于 C &#x3D; C | 2</td>
</tr>
</tbody></table>
<h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C++ 中可用的赋值运算符。</p>
<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>
<h2 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">21</span>;   <span class="type">int</span> c ; </span><br><span class="line">   c =  a;   cout &lt;&lt; <span class="string">&quot;Line 1 - =  运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c +=  a;   cout &lt;&lt; <span class="string">&quot;Line 2 - += 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c -=  a;   cout &lt;&lt; <span class="string">&quot;Line 3 - -= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c *=  a;   cout &lt;&lt; <span class="string">&quot;Line 4 - *= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c /=  a;   cout &lt;&lt; <span class="string">&quot;Line 5 - /= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c  = <span class="number">200</span>;   c %=  a;   cout &lt;&lt; <span class="string">&quot;Line 6 - %= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c &lt;&lt;=  <span class="number">2</span>;   cout &lt;&lt; <span class="string">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c &gt;&gt;=  <span class="number">2</span>;   cout &lt;&lt; <span class="string">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c &amp;=  <span class="number">2</span>;   cout &lt;&lt; <span class="string">&quot;Line 9 - &amp;= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c ^=  <span class="number">2</span>;   cout &lt;&lt; <span class="string">&quot;Line 10 - ^= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   c |=  <span class="number">2</span>;   cout &lt;&lt; <span class="string">&quot;Line 11 - |= 运算符实例，c 的值 = : &quot;</span> &lt;&lt;c&lt;&lt; endl ; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Line <span class="number">1</span> - =  运算符实例，c 的值 = <span class="number">21L</span>ine <span class="number">2</span> - += 运算符实例，c 的值 = <span class="number">42L</span>ine <span class="number">3</span> - -= 运算符实例，c 的值 = <span class="number">21L</span>ine <span class="number">4</span> - *= 运算符实例，c 的值 = <span class="number">441L</span>ine <span class="number">5</span> - /= 运算符实例，c 的值 = <span class="number">21L</span>ine <span class="number">6</span> - %= 运算符实例，c 的值 = <span class="number">11L</span>ine <span class="number">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class="number">44L</span>ine <span class="number">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class="number">11L</span>ine <span class="number">9</span> - &amp;= 运算符实例，c 的值 = <span class="number">2L</span>ine <span class="number">10</span> - ^= 运算符实例，c 的值 = <span class="number">0L</span>ine <span class="number">11</span> - |= 运算符实例，c 的值 = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h2><p>下表列出了 C++ 支持的其他一些重要的运算符。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sizeof</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td>
</tr>
<tr>
<td align="left">Condition ? X : Y</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td>
</tr>
<tr>
<td align="left">,</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>
</tr>
<tr>
<td align="left">.（点）和 -&gt;（箭头）</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td>
</tr>
<tr>
<td align="left">Cast</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td>
</tr>
</tbody></table>
<h2 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C++ 中的运算符优先级"></a>C++ 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] -&gt; . ++ - -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* &#x2F; %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><p>请看下面的实例，了解 C++ 中运算符的优先级。</p>
<p>复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。</p>
<p>对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 &#x2F;、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。</p>
<h2 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">20</span>;   <span class="type">int</span> b = <span class="number">10</span>;   <span class="type">int</span> c = <span class="number">15</span>;   <span class="type">int</span> d = <span class="number">5</span>;   <span class="type">int</span> e; </span><br><span class="line">   e = (a + b) * c / d;      <span class="comment">// ( 30 * 15 ) / 5</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;(a + b) * c / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class="line">   e = ((a + b) * c) / d;    <span class="comment">// (30 * 15 ) / 5</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;((a + b) * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class="line">   e = (a + b) * (c / d);   <span class="comment">// (30) * (15/5)</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;(a + b) * (c / d) 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ; </span><br><span class="line">   e = a + (b * c) / d;     <span class="comment">//  20 + (150/5)</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;a + (b * c) / d 的值是 &quot;</span> &lt;&lt; e &lt;&lt; endl ;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(a + b) * c / d 的值是 <span class="number">90</span>((a + b) * c) / d 的值是 <span class="number">90</span>(a + b) * (c / d) 的值是 <span class="number">90</span>a + (b * c) / d 的值是 <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++ 循环"></a>C++ 循环</h1><p>有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>
<p>编程语言提供了允许更为复杂的执行路径的多种控制结构。</p>
<p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/16103394c44b631388.png" alt="img"></p>
<h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">while 循环</td>
<td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td align="left">for 循环</td>
<td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td align="left">do…while 循环</td>
<td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td align="left">嵌套循环</td>
<td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table>
<h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>
<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">break 语句</td>
<td align="left">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>
</tr>
<tr>
<td align="left">continue 语句</td>
<td align="left">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>
</tr>
<tr>
<td align="left">goto 语句</td>
<td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>
</tr>
</tbody></table>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;This loop will run forever.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>
<p><strong>注意：</strong>您可以按 Ctrl + C 键终止一个无限循环。</p>
<h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C++ 判断"></a>C++ 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
<p>下面是大多数编程语言中典型的判断结构的一般形式：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/161155bc605b784844.png" alt="img"></p>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">if 语句</td>
<td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left">if…else 语句</td>
<td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td align="left">嵌套 if 语句</td>
<td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left">switch 语句</td>
<td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td align="left">嵌套 switch 语句</td>
<td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="? : 运算符"></a>? : 运算符</h2><p>我们已经在前面的章节中讲解了 <a href="https://edu.aliyun.com/cplusplus/cpp-conditional-operator.html"><strong>条件运算符 ? :</strong></a>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>

<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++ 函数"></a>C++ 函数</h1><p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>C++ 中的函数定义的一般形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span></span>&#123;   body of the function&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<h2 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h2><p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数返回两个数中较大的那个数 int max(int num1, int num2) &#123;   // 局部变量声明   int result;    if (num1 &gt; num2)      result = num1;   else      result = num2;    return result; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter list )</span></span>;</span><br></pre></td></tr></table></figure>

<p>针对上面定义的函数 max()，以下是函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="comment">// 函数声明int max(int num1, int num2);</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用函数来获取最大值</span></span><br><span class="line">   ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Max value is : &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"> <span class="comment">// 函数返回两个数中较大的那个数int max(int num1, int num2) &#123;</span></span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; &#125;</span><br></pre></td></tr></table></figure>

<p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Max value is : <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-function-call-by-value.html">传值调用</a></td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-function-call-by-pointer.html">指针调用</a></td>
<td align="left">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://edu.aliyun.com/cplusplus/cpp-function-call-by-reference.html">引用调用</a></td>
<td align="left">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。</p>
<h2 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h2><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>
<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">20</span>)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (result);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用函数来添加值</span></span><br><span class="line">   result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 再次调用函数</span></span><br><span class="line">   result = <span class="built_in">sum</span>(a);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total value is :&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Total value is :<span class="number">300</span>Total value is :<span class="number">120</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h2><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters)-&gt;<span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br></pre></td></tr></table></figure>

<p>如果没有参数可以表示为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters)&#123;body&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]&#123; ++global_x; &#125;</span><br></pre></td></tr></table></figure>

<p>在一个更为复杂的例子中，返回类型可以被明确的指定如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;</span><br></pre></td></tr></table></figure>

<p>本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。</p>
<p>如果 lambda 函数没有传回值（例如 void），其回返类型可被完全忽略。</p>
<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>

<p>另外有一点需要注意。对于[&#x3D;]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure>

<h1 id="C-数字"><a href="#C-数字" class="headerlink" title="C++ 数字"></a>C++ 数字</h1><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>
<h2 id="C-定义数字"><a href="#C-定义数字" class="headerlink" title="C++ 定义数字"></a>C++ 定义数字</h2><p>我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 数字定义</span></span><br><span class="line">   <span class="type">short</span>  s;</span><br><span class="line">   <span class="type">int</span>    i;</span><br><span class="line">   <span class="type">long</span>   l;</span><br><span class="line">   <span class="type">float</span>  f;</span><br><span class="line">   <span class="type">double</span> d;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数字赋值</span></span><br><span class="line">   s = <span class="number">10</span>;      </span><br><span class="line">   i = <span class="number">1000</span>;    </span><br><span class="line">   l = <span class="number">1000000</span>; </span><br><span class="line">   f = <span class="number">230.47</span>;  </span><br><span class="line">   d = <span class="number">30949.374</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数字输出</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;short  s :&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;int    i :&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;long   l :&quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;float  f :&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;double d :&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span>  s :<span class="number">10</span><span class="type">int</span>    i :<span class="number">1000l</span>ong   l :<span class="number">1000000f</span>loat  f :<span class="number">230.47</span><span class="type">double</span> d :<span class="number">30949.4</span></span><br></pre></td></tr></table></figure>

<h2 id="C-数学运算"><a href="#C-数学运算" class="headerlink" title="C++ 数学运算"></a>C++ 数学运算</h2><p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置</strong>函数。您可以在程序中引用这些函数。</p>
<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>
<p>为了利用这些函数，您需要引用数学头文件 **<cmath>**。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个十进制数的绝对值。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td>
</tr>
</tbody></table>
<p>下面是一个关于数学运算的简单实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 数字定义</span></span><br><span class="line">   <span class="type">short</span>  s = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span>    i = <span class="number">-1000</span>;</span><br><span class="line">   <span class="type">long</span>   l = <span class="number">100000</span>;</span><br><span class="line">   <span class="type">float</span>  f = <span class="number">230.47</span>;</span><br><span class="line">   <span class="type">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 数学运算</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sin(d) :&quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;abs(i)  :&quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;floor(d) :&quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sign</span>(d) :<span class="number">-0.634939</span>abs(i)  :<span class="number">1000f</span>loor(d) :<span class="number">200</span>sqrt(f) :<span class="number">15.1812</span>pow( d, <span class="number">2</span> ) :<span class="number">40149.7</span></span><br></pre></td></tr></table></figure>

<h2 id="C-随机数"><a href="#C-随机数" class="headerlink" title="C++ 随机数"></a>C++ 随机数</h2><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>
<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置种子</span></span><br><span class="line">   <span class="built_in">srand</span>( (<span class="type">unsigned</span>)<span class="built_in">time</span>( <span class="literal">NULL</span> ) );</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 生成 10 个随机数 */</span></span><br><span class="line">   <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 生成实际的随机数</span></span><br><span class="line">      j= <span class="built_in">rand</span>();</span><br><span class="line">      cout &lt;&lt;<span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">随机数： <span class="number">1748144778</span>随机数： <span class="number">630873888</span>随机数： <span class="number">2134540646</span>随机数： <span class="number">219404170</span>随机数： <span class="number">902129458</span>随机数： <span class="number">920445370</span>随机数： <span class="number">1319072661</span>随机数： <span class="number">257938873</span>随机数： <span class="number">1256201101</span>随机数： <span class="number">580322989</span></span><br></pre></td></tr></table></figure>

<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++ 数组"></a>C++ 数组</h1><p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
<p>数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure>

<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>
<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">17.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">17.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>

<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</p>
<p><img src="https://edu.aliyun.com/ueditor/php/upload/image/20170504/1493862028514037.jpg" alt="数组表示"></p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure>

<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>using std::setw;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n[ <span class="number">10</span> ]; <span class="comment">// n 是一个包含 10 个整数的数组</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 初始化数组元素          </span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      n[ i ] = i + <span class="number">100</span>; <span class="comment">// 设置元素 i 为 i + 100</span></span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Element&quot;</span> &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; <span class="string">&quot;Value&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出数组中每个元素的值                     </span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">setw</span>( <span class="number">7</span> )&lt;&lt; j &lt;&lt; <span class="built_in">setw</span>( <span class="number">13</span> ) &lt;&lt; n[ j ] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序使用了 <strong>setw()</strong> 函数来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Element        Value</span><br><span class="line">      <span class="number">0</span>          <span class="number">100</span></span><br><span class="line">      <span class="number">1</span>          <span class="number">101</span></span><br><span class="line">      <span class="number">2</span>          <span class="number">102</span></span><br><span class="line">      <span class="number">3</span>          <span class="number">103</span></span><br><span class="line">      <span class="number">4</span>          <span class="number">104</span></span><br><span class="line">      <span class="number">5</span>          <span class="number">105</span></span><br><span class="line">      <span class="number">6</span>          <span class="number">106</span></span><br><span class="line">      <span class="number">7</span>          <span class="number">107</span></span><br><span class="line">      <span class="number">8</span>          <span class="number">108</span></span><br><span class="line">      <span class="number">9</span>          <span class="number">109</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中数组详解"><a href="#C-中数组详解" class="headerlink" title="C++ 中数组详解"></a>C++ 中数组详解</h2><p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">多维数组</td>
<td align="left">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr>
<td align="left">指向数组的指针</td>
<td align="left">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>
</tr>
<tr>
<td align="left">传递数组给函数</td>
<td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr>
<td align="left">从函数返回数组</td>
<td align="left">C++ 允许从函数返回数组。</td>
</tr>
</tbody></table>
<h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
<h2 id="C-风格字符串"><a href="#C-风格字符串" class="headerlink" title="C 风格字符串"></a>C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以下是 C&#x2F;C++ 中定义的字符串的内存表示：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/1618593bac57374932.jpg" alt="img"></p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。让我们尝试输出上面的字符串：</p>
<h2 id="实例-19"><a href="#实例-19" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Greeting message: &quot;</span>;   cout &lt;&lt; greeting &lt;&lt; endl; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Greeting message: Hello</span><br></pre></td></tr></table></figure>

<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<p>下面的实例使用了上述的一些函数：</p>
<h2 id="实例-20"><a href="#实例-20" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">char</span> str1[<span class="number">11</span>] = <span class="string">&quot;Hello&quot;</span>;   <span class="type">char</span> str2[<span class="number">11</span>] = <span class="string">&quot;World&quot;</span>;   <span class="type">char</span> str3[<span class="number">11</span>];   <span class="type">int</span>  len ; </span><br><span class="line">   <span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">   <span class="built_in">strcpy</span>( str3, str1);   cout &lt;&lt; <span class="string">&quot;strcpy( str3, str1) : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   <span class="built_in">strcat</span>( str1, str2);   cout &lt;&lt; <span class="string">&quot;strcat( str1, str2): &quot;</span> &lt;&lt; str1 &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 连接后，str1 的总长度</span></span><br><span class="line">   len = <span class="built_in">strlen</span>(str1);   cout &lt;&lt; <span class="string">&quot;strlen(str1) : &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>( str3, str1) : <span class="built_in">Hellostrcat</span>( str1, str2): <span class="built_in">HelloWorldstrlen</span>(str1) : <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的-String-类"><a href="#C-中的-String-类" class="headerlink" title="C++ 中的 String 类"></a>C++ 中的 String 类</h2><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>
<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>
<h2 id="实例-21"><a href="#实例-21" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   string str1 = <span class="string">&quot;Hello&quot;</span>;   string str2 = <span class="string">&quot;World&quot;</span>;   string str3;   <span class="type">int</span>  len ; </span><br><span class="line">   <span class="comment">// 复制 str1 到 str3</span></span><br><span class="line">   str3 = str1;   cout &lt;&lt; <span class="string">&quot;str3 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 连接 str1 和 str2</span></span><br><span class="line">   str3 = str1 + str2;   cout &lt;&lt; <span class="string">&quot;str1 + str2 : &quot;</span> &lt;&lt; str3 &lt;&lt; endl; </span><br><span class="line">   <span class="comment">// 连接后，str3 的总长度</span></span><br><span class="line">   len = str3.<span class="built_in">size</span>();   cout &lt;&lt; <span class="string">&quot;str3.size() :  &quot;</span> &lt;&lt; len &lt;&lt; endl; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str3 : Hellostr1 + str2 : HelloWorldstr3.<span class="built_in">size</span>() :  <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h1><p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class="line">   <span class="type">int</span>  var1;</span><br><span class="line">   <span class="type">char</span> var2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">   cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">   cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var1 变量的地址： <span class="number">0xbfebd5c0</span>var2 变量的地址： <span class="number">0xbfebd5b6</span></span><br></pre></td></tr></table></figure>

<p>通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。</p>
<h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<h2 id="C-中使用指针"><a href="#C-中使用指针" class="headerlink" title="C++ 中使用指针"></a>C++ 中使用指针</h2><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">// 实际变量的声明</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">// 指针变量的声明</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;var;       <span class="comment">// 在指针变量中存储 var 的地址</span></span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出在指针变量中存储的地址</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 访问指针中地址的值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span>;</span><br><span class="line">   cout &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Value of var variable: <span class="number">20</span>Address stored in ip variable: <span class="number">0xbfc601ac</span>Value of *ip variable: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="C-指针详解"><a href="#C-指针详解" class="headerlink" title="C++ 指针详解"></a>C++ 指针详解</h2><p>在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">C++ Null 指针</td>
<td align="left">C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。</td>
</tr>
<tr>
<td align="left">C++ 指针的算术运算</td>
<td align="left">可以对指针进行四种算术运算：++、–、+、-</td>
</tr>
<tr>
<td align="left">C++ 指针 vs 数组</td>
<td align="left">指针和数组之间有着密切的关系。</td>
</tr>
<tr>
<td align="left">C++ 指针数组</td>
<td align="left">可以定义用来存储指针的数组。</td>
</tr>
<tr>
<td align="left">C++ 指向指针的指针</td>
<td align="left">C++ 允许指向指针的指针。</td>
</tr>
<tr>
<td align="left">C++ 传递指针给函数</td>
<td align="left">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td>
</tr>
<tr>
<td align="left">C++ 从函数返回指针</td>
<td align="left">C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。</td>
</tr>
</tbody></table>
<h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<h2 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h2><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<h2 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h2><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">17</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以为 i 声明引用变量，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp;    r = i;</span><br></pre></td></tr></table></figure>

<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 声明简单的变量</span></span><br><span class="line">   <span class="type">int</span>    i;</span><br><span class="line">   <span class="type">double</span> d;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 声明引用变量</span></span><br><span class="line">   <span class="type">int</span>&amp;    r = i;</span><br><span class="line">   <span class="type">double</span>&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of i reference : &quot;</span> &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = <span class="number">11.7</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d : &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of d reference : &quot;</span> &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Value of i : <span class="number">5</span>Value of i reference : <span class="number">5</span>Value of d : <span class="number">11.7</span>Value of d reference : <span class="number">11.7</span></span><br></pre></td></tr></table></figure>

<p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">把引用作为参数</td>
<td align="left">C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。</td>
</tr>
<tr>
<td align="left">把引用作为返回值</td>
<td align="left">可以从 C++ 函数中返回引用，就像返回其他数据类型一样。</td>
</tr>
</tbody></table>
<h1 id="C-日期-时间"><a href="#C-日期-时间" class="headerlink" title="C++ 日期 &amp; 时间"></a>C++ 日期 &amp; 时间</h1><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</p>
<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
<p>结构类型 <strong>tm</strong> 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">  <span class="type">int</span> tm_sec;   <span class="comment">// 秒，正常范围从 0 到 59，但允许至 61</span></span><br><span class="line">  <span class="type">int</span> tm_min;   <span class="comment">// 分，范围从 0 到 59</span></span><br><span class="line">  <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围从 0 到 23</span></span><br><span class="line">  <span class="type">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围从 1 到 31</span></span><br><span class="line">  <span class="type">int</span> tm_mon;   <span class="comment">// 月，范围从 0 到 11</span></span><br><span class="line">  <span class="type">int</span> tm_year;  <span class="comment">// 自 1900 年起的年数</span></span><br><span class="line">  <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围从 0 到 6，从星期日算起</span></span><br><span class="line">  <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span></span><br><span class="line">  <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面是 C&#x2F;C++ 中关于日期和时间的重要函数。所有这些函数都是 C&#x2F;C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>time_t time(time_t *time);</strong> 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>char *ctime(const time_t *time);</strong> 该返回一个表示当地时间的字符串指针，字符串形式 <em>day month year hours:minutes:seconds year\n\0</em>。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>struct tm *localtime(const time_t *time);</strong> 该函数返回一个指向表示本地时间的 <strong>tm</strong> 结构的指针。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>clock_t clock(void);</strong> 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>char * asctime ( const struct tm * time );</strong> 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>struct tm *gmtime(const time_t *time);</strong> 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>time_t mktime(struct tm *time);</strong> 该函数返回日历时间，相当于 time 所指向结构中存储的时间。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>double difftime ( time_t time2, time_t time1 );</strong> 该函数返回 time1 和 time2 之间相差的秒数。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>size_t strftime();</strong> 该函数可用于格式化日期和时间为指定的格式。</td>
</tr>
</tbody></table>
<h2 id="当前日期和时间"><a href="#当前日期和时间" class="headerlink" title="当前日期和时间"></a>当前日期和时间</h2><p>下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line">   <span class="type">char</span>* dt = <span class="built_in">ctime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把 now 转换为 tm 结构</span></span><br><span class="line">   tm *gmtm = <span class="built_in">gmtime</span>(&amp;now);</span><br><span class="line">   dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span>&lt;&lt; dt &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">本地日期和时间：Sat Jan  <span class="number">8</span> <span class="number">20</span>:<span class="number">07</span>:<span class="number">41</span> <span class="number">2011U</span>TC 日期和时间：Sun Jan  <span class="number">9</span> <span class="number">03</span>:<span class="number">07</span>:<span class="number">41</span> <span class="number">2011</span></span><br></pre></td></tr></table></figure>

<h2 id="使用结构-tm-格式化时间"><a href="#使用结构-tm-格式化时间" class="headerlink" title="使用结构 tm 格式化时间"></a>使用结构 tm 格式化时间</h2><p><strong>tm</strong> 结构在 C&#x2F;C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>
<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>using namespace std;int main( )&#123;</span></span><br><span class="line">   <span class="comment">// 基于当前系统的当前日期/时间</span></span><br><span class="line">   <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Number of sec since January 1,1970:&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   tm *ltm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 tm 结构的各个组成部分</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Year: &quot;</span>&lt;&lt; <span class="number">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Month: &quot;</span>&lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Day: &quot;</span>&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Time: &quot;</span>&lt;&lt; <span class="number">1</span> + ltm-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> + ltm-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> + ltm-&gt;tm_sec &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Number of sec since January <span class="number">1</span>, <span class="number">1970</span>:<span class="number">1294548238</span>Year: <span class="number">2011</span>Month: <span class="number">1</span>Day: <span class="number">8</span>Time: <span class="number">22</span>: <span class="number">44</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>

<h1 id="C-基本的输入输出"><a href="#C-基本的输入输出" class="headerlink" title="C++ 基本的输入输出"></a>C++ 基本的输入输出</h1><p>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</p>
<p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<h2 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I&#x2F;O 库头文件"></a>I&#x2F;O 库头文件</h2><p>下列的头文件在 C++ 编程中很重要。</p>
<table>
<thead>
<tr>
<th align="left">头文件</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><iostream></td>
<td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td align="left"><iomanip></td>
<td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td>
</tr>
<tr>
<td align="left"><fstream></td>
<td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>
</tr>
</tbody></table>
<h2 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h2><p>预定义的对象 <strong>cout</strong> 是 <strong>ostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; int main( )&#123;   char str[] = <span class="string">&quot;Hello C++&quot;</span>;    cout &lt;&lt; <span class="string">&quot;Value of str is : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Value of str is : Hello C++</span><br></pre></td></tr></table></figure>

<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>
<h2 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h2><p>预定义的对象 <strong>cin</strong> 是 <strong>istream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; int main( )&#123;  </span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">50</span>];    cout &lt;&lt; <span class="string">&quot;请输入您的名称： &quot;</span>;   </span><br><span class="line">	cin &gt;&gt; name;   cout &lt;&lt; <span class="string">&quot;您的名称是： &quot;</span> &lt;&lt; name &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">请输入您的名称： cplusplus您的名称是： cplusplus</span><br></pre></td></tr></table></figure>

<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure>

<p>这相当于下面两个语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; name;cin &gt;&gt; age;</span><br></pre></td></tr></table></figure>

<h2 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h2><p>预定义的对象 <strong>cerr</strong> 是 <strong>ostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   <span class="type">char</span> str[] = <span class="string">&quot;Unable to read....&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   cerr &lt;&lt; <span class="string">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Error message : Unable to read....</span><br></pre></td></tr></table></figure>

<h2 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h2><p>预定义的对象 <strong>clog</strong> 是 <strong>ostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   <span class="type">char</span> str[] = <span class="string">&quot;Unable to read....&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   clog &lt;&lt; <span class="string">&quot;Error message : &quot;</span> &lt;&lt; str &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Error message : Unable to read....</span><br></pre></td></tr></table></figure>

<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
<h1 id="C-数据结构"><a href="#C-数据结构" class="headerlink" title="C++ 数据结构"></a>C++ 数据结构</h1><p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title ：标题</li>
<li>Author ：作者</li>
<li>Subject ：类目</li>
<li>Book ID ：书的 ID</li>
</ul>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names;</span><br></pre></td></tr></table></figure>

<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 <strong>Books</strong>，变量为 <strong>book</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span>&#123;   <span class="type">char</span>  title[<span class="number">50</span>];   <span class="type">char</span>  author[<span class="number">50</span>];   <span class="type">char</span>  subject[<span class="number">100</span>];      <span class="type">int</span>   book_id;&#125; book;</span><br></pre></td></tr></table></figure>

<h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>
<p>下面的实例演示了结构的用法：</p>
<h2 id="实例-22"><a href="#实例-22" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];   <span class="type">char</span>  author[<span class="number">50</span>];   <span class="type">char</span>  subject[<span class="number">100</span>];   <span class="type">int</span>   book_id;&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C++ 教程&quot;</span>);   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;编程语言&quot;</span>);   Book1.book_id = <span class="number">12345</span>; </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;CSS 教程&quot;</span>);   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Runoob&quot;</span>);   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;前端技术&quot;</span>);   Book2.book_id = <span class="number">12346</span>; </span><br><span class="line">   <span class="comment">// 输出 Book1 信息</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第一本书标题 : &quot;</span> &lt;&lt; Book1.title &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;第一本书作者 : &quot;</span> &lt;&lt; Book1.author &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;第一本书类目 : &quot;</span> &lt;&lt; Book1.subject &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;第一本书 ID : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt;endl; </span><br><span class="line">   <span class="comment">// 输出 Book2 信息</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;第二本书标题 : &quot;</span> &lt;&lt; Book2.title &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;第二本书作者 : &quot;</span> &lt;&lt; Book2.author &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;第二本书类目 : &quot;</span> &lt;&lt; Book2.subject &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;第二本书 ID : &quot;</span> &lt;&lt; Book2.book_id &lt;&lt;endl; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">第一本书标题 : C++ 教程第一本书作者 : Runoob第一本书类目 : 编程语言第一本书 ID : <span class="number">12345</span>第二本书标题 : CSS 教程第二本书作者 : Runoob第二本书类目 : 前端技术第二本书 ID : <span class="number">12346</span></span><br></pre></td></tr></table></figure>

<h2 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h2><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
<h2 id="实例-23"><a href="#实例-23" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span>; </span><br><span class="line"><span class="comment">// 声明一个结构体类型 Books struct Books&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];   <span class="type">char</span>  author[<span class="number">50</span>];   <span class="type">char</span>  subject[<span class="number">100</span>];   <span class="type">int</span>   book_id;&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C++ 教程&quot;</span>);   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;编程语言&quot;</span>);   Book1.book_id = <span class="number">12345</span>; </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;CSS 教程&quot;</span>);   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Runoob&quot;</span>);   </span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;前端技术&quot;</span>);   Book2.book_id = <span class="number">12346</span>; </span><br><span class="line">   <span class="comment">// 输出 Book1 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( Book1 ); </span><br><span class="line">   <span class="comment">// 输出 Book2 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( Book2 ); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书标题 : &quot;</span> &lt;&lt; book.title &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> </span><br><span class="line">   &lt;&lt; book.author &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book.subject &lt;&lt;endl;   </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book.book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">书标题 : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class="number">12345</span>书标题 : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class="number">12346</span></span><br></pre></td></tr></table></figure>

<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span> *struct_pointer;</span><br></pre></td></tr></table></figure>

<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<h2 id="实例-24"><a href="#实例-24" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span></span>; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span>&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];   <span class="type">char</span>  author[<span class="number">50</span>];   <span class="type">char</span>  subject[<span class="number">100</span>];   <span class="type">int</span>   book_id;&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   Books Book1;        <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Books Book2;        <span class="comment">// 定义结构体类型 Books 的变量 Book2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Book1 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C++ 教程&quot;</span>);   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;编程语言&quot;</span>);   Book1.book_id = <span class="number">12345</span>; </span><br><span class="line">   <span class="comment">// Book2 详述</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;CSS 教程&quot;</span>);   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Runoob&quot;</span>);   </span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;前端技术&quot;</span>);   Book2.book_id = <span class="number">12346</span>; </span><br><span class="line">   <span class="comment">// 通过传 Book1 的地址来输出 Book1 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( &amp;Book1 ); </span><br><span class="line">   <span class="comment">// 通过传 Book2 的地址来输出 Book2 信息</span></span><br><span class="line">   <span class="built_in">printBook</span>( &amp;Book2 ); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">// 该函数以结构指针作为参数void printBook( struct Books *book )&#123;</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书标题  : &quot;</span> &lt;&lt; book-&gt;title &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;书作者 : &quot;</span> </span><br><span class="line">   &lt;&lt; book-&gt;author &lt;&lt;endl;   cout &lt;&lt; <span class="string">&quot;书类目 : &quot;</span> &lt;&lt; book-&gt;subject &lt;&lt;endl;   </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;书 ID : &quot;</span> &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">书标题  : C++ 教程书作者 : Runoob书类目 : 编程语言书 ID : <span class="number">12345</span>书标题  : CSS 教程书作者 : Runoob书类目 : 前端技术书 ID : <span class="number">12346</span></span><br></pre></td></tr></table></figure>

<h2 id="typedef-关键字"><a href="#typedef-关键字" class="headerlink" title="typedef 关键字"></a>typedef 关键字</h2><p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;&#125;Books;</span><br></pre></td></tr></table></figure>

<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Books Book1, Book2;</span><br></pre></td></tr></table></figure>

<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> *pint32;</span><br><span class="line"> pint32 x, y, z;</span><br></pre></td></tr></table></figure>

<p>x, y 和 z 都是指向长整型 long int 的指针。</p>
<h1 id="C-类-对象"><a href="#C-类-对象" class="headerlink" title="C++ 类 &amp; 对象"></a>C++ 类 &amp; 对象</h1><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。</p>
<h2 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h2><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;   <span class="keyword">public</span>:      <span class="type">double</span> length;   <span class="comment">// Length of a box      double breadth;  // Breadth of a box      double height;   // Height of a box&#125;;</span></span><br></pre></td></tr></table></figure>

<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>，这个我们稍后会进行讲解。</p>
<h2 id="定义-C-对象"><a href="#定义-C-对象" class="headerlink" title="定义 C++ 对象"></a>定义 C++ 对象</h2><p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box Box1;          <span class="comment">// 声明 Box1，类型为 BoxBox Box2;          // 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>

<p>对象 Box1 和 Box2 都有它们各自的数据成员。</p>
<h2 id="访问数据成员"><a href="#访问数据成员" class="headerlink" title="访问数据成员"></a>访问数据成员</h2><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 高度&#125;;int main( )&#123;</span></span><br><span class="line">   Box Box1;        <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">   Box Box2;        <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">   <span class="type">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 用于存储体积</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 1 详述</span></span><br><span class="line">   Box1.height = <span class="number">5.0</span>; </span><br><span class="line">   Box1.length = <span class="number">6.0</span>; </span><br><span class="line">   Box1.breadth = <span class="number">7.0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// box 2 详述</span></span><br><span class="line">   Box2.height = <span class="number">10.0</span>;</span><br><span class="line">   Box2.length = <span class="number">12.0</span>;</span><br><span class="line">   Box2.breadth = <span class="number">13.0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// box 1 的体积</span></span><br><span class="line">   volume = Box1.height * Box1.length * Box1.breadth;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// box 2 的体积</span></span><br><span class="line">   volume = Box2.height * Box2.length * Box2.breadth;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box1 的体积：<span class="number">210B</span>ox2 的体积：<span class="number">1560</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。</p>
<h1 id="类-对象详解"><a href="#类-对象详解" class="headerlink" title="类 &amp; 对象详解"></a>类 &amp; 对象详解</h1><p>到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类成员函数</td>
<td align="left">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td>
</tr>
<tr>
<td align="left">类访问修饰符</td>
<td align="left">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td>
</tr>
<tr>
<td align="left">构造函数 &amp; 析构函数</td>
<td align="left">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td>
</tr>
<tr>
<td align="left">C++ 拷贝构造函数</td>
<td align="left">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td>
</tr>
<tr>
<td align="left">C++ 友元函数</td>
<td align="left"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td>
</tr>
<tr>
<td align="left">C++ 内联函数</td>
<td align="left">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td>
</tr>
<tr>
<td align="left">C++ 中的 this 指针</td>
<td align="left">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td>
</tr>
<tr>
<td align="left">C++ 中指向类的指针</td>
<td align="left">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td>
</tr>
<tr>
<td align="left">C++ 类的静态成员</td>
<td align="left">类的数据成员和函数成员都可以被声明为静态的。</td>
</tr>
</tbody></table>
<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++ 继承"></a>C++ 继承</h1><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>
<h2 id="基类-派生类"><a href="#基类-派生类" class="headerlink" title="基类 &amp; 派生类"></a>基类 &amp; 派生类</h2><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<p>假设有一个基类 <strong>Shape</strong>，<strong>Rectangle</strong> 是它的派生类，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">// 基类class Shape &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;&#125;;<span class="comment">// 派生类class Rectangle: public Shape&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total area: 35</span><br></pre></td></tr></table></figure>

<h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">访问</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">派生类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">外部的类</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…&#123;&lt;派生类类体&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">// 基类 Shapeclass Shape &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;&#125;;<span class="comment">// 基类 PaintCostclass PaintCost &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;&#125;;<span class="comment">// 派生类class Rectangle: public Shape, public PaintCost&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Total area: <span class="number">35</span>Total paint cost: $<span class="number">2450</span></span><br></pre></td></tr></table></figure>

<h1 id="C-重载运算符和重载函数"><a href="#C-重载运算符和重载函数" class="headerlink" title="C++ 重载运算符和重载函数"></a>C++ 重载运算符和重载函数</h1><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>
<h2 id="C-中的函数重载"><a href="#C-中的函数重载" class="headerlink" title="C++ 中的函数重载"></a>C++ 中的函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>
<p>下面的实例中，同名函数 <strong>print()</strong> 被用于输出不同的数据类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">printData</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span>* c)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Printing character: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Call print to print integer</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// Call print to print float</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// Call print to print character</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Printing <span class="type">int</span>: <span class="number">5</span>Printing <span class="type">float</span>: <span class="number">500.263</span>Printing character: Hello C++</span><br></pre></td></tr></table></figure>

<h2 id="C-中的运算符重载"><a href="#C-中的运算符重载" class="headerlink" title="C++ 中的运算符重载"></a>C++ 中的运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>

<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp;, <span class="type">const</span> Box&amp;);</span><br></pre></td></tr></table></figure>

<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 <strong>this</strong> 运算符进行访问，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setBreadth</span><span class="params">( <span class="type">double</span> bre )</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">( <span class="type">double</span> hei )</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">      Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">         box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">         <span class="keyword">return</span> box;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度&#125;;// 程序的主函数int main( )&#123;</span></span><br><span class="line">   Box Box1;                <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">   Box Box2;                <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">   Box Box3;                <span class="comment">// 声明 Box3，类型为 Box</span></span><br><span class="line">   <span class="type">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 把体积存储在该变量中</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Box1 详述</span></span><br><span class="line">   Box1.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">   Box1.<span class="built_in">setBreadth</span>(<span class="number">7.0</span>); </span><br><span class="line">   Box1.<span class="built_in">setHeight</span>(<span class="number">5.0</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Box2 详述</span></span><br><span class="line">   Box2.<span class="built_in">setLength</span>(<span class="number">12.0</span>); </span><br><span class="line">   Box2.<span class="built_in">setBreadth</span>(<span class="number">13.0</span>); </span><br><span class="line">   Box2.<span class="built_in">setHeight</span>(<span class="number">10.0</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Box1 的体积</span></span><br><span class="line">   volume = Box1.<span class="built_in">getVolume</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Box2 的体积</span></span><br><span class="line">   volume = Box2.<span class="built_in">getVolume</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把两个对象相加，得到 Box3</span></span><br><span class="line">   Box3 = Box1 + Box2;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Box3 的体积</span></span><br><span class="line">   volume = Box3.<span class="built_in">getVolume</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Volume of Box1 : <span class="number">210</span>Volume of Box2 : <span class="number">1560</span>Volume of Box3 : <span class="number">5400</span></span><br></pre></td></tr></table></figure>

<h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符&#x2F;不可重载运算符"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>+</th>
<th>-</th>
<th>*</th>
<th>&#x2F;</th>
<th>%</th>
<th>^</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>|</td>
<td>~</td>
<td>!</td>
<td>,</td>
<td>&#x3D;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&gt;</td>
<td>&lt;&#x3D;</td>
<td>&gt;&#x3D;</td>
<td>++</td>
<td>–</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>&gt;&gt;</td>
<td>&#x3D;&#x3D;</td>
<td>!&#x3D;</td>
<td>&amp;&amp;</td>
<td>||</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>-&#x3D;</td>
<td>&#x2F;&#x3D;</td>
<td>%&#x3D;</td>
<td>^&#x3D;</td>
<td>&amp;&#x3D;</td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>*&#x3D;</td>
<td>&lt;&lt;&#x3D;</td>
<td>&gt;&gt;&#x3D;</td>
<td>[]</td>
<td>()</td>
</tr>
<tr>
<td>-&gt;</td>
<td>-&gt;*</td>
<td>new</td>
<td>new []</td>
<td>delete</td>
<td>delete []</td>
</tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>::</th>
<th>.*</th>
<th>.</th>
<th>?:</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><p>下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">运算符和实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">一元运算符重载</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">二元运算符重载</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">关系运算符重载</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">输入&#x2F;输出运算符重载</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">++ 和 – 运算符重载</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">赋值运算符重载</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">函数调用运算符 () 重载</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">下标运算符 [] 重载</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">类成员访问运算符 -&gt; 重载</td>
</tr>
</tbody></table>
<h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h1><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std;</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;&#125;;<span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;&#125;;<span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Triangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;&#125;;<span class="comment">// 程序的主函数int main( )&#123;</span></span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Parent <span class="keyword">class</span> <span class="title class_">areaParent</span> <span class="keyword">class</span> <span class="title class_">area</span></span><br></pre></td></tr></table></figure>

<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rectangle <span class="keyword">class</span> <span class="title class_">areaTriangle</span> <span class="keyword">class</span> <span class="title class_">area</span></span><br></pre></td></tr></table></figure>

<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// pure virtual function</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D; 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p>
<h1 id="C-数据抽象"><a href="#C-数据抽象" class="headerlink" title="C++ 数据抽象"></a>C++ 数据抽象</h1><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>
<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>
<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>
<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为<strong>数据抽象</strong>提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>
<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>
<p>在 C++ 中，我们使用<strong>类</strong>来定义我们自己的抽象数据类型（ADT）。您可以使用类 <strong>ostream</strong> 的 <strong>cout</strong> 对象来输出数据到标准输出，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main( )&#123;   cout &lt;&lt; <span class="string">&quot;Hello C++&quot;</span> &lt;&lt;endl;   return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这里，您不需要理解 <strong>cout</strong> 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。</p>
<h2 id="访问标签强制抽象"><a href="#访问标签强制抽象" class="headerlink" title="访问标签强制抽象"></a>访问标签强制抽象</h2><p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p>
<ul>
<li>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。</li>
<li>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。</li>
</ul>
<p>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p>
<h2 id="数据抽象的好处"><a href="#数据抽象的好处" class="headerlink" title="数据抽象的好处"></a>数据抽象的好处</h2><p>数据抽象有两个重要的优势：</p>
<ul>
<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>
<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>
</ul>
<p>如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。</p>
<h2 id="数据抽象的实例"><a href="#数据抽象的实例" class="headerlink" title="数据抽象的实例"></a>数据抽象的实例</h2><p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      <span class="built_in">Adder</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        total = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          total += number;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> total;</span><br><span class="line">      &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 对外隐藏的数据</span></span><br><span class="line">      <span class="type">int</span> total;&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   Adder a;</span><br><span class="line">   </span><br><span class="line">   a.<span class="built_in">addNum</span>(<span class="number">10</span>);</span><br><span class="line">   a.<span class="built_in">addNum</span>(<span class="number">20</span>);</span><br><span class="line">   a.<span class="built_in">addNum</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total &quot;</span> &lt;&lt; a.<span class="built_in">getTotal</span>() &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Total <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是用户不需要了解的，但又是类能正常工作所必需的。</p>
<h2 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h2><p>抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。</p>
<p>在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。</p>
<h1 id="C-数据封装"><a href="#C-数据封装" class="headerlink" title="C++ 数据封装"></a>C++ 数据封装</h1><p>所有的 C++ 程序都有以下两个基本要素：</p>
<ul>
<li><strong>程序语句（代码）：</strong>这是程序中执行动作的部分，它们被称为函数。</li>
<li><strong>程序数据：</strong>数据是程序的信息，会受到程序函数的影响。</li>
</ul>
<p>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即<strong>数据隐藏</strong>。</p>
<p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<p>C++ 通过创建<strong>类</strong>来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。</p>
<p>为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 <strong>public</strong> 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。</p>
<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。</p>
<h2 id="数据封装的实例"><a href="#数据封装的实例" class="headerlink" title="数据封装的实例"></a>数据封装的实例</h2><p>C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;class Adder&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      <span class="built_in">Adder</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        total = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          total += number;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> total;</span><br><span class="line">      &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 对外隐藏的数据</span></span><br><span class="line">      <span class="type">int</span> total;&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   Adder a;</span><br><span class="line">   </span><br><span class="line">   a.<span class="built_in">addNum</span>(<span class="number">10</span>);</span><br><span class="line">   a.<span class="built_in">addNum</span>(<span class="number">20</span>);</span><br><span class="line">   a.<span class="built_in">addNum</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total &quot;</span> &lt;&lt; a.<span class="built_in">getTotal</span>() &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Total <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>上面的类把数字相加，并返回总和。公有成员 <strong>addNum</strong> 和 <strong>getTotal</strong> 是对外的接口，用户需要知道它们以便使用类。私有成员 <strong>total</strong> 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。</p>
<h2 id="设计策略-1"><a href="#设计策略-1" class="headerlink" title="设计策略"></a>设计策略</h2><p>通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的<strong>封装性</strong>。</p>
<p>这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。</p>
<h1 id="C-接口（抽象类）"><a href="#C-接口（抽象类）" class="headerlink" title="C++ 接口（抽象类）"></a>C++ 接口（抽象类）</h1><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度&#125;;</span></span><br></pre></td></tr></table></figure>

<p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>
<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>
<p>可用于实例化对象的类被称为<strong>具体类</strong>。</p>
<h2 id="抽象类的实例"><a href="#抽象类的实例" class="headerlink" title="抽象类的实例"></a>抽象类的实例</h2><p>请看下面的实例，基类 Shape 提供了一个接口 **getArea()**，在两个派生类 Rectangle 和 Triangle 中分别实现了 **getArea()**：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="comment">// 基类class Shape &#123;public:</span></span><br><span class="line">   <span class="comment">// 提供接口框架的纯虚函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      width = w;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;<span class="keyword">protected</span>:</span><br><span class="line">   <span class="type">int</span> width;</span><br><span class="line">   <span class="type">int</span> height;&#125;;</span><br><span class="line"> <span class="comment">// 派生类class Rectangle: public Shape&#123;public:</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height); </span><br><span class="line">   &#125;&#125;;<span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape&#123;<span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (width * height)/<span class="number">2</span>; </span><br><span class="line">   &#125;&#125;;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   Triangle  Tri;</span><br><span class="line"> </span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   Tri.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Tri.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.<span class="built_in">getArea</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Total Rectangle area: <span class="number">35</span>Total Triangle area: <span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。</p>
<h2 id="设计策略-2"><a href="#设计策略-2" class="headerlink" title="设计策略"></a>设计策略</h2><p>面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。</p>
<p>外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。</p>
<p>这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。</p>
<h1 id="C-文件和流"><a href="#C-文件和流" class="headerlink" title="C++ 文件和流"></a>C++ 文件和流</h1><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>
<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>
<table>
<thead>
<tr>
<th align="left">模式标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios::app</td>
<td align="left">追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::ate</td>
<td align="left">文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::in</td>
<td align="left">打开文件用于读取。</td>
</tr>
<tr>
<td align="left">ios::out</td>
<td align="left">打开文件用于写入。</td>
</tr>
<tr>
<td align="left">ios::trunc</td>
<td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody></table>
<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream outfile;outfile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fstream  afile;afile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>
<h2 id="读取-写入实例"><a href="#读取-写入实例" class="headerlink" title="读取 &amp; 写入实例"></a>读取 &amp; 写入实例</h2><p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$./a.outWriting to the fileEnter your name: ZaraEnter your age: <span class="number">9</span>Reading from the fileZara9</span><br></pre></td></tr></table></figure>

<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<h2 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n );// 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur );// 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end );// 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );</span></span><br></pre></td></tr></table></figure>

<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 保护代码&#125;catch( ExceptionName e1 )&#123;</span></span><br><span class="line">   <span class="comment">// catch 块&#125;catch( ExceptionName e2 )&#123;</span></span><br><span class="line">   <span class="comment">// catch 块&#125;catch( ExceptionName eN )&#123;</span></span><br><span class="line">   <span class="comment">// catch 块&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 保护代码&#125;catch( ExceptionName e )&#123;</span></span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 保护代码&#125;catch(...)&#123;</span></span><br><span class="line">  <span class="comment">// 能处理任何异常的代码&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;double division(int a, int b)&#123;</span></span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Division by zero condition!</span><br></pre></td></tr></table></figure>

<h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/1641382aba76354408.jpg" alt="img"></p>
<p>下表是对上面层次结构中出现的每个异常的说明：</p>
<table>
<thead>
<tr>
<th align="left">异常</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>std::exception</strong></td>
<td align="left">该异常是所有标准 C++ 异常的父类。</td>
</tr>
<tr>
<td align="left">std::bad_alloc</td>
<td align="left">该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_cast</td>
<td align="left">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_exception</td>
<td align="left">这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td align="left">std::bad_typeid</td>
<td align="left">该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td align="left"><strong>std::logic_error</strong></td>
<td align="left">理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td align="left">std::domain_error</td>
<td align="left">当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::invalid_argument</td>
<td align="left">当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::length_error</td>
<td align="left">当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::out_of_range</td>
<td align="left">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td align="left"><strong>std::runtime_error</strong></td>
<td align="left">理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td align="left">std::overflow_error</td>
<td align="left">当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::range_error</td>
<td align="left">当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::underflow_error</td>
<td align="left">当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>using namespace std;struct MyException : public exception&#123;</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这将产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyException caught</span><br><span class="line">C++ Exception</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>
<h1 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h1><p>了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：</p>
<ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>
<p>如果您不需要动态分配内存，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>
<h2 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h2><p>下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> data-type;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>data-type</strong> 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 <strong>new</strong> 运算符来完成这点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针pvalue  = new double;   // 为变量请求内存</span></span><br></pre></td></tr></table></figure>

<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>;<span class="keyword">if</span>( !(pvalue  = <span class="keyword">new</span> <span class="type">double</span> ))&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Error: out of memory.&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure>

<p><strong>malloc()</strong> 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>
<p>在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pvalue;        <span class="comment">// 释放 pvalue 所指向的内存</span></span><br></pre></td></tr></table></figure>

<p>下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class="line">   <span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">   pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line"> </span><br><span class="line">   *pvalue = <span class="number">29494.99</span>;     <span class="comment">// 在分配的地址存储值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> pvalue;         <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Value of pvalue : <span class="number">29495</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的动态内存分配"><a href="#数组的动态内存分配" class="headerlink" title="数组的动态内存分配"></a>数组的动态内存分配</h2><p>假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针pvalue  = new char[20]; // 为变量请求内存</span></span><br></pre></td></tr></table></figure>

<p>要删除我们刚才创建的数组，语句如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pvalue;        <span class="comment">// 删除 pvalue 所指向的数组</span></span><br></pre></td></tr></table></figure>

<p>下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ROW = <span class="number">2</span>;<span class="type">int</span> COL = <span class="number">3</span>;<span class="type">double</span> **pvalue  = <span class="keyword">new</span> <span class="type">double</span>* [ROW]; <span class="comment">// 为行分配内存// 为列分配内存for(int i = 0; i &lt; COL; i++) &#123;</span></span><br><span class="line">    pvalue[i] = <span class="keyword">new</span> <span class="type">double</span>[COL];&#125;</span><br></pre></td></tr></table></figure>

<p>释放多维数组内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; COL; i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pvalue[i];&#125;<span class="keyword">delete</span> [] pvalue;</span><br></pre></td></tr></table></figure>

<h2 id="对象的动态内存分配"><a href="#对象的动态内存分配" class="headerlink" title="对象的动态内存分配"></a>对象的动态内存分配</h2><p>对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;class Box&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Box</span>() &#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;调用构造函数！&quot;</span> &lt;&lt;endl; </span><br><span class="line">      &#125;</span><br><span class="line">      ~<span class="built_in">Box</span>() &#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;调用析构函数！&quot;</span> &lt;&lt;endl; </span><br><span class="line">      &#125;&#125;;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">   Box* myBoxArray = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> [] myBoxArray; <span class="comment">// Delete array</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。</p>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！</span><br></pre></td></tr></table></figure>

<h1 id="C-命名空间"><a href="#C-命名空间" class="headerlink" title="C++ 命名空间"></a>C++ 命名空间</h1><p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p>
<p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</p>
<p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>
<h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;   <span class="comment">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>

<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">name::code;  <span class="comment">// code 可以是变量或函数</span></span><br></pre></td></tr></table></figure>

<p>让我们来看看命名空间如何为变量或函数等实体定义范围：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;<span class="comment">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;&#125;<span class="comment">// 第二个命名空间namespace second_space&#123;</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   first_space::<span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   second_space::<span class="built_in">func</span>(); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Inside first_spaceInside second_space</span><br></pre></td></tr></table></figure>

<h2 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h2><p>您可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;<span class="comment">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;&#125;<span class="comment">// 第二个命名空间namespace second_space&#123;</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> first_space;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第一个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Inside first_space</span><br></pre></td></tr></table></figure>

<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></table></figure>

<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 <strong>std</strong> 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using std::cout;int main ()&#123;   </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;std::endl is used with std!&quot;</span> &lt;&lt; std::endl;      </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::endl is used with std!</span><br></pre></td></tr></table></figure>

<p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>
<h2 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h2><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p>
<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name &#123;</span><br><span class="line">   <span class="comment">// 代码声明&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h2><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">   <span class="keyword">namespace</span> namespace_name2 &#123;</span><br><span class="line">      <span class="comment">// 代码声明</span></span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2;// 访问 namespace:name1 中的成员using namespace namespace_name1;</span></span><br></pre></td></tr></table></figure>

<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;<span class="comment">// 第一个命名空间namespace first_space&#123;</span></span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 第二个命名空间</span></span><br><span class="line">   <span class="keyword">namespace</span> second_space&#123;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> first_space::second_space;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 调用第二个命名空间中的函数</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Inside second_space</span><br></pre></td></tr></table></figure>

<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector <int></strong> 或 **vector <string>**。</p>
<p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板函数定义的一般形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; ret-type func-<span class="built_in">name</span>(parameter list)&#123;   <span class="comment">// 函数的主体&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数种的最大值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>using namespace std;template <span class="string">&lt;typename T&gt;</span>inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; </span></span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; &#125; <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Max</span>(i, j): <span class="number">39</span>Max(f1, f2): <span class="number">20.7</span>Max(s1, s2): World</span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; <span class="keyword">class</span> <span class="title class_">class</span>-name &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>
<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>using namespace std;template <span class="string">&lt;class T&gt;</span>class Stack &#123; </span></span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    vector&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125; &#125;; <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) &#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    &#125; <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () &#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         &#125; <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;T Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();      &#125; <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>helloException: Stack&lt;&gt;::<span class="built_in">pop</span>(): empty stack</span><br></pre></td></tr></table></figure>

<h1 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C++ 预处理器"></a>C++ 预处理器</h1><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>
<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>
<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>
<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。</p>
<h2 id="define-预处理"><a href="#define-预处理" class="headerlink" title="#define 预处理"></a>#define 预处理</h2><p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>，指令的一般形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> macro-name replacement-text</span></span><br></pre></td></tr></table></figure>

<p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;#<span class="keyword">define</span> PI 3.14159int main ()&#123;     cout &lt;&lt; <span class="string">&quot;Value of PI :&quot;</span> &lt;&lt; PI &lt;&lt; endl;     return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$gcc -E test.cpp &gt; test.p...<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;     cout &lt;&lt; <span class="string">&quot;Value of PI :&quot;</span> &lt;&lt; <span class="number">3.14159</span> &lt;&lt; endl;     <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a>函数宏</h2><p>您可以使用 #define 来定义一个带有参数的宏，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;#<span class="keyword">define</span> MIN(a,b) (a&lt;b ? a : b)int main ()&#123;</span></span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   i = <span class="number">100</span>;</span><br><span class="line">   j = <span class="number">30</span>;</span><br><span class="line">   cout &lt;&lt;<span class="string">&quot;较小的值为：&quot;</span> &lt;&lt; <span class="built_in">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">较小的值为：<span class="number">30</span></span><br></pre></td></tr></table></figure>

<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>
<p>条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL   #<span class="keyword">define</span> NULL 0#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG   cerr &lt;&lt;<span class="string">&quot;Variable x = &quot;</span> &lt;&lt; x &lt;&lt; endl;#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 <strong>cerr</strong> 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0   不进行编译的代码#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>让我们尝试下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;#<span class="keyword">define</span> DEBUG#<span class="keyword">define</span> MIN(a,b) (((a)&lt;(b)) ? a : b)int main ()&#123;</span></span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   i = <span class="number">100</span>;</span><br><span class="line">   j = <span class="number">30</span>;<span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;<span class="meta">#<span class="keyword">endif</span>#<span class="keyword">if</span> 0</span></span><br><span class="line">   <span class="comment">/* 这是注释部分 */</span></span><br><span class="line">   cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   cout &lt;&lt;<span class="string">&quot;The minimum is &quot;</span> &lt;&lt; <span class="built_in">MIN</span>(i, j) &lt;&lt; endl;<span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Coming out of main function&quot;</span> &lt;&lt; endl;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Trace: Inside main functionThe minimum is <span class="number">30</span>Trace: Coming out of main function</span><br></pre></td></tr></table></figure>

<h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI&#x2F;ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</p>
<p>请看下面的宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;#<span class="keyword">define</span> MKSTR( x ) #xint main ()&#123;    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HELLO C++</span><br></pre></td></tr></table></figure>

<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>转换成了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;HELLO C++&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>## 运算符用于连接两个令牌。下面是一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT( x, y )  x ## y</span></span><br></pre></td></tr></table></figure>

<p>当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;#<span class="keyword">define</span> concat(a, b) a ## bint main()&#123;   int xy = 100;      cout &lt;&lt; concat(x, y);   return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">concat</span>(x, y);</span><br></pre></td></tr></table></figure>

<p>转换成了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; xy;</span><br></pre></td></tr></table></figure>

<h2 id="C-中的预定义宏"><a href="#C-中的预定义宏" class="headerlink" title="C++ 中的预定义宏"></a>C++ 中的预定义宏</h2><p>C++ 提供了下表所示的一些预定义宏：</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>LINE</strong></td>
<td align="left">这会在程序编译时包含当前行号。</td>
</tr>
<tr>
<td align="left"><strong>FILE</strong></td>
<td align="left">这会在程序编译时包含当前文件名。</td>
</tr>
<tr>
<td align="left"><strong>DATE</strong></td>
<td align="left">这会包含一个形式为 month&#x2F;day&#x2F;year 的字符串，它表示把源文件转换为目标代码的日期。</td>
</tr>
<tr>
<td align="left"><strong>TIME</strong></td>
<td align="left">这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。</td>
</tr>
</tbody></table>
<p>让我们看看上述这些宏的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __LINE__ : &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __FILE__ : &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __DATE__ : &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of __TIME__ : &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Value of __LINE__ : <span class="number">6</span>Value of __FILE__ : test.cppValue of __DATE__ : Feb <span class="number">28</span> <span class="number">2011</span>Value of __TIME__ : <span class="number">18</span>:<span class="number">52</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>

<h1 id="C-信号处理"><a href="#C-信号处理" class="headerlink" title="C++ 信号处理"></a>C++ 信号处理</h1><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>
<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</p>
<table>
<thead>
<tr>
<th align="left">信号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIGABRT</td>
<td align="left">程序的异常终止，如调用 <strong>abort</strong>。</td>
</tr>
<tr>
<td align="left">SIGFPE</td>
<td align="left">错误的算术运算，比如除以零或导致溢出的操作。</td>
</tr>
<tr>
<td align="left">SIGILL</td>
<td align="left">检测非法指令。</td>
</tr>
<tr>
<td align="left">SIGINT</td>
<td align="left">接收到交互注意信号。</td>
</tr>
<tr>
<td align="left">SIGSEGV</td>
<td align="left">非法访问内存。</td>
</tr>
<tr>
<td align="left">SIGTERM</td>
<td align="left">发送到程序的终止请求。</td>
</tr>
</tbody></table>
<h2 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal() 函数"></a>signal() 函数</h2><p>C++ 信号处理库提供了 <strong>signal</strong> 函数，用来捕获突发事件。以下是 signal() 函数的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span> (<span class="type">int</span> sig, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>
<p>让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 <strong>signal</strong> 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序  </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(signum);  &#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Going to sleep....Going to sleep....Going to sleep....</span><br></pre></td></tr></table></figure>

<p>现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Going to sleep....Going to sleep....Going to sleep....<span class="function">Interrupt <span class="title">signal</span> <span class="params">(<span class="number">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>

<h2 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h2><p>您可以使用函数 <strong>raise()</strong> 生成信号，该函数带有一个整数信号编号作为参数，语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span> <span class="params">(signal sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>sig</strong> 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span>using namespace std;void signalHandler( int signum )&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Interrupt signal (&quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;) received.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理并关闭</span></span><br><span class="line">    <span class="comment">// 终止程序 </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(signum);  &#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号 SIGINT 和信号处理程序</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, signalHandler);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(++i)&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Going to sleep....&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">if</span>( i == <span class="number">3</span> )&#123;</span><br><span class="line">          <span class="built_in">raise</span>( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Going to sleep....Going to sleep....Going to sleep....<span class="function">Interrupt <span class="title">signal</span> <span class="params">(<span class="number">2</span>)</span> received.</span></span><br></pre></td></tr></table></figure>

<h1 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h1><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。</p>
<p>本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU&#x2F;Linux、Mac OS X 和 Solaris。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>pthread_create (thread, attr, start_routine, arg)</span></span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_create</strong> 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">thread</td>
<td align="left">指向线程标识符指针。</td>
</tr>
<tr>
<td align="left">attr</td>
<td align="left">一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td align="left">start_routine</td>
<td align="left">线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td align="left">arg</td>
<td align="left">运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody></table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>pthread_exit (status)</span></span><br></pre></td></tr></table></figure>

<p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</p>
<h2 id="实例-25"><a href="#实例-25" class="headerlink" title="实例"></a>实例</h2><p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出”Hello Runoob！”:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">// 必须的头文件是#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS 5// 线程的运行函数void* say_hello(void* args)&#123;</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello Runoob！&quot;</span> &lt;&lt; endl;&#125;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class="line">    <span class="type">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tids[i], <span class="literal">NULL</span>, say_hello, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>使用 -lpthread 库编译下面的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o</span><br></pre></td></tr></table></figure>

<p>现在，执行程序，将产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ./test.oHello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！Hello Runoob！</span><br></pre></td></tr></table></figure>

<p>以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件名：test.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;pthread.h&gt;using namespace std;#define NUM_THREADS     5void *PrintHello(void *threadid)&#123;  </span></span><br><span class="line">   <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">   <span class="type">int</span> tid = *((<span class="type">int</span>*)threadid);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello Runoob! 线程 ID, &quot;</span> &lt;&lt; tid &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="type">int</span> indexes[NUM_THREADS];<span class="comment">// 用数组来保存i的值</span></span><br><span class="line">   <span class="type">int</span> rc;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : 创建线程, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line">      <span class="comment">// 传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, </span><br><span class="line">                          PrintHello, (<span class="type">void</span> *)&amp;(indexes[i]));</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:无法创建线程,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>现在编译并执行程序，将产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o$ ./test.<span class="built_in">omain</span>() : 创建线程, <span class="number">0</span>main() : 创建线程, <span class="number">1</span>main() : 创建线程, <span class="number">2</span>main() : 创建线程, <span class="number">3</span>main() : 创建线程, <span class="number">4</span>Hello Runoob! 线程 ID, <span class="number">4</span>Hello Runoob! 线程 ID, <span class="number">3</span>Hello Runoob! 线程 ID, <span class="number">2</span>Hello Runoob! 线程 ID, <span class="number">1</span>Hello Runoob! 线程 ID, <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h2><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>using namespace std;#<span class="keyword">define</span> NUM_THREADS     5struct thread_data&#123;   int  thread_id;   char *message;&#125;;void *PrintHello(void *threadarg)&#123;   struct thread_data *my_data;   my_data = (struct thread_data *) threadarg;   cout <span class="string">&lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;</span>thread_id ;   cout <span class="string">&lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;</span>message &lt;&lt; endl;   pthread_exit(NULL);&#125;int main ()&#123;   pthread_t threads[NUM_THREADS];   struct thread_data td[NUM_THREADS];   int rc;   int i;   for( i=0; i &lt; NUM_THREADS; i++ )&#123;      cout &lt;&lt;<span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;      td[i].thread_id = i;      td[i].message = <span class="string">&quot;This is message&quot;</span>;      rc = pthread_create(&amp;threads[i], NULL,                          PrintHello, (void *)&amp;td[i]);      <span class="keyword">if</span> (rc)&#123;         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;         exit(-1);      &#125;   &#125;   pthread_exit(NULL);&#125;</span></span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.<span class="function">o</span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span> : 创建线程, <span class="number">0</span>main() : 创建线程, <span class="number">1</span>main() : 创建线程, <span class="number">2</span>main() : 创建线程, <span class="number">3</span>main() : 创建线程, <span class="number">4</span>Hello Runoob! 线程 ID, <span class="number">4</span>Hello Runoob! 线程 ID, <span class="number">3</span>Hello Runoob! 线程 ID, <span class="number">2</span>Hello Runoob! 线程 ID, <span class="number">1</span>Hello Runoob! 线程 ID, <span class="number">0</span></span></span><br></pre></td></tr></table></figure>

<h2 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h2><p>我们可以使用以下两个函数来连接或分离线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_join</span> (threadid, status) <span class="built_in">pthread_detach</span> (threadid)</span><br></pre></td></tr></table></figure>

<p>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>
<p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>using namespace std;#<span class="keyword">define</span> NUM_THREADS     5void *wait(void *t)&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">long</span> tid;</span><br><span class="line"></span><br><span class="line">   tid = (<span class="type">long</span>)t;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Sleeping in thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Thread with id : &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;  ...exiting &quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);&#125;<span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> rc;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">   <span class="type">void</span> *status;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class="line">   <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">   <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;main() : creating thread, &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, wait, (<span class="type">void</span> *)&amp;i );</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to create thread,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除属性，并等待其他线程</span></span><br><span class="line">   <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = <span class="built_in">pthread_join</span>(threads[i], &amp;status);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Error:unable to join,&quot;</span> &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Main: completed thread id :&quot;</span> &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;  exiting with status :&quot;</span> &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Main: program exiting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span>() : creating thread, <span class="number">0</span>main() : creating thread, <span class="number">1</span>main() : creating thread, <span class="number">2</span>main() : creating thread, <span class="number">3</span>main() : creating thread, <span class="number">4</span>Sleeping in thread </span><br><span class="line">Thread with id : <span class="number">4</span>  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : <span class="number">3</span>  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : <span class="number">2</span>  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : <span class="number">1</span>  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : <span class="number">0</span>  ...exiting </span><br><span class="line">Main: completed thread id :<span class="number">0</span>  exiting with status :<span class="number">0</span>Main: completed thread id :<span class="number">1</span>  exiting with status :<span class="number">0</span>Main: completed thread id :<span class="number">2</span>  exiting with status :<span class="number">0</span>Main: completed thread id :<span class="number">3</span>  exiting with status :<span class="number">0</span>Main: completed thread id :<span class="number">4</span>  exiting with status :<span class="number">0</span>Main: program exiting.</span><br></pre></td></tr></table></figure>

<h1 id="C-Web-编程"><a href="#C-Web-编程" class="headerlink" title="C++ Web 编程"></a>C++ Web 编程</h1><h2 id="什么是-CGI？"><a href="#什么是-CGI？" class="headerlink" title="什么是 CGI？"></a>什么是 CGI？</h2><ul>
<li>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</li>
<li>CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下：</li>
<li>公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。</li>
<li>目前的版本是 CGI&#x2F;1.1，CGI&#x2F;1.2 版本正在推进中。</li>
</ul>
<h2 id="Web-浏览"><a href="#Web-浏览" class="headerlink" title="Web 浏览"></a>Web 浏览</h2><p>为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。</p>
<ul>
<li>您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。</li>
<li>Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。</li>
<li>Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。</li>
</ul>
<p>然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。</p>
<p>公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。</p>
<h2 id="CGI-架构图"><a href="#CGI-架构图" class="headerlink" title="CGI 架构图"></a>CGI 架构图</h2><p>下图演示了 CGI 的架构：</p>
<p><img src="https://edu.aliyun.com/files/course/2017/09-24/1655506773c2493212.gif" alt="img"></p>
<h2 id="Web-服务器配置"><a href="#Web-服务器配置" class="headerlink" title="Web 服务器配置"></a>Web 服务器配置</h2><p>在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 &#x2F;var&#x2F;www&#x2F;cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 <strong>.cgi</strong>。</p>
<p>默认情况下，Apache Web 服务器会配置在 &#x2F;var&#x2F;www&#x2F;cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;Directory <span class="string">&quot;/var/www/cgi-bin&quot;</span>&gt;   AllowOverride None   Options ExecCGI   Order allow,deny   Allow from all&lt;/Directory&gt; &lt;Directory <span class="string">&quot;/var/www/cgi-bin&quot;</span>&gt;Options All&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p>在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。</p>
<h2 id="第一个-CGI-程序"><a href="#第一个-CGI-程序" class="headerlink" title="第一个 CGI 程序"></a>第一个 CGI 程序</h2><p>请看下面的 C++ 程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;Hello World - 第一个 CGI 程序&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;h2&gt;Hello World! 这是我的第一个 CGI 程序&lt;/h2&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 &#x2F;var&#x2F;www&#x2F;cgi-bin 目录中。在运行 CGI 程序之前，请使用 <strong>chmod 755 cplusplus.cgi</strong> UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出：</p>
<h2 id="Hello-World-这是我的第一个-CGI-程序"><a href="#Hello-World-这是我的第一个-CGI-程序" class="headerlink" title="Hello World! 这是我的第一个 CGI 程序"></a>Hello World! 这是我的第一个 CGI 程序</h2><p>上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 <strong>Content-type:text&#x2F;html\r\n\r\n</strong>。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。</p>
<h2 id="HTTP-头信息"><a href="#HTTP-头信息" class="headerlink" title="HTTP 头信息"></a>HTTP 头信息</h2><p>行 <strong>Content-type:text&#x2F;html\r\n\r\n</strong> 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HTTP 字段名称: 字段内容 例如Content-type: text/html\r\n\r\n</span><br></pre></td></tr></table></figure>

<p>还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。</p>
<table>
<thead>
<tr>
<th align="left">头信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Content-type:</td>
<td align="left">MIME 字符串，定义返回的文件格式。例如 Content-type:text&#x2F;html。</td>
</tr>
<tr>
<td align="left">Expires: Date</td>
<td align="left">信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。</td>
</tr>
<tr>
<td align="left">Location: URL</td>
<td align="left">这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。</td>
</tr>
<tr>
<td align="left">Last-modified: Date</td>
<td align="left">资源的最后修改日期。</td>
</tr>
<tr>
<td align="left">Content-length: N</td>
<td align="left">要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。</td>
</tr>
<tr>
<td align="left">Set-Cookie: String</td>
<td align="left">通过 <em>string</em> 设置 cookie。</td>
</tr>
</tbody></table>
<h2 id="CGI-环境变量"><a href="#CGI-环境变量" class="headerlink" title="CGI 环境变量"></a>CGI 环境变量</h2><p>所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONTENT_TYPE</td>
<td align="left">内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。</td>
</tr>
<tr>
<td align="left">CONTENT_LENGTH</td>
<td align="left">查询的信息长度。只对 POST 请求可用。</td>
</tr>
<tr>
<td align="left">HTTP_COOKIE</td>
<td align="left">以键 &amp; 值对的形式返回设置的 cookies。</td>
</tr>
<tr>
<td align="left">HTTP_USER_AGENT</td>
<td align="left">用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。</td>
</tr>
<tr>
<td align="left">PATH_INFO</td>
<td align="left">CGI 脚本的路径。</td>
</tr>
<tr>
<td align="left">QUERY_STRING</td>
<td align="left">通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。</td>
</tr>
<tr>
<td align="left">REMOTE_ADDR</td>
<td align="left">发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。</td>
</tr>
<tr>
<td align="left">REMOTE_HOST</td>
<td align="left">发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。</td>
</tr>
<tr>
<td align="left">REQUEST_METHOD</td>
<td align="left">用于发出请求的方法。最常见的方法是 GET 和 POST。</td>
</tr>
<tr>
<td align="left">SCRIPT_FILENAME</td>
<td align="left">CGI 脚本的完整路径。</td>
</tr>
<tr>
<td align="left">SCRIPT_NAME</td>
<td align="left">CGI 脚本的名称。</td>
</tr>
<tr>
<td align="left">SERVER_NAME</td>
<td align="left">服务器的主机名或 IP 地址。</td>
</tr>
<tr>
<td align="left">SERVER_SOFTWARE</td>
<td align="left">服务器上运行的软件的名称和版本。</td>
</tr>
</tbody></table>
<p>下面的 CGI 程序列出了所有的 CGI 变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>using namespace std;const string ENV[ 24 ] = &#123;                 </span></span><br><span class="line">        <span class="string">&quot;COMSPEC&quot;</span>, <span class="string">&quot;DOCUMENT_ROOT&quot;</span>, <span class="string">&quot;GATEWAY_INTERFACE&quot;</span>,   </span><br><span class="line">        <span class="string">&quot;HTTP_ACCEPT&quot;</span>, <span class="string">&quot;HTTP_ACCEPT_ENCODING&quot;</span>,    &amp;nbsnbsp;        </span><br><span class="line">        <span class="string">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span>, <span class="string">&quot;HTTP_CONNECTION&quot;</span>,         </span><br><span class="line">        <span class="string">&quot;HTTP_HOST&quot;</span>, <span class="string">&quot;HTTP_USER_AGENT&quot;</span>, <span class="string">&quot;PATH&quot;</span>,            </span><br><span class="line">        <span class="string">&quot;QUERY_STRING&quot;</span>, <span class="string">&quot;REMOTE_ADDR&quot;</span>, <span class="string">&quot;REMOTE_PORT&quot;</span>,      </span><br><span class="line">        <span class="string">&quot;REQUEST_METHOD&quot;</span>, <span class="string">&quot;REQUEST_URI&quot;</span>, <span class="string">&quot;SCRIPT_FILENAME&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SCRIPT_NAME&quot;</span>, <span class="string">&quot;SERVER_ADDR&quot;</span>, <span class="string">&quot;SERVER_ADMIN&quot;</span>,      </span><br><span class="line">        <span class="string">&quot;SERVER_NAME&quot;</span>,<span class="string">&quot;SERVER_PORT&quot;</span>,<span class="string">&quot;SERVER_PROTOCOL&quot;</span>,     </span><br><span class="line">        <span class="string">&quot;SERVER_SIGNATURE&quot;</span>,<span class="string">&quot;SERVER_SOFTWARE&quot;</span> &#125;;   <span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 环境变量&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;table border = \&quot;0\&quot; cellspacing = \&quot;2\&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; ENV[ i ] &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class="line">       <span class="comment">// 尝试检索环境变量的值</span></span><br><span class="line">       <span class="type">char</span> *value = <span class="built_in">getenv</span>( ENV[ i ].<span class="built_in">c_str</span>() );  </span><br><span class="line">       <span class="keyword">if</span> ( value != <span class="number">0</span> )&#123;</span><br><span class="line">         cout &lt;&lt; value;                                 </span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;环境变量不存在。&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/table&gt;&lt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-CGI-库"><a href="#C-CGI-库" class="headerlink" title="C++ CGI 库"></a>C++ CGI 库</h2><p>在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 <a href="ftp://ftp.gnu.org/gnu/cgicc/">ftp://ftp.gnu.org/gnu/cgicc/</a> 上下载这个 CGI 库，并按照下面的步骤安装库：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$tar xzf cgicc-X.X.X.tar.gz $cd cgicc-X.X.X/ $./configure --prefix=/usr $make$make install</span><br></pre></td></tr></table></figure>

<p>您可以点击 C++ CGI Lib Documentation，查看相关的库文档。</p>
<h2 id="GET-和-POST-方法"><a href="#GET-和-POST-方法" class="headerlink" title="GET 和 POST 方法"></a>GET 和 POST 方法</h2><p>您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。</p>
<h2 id="使用-GET-方法传递信息"><a href="#使用-GET-方法传递信息" class="headerlink" title="使用 GET 方法传递信息"></a>使用 GET 方法传递信息</h2><p>GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//www.test.com/cgi-bin/cpp.cgi?key1=value1&amp;key2=value2</span></span><br></pre></td></tr></table></figure>

<p>GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。</p>
<p>当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。</p>
<p>您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML <FORM> 标签的 GET 方法来传信息。</p>
<h2 id="简单的-URL-实例：Get-方法"><a href="#简单的-URL-实例：Get-方法" class="headerlink" title="简单的 URL 实例：Get 方法"></a>简单的 URL 实例：Get 方法</h2><p>下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。</p>
<p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p>
<p>下面的实例生成 <strong>cpp_get.cgi</strong> CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span>  using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc formData;</span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;使用 GET 和 POST 方法&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;first_name&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;名：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No text entered for first name&quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;last_name&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp;fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;姓：&quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No text entered for last name&quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，编译上面的程序，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$g++ -o cpp_get.cgi cpp_get.cpp -lcgicc</span><br></pre></td></tr></table></figure>

<p>生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问：</p>
<p>&#x2F;cgi-bin&#x2F;cpp_get.cgi?first_name&#x3D;ZARA&amp;last_name&#x3D;ALI</p>
<p>这会产生以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">名：ZARA 姓：ALI</span><br></pre></td></tr></table></figure>

<h2 id="简单的表单实例：GET-方法"><a href="#简单的表单实例：GET-方法" class="headerlink" title="简单的表单实例：GET 方法"></a>简单的表单实例：GET 方法</h2><p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;first_name&quot;</span>&gt;  &lt;br /&gt; 姓：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;last_name&quot;</span> /&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。</p>
<h2 id="使用-POST-方法传递信息"><a href="#使用-POST-方法传递信息" class="headerlink" title="使用 POST 方法传递信息"></a>使用 POST 方法传递信息</h2><p>一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。</p>
<p>我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/cgi-bin/cpp_get.cgi&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;first_name&quot;</span>&gt;&lt;br /&gt;姓：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;last_name&quot;</span> /&gt; &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h2 id="向-CGI-程序传递复选框数据"><a href="#向-CGI-程序传递复选框数据" class="headerlink" title="向 CGI 程序传递复选框数据"></a>向 CGI 程序传递复选框数据</h2><p>当需要选择多个选项时，我们使用复选框。</p>
<p>下面的 HTML 代码实例是一个带有两个复选框的表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/cgi-bin/cpp_checkbox.cgi&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;maths&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 数学<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;physics&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> 物理<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;选择学科&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc formData;</span><br><span class="line">   <span class="type">bool</span> maths_flag, physics_flag;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递复选框数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   maths_flag = formData.<span class="built_in">queryCheckbox</span>(<span class="string">&quot;maths&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>( maths_flag ) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Maths Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Maths Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   physics_flag = formData.<span class="built_in">queryCheckbox</span>(<span class="string">&quot;physics&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>( physics_flag ) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Physics Flag: ON &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Physics Flag: OFF &quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向-CGI-程序传递单选按钮数据"><a href="#向-CGI-程序传递单选按钮数据" class="headerlink" title="向 CGI 程序传递单选按钮数据"></a>向 CGI 程序传递单选按钮数据</h2><p>当只需要选择一个选项时，我们使用单选按钮。</p>
<p>下面的 HTML 代码实例是一个带有两个单选按钮的表单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/cgi-bin/cpp_radiobutton.cgi&quot;</span> </span><br><span class="line">         method=<span class="string">&quot;post&quot;</span> </span><br><span class="line">         target=<span class="string">&quot;_blank&quot;</span>&gt;&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;subject&quot;</span> value=<span class="string">&quot;maths&quot;</span> </span><br><span class="line">                                    checked=<span class="string">&quot;checked&quot;</span>/&gt; 数学 </span><br><span class="line">&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;subject&quot;</span> value=<span class="string">&quot;physics&quot;</span> /&gt; 物理&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;选择学科&quot;</span> /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc formData;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递单选按钮数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;subject&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Radio box selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向-CGI-程序传递文本区域数据"><a href="#向-CGI-程序传递文本区域数据" class="headerlink" title="向 CGI 程序传递文本区域数据"></a>向 CGI 程序传递文本区域数据</h2><p>当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。</p>
<p>下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/cgi-bin/cpp_textarea.cgi&quot; </span><br><span class="line">         method=&quot;post&quot; </span><br><span class="line">         target=&quot;_blank&quot;&gt;&lt;textarea name=&quot;textcontent&quot; cols=&quot;40&quot; rows=&quot;4&quot;&gt;请在这里输入文本...&lt;/textarea&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc formData;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递文本区域数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;textcontent&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Text Content: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;No text entered&quot;</span> &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向-CGI-程序传递下拉框数据"><a href="#向-CGI-程序传递下拉框数据" class="headerlink" title="向 CGI 程序传递下拉框数据"></a>向 CGI 程序传递下拉框数据</h2><p>当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。</p>
<p>下面的 HTML 代码实例是一个带有下拉框的表单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/cgi-bin/cpp_dropdown.cgi&quot;</span> </span><br><span class="line">                       method=<span class="string">&quot;post&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;&lt;select name=<span class="string">&quot;dropdown&quot;</span>&gt;&lt;option value=<span class="string">&quot;Maths&quot;</span> selected&gt;数学&lt;/option&gt;&lt;option value=<span class="string">&quot;Physics&quot;</span>&gt;物理&lt;/option&gt;&lt;/select&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span> using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc formData;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;向 CGI 程序传递下拉框数据&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   form_iterator fi = formData.<span class="built_in">getElement</span>(<span class="string">&quot;dropdown&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span>( !fi-&gt;<span class="built_in">isEmpty</span>() &amp;&amp; fi != (*formData).<span class="built_in">end</span>()) &#123;  </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Value Selected: &quot;</span> &lt;&lt; **fi &lt;&lt; endl;  </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-CGI-中使用-Cookies"><a href="#在-CGI-中使用-Cookies" class="headerlink" title="在 CGI 中使用 Cookies"></a>在 CGI 中使用 Cookies</h2><p>HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。</p>
<p>在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。</p>
<h3 id="它是如何工作的"><a href="#它是如何工作的" class="headerlink" title="它是如何工作的"></a>它是如何工作的</h3><p>服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。</p>
<p>cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段：</p>
<ul>
<li><strong>Expires :</strong> cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。</li>
<li><strong>Domain :</strong> 网站的域名。</li>
<li><strong>Path :</strong> 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。</li>
<li><strong>Secure :</strong> 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。</li>
<li><strong>Name&#x3D;Value :</strong> cookie 以键值对的形式被设置和获取。</li>
</ul>
<h3 id="设置-Cookies"><a href="#设置-Cookies" class="headerlink" title="设置 Cookies"></a>设置 Cookies</h3><p>向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>using namespace std;int main ()&#123;</span></span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:UserID=XYZ;\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:Password=XYZ123;\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:Domain=www.w3cschool.cc;\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Set-Cookie:Path=/perl;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;设置 cookies&quot;</span> &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>从这个实例中，我们了解了如何设置 cookies。我们使用 <strong>Set-Cookie</strong> HTTP 头来设置 cookies。</p>
<p>在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 <strong>“Content-type:text&#x2F;html\r\n\r\n</strong> 之前被设置的。</p>
<p>编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies：</p>
<p>&#x2F;cgi-bin&#x2F;setcookies.cgi</p>
<h3 id="获取-Cookies"><a href="#获取-Cookies" class="headerlink" title="获取 Cookies"></a>获取 Cookies</h3><p>检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">key1=value1;key2=value2;key3=value3....</span><br></pre></td></tr></table></figure>

<p>下面的实例演示了如何获取 cookies。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc cgi;</span><br><span class="line">   const_cookie_iterator cci;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 中的 Cookies&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;table border = \&quot;0\&quot; cellspacing = \&quot;2\&quot;&gt;&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取环境变量</span></span><br><span class="line">   <span class="type">const</span> CgiEnvironment&amp; env = cgi.<span class="built_in">getEnvironment</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>( cci = env.<span class="built_in">getCookieList</span>().<span class="built_in">begin</span>();</span><br><span class="line">        cci != env.<span class="built_in">getCookieList</span>().<span class="built_in">end</span>(); </span><br><span class="line">        ++cci )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> &lt;&lt; cci-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>;</span><br><span class="line">      cout &lt;&lt; cci-&gt;<span class="built_in">getValue</span>();                                 </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/table&gt;&lt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;br/&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies：</p>
<p>&#x2F;cgi-bin&#x2F;getcookies.cgi</p>
<p>这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl</span><br></pre></td></tr></table></figure>

<h2 id="文件上传实例"><a href="#文件上传实例" class="headerlink" title="文件上传实例"></a>文件上传实例</h2><p>为了上传一个文件，HTML 表单必须把 enctype 属性设置为 <strong>multipart&#x2F;form-data</strong>。带有文件类型的 input 标签会创建一个 “Browse” 按钮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">   &lt;form enctype=<span class="string">&quot;multipart/form-data&quot;</span> </span><br><span class="line">            action=<span class="string">&quot;/cgi-bin/cpp_uploadfile.cgi&quot;</span> </span><br><span class="line">            method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">   &lt;p&gt;文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;userfile&quot;</span> /&gt;&lt;/p&gt;</span><br><span class="line">   &lt;p&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span> /&gt;&lt;/p&gt;</span><br><span class="line">   &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码的结果是下面的表单：</p>
<p>文件：</p>
<p><strong>注意：</strong>上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。</p>
<p>下面是用于处理文件上传的脚本 <strong>cpp_uploadfile.cpp</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  #<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/CgiDefs.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/Cgicc.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTTPHTMLHeader.h&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;cgicc/HTMLClasses.h&gt;</span>using namespace std;using namespace cgicc;int main ()&#123;</span></span><br><span class="line">   Cgicc cgi;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Content-type:text/html\r\n\r\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;title&gt;CGI 中的文件上传&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取要被上传的文件列表</span></span><br><span class="line">   const_file_iterator file = cgi.<span class="built_in">getFile</span>(<span class="string">&quot;userfile&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(file != cgi.<span class="built_in">getFiles</span>().<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="comment">// 在 cout 中发送数据类型</span></span><br><span class="line">      cout &lt;&lt; <span class="built_in">HTTPContentHeader</span>(file-&gt;<span class="built_in">getDataType</span>());</span><br><span class="line">      <span class="comment">// 在 cout 中写入内容</span></span><br><span class="line">      file-&gt;<span class="built_in">writeToStream</span>(cout);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;文件上传成功&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例是在 <strong>cout</strong> 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。</p>
<h1 id="C-STL-教程"><a href="#C-STL-教程" class="headerlink" title="C++ STL 教程"></a>C++ STL 教程</h1><p>在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<p>C++ 标准模板库的核心包括以下三个组件：</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器（Containers）</td>
<td align="left">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>
</tr>
<tr>
<td align="left">算法（Algorithms）</td>
<td align="left">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>
</tr>
<tr>
<td align="left">迭代器（iterators）</td>
<td align="left">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>
</tr>
</tbody></table>
<p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。</p>
<p>下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>using namespace std;</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个向量存储 int</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec; </span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line">   <span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">      v++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector size = <span class="number">0</span>extended vector size = <span class="number">5</span>value of vec [<span class="number">0</span>] = <span class="number">0</span>value of vec [<span class="number">1</span>] = <span class="number">1</span>value of vec [<span class="number">2</span>] = <span class="number">2</span>value of vec [<span class="number">3</span>] = <span class="number">3</span>value of vec [<span class="number">4</span>] = <span class="number">4</span>value of v = <span class="number">0</span>value of v = <span class="number">1</span>value of v = <span class="number">2</span>value of v = <span class="number">3</span>value of v = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>关于上面实例中所使用的各种函数，有几点要注意：</p>
<ul>
<li>push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。</li>
<li>size( ) 函数显示向量的大小。</li>
<li>begin( ) 函数返回一个指向向量开头的迭代器。</li>
<li>end( ) 函数返回一个指向向量末尾的迭代器。</li>
</ul>
<h1 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h1><p>C++ 标准库可以分为两部分：</p>
<ul>
<li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</li>
<li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li>
</ul>
<p>C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。</p>
<h2 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h2><p>标准函数库分为以下几类：</p>
<ul>
<li>输入&#x2F;输出 I&#x2F;O</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间、日期和本地化</li>
<li>动态分配</li>
<li>其他</li>
<li>宽字符函数</li>
</ul>
<h2 id="面向对象类库"><a href="#面向对象类库" class="headerlink" title="面向对象类库"></a>面向对象类库</h2><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p>
<ul>
<li>标准的 C++ I&#x2F;O 类</li>
<li>String 类</li>
<li>数值类</li>
<li>STL 容器类</li>
<li>STL 算法</li>
<li>STL 函数对象</li>
<li>STL 迭代器</li>
<li>STL 分配器</li>
<li>本地化库</li>
<li>异常处理类</li>
<li>杂项支持库</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>来源：<a href="https://github.com/0voice/cpp_new_features">https://github.com/0voice/cpp_new_features</a></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI/ISO七层网络</title>
    <url>/2023/08/31/OSI-ISO%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp; 七层网络的常见设备，如下图所示：<br><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87.png?raw=true" alt="七层网络的常见设备"></p>
<p>&ensp;&ensp; 七层网络的常见协议与功能，如下图所示：<br><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E.gif?raw=true" alt="七层网络的常见协议与功能"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>IP数据报</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 OGNL 与  Mybatis 源代码分析一次 Mybatis 升级引发的线上事故</title>
    <url>/2023/08/31/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 项目中对 Mybatis 做了一次升级。前后版本如下，3.2.5 -&gt; 3.4.4：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/mybatis%E5%89%8D%E5%90%8E%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7.png?raw=true" alt="mybatis前后版本升级"></p>
<p>&ensp;&ensp;&ensp;&ensp; 结果第二天巡检发现如下报错，过了两个小时业务高峰期，前台业务人员不断反馈某最核心的业务无法进行：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png?raw=true" alt="报错信息"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我们当时定位到错误的地方，根据经验修改之后验证通过，重新上线之后得以解决。可能涉及敏感数据，所以不展示实际的报错与弥补方案。</p>
<p>&ensp;&ensp;&ensp;&ensp; 以下是我在本地的问题复现。在本地的一个标准的 SSM 工程中分别引入以下两个版本的 Mybatis 依赖:</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E5%88%86%E5%88%AB%E5%BC%95%E5%85%A5%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%9D%E8%B5%96.png?raw=true" alt="分别引入两个版本的依赖"></p>
<p>&ensp;&ensp;&ensp;&ensp; 编写如下数据库脚本:</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC.png?raw=true" alt="数据库脚本"></p>
<p>&ensp;&ensp;&ensp;&ensp; dao 层调用方法如下：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/dao%E5%B1%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png?raw=true" alt="dao层方法调用"></p>
<p>&ensp;&ensp;&ensp;&ensp; 当 Mybatis 依赖为 3.2.5 的较低版本时，不会报错；当 Mybatis 依赖版本为 3.4.4 的较高版本时，则会报出上面的错误:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">invalid comparision:  java.util.HashMap and java.lang.String</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 在本地问题得到复现。问题的关键在于数据库脚本中的 if 条件编译语句的这一个子句 _parameter!&#x3D;’’ 将_parameter 与 ‘’ 做比较，_parameter 是 Mybatis 的一个内置对象，你不需要知道它的作用，只需要知道他是 Map 类型的就行了，显然 ‘’ 是 String 类型的。到这里我们其实已经猜出来了，正是因为这种不规范的比较导致数据库脚本执行失败（实际上是 Mybatis 编译 SQL 失败）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 但是问题又来了，<strong>为什么 Mybatis 较低版本的时候没有问题，而较高版本则暴露出这个问题了？</strong> 我们深入源码分析一下。因为我对 Mybatis 源码比较熟悉，加上实际生产中报错的堆栈信息也很全，所以直接定位到了 Mybatis 的这个类型：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/ifnode.png?raw=true" alt="ifnode"></p>
<p>&ensp;&ensp;&ensp;&ensp; 上述代码的作用：在我们上述 SQL 脚本中，根据 if 子句的测试语句（就是 … &amp;&amp; _parameter!&#x3D;’’ 那一坨）判断，当前 if 子句所包裹的 sql 是否需要动态编译进最终的执行sql中。当我们进一步追踪，就进入到了 OGNL 的源码中，OGNL 是一套表达式解析引擎，一直定位下去就到了具体报错的方法。到这里我们补充一下版本依赖关系：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mybatis-3.2.5  -&gt;  ognl-2.6.9</span><br><span class="line">mybatis-3.4.4  -&gt;  ognl-3.1.14</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 高版本 OGNL 源码如下：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E9%AB%98%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true" alt="高版本 OGNL 代码"></p>
<p>&ensp;&ensp;&ensp;&ensp; 低版本 OGNL 源码如下：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E4%BD%8E%E7%89%88%E6%9C%ACOGNL%E4%BB%A3%E7%A0%81.png?raw=true" alt="低版本 OGNL 代码"></p>
<p>&ensp;&ensp;&ensp;&ensp; 类型标识相关的源码如下：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0.png?raw=true" alt="类型标记"></p>
<p>&ensp;&ensp;&ensp;&ensp; case 为 NONUMBERIC 的含义是当比较的值是非数值类型，所以 _parameter!&#x3D;’’ 子句的判断自然是走该分支语句的代码。t1、t2，v1、v2 的含义是两个待比值（ _parameter 和 ‘’）的类型和 value，在这个场景中分别是如下调试面板所示的（不明白的请观察为了复现问题所编写的 SQL 脚本和 dao 层语句）：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B.png?raw=true" alt="调试信息如下"></p>
<p>&ensp;&ensp;&ensp;&ensp; 解释一下：t1 &#x3D; t2 &#x3D; 10，表示 _parameter 与 ‘’ 都是非数值类型。v1 表明了 _parameter 是个 HashMap 类型的变量，有一个 (blurname,cat) 的键值对，v2 &#x3D; ‘’。另外，类的 Class 实例中有一个 isAssignableFrom 方法，这个方法是用来判断两个类的之间的关联关系，也可以说是一个类是否可以被强制转换为另外一个实例对象。</p>
<p>&ensp;&ensp;&ensp;&ensp; 至此所需信息全部已经准备完毕，我们可以来分析高低版本 OGNL 的源码了。高版本 OGNL 中，我们直接看 case:NONUMBERIC 的分支子句。代码含义为：</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 V1 是 Comparable 类型的并且 V1 可以强转为 V2 的类型，则进入 if 分支，否则进入 else 分支，而 else 分支直接报错，而且报错信息是我们实际生产环境中遇到的。显然，V1 既不是 Comparable 类型，也无法转换为 V2 的类型（HashMap -&gt; String），所以进入了 else 分支，mybatis 升级之后携带 OGNL 的升级，数据库不规范的写法导致 mybatis 编译 sql 语句报错，阻塞了业务</strong></p>
<p>&ensp;&ensp;&ensp;&ensp; 低版本的 OGNL 的 case:NONUMBERIC 的分支子句的代码逻辑说实话非常拧巴，含义是：</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>如果 v1、v2 任一变量为 null，则进入 if 分支，显然不会进入。else 先判断v1、v2 是否能互转，显然不能，直接跳过。接下来是重中之重：如果 equals 为 true ,跳出 case，否则报错。我们根据结果看，equals 必定为 true，因为我们那种不规范的 mybatis 在这个地方，它每没报错——事实上是应该将该问题抛出来的，从而引导开发者更正 mybatis 脚本。接下来我们看方法外面这个 equals 的来源：</strong></p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BA%8B%E6%95%85%E5%A4%8D%E7%9B%98/%E4%B8%80%E6%AC%A1Mybatis%E5%8D%87%E7%BA%A7%E5%BC%95%E5%8F%91%E7%9A%84%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/equals.png?raw=true" alt="equals"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我惊呆了，直接写死传经来的，至于这个 equals 意欲何为，当初作者为什么这么写，也许只有作者自己知道。反正高版本的 OGNL 已经将这部分的代码逻辑全部重构了。</p>
<p>&ensp;&ensp;&ensp;&ensp; 我们可以得到如下结论： _<em>低版本的 mybatis 依赖了低版本的 OGNL ，低版本的 OGNL 在上述分析的函数中存在一定缺陷，这个缺陷会导致我们在编写 Mybatis 脚本的时候类似于 <em>parameter!&#x3D;’’ 的不规范写法不被发现。当我们升级了 Mybatis 之后，这种不规范的写法反而兜不住暴露出来了，加上组件升级测试不充分，直接上到了生产环境。</em></em></p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>反思：</strong></p>
<ul>
<li><strong>日常开发要严格要求自己，追求正规、大气的编程素养，每一行代码，每一个字符，都要过大脑，不要太随便，不要随便复制粘贴能跑就行。</strong></li>
<li><strong>组件升级要慎之又慎，测试要充分。</strong></li>
</ul>
]]></content>
      <categories>
        <category>工程</category>
        <category>问题记录与事故复盘</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>问题记录</tag>
        <tag>线上事故</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>GPM模型</title>
    <url>/2023/08/29/GPM%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Go</category>
        <category>GPM</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Go</tag>
        <tag>GPM</tag>
      </tags>
  </entry>
  <entry>
    <title>GC-全流程</title>
    <url>/2023/08/29/GC%E2%80%94%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、minorGC-和-Full-GC-区别"><a href="#1、minorGC-和-Full-GC-区别" class="headerlink" title="1、minorGC 和 Full GC 区别"></a><strong>1、minorGC 和 Full GC 区别</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 新生代 GC（Minor GC）：指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p>
<p>&ensp;&ensp;&ensp;&ensp; 老年代 GC（Major GC&#x2F;Full GC）：指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</p>
<h4 id="2、minorGC-过程详解"><a href="#2、minorGC-过程详解" class="headerlink" title="2、minorGC 过程详解"></a><strong>2、minorGC 过程详解</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在初始阶段，新创建的对象被分配到 Eden 区，Survivor 的两块空间都为空。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B1.png?raw=true" alt="图一"></p>
<p>&ensp;&ensp;&ensp;&ensp; 当Eden区满了的时候，minor garbage 被触发。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B2.png?raw=true" alt="图二"></p>
<p>&ensp;&ensp;&ensp;&ensp; 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B3.png?raw=true" alt="图三"></p>
<p>&ensp;&ensp;&ensp;&ensp; 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 Survivor区。当 Eden 和 s0区空间满了，S0 的所有的数据都被复制到S1，需要注意的是，在上次 Minor GC 过程中移动到S0 中的两个对象在复制到 S1 后其年龄要加1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象，过程如下图所示：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B4.png?raw=true" alt="图四"></p>
<p>&ensp;&ensp;&ensp;&ensp; 再下一次 Minor GC 则重复这个过程，这一次 Survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加1，Eden 区和另一个 Survivor 区被清空。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B5.png?raw=true" alt="图五"></p>
<p>&ensp;&ensp;&ensp;&ensp; 再经过几次 Minor GC 之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold 默认是15），就会被从年轻代 Promotion 到老年代。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B6.png?raw=true" alt="图六"></p>
<p>&ensp;&ensp;&ensp;&ensp; 随着 MinorGC 一次又一次的进行，不断会有新的对象被 Promote 到老年代。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B7.png?raw=true" alt="图七"></p>
<p>&ensp;&ensp;&ensp;&ensp; 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记-整理)。从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p>
<p>&ensp;&ensp;&ensp;&ensp; 老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次 Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行 MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（ 这代表着如果设置-<br>XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>
<h4 id="3、整体描述"><a href="#3、整体描述" class="headerlink" title="3、整体描述"></a><strong>3、整体描述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1( Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次 GC 后，Eden 区和 From 区已经被清空。这个时候，From 和 To 会交换他们的角色，也就是新的 To 就是上次 GC 前的 From ，新的 From 就是上次 GC 前的 To。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到 To 区被填满，To 区被填满之后，会将所有对象移动到年老代中。</p>
<h4 id="4、GC-触发条件"><a href="#4、GC-触发条件" class="headerlink" title="4、GC 触发条件"></a><strong>4、GC 触发条件</strong></h4><p>&ensp;&ensp;&ensp;&ensp; Minor GC 触发条件：Eden 区满时。Full GC 触发条件：</p>
<ul>
<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；</li>
<li>老年代空间不足；</li>
<li>方法去空间不足；</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存；</li>
<li>由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>
</ul>
<h4 id="5、对象进入老年代的四种情况"><a href="#5、对象进入老年代的四种情况" class="headerlink" title="5、对象进入老年代的四种情况"></a><strong>5、对象进入老年代的四种情况</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 假如进行Minor GC时发现，存活的对象在ToSpace区中存不下，那么把存活的对象存入老年代。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B8.png?raw=true" alt="图八"></p>
<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代：假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B9.png?raw=true" alt="图九"></p>
<p>&ensp;&ensp;&ensp;&ensp; 长期存活的对象将进入老年代：此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>
<p>&ensp;&ensp;&ensp;&ensp; 动态对象年龄判定：还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC-%E5%85%A8%E6%B5%81%E7%A8%8B/GC%E5%85%A8%E6%B5%81%E7%A8%8B10.png?raw=true" alt="图十"></p>
<h4 id="6、空间分配担保"><a href="#6、空间分配担保" class="headerlink" title="6、空间分配担保"></a><strong>6、空间分配担保</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlerPromotionFailure 这个参数设置的值（ true 或 flase ）是否允许担保失败（如果这个值为 true，代表着 JVM 说，我允许在这种条件下尝试执行 Minor GC，出了事我负责）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC。如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么 HandlerPromotionFailure 为 true 的情况下，可以尝试进行一次 Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么 Minor GC 还是无法执行，此时还得改为 Full GC。</p>
<p>&ensp;&ensp;&ensp;&ensp; 注意：JDK 6Update 24 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大 小就会进行 Minor GC，否则进行 Full GC。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S架构图</title>
    <url>/2023/08/29/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/K8S/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE/K8S%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt="K8S架构图"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>云计算领域</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>本地调试Docker源码</title>
    <url>/2023/08/29/%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95Docker%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>工程</category>
        <category>云计算</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>云计算领域</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt简介</title>
    <url>/2023/08/29/Qt%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>工程</category>
        <category>Qt 开发</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>桌面开发</tag>
      </tags>
  </entry>
  <entry>
    <title>IP数据报</title>
    <url>/2023/08/29/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; IP 协议控制传输的协议单元称为 IP 数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。lP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明lP协议具有什么功能。IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png?raw=true" alt="IP报文结构"></p>
<h4 id="1、固定部分"><a href="#1、固定部分" class="headerlink" title="1、固定部分"></a><strong>1、固定部分</strong></h4><ul>
<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。广泛使用的 IP 协议版本号为 4（即 IPv4）。关于 IPv6，还处于草案阶段。</li>
<li>首部长度：占 4 位，可表示的最大十进制数值是 15。请注意，这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节），因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>
<li>区分服务：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务DS(Differentiated Services)。只有在使用区分服务时，这个字段才起作用。</li>
<li>总长度：总长度指首部和数据之和的长度，单位为字节。总长度字长为 16 位，因此数据报的最大长度为 2^16-1&#x3D;65535 字节。在 IP 层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元 MTU（Maximum Transfer Unit）。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的 MTU 值。</li>
<li>标识：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>
<li>标志：占 3 位，但只有 2 位有意义。标志字段中的最低位记为 MF（More Fragment）。MF&#x3D;1 即表示后面“还有分片”的数据报。MF&#x3D;0 表示这已是若干数据报片中的最后一个。标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF&#x3D;0 时才允许分片。</li>
<li>片偏移：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对用户数据字段的起点，该片从何处开始。片偏移以 8  个字节为偏移单位。这就是说，除了最后一个分片，每个分片的长度一定是 8 字节（64 位）的整数倍。</li>
<li>生存时间：占 8 位，生存时间字段常用的的英文缩写是 TTL（Time To Live），表明是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在因特网中兜圈子，因而白白消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值为 0 时，就丢弃这个数据报。后来把 TTL 字段的功能改为“跳数限制”（但名称不变）。路由器在转发数据报之前就把 TTL 值减 1。若 TTL 值减少到零，就丢弃这个数据报，不再转发。因此，TTL 的单位不再是秒，而是跳数。TTL 的意义是指明数据报在网络中至多可经过多少个路由器。显然，数据报在网络上经过的路由器的最大数值是 255。若把 TTL 的初始值设为 1，就表示这个数据报只能在本局域网中传送。</li>
<li>协议：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。6 指 TCP 协议，17 指的是 UDP 协议。</li>
<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>
<li>源地址和目的地址：32位，IPV4 地址。</li>
</ul>
<h4 id="2、可变部分"><a href="#2、可变部分" class="headerlink" title="2、可变部分"></a><strong>2、可变部分</strong></h4><p>&ensp;&ensp;&ensp;&ensp; IP 首部的可变部分就是一个可选字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的 IP 版本 IPv6 就将 IP 数据报的首部长度做成固定的。这些任选项定义如下：</p>
<ul>
<li>安全和处理限制（用于军事领域）。</li>
<li>记录路径（让每个路由器都记下它的IP地址）。</li>
<li>时间戳（Time Stamp）（让每个路由器都记下IP数据报经过每一个路由器的IP地址和当地时间）。</li>
<li>宽松的源站路由（Loose Source Route）（为数据报指定一系列必须经过的IP地址）。</li>
<li>严格的源站路由（Strict Source Route）（与宽松的源站路由类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 这些选项很少被使用，并非所有主机和路由器都支持这些选项。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>IP数据报</tag>
      </tags>
  </entry>
  <entry>
    <title>Innodb中的事务隔离级别和锁实现</title>
    <url>/2023/08/29/Innodb%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring全景</title>
    <url>/2023/08/29/Spring%E5%85%A8%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Spring/Spring%E5%85%A8%E6%99%AF/Spring%E5%85%A8%E6%99%AF.png?raw=true" alt="Spring 全景图"></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java EE</tag>
      </tags>
  </entry>
  <entry>
    <title>保持敬畏之心</title>
    <url>/2023/08/29/%E4%BF%9D%E6%8C%81%E6%95%AC%E7%95%8F%E4%B9%8B%E5%BF%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; 世界何其广大，能人异士很多。 搞清楚自己的能力边界很重要。对未知或者模糊不清的事物保持敬畏之心，不鲁莽下结论， 避免盲目自负也很重要。</p>
]]></content>
      <categories>
        <category>思考</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行常用指令</title>
    <url>/2023/08/29/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp; MySQL 创建数据库并指定字符集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop schema if exists `test`;</span><br><span class="line">CREATE DATABASE `test` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; Brew 相关的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 先卸载Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br><span class="line">// 然后在安装</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">// 搜索包</span><br><span class="line">brew search mysql</span><br><span class="line">// 安装包</span><br><span class="line">brew install mysql</span><br><span class="line">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span><br><span class="line">brew info mysql</span><br><span class="line">// 卸载包</span><br><span class="line">brew uninstall wget</span><br><span class="line">// 显示已安装的包</span><br><span class="line">brew list</span><br><span class="line">// 查看brew的帮助</span><br><span class="line">brew –help</span><br><span class="line">// 更新， 这会更新 Homebrew 自己</span><br><span class="line">brew update</span><br><span class="line">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span><br><span class="line">brew outdated</span><br><span class="line">brew outdated mysql</span><br><span class="line">// 升级所有可以升级的软件们</span><br><span class="line">brew upgrade</span><br><span class="line">brew upgrade mysql</span><br><span class="line">// 清理不需要的版本极其安装包缓存</span><br><span class="line">brew cleanup</span><br><span class="line">brew cleanup mysql</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp; MySQL 源码构建参数(将目录修改为你自己的)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-DCMAKE_BUILD_TYPE=Debug</span><br><span class="line">-DWITH_BOOST=/Users/setsunayang/Documents/learning/mysql/boost_1_77_0</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/Users/setsunayang/Documents/learning/mysql/build</span><br><span class="line">-DWITH_SSL=system</span><br><span class="line"></span><br><span class="line">./mysqld --basedir=/Users/setsunayang/Documents/learning/mysql/build \</span><br><span class="line">--datadir=/Users/setsunayang/Documents/learning/mysql/build/data \</span><br><span class="line">--initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; Git重新关联远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm origin </span><br><span class="line">git remote add origin [url]</span><br><span class="line">git config --global user.name &quot;杨海波&quot;</span><br><span class="line">git config --global user.email “3546514206@QQ.COM&quot;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; 设置主机名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo scutil --set HostName SetsunaYang</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp; Macbook Pro 显示被隐藏的文件或文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder </span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder</span><br><span class="line"></span><br><span class="line">chflags hidden </span><br><span class="line">chflags nohidden</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat启动流程</title>
    <url>/2023/08/29/Tomcat%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>工程</category>
        <category>服务端</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Java EE</tag>
        <tag>Tomcat</tag>
        <tag>Java Web</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序内存分区</title>
    <url>/2023/08/29/C-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>代码区：</strong> 程序被操作系统加载到内存时，所有可执⾏的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运⾏时，代码区是共享只读的。</p>
<p><strong>静态区：</strong> 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在⼀块区域）。代码执⾏期间⼀直占⽤内存！</p>
<p><strong>堆：</strong> 堆是不连续的内存区域，获得的空间⽐较灵活，也⽐较⼤，⼀般速度⽐较慢，⽽且容易产⽣内存碎⽚,不过⽤起来最⽅便。需要程序员申请的内存空间，空间的释放⼀般由程序员控制(⽐如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运⾏完毕时操作系统会对该内存空间进⾏回收。</p>
<p><strong>栈：</strong> 栈是⼀块连续的内存的区域，⼀般栈的⼤⼩都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提⽰overflow。存放的通常是变量通常是局部变量、函数参数等。</p>
<p><strong>常量区：</strong> 常量字符串就是放在这⾥的。 程序结束后由系统释放。</p>
<p><strong>BSS段：</strong> 定义⽽没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和⼤⼩，相当于⼀个占位符。⼀个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss ⾥⾯装载了未被初始化的数据。如图：</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++/C++%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?raw=true" alt="C++ 内存分区"></p>
<p>&ensp;&ensp;&ensp;&ensp; ⽰例代码及注释如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区（静态区）</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//全局未初始化区 （BSS段）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈 6 char s[] = &quot;abc&quot;; //栈 7 char *p2; //栈 8 char *p3 = &quot;123456&quot;; //123456/0在常量区，p3在栈上。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">//全局（静态）初始化区 （静态区）</span></span><br><span class="line">    p1 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">//分配得10和20字节的区域就在堆区。</span></span><br><span class="line">    <span class="comment">// p2 = (char *) malloc(20);</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成⼀块。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>回调机制</title>
    <url>/2023/08/29/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、C语言中的回调"><a href="#1、C语言中的回调" class="headerlink" title="1、C语言中的回调"></a><strong>1、C语言中的回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数 组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参 数。函数指针变量的声明： typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型 以下实例声明了函数指针变量 p，指向函数 max：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp;max; <span class="comment">// &amp;可以省略 </span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = <span class="built_in">p</span>(<span class="built_in">p</span>(a, b), c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 输出的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入三个数字:1 2 3 </span><br><span class="line">最大的数字是: 3</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp; 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用 的函数。下面的实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指 针，通过该函数来设置数组的值。实例中我们定义了回调函数 getNextRandomValue，它返 回一个随机值，它作为一个函数指针传递给 populate_array 函数。populate_array 将调 用 10 次回调函数，并将回调函数的返回值赋值给数组。编译执行，输出结果如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure>

<h4 id="2、什么是回调"><a href="#2、什么是回调" class="headerlink" title="2、什么是回调"></a><strong>2、什么是回调</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调 用、回调和异步调用。回调是一种双向调用的模式，也就是说，被调用方在接口被调用时也 会调用对方的接口。 </p>
<p>&ensp;&ensp;&ensp;&ensp; 同步调用：一种阻塞式调用，调用方要等待对方执行完毕才能返回，它是一种单向调 用。</p>
<p>&ensp;&ensp;&ensp;&ensp; 回调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 </p>
<p>&ensp;&ensp;&ensp;&ensp; 异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收 到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。 回调和异步调用的关系非常紧密：通常可以使用回调来实现异步消息的注册，通过异步 调用来实现消息的通知。</p>
<p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6.jpg?raw=true" alt="程序调用的几种方式"></p>
<p>&ensp;&ensp;&ensp;&ensp; 回调机制的实现通常需要实现一个回调函数，回调函数，顾名思义，用于回调的函数。回调函数只是一个功能片段，由用户按照回调函数调用约定来实现的一个函数。回调函数是一个工作流的一部分，由工作流来决定函数的调用（回调）时机。回调函数包含下面几个特性：</p>
<ul>
<li><p>属于工作流的一个部分； </p>
</li>
<li><p>必须按照工作流指定的调用约定来申明（定义）； </p>
</li>
<li><p>他的调用时机由工作流决定，回调函数的实现者不能直接调用回调 函数来实现工作流的功能。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>编程理论</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title>GC—基础知识</title>
    <url>/2023/08/28/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp; JVM 的 GC 是指垃圾回收，主要是对堆内存的回收。本文将介绍 JVM 中一次完整的 GC 流程是怎样<br>的，首先抛出第一个问题，什么样的对象会是 JVM 回收的目标？</p>
<h4 id="1、可达性分析算法（GC-Roots）"><a href="#1、可达性分析算法（GC-Roots）" class="headerlink" title="1、可达性分析算法（GC Roots）"></a><strong>1、可达性分析算法（GC Roots）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 有一种引用计数法，可以用来判断对象被引用的次数，如果引用次数为0，则代表可以被回收。这种实现<br>方式比较简单，但对于循环引用的情况束手无策，所以 Java 采用了可达性分析算法。即判断某个对象是否与 GC Roots 的这类对象之<br>间的路径可达，若不可达，则有可能成为回收对象，被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标<br>记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在 Java 中，可作为 GC Roots 的对象包括以下<br>几种：</p>
<ul>
<li>虚拟机栈（本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ul>
<h4 id="2、JVM中的堆结构"><a href="#2、JVM中的堆结构" class="headerlink" title="2、JVM中的堆结构"></a><strong>2、JVM中的堆结构</strong></h4><p>&ensp;&ensp;&ensp;&ensp; JVM 中的堆可划分为两大部分，新生代和老年代，大小比例为1:2，如下：<br><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A0%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86%E6%AF%94%E4%BE%8B.png?raw=true" alt="JVM 分代比例"></p>
<p>&ensp;&ensp;&ensp;&ensp; 其中，新生代分为 Eden 区和 Survivor 区， Survivor 幸存者区又分为大小相等的两块 from 和 to<br>区。这便是 JVM 中堆的结构和各部分默认的比例，当然这些比例都可通过对应 JVM 参数来调整。完整的 JMM 如下：<br><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Java/JVM/GC%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JVM%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt="JVM 内存模型全景"></p>
<h4 id="2-1、为何新生代要分为三个区"><a href="#2-1、为何新生代要分为三个区" class="headerlink" title="2.1、为何新生代要分为三个区"></a><strong>2.1、为何新生代要分为三个区</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 这里需要介绍新生代的垃圾回收算法——复制算法。该算法的核心是将可用内存按容量划分为大小<br>相等的两块，每次回收周期只用其中一块，当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已使用过的内存空间清理掉。</p>
<p>&ensp;&ensp;&ensp;&ensp; 优点：不必考虑内存碎片问题；效率高。</p>
<p>&ensp;&ensp;&ensp;&ensp; 缺点：可用容量减少为原来的一半，比较浪费。</p>
<p>&ensp;&ensp;&ensp;&ensp; 最优设置：根据权威数据分析，90%的对象都是朝生夕死的，所以采用10%的空间用作交换区，因为交换区必须要有等量的两个，所以采用复制算法中新生代中三个区默认分配比例为8:1:1。</p>
<h4 id="2-2、新生代对象的分配和回收"><a href="#2-2、新生代对象的分配和回收" class="headerlink" title="2.2、新生代对象的分配和回收"></a><strong>2.2、新生代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 基本上新的对象优先在 Eden 区分配；</p>
<p>&ensp;&ensp;&ensp;&ensp; 当 Eden 区没有足够空间时，会发起一次 Minor GC；</p>
<p>&ensp;&ensp;&ensp;&ensp; Minor GC 回收新生代采用复制回收算法的改进版本。即：<br>from 区和 to 区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例（-XX:SurvivorRatio默认为8，代表 Eden 区与 Survivor 区的大小比例）</p>
<h4 id="2-3、老年代对象的分配和回收"><a href="#2-3、老年代对象的分配和回收" class="headerlink" title="2.3、老年代对象的分配和回收"></a><strong>2.3、老年代对象的分配和回收</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 老年代的对象一般来自于新生代中的长期存活对象。这里有一概念叫做年龄阈值，每个对象定义了年龄计数器，经<br>过一次 Minor GC （在交换区）后年龄加1，对象年龄达到15次后将会晋升到老年代，老年代空间不够时进行 Full GC。当然这个参数仍是可以通过 JVM 参数（-XX:MaxTenuringThreshold，默认15）来调整。</p>
<p>&ensp;&ensp;&ensp;&ensp; 大对象直接进入老年代。即超过 Eden 区空间，或超过一个参数值（-<br>XX:PretenureSizeThreshold&#x3D;30m，无默认值）。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<p>&ensp;&ensp;&ensp;&ensp; 对象提前晋升到老年代（组团）。动态年龄判定：如果在 Survivor 区中相同年龄所有对象大小总和<br>大于 Survivor 区大小的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到自己<br>的晋升年龄。</p>
<h4 id="3、JVM完整的GC流程"><a href="#3、JVM完整的GC流程" class="headerlink" title="3、JVM完整的GC流程"></a><strong>3、JVM完整的GC流程</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 对象的正常流程：Eden 区 -&gt; Survivor 区 -&gt; 老年代。</p>
<p>&ensp;&ensp;&ensp;&ensp; 新生代GC：Minor GC；老年代GC：Full GC，比 Minor GC 慢10倍，JVM 会“stop the world”，严重<br>影响性能。</p>
<p>&ensp;&ensp;&ensp;&ensp; 总结：内存区域不够用了，就会引发GC。Minor GC 避免不了，Full GC 尽量避免。<br>处理方式：保存堆栈快照日志、分析内存泄漏、调整内存设置控制垃圾回收频率，选择合适的垃圾<br>回收器等。</p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>编程基础</category>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>内核页表设计</title>
    <url>/2023/08/28/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E8%AE%BE%E8%AE%A1.png?raw=true" alt="内核页表设计"></p>
]]></content>
      <categories>
        <category>基本功</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
