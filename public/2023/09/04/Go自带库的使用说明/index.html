<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Go自带库的使用说明 |  杨海波（勤奋的全栈开发工程师）</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/SETSUNAYANG.JPG" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Go自带库的使用说明"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Go自带库的使用说明
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/Go%E8%87%AA%E5%B8%A6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" class="article-date">
  <time datetime="2023-09-03T16:24:13.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">19.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">85 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Go-中的时间操作"><a href="#Go-中的时间操作" class="headerlink" title="Go 中的时间操作"></a>Go 中的时间操作</h1><p>Golang中与时间有关的操作，主要涉及到 time 包，核心数据结构是 <code>time.Time</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    wall <span class="type">uint64</span></span><br><span class="line">    ext  <span class="type">int64</span></span><br><span class="line">    loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、获取时间相关函数"><a href="#1、获取时间相关函数" class="headerlink" title="1、获取时间相关函数"></a>1、获取时间相关函数</h3><h4 id="1-1-获取当前时间"><a href="#1-1-获取当前时间" class="headerlink" title="1.1 获取当前时间"></a>1.1 获取当前时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间，注意此时返回的是 time.Time 类型</span></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 当前时间戳</span></span><br><span class="line">fmt.Println(now.Unix())</span><br><span class="line"><span class="comment">// 纳秒级时间戳</span></span><br><span class="line">fmt.Println(now.UnixNano())</span><br><span class="line"><span class="comment">// 时间戳小数部分 单位：纳秒</span></span><br><span class="line">fmt.Println(now.Nanosecond())</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">15.930562</span> +<span class="number">0800</span> CST m=+<span class="number">0.000124449</span></span><br><span class="line"><span class="number">1610261775</span></span><br><span class="line"><span class="number">1610261775930562000</span></span><br><span class="line"><span class="number">930562000</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-返回当前年月日时分秒、星期几、一年中的第几天等操作"><a href="#1-2-返回当前年月日时分秒、星期几、一年中的第几天等操作" class="headerlink" title="1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作"></a>1.2 返回当前年月日时分秒、星期几、一年中的第几天等操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 返回日期</span></span><br><span class="line">year, month, day := now.Date()</span><br><span class="line">fmt.Printf(<span class="string">&quot;year:%d, month:%d, day:%d\n&quot;</span>, year, month, day)</span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line">fmt.Println(now.Year())</span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line">fmt.Println(now.Month())</span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line">fmt.Println(now.Day())</span><br><span class="line"><span class="comment">// 时分秒</span></span><br><span class="line">hour, minute, second := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;hour:%d, minute:%d, second:%d\n&quot;</span>, hour, minute, second)</span><br><span class="line"><span class="comment">// 时</span></span><br><span class="line">fmt.Println(now.Hour())</span><br><span class="line"><span class="comment">// 分</span></span><br><span class="line">fmt.Println(now.Minute())</span><br><span class="line"><span class="comment">// 秒</span></span><br><span class="line">fmt.Println(now.Second())</span><br><span class="line"><span class="comment">// 返回星期</span></span><br><span class="line">fmt.Println(now.Weekday())</span><br><span class="line"><span class="comment">//返回一年中对应的第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br><span class="line"><span class="comment">//返回时区</span></span><br><span class="line">fmt.Println(now.Location())</span><br><span class="line"><span class="comment">// 返回一年中第几天</span></span><br><span class="line">fmt.Println(now.YearDay())</span><br></pre></td></tr></table></figure>

<h4 id="1-3-格式化时间"><a href="#1-3-格式化时间" class="headerlink" title="1.3 格式化时间"></a>1.3 格式化时间</h4><p>Go 语言提供了时间类型格式化函数 <code>Format()</code>，需要注意的是 Go 语言格式化时间模板不是常见的 <code>Y-m-d H:i:s</code>，而是 2006-01-02 15:04:05，也很好记忆(2006 1 2 3 4 5)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2、时间戳与日期字符串相互转化"><a href="#2、时间戳与日期字符串相互转化" class="headerlink" title="2、时间戳与日期字符串相互转化"></a>2、时间戳与日期字符串相互转化</h3><p>时间戳转成日期格式，需要先转成将时间戳转成 <code>time.Time</code> 类型再格式化成日期格式。</p>
<h4 id="2-1-根据秒数、纳秒数返回-time-Time-类型"><a href="#2-1-根据秒数、纳秒数返回-time-Time-类型" class="headerlink" title="2.1 根据秒数、纳秒数返回 time.Time 类型"></a>2.1 根据秒数、纳秒数返回 <code>time.Time</code> 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">t := time.Unix(now.Unix(),<span class="number">0</span>)    <span class="comment">// 参数分别是：秒数,纳秒数</span></span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<h4 id="2-2-根据指定时间返回-time-Time-类型，使用函数-time-Date"><a href="#2-2-根据指定时间返回-time-Time-类型，使用函数-time-Date" class="headerlink" title="2.2 根据指定时间返回 time.Time 类型，使用函数 time.Date()"></a>2.2 根据指定时间返回 <code>time.Time</code> 类型，使用函数 <code>time.Date()</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">layout := <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"><span class="comment">//根据指定时间返回 time.Time 类型</span></span><br><span class="line"><span class="comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span></span><br><span class="line">t := time.Date(<span class="number">2011</span>, time.Month(<span class="number">3</span>), <span class="number">12</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">0</span>, now.Location())</span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<h4 id="2-3-日期字符串解析成-time-Time-类型"><a href="#2-3-日期字符串解析成-time-Time-类型" class="headerlink" title="2.3 日期字符串解析成 time.Time 类型"></a>2.3 日期字符串解析成 <code>time.Time</code> 类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>), time.Local)</span><br><span class="line">fmt.Println(t)  </span><br><span class="line"><span class="comment">// 输出 2021-01-10 17:28:50 +0800 CST</span></span><br><span class="line"><span class="comment">// time.Local 指定本地时间</span></span><br></pre></td></tr></table></figure>

<p>解析的时候需要特别注意时区的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Now())</span><br><span class="line">fmt.Println(time.Now().Location())</span><br><span class="line">t, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2021-01-10 15:01:02&quot;</span>)</span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-01-10 17:22:10.951904 +0800 CST m=+0.000094166</span><br><span class="line">Local</span><br><span class="line">2021-01-10 15:01:02 +0000 UTC</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>time.Now()</code> 使用的 CST(中国标准时间)，而 <code>time.Parse()</code> 默认的是 UTC(零时区)，它们相差 8 小时。所以解析时常用 <code>time.ParseInLocation()</code>，可以指定时区。<img src="https://cdn.nlark.com/yuque/0/2021/gif/396745/1610587943191-e1905a90-4157-43d7-8623-c98b46969a36.gif" alt="img"></p>
<h3 id="3、计算、比较日期"><a href="#3、计算、比较日期" class="headerlink" title="3、计算、比较日期"></a>3、计算、比较日期</h3><p>讲到日期的计算就不得不提 time 包提供的一种新的类型 <code>Duration</code>，源码是这样定义的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="type">int64</span></span><br></pre></td></tr></table></figure>

<p>底层类型是 int64，表示一段时间间隔，单位是 纳秒。</p>
<h4 id="3-1-24小时之内的时间计算"><a href="#3-1-24小时之内的时间计算" class="headerlink" title="3.1 24小时之内的时间计算"></a>3.1 24小时之内的时间计算</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 1小时1分1s之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;1h1m1s&quot;</span>)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"><span class="comment">// 1小时1分1s之前</span></span><br><span class="line">t2, _ := time.ParseDuration(<span class="string">&quot;-1h1m1s&quot;</span>)</span><br><span class="line">m2 := now.Add(t2)</span><br><span class="line">fmt.Println(m2)</span><br><span class="line"><span class="comment">// 3小时之前</span></span><br><span class="line">t3, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">m3 := now.Add(t3 * <span class="number">3</span>)</span><br><span class="line">fmt.Println(m3)</span><br><span class="line"><span class="comment">// 10 分钟之后</span></span><br><span class="line">t4, _ := time.ParseDuration(<span class="string">&quot;10m&quot;</span>)</span><br><span class="line">m4 := now.Add(t4)</span><br><span class="line">fmt.Println(m4)</span><br><span class="line"><span class="comment">// Sub 计算两个时间差</span></span><br><span class="line">sub1 := now.Sub(m3)</span><br><span class="line">fmt.Println(sub1.Hours())   <span class="comment">// 相差小时数</span></span><br><span class="line">fmt.Println(sub1.Minutes()) <span class="comment">// 相差分钟数</span></span><br></pre></td></tr></table></figure>

<p>额外再介绍两个函数 <code>time.Since()</code>、<code>time.Until()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间与 t 的时间差，返回值是 Duration</span></span><br><span class="line">time.Since(t Time) Duration</span><br><span class="line"><span class="comment">// 返回 t 与当前时间的时间差，返回值是 Duration</span></span><br><span class="line">time.Until(t Time) Duration</span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line">fmt.Println(time.Since(m1))</span><br><span class="line">fmt.Println(time.Until(m1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-01-10 20:41:48.668232 +0800 CST m=+0.000095594</span><br><span class="line">2021-01-10 19:41:48.668232 +0800 CST m=-3599.999904406</span><br><span class="line">1h0m0.000199007s</span><br><span class="line">-1h0m0.000203035s</span><br></pre></td></tr></table></figure>

<h4 id="3-2-24小时之外的时间计算"><a href="#3-2-24小时之外的时间计算" class="headerlink" title="3.2 24小时之外的时间计算"></a>3.2 24小时之外的时间计算</h4><p>涉及到一天以外的时间计算，就需要用到 <code>time.AddDate()</code>，函数原型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> AddDate(years <span class="type">int</span>, months <span class="type">int</span>, days <span class="type">int</span>) Time</span><br></pre></td></tr></table></figure>

<p>比如想知道 一年一个月零一天 之后的时间，就可以这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></table></figure>

<p>再比如，想获得 2 天之前时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line">m1 := now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-2</span>)</span><br><span class="line">fmt.Println(m1)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-日期比较"><a href="#3-3-日期比较" class="headerlink" title="3.3 日期比较"></a>3.3 日期比较</h4><p>日期的比较总共有三种：之前、之后和相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之前，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br><span class="line"><span class="comment">// 如果 t 代表的时间点在 u 之后，返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br><span class="line"><span class="comment">// 比较时间是否相等，相等返回真；否则返回假。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 1小时之后</span></span><br><span class="line">t1, _ := time.ParseDuration(<span class="string">&quot;1h&quot;</span>)</span><br><span class="line">m1 := now.Add(t1)</span><br><span class="line">fmt.Println(m1)</span><br><span class="line">fmt.Println(m1.After(now))</span><br><span class="line">fmt.Println(now.Before(m1))</span><br><span class="line">fmt.Println(now.Equal(m1))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2021-01-10 21:00:44.409785 +0800 CST m=+0.000186800</span><br><span class="line">2021-01-10 22:00:44.409785 +0800 CST m=+3600.000186800</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="4、常见例子"><a href="#4、常见例子" class="headerlink" title="4、常见例子"></a>4、常见例子</h3><p>下面列举一些常见的例子和函数封装。</p>
<h4 id="4-1-日期格式-转-时间戳"><a href="#4-1-日期格式-转-时间戳" class="headerlink" title="4.1 日期格式 转 时间戳"></a>4.1 日期格式 转 时间戳</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeStr2Time</span><span class="params">(fmtStr,valueStr, locStr <span class="type">string</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    loc := time.Local</span><br><span class="line">    <span class="keyword">if</span> locStr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        loc, _ = time.LoadLocation(locStr) <span class="comment">// 设置时区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    t, _ := time.ParseInLocation(fmtStr, valueStr, loc)</span><br><span class="line">    <span class="keyword">return</span> t.Unix()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-获取当前时间日期格式"><a href="#4-2-获取当前时间日期格式" class="headerlink" title="4.2 获取当前时间日期格式"></a>4.2 获取当前时间日期格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentFormatStr</span><span class="params">(fmtStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Now().Format(fmtStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-时间戳-to-日期格式"><a href="#4-3-时间戳-to-日期格式" class="headerlink" title="4.3 时间戳 to 日期格式"></a>4.3 时间戳 to 日期格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sec2TimeStr</span><span class="params">(sec <span class="type">int64</span>, fmtStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fmtStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmtStr = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time.Unix(sec, <span class="number">0</span>).Format(fmtStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go-regexp正则"><a href="#Go-regexp正则" class="headerlink" title="Go-regexp正则"></a>Go-regexp正则</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;My email is ccmouse@gmail.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	compile := regexp.MustCompile(<span class="string">`[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+`</span>)</span><br><span class="line">	match := compile.FindString(text)</span><br><span class="line">	fmt.Println(match)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go存储基础-—-文件-IO-操作"><a href="#Go存储基础-—-文件-IO-操作" class="headerlink" title="Go存储基础 — 文件 IO 操作"></a>Go存储基础 — 文件 IO 操作</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059277-22fc4174-ea19-40a1-96a9-dc837804eaff.png" alt="img"></p>
<h2 id="两大-IO-分类"><a href="#两大-IO-分类" class="headerlink" title="两大 IO 分类"></a>两大 IO 分类</h2><p>计算的体系架构，CPU，内存，网络，IO。那么 IO 是什么呢？一般理解成 Input、Output 的缩写，通俗话就是输入输出的意思。</p>
<p>IO 分为网络和存储 IO 两种类型（<strong>其实网络 IO 和磁盘 IO 在 Go 里面有着根本性区别</strong>）。网络 IO 对应的是网络数据传输过程，网络是分布式系统的基石，通过网络把离散的物理节点连接起来，形成一个有机的系统。</p>
<p>存储 IO 对应的就是数据存储到物理介质的过程，通常物理介质对应的是磁盘，磁盘上一般会分个区，然后在上面格式化个文件系统出来，所以普通程序员最常看见的是文件 IO 的形式。</p>
<p>在 Golang 里可以归类出两种读写文件的方式：</p>
<ol>
<li>标准库封装：操作对象 <code>File</code>;</li>
<li>系统调用 ：操作对象 <code>fd</code>;</li>
</ol>
<h2 id="读写数据要素"><a href="#读写数据要素" class="headerlink" title="读写数据要素"></a>读写数据要素</h2><p>文件的读写最核心的要素是什么？</p>
<p>通俗来讲：读文件，就是把磁盘上的文件的<strong>特定位置</strong>的数据读到<strong>内存的 buffer</strong> 。写文件，就是把<strong>内存 buffer</strong> 的数据写到磁盘的文件的<strong>特定位置</strong>。</p>
<p>这里注意到两个关键词：</p>
<ol>
<li>特定位置；</li>
<li>内存 buffer；</li>
</ol>
<p><strong>特定位置怎么理解？怎么指定所谓的</strong><code>特定位置</code><strong>？</strong></p>
<p>很简单，用 <code>[ offset, length ]</code> 这两个参数就能标识一段位置。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059263-970193ad-ab90-4abd-8c62-bf040410e14d.png" alt="img"></p>
<p>也就是 IO 偏移和长度，Offset 和 Length。</p>
<p><strong>内存 buffer 怎么理解？</strong></p>
<p>归根结底，文件的数据和谁直接打交道？<strong>内存</strong>，写的时候是从内存写到磁盘文件的，读的时候是从磁盘文件读到内存的。</p>
<p>本质上，下面的 IO 函数都离不开 Offset，Length，buffer 这三个要素。</p>
<h2 id="标准库封装"><a href="#标准库封装" class="headerlink" title="标准库封装"></a>标准库封装</h2><p>Go 对文件进行读写非常简单，因为 Go 已经封装了一个非常便捷的使用接口，位于标准库 os 中。Go 标准库对文件 IO 的封装也就是 Go 推荐对文件进行 IO 时使用的操作方式。</p>
<h3 id="打开文件（Open）"><a href="#打开文件（Open）" class="headerlink" title="打开文件（Open）"></a>打开文件（Open）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>Open 文件之后，获取到一个句柄，也就是 <code>File</code> 结构，之后对文件的读写都是基于 <code>File</code> 结构之上进行的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    *file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件读写只需要针对这个句柄结构体做操作即可。</p>
<p>另外有一点隐藏起来的知识点必须要提一下：<strong>偏移</strong>。也就是最开始强调的读写 3 要素之一的 Offset 。打开（<code>Open</code>）文件的时候，文件当前偏移量默认设置为 0，也就是说 IO 的起始位置就是文件的最开头。举个例子，如果这个时候，写 4K 的数据到文件，那么就是写 [0, 4K] 这个位置的数据，如果之前这上面已经有数据了，那么就会是覆盖写。</p>
<p>除非 <code>Open</code> 文件的时候指定 <code>O_APPEND</code> 选项，偏移量会设置为文件末尾，那么 IO 都是从文件末尾开始。</p>
<h3 id="文件写操作（Write）"><a href="#文件写操作（Write）" class="headerlink" title="文件写操作（Write）"></a>文件写操作（Write）</h3><p>文件 <code>File</code> 句柄对象有两个写方法：</p>
<p>第一种：写一个 buffer 到文件 ，使用文件当前偏移</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该写操作会导致文件偏移量的增加。</strong></p>
<p>第二种：从指定文件偏移，写入 buffer 到文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该写操作不会更新文件偏移量</strong></p>
<h3 id="文件读操作（Read）"><a href="#文件读操作（Read）" class="headerlink" title="文件读操作（Read）"></a>文件读操作（Read）</h3><p>和写对应，文件 <code>File</code> 句柄对象有两个读方法：</p>
<p>第一种：从文件当前偏移读一个 buffer 的数据上来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该读操作会导致文件偏移量的增加。</strong></p>
<p>第二种：从指定文件偏移，读一个 buffer 大小的数据上来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadAt(b []<span class="type">byte</span>, off <span class="type">int64</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：该读操作不会更新文件偏移量</strong></p>
<h3 id="指定偏移量（Seek）"><a href="#指定偏移量（Seek）" class="headerlink" title="指定偏移量（Seek）"></a>指定偏移量（Seek）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>这个句柄方法允许用户指定文件的偏移位置。这个很容易理解，举个例子，文件刚开始是 0 字节，写 1M 的数据下去，大小变成 1M，Offset 往后挪 1M ，默认就是往后挪。</p>
<p>现在 Seek 方法允许把写的偏移定位到任意位置，可以就可以从任意地方覆盖写入数据。</p>
<p>所以在 Go 里面，文件 IO 非常简单，先 Open 一个文件，拿到 <code>File</code> 句柄，然后就可以使用这个句柄 Write ，Read，Seek 就能进行 IO 了。</p>
<h2 id="底层的原理"><a href="#底层的原理" class="headerlink" title="底层的原理"></a>底层的原理</h2><p>Go 的标准库 <code>os</code> 提供了极其方便的封装，深入最原始的本质可以发现最核心的东西：<strong>系统调用</strong>。</p>
<p>Go 标准库的文件存储 IO 就是基于系统调用之上的。可以稍微跟一下 <code>os.OpenFile</code> 的调用：</p>
<p>os 库的 <code>OpenFile</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    f, err := openFileNolog(name, flag, perm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微看下 <code>openFileNolog</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openFileNolog</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> e <span class="type">error</span></span><br><span class="line">        r, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;darwin&quot;</span> &amp;&amp; e == syscall.EINTR &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;open&quot;</span>, name, e&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFile(<span class="type">uintptr</span>(r), name, kindOpenFile), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>syscall.Open</code> ，这个函数获取到一个整数，也就是在 c 语言里最常见的 fd 句柄，而 <code>File</code> 结构体则仅仅是基于这个的一层封装而已。</p>
<p><strong>思考下，为什么会有标准库封装这一层存在？</strong></p>
<p><strong>划重点：为了屏蔽操作系统的区别</strong>，使用这个标准库的所有操作都是跨平台的。换句话说，如果是特殊操作系统才有的特性，那么在 os 库里就找不到对应封装的 IO 操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059293-a7135eb0-0608-41ad-8262-cc658863c19d.png" alt="img"></p>
<p>那么怎么使用系统调用？</p>
<p>直接使用 syscall 库，也就是系统调用。从名字也能看出来，系统调用是和操作系统强相关的，因为是操作系统提供的调用接口，所以系统调用会因为操作系统不同而导致不同的特性，不同的接口。</p>
<p>所以，如果直接使用 syscall 库来使用系统调用，那么需要自己来承受系统带来的兼容性问题。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用在 syscall 里有一层最基础的封装：</p>
<h3 id="文件-Open"><a href="#文件-Open" class="headerlink" title="文件 Open"></a>文件 Open</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="type">string</span>, mode <span class="type">int</span>, perm <span class="type">uint32</span>)</span></span> (fd <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<h3 id="文件-Read"><a href="#文件-Read" class="headerlink" title="文件 Read"></a>文件 Read</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) <span class="function"><span class="keyword">func</span> <span class="title">Pread</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>, offset <span class="type">int64</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>文件读有两个接口，一个 <code>Read</code> 是从<strong>当前默认偏移</strong>读一个 buffer 数据，<code>Pread</code> 接口则是从指定位置读数据的接口。</p>
<p>思考一个问题：<code>Pread</code> 从效果上来讲等于 <code>Seek</code> 和 <code>Read</code> 组合起来使用，那么是否可以认为 <code>Pread</code> 就可以被 <code>Seek</code> + <code>Read</code> 替代呢？</p>
<p>不行！根本原因在于 <code>Seek</code> + <code>Read</code> 是在用户层就是两步操作，而 <code>Pread</code> 虽然是 <code>Seek</code> + <code>Read</code> 的效果，但是操作系统给到用户的语义是：<code>Pread</code> 是一个原子操作。还有一个重要区别，<code>Pread</code> 不会改变当前文件的偏移量（普通的 <code>Read</code> 调用会更新偏移量）。</p>
<p><strong>所以，总结下，</strong><code>**Pread**</code> <strong>和顺序调用</strong> <code>**Seek**</code> <strong>后调用</strong> <code>**Read**</code>  <strong>有两点重要区别：</strong></p>
<ol>
<li><code>Pread</code> 对用户提供的语义是原子操作，在调用 <code>Pread</code> 时，无法中断 <code>Seek</code> 和 <code>Read</code> 操作；</li>
<li><code>Pread</code> 调用不会更新当前文件偏移量；</li>
</ol>
<h3 id="文件-Write"><a href="#文件-Write" class="headerlink" title="文件 Write"></a>文件 Write</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) <span class="function"><span class="keyword">func</span> <span class="title">Pwrite</span><span class="params">(fd <span class="type">int</span>, p []<span class="type">byte</span>, offset <span class="type">int64</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>文件写对应也是有两种接口，<code>Wrtie</code> 和 <code>Pwrite</code> 分别是对应 <code>Read</code> 和 <code>Pread</code> 。同样的，<code>Pwrite</code> 作用上也是相当于先调用 <code>Seek</code>  再调用 <code>Write</code> ，但是同样的也有<strong>两点不同</strong>：</p>
<ol>
<li><code>Pwrite</code>  完成 <code>Seek</code> 和 <code>Write</code> 对外是原子操作的语义；</li>
<li><code>Pwrite</code> 调用不会更新当前文件偏移量；</li>
</ol>
<h3 id="文件-Seek"><a href="#文件-Seek" class="headerlink" title="文件 Seek"></a>文件 Seek</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seek</span><span class="params">(fd <span class="type">int</span>, offset <span class="type">int64</span>, whence <span class="type">int</span>)</span></span> (off <span class="type">int64</span>, err <span class="type">error</span>) </span><br></pre></td></tr></table></figure>

<p>这个函数调用允许用户指定偏移（这个会影响到 <code>Read</code> 和 <code>Write</code> 读写的位置）。一般来说，每个打开文件都有一个相关联的“当前文件偏移量”（ current file offset ）。读（<code>Read</code>）、写（<code>Write</code>）操作都是从<strong>当前文件偏移量处</strong>开始，并且 <code>Read</code> 和 <code>Write</code> 会导致偏移量增加，增加量就是所读写的字节数。</p>
<p><strong>小结一下</strong>：Go核心的 Open，Read，Write，Seek 几个系统调用，可以发现一个明显不同与标准 IO 库的区别：<strong>系统调用操作对象是一个整数句柄</strong>。<code>Open</code> 文件得到一个整数 fd，之后的所有 IO 都是针对这个 fd 来操作的。这个明显和标准库不同，os 标准库 OpenFile 得到的是一个 <code>File</code> 结构体，所有的 IO 也是针对这个结构体的。</p>
<h2 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h2><p>那么究竟封装的层次一般是什么样的呢， Unix 编程里面开篇就有一张如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1617428059414-c1855d9c-8b70-473a-83ac-7889f7e0c8a9.png" alt="img"></p>
<p>这张图就非常形象的讲明白了整个 Unix 体系结构。</p>
<ul>
<li><p>内核是最核心的实现，包括了和 IO 设备，硬件交互等功能。与内核紧密的一层是内核提供给外部调用的系统调用，系统调用提供了用户态到内核态调用的一个通道；</p>
</li>
<li><p>对于系统调用，各个语言的标准库会有一些封装，比如 <strong>C 语言的 libc 库，Go 语言的 os ，syscall 库都是类似的地位，这个就是所谓的公共库</strong>。这层封装的作用最主要是简化普通程序员使用效率，并且屏蔽系统细节，为跨平台提供基础（同样的，为了跨平台的特性，可能会阉割很多不兼容的功能，所以才会有直接调用系统掉调用的需求）；</p>
</li>
<li><p>当然，右上角还看到一个缺口，应用程序除了可以使用公共函数库，<strong>其实是可以直接调用系统调用的，但是由此带来的复杂性又应用自己承担</strong>。这种需求也是很常见的，标准库封装了通用的东西，同样割舍了很多系统调用的功能，这种情况下，只能通过系统调用来获取；</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>IO 大类分为网络 IO 和磁盘 IO，IO 对文件来说就是读写操作，写的时候<strong>数据从内存到磁盘</strong>，读的时候<strong>数据从磁盘到内存</strong>；</p>
</li>
<li><p>Go 文件 IO 最常用的是 os 库，使用 Go 封装的标准库，<code>os.OpenFile</code> 打开，<code>File.Write</code>，<code>File.Read</code> 进行读写，操作对象都是 <code>File</code> 结构体；</p>
</li>
<li><p>Go 标准库对 IO 的封装是为了屏蔽复杂的系统调用，提供跨平台的使用姿势。然后单独提供 <code>syscall</code> 库，让程序员自我决策使用要使用更丰富的系统调用功能，当然后果自负；</p>
</li>
<li><p>Go 标准库 IO 操作对象是 <code>File</code> ，系统调用 IO 操作对象是 fd（非负整数）。</p>
</li>
<li><p><code>Open</code> 文件默认当前偏移量是 0 （文件最开始），加上 <code>O_APPEND</code> 参数之后偏移量会是文件末尾。通过 Seek 调用可以任意指定文件偏移，从而影响文件 IO 的位置；</p>
</li>
<li><p><code>Read</code>，<code>Write</code> 函数只有 buffer （buffer 有长度），偏移则使用当前文件偏移量；</p>
</li>
<li><p><code>Pread</code>，<code>Pwrite</code> 的系统调用效果等同于 <code>Seek</code> 偏移量然后 <code>Read</code>，<code>Write</code>，但是又大有不同。对外语义是原子操作，并且不更新当前文件偏移量；</p>
</li>
</ol>
<h1 id="Go-文件读写操作"><a href="#Go-文件读写操作" class="headerlink" title="Go-文件读写操作"></a>Go-文件读写操作</h1><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容进行追加*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*关闭文件流*/</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">/*读取*/</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*写入文件*/</span></span><br><span class="line">	str := <span class="string">&quot;hello FCC您好！！！\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件内容拷贝至新文件"><a href="#文件内容拷贝至新文件" class="headerlink" title="文件内容拷贝至新文件"></a>文件内容拷贝至新文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件1的内容拷贝到文件2*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file1Path := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file2Path := <span class="string">&quot;D:\\fcofficework\\DNS\\2.txt&quot;</span></span><br><span class="line">	data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read file err=%v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = ioutil.WriteFile(file2Path, data, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;write file err=%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断文件或者目录是否存在"><a href="#判断文件或者目录是否存在" class="headerlink" title="判断文件或者目录是否存在"></a>判断文件或者目录是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断文件以及目录是否存在*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前文件存在！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前文件不存在！&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path := <span class="string">&quot;D:\\fcofficework\\2.txt&quot;</span></span><br><span class="line">	PathExists(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件的拷贝*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>, srcFileName <span class="type">string</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	srcFile, err := os.Open(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	reader := bufio.NewReader(srcFile)</span><br><span class="line"></span><br><span class="line">	dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	writer := bufio.NewWriter(dstFile)</span><br><span class="line">	<span class="keyword">defer</span> dstFile.Close()</span><br><span class="line">	<span class="keyword">return</span> io.Copy(writer, reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcFile := <span class="string">&quot;D:\\Photos\\Datapicture\\mmexport1530688562488.jpg&quot;</span></span><br><span class="line">	dstFile := <span class="string">&quot;D:\\Photos\\1.jpg&quot;</span></span><br><span class="line">	_, err := CopyFile(dstFile, srcFile)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝完成！&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;拷贝失败，err=&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件并统计文件中字符的个数"><a href="#读取文件并统计文件中字符的个数" class="headerlink" title="读取文件并统计文件中字符的个数"></a>读取文件并统计文件中字符的个数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统计文件的字符个数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/*英文的个数*/</span></span><br><span class="line">	ChCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*数字的个数*/</span></span><br><span class="line">	NumCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*空格的个数*/</span></span><br><span class="line">	SpaceCount <span class="type">int</span></span><br><span class="line">	<span class="comment">/*其他字符的个数*/</span></span><br><span class="line">	OtherCount <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">var</span> count CharCount</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">				<span class="keyword">fallthrough</span></span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">				count.ChCount++</span><br><span class="line">			<span class="keyword">case</span> v == <span class="string">&#x27; &#x27;</span> || v == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">				count.SpaceCount++</span><br><span class="line">			<span class="keyword">case</span> v &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">				count.NumCount++</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				count.OtherCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符的个数为：%v 数字的个数为：%v 空格的个数为：%v 其他字符的个数为：%v&quot;</span>,</span><br><span class="line">		count.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种读取文件的方式"><a href="#三种读取文件的方式" class="headerlink" title="三种读取文件的方式"></a>三种读取文件的方式</h3><h4 id="通过os读取"><a href="#通过os读取" class="headerlink" title="通过os读取"></a>通过os读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;d:\\Photos\\Screenshots\\暗物质\\IMG_20180927_194619.jpg&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;file=%v&quot;</span>, file)</span><br><span class="line">	err1 := file.Close()</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;close file err = &quot;</span>, err1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲式读取文件"><a href="#缓冲式读取文件" class="headerlink" title="缓冲式读取文件"></a>缓冲式读取文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*缓冲式读取文件*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;d:\\Photos\\Screenshots\\暗物质\\IMG_20180927_194619.jpg&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件读取结束!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过ioutil读取"><a href="#通过ioutil读取" class="headerlink" title="通过ioutil读取"></a>通过ioutil读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file := <span class="string">&quot;D:\\fcofficework\\DNS\\authorized_keys&quot;</span></span><br><span class="line">	content, err := ioutil.ReadFile(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read file err=%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, <span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件写入的案例"><a href="#文件写入的案例" class="headerlink" title="文件写入的案例"></a>文件写入的案例</h3><h4 id="在文件写入内容，没有则重新创建"><a href="#在文件写入内容，没有则重新创建" class="headerlink" title="在文件写入内容，没有则重新创建"></a>在文件写入内容，没有则重新创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在文件写入内容，没有文件则重新创建*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello world\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在已存在文件清空原有内容重新写入"><a href="#在已存在文件清空原有内容重新写入" class="headerlink" title="在已存在文件清空原有内容重新写入"></a>在已存在文件清空原有内容重新写入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容重新写入*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello FCC\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在已存在文件清空原有内容进行追加"><a href="#在已存在文件清空原有内容进行追加" class="headerlink" title="在已存在文件清空原有内容进行追加"></a>在已存在文件清空原有内容进行追加</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在已存在文件清空原有内容进行追加*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;D:\\fcofficework\\DNS\\1.txt&quot;</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;open file err = %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello FCC您好！！！\r\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*因为writer是带缓存的，需要通过flush到磁盘*/</span></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析命令行参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;命令行参数有：&quot;</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;args[%v]=%v\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析命令行参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> pwd <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line">	flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;pwd, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码，默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;主机名，默认为空&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;端口号，默认为空&quot;</span>)</span><br><span class="line">	<span class="comment">/*转换*/</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user=%v pwd=%v host=%v port=%v&quot;</span>, user, pwd, host, port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go-json序列化"><a href="#Go-json序列化" class="headerlink" title="Go-json序列化"></a>Go-json序列化</h1><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>     <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span>  <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">float64</span> <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span>  <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结构体序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMinsterStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	monster := Monster&#123;</span><br><span class="line">		Name:     <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">		Age:      <span class="number">500</span>,</span><br><span class="line">		Birthday: <span class="string">&quot;2011-11-11&quot;</span>,</span><br><span class="line">		Sal:      <span class="number">8000.0</span>,</span><br><span class="line">		Skill:    <span class="string">&quot;如意七十二变&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(&amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Map序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Map序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapSerlizer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;牛魔王&quot;</span></span><br><span class="line">	a[<span class="string">&quot;age&quot;</span>] = <span class="number">10</span></span><br><span class="line">	a[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;火云洞&quot;</span></span><br><span class="line">	data, err := json.Marshal(a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;monster序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切片序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceSerlizer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;TGH&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;19&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;FCC&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;18&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;address&quot;</span>] = [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;华府&quot;</span>, <span class="string">&quot;影视帝国&quot;</span>&#125;</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, m2)</span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;切片序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本数据类型序列化*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FloatSerlize</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num1 <span class="type">float64</span> = <span class="number">245.56</span></span><br><span class="line">	data, err := json.Marshal(num1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化错误err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;基本数据类型序列化后=%v\n&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	NewMinsterStruct()</span><br><span class="line">	MapSerlizer()</span><br><span class="line">	SliceSerlizer()</span><br><span class="line">	FloatSerlize()</span><br><span class="line">&#125;</span><br><span class="line">Map序列化后=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">500</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;2011-11-11&quot;</span>,<span class="string">&quot;sal&quot;</span>:<span class="number">8000</span>,<span class="string">&quot;skill&quot;</span>:<span class="string">&quot;如意七十二变&quot;</span>&#125;</span><br><span class="line">monster序列化后=&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;火云洞&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">10</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;牛魔王&quot;</span>&#125;</span><br><span class="line">切片序列化后=[&#123;<span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;19&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;TGH&quot;</span>&#125;,&#123;<span class="string">&quot;address&quot;</span>:[<span class="string">&quot;华府&quot;</span>,<span class="string">&quot;影视帝国&quot;</span>],<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;FCC&quot;</span>&#125;]</span><br><span class="line">基本数据类型序列化后=<span class="number">245.56</span></span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age      <span class="type">int</span>     <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">	Birthday <span class="type">string</span>  <span class="string">`json:&quot;birthday&quot;`</span></span><br><span class="line">	Sal      <span class="type">float64</span> <span class="string">`json:&quot;sal&quot;`</span></span><br><span class="line">	Skill    <span class="type">string</span>  <span class="string">`json:&quot;skill&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalStruct</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;孙悟空\&quot;,\&quot;age\&quot;:500,\&quot;birthday\&quot;:\&quot;2011-11-11\&quot;,\&quot;sal\&quot;:8000,\&quot;skill\&quot;:\&quot;如意七十二变\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> monster Monster</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;monster)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化后monster：%v\n&quot;</span>, monster)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshallMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;address\&quot;:\&quot;火云洞\&quot;,\&quot;age\&quot;:10,\&quot;name\&quot;:\&quot;牛魔王\&quot;&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;a)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化Map后：%v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;[&#123;\&quot;address\&quot;:\&quot;北京\&quot;,\&quot;age\&quot;:\&quot;19\&quot;,\&quot;name\&quot;:\&quot;TGH\&quot;&#125;,&quot;</span> +</span><br><span class="line">		<span class="string">&quot;&#123;\&quot;address\&quot;:[\&quot;华府\&quot;,\&quot;影视帝国\&quot;],\&quot;age\&quot;:\&quot;18\&quot;,\&quot;name\&quot;:\&quot;FCC\&quot;&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;slice)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;反序列化失败err：%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;反序列化Slice后：%v\n&quot;</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unmarshalStruct()</span><br><span class="line">	unmarshallMap()</span><br><span class="line">	unmarshalSlice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反序列化后monster：&#123;孙悟空 <span class="number">500</span> <span class="number">2011</span><span class="number">-11</span><span class="number">-11</span> <span class="number">8000</span> 如意七十二变&#125; </span><br><span class="line">反序列化Map后：<span class="keyword">map</span>[address:火云洞 age:<span class="number">10</span> name:牛魔王] </span><br><span class="line">反序列化Slice后：[<span class="keyword">map</span>[address:北京 age:<span class="number">19</span> name:TGH] <span class="keyword">map</span>[address:[华府 影视帝国] age:<span class="number">18</span> name:FCC]]</span><br></pre></td></tr></table></figure>

<h1 id="Go-HTTP包的使用"><a href="#Go-HTTP包的使用" class="headerlink" title="Go-HTTP包的使用"></a>Go-HTTP包的使用</h1><p>Web是基于http协议的一个服务，Go语言里面提供了一个完善的net&#x2F;http包，通过http包可以很方便的搭建起来一个可以运行的Web服务。同时使用这个包能很简单地对Web的路由，静态文件，模版，cookie等数据进行设置和操作。</p>
<h2 id="http包建立Web服务器"><a href="#http包建立Web服务器" class="headerlink" title="http包建立Web服务器"></a>http包建立Web服务器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello golang!&quot;</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码，build之后，然后执行web.exe,这个时候其实已经在8080端口监听http链接请求了。</p>
<p>在浏览器输入<code>http://localhost:8080</code></p>
<p>可以看到浏览器页面输出了<code>Hello golang!</code></p>
<p>浏览器输入地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/?url_long=var1&amp;url_long=var2</span><br></pre></td></tr></table></figure>

<p>可以看看浏览器输出的是什么</p>
<p>看到上面的代码，要编写一个Web服务器很简单，只要调用http包的两个函数就可以了。</p>
<h2 id="使用http包请求页面"><a href="#使用http包请求页面" class="headerlink" title="使用http包请求页面"></a>使用http包请求页面</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httputil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	request, err := http.NewRequest(http.MethodGet, <span class="string">&quot;http://www.imooc.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	request.Header.Add(<span class="string">&quot;User-Agent&quot;</span>,</span><br><span class="line">		<span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	client := http.Client&#123;</span><br><span class="line">		CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Redirect:&quot;</span>, req)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="comment">//resp, err := http.DefaultClient.Do(request)</span></span><br><span class="line">	<span class="comment">//resp, err := http.Get(&quot;http://www.imooc.com&quot;)</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	s, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行打印出HTML内容</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1603443525745-bf6b18f4-8ee9-45a8-8e21-67531abdf88b.png" alt="img"></p>
<h1 id="net-http包的坑——i-o-timeout"><a href="#net-http包的坑——i-o-timeout" class="headerlink" title="net&#x2F;http包的坑——i&#x2F;o timeout"></a>net&#x2F;http包的坑——i&#x2F;o timeout</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>来看一段日常代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr = &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">        Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">            conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body := bytes.NewReader(data)</span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">    req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Transport: tr,</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做的事情，比较简单，就是循环去请求<a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a>, 然后等待响应。</p>
<p>看上去貌似没啥问题吧。</p>
<p>代码跑起来，也确实能正常收发消息。</p>
<p>但是这段代码跑一段时间，就会出现i&#x2F;o timeout的报错。</p>
<p>这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，这边对代码做了简化。</p>
<p>实际生产中发生的现象是，golang服务在发起http调用时，虽然<code>http.Transport</code>设置了3s超时，会偶发出现i&#x2F;o timeout的报错。</p>
<p>但是查看下游服务的时候，发现下游服务其实100ms就已经返回了。</p>
<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351380664-f90f9eac-6fcd-4446-8a4e-d08df02ab269.png" alt="img"></p>
<p>五层网络协议对应的消息体变化分析</p>
<p>就很奇怪了，明明服务端显示处理耗时才100ms，且客户端超时设的是3s, 怎么就出现超时报错i&#x2F;o timeout呢？</p>
<p>这里推测有两个可能。</p>
<ul>
<li>因为服务端打印的日志其实只是服务端应用层打印的日志。但客户端应用层发出数据后，中间还经过客户端的传输层，网络层，数据链路层和物理层，再经过服务端的物理层，数据链路层，网络层，传输层到服务端的应用层。服务端应用层处耗时100ms，再原路返回。那剩下的3s-100ms可能是耗在了整个流程里的各个层上。比如网络不好的情况下，传输层TCP使劲丢包重传之类的原因。</li>
<li>网络没问题，客户端到服务端链路整个收发流程大概耗时就是100ms左右。客户端处理逻辑问题导致超时。</li>
</ul>
<p>一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了，不死心就抓个包看下。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351368734-c0656d47-9e8b-41c1-bdbb-115362ceebe8.png" alt="img"></p>
<p>抓包结果</p>
<p>分析下，从刚开始三次握手（画了红框的地方）。</p>
<p>到最后出现超时报错i&#x2F;o timeout（画了蓝框的地方）。</p>
<p>从time那一列从7到10，确实间隔3s。而且看右下角的蓝框，是51169端口发到80端口的一次Reset连接。</p>
<p>80端口是服务端的端口。换句话说就是客户端3s超时主动断开链接的。</p>
<p>但是再仔细看下第一行三次握手到最后客户端超时主动断开连接的中间，其实有非常多次HTTP请求。</p>
<p>回去看代码设置超时的方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">    Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">        conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这里的3s超时，其实是在建立连接之后开始算的，而不是单次调用开始算的超时。</p>
<p>看注释里写的是</p>
<p>SetDeadline sets the read and write deadlines associated with theconnection.</p>
<h3 id="超时原因"><a href="#超时原因" class="headerlink" title="超时原因"></a>超时原因</h3><p>大家知道HTTP是应用层协议，传输层用的是TCP协议。</p>
<p>HTTP协议从1.0以前，默认用的是短连接，每次发起请求都会建立TCP连接。收发数据。然后断开连接。</p>
<p>TCP连接每次都是三次握手。每次断开都要四次挥手。</p>
<p>其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。</p>
<p>于是乎，HTTP协议从1.1之后就默认使用长连接。具体相关信息可以看之前的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484204&idx=1&sn=0e83aabb2a48570b5bec563a777f4d26&scene=21#wechat_redirect">这篇文章</a>。</p>
<p>那么golang标准库里也兼容这种实现。</p>
<p>通过建立一个连接池，针对每个域名建立一个TCP长连接，比如<a target="_blank" rel="noopener" href="http://baidu.com和http//golang.com%E5%B0%B1%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9F%9F%E5%90%8D%E3%80%82">http://baidu.com和http://golang.com就是两个不同的域名。</a></p>
<p>第一次访问<a target="_blank" rel="noopener" href="http://baidu.com域名的时候会建立一个连接,用完之后放到空闲连接池里,下次再要访问http//baidu.com%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E9%87%8D%E6%96%B0%E4%BB%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%87%8C%E6%8A%8A%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%8D%9E%E5%87%BA%E6%9D%A5%E5%A4%8D%E7%94%A8%E3%80%82">http://baidu.com域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问http://baidu.com的时候会重新从连接池里把这个连接捞出来复用。</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351347346-43a1b64f-2a30-46d4-8fbb-0e201084f4bd.png" alt="img"></p>
<p>复用长连接</p>
<p>为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应一个读goroutine和一个写goroutine。正因为是同一个域名，所以最后才会泄漏3个goroutine，如果不同域名的话，那就会泄漏1+2*N个协程，N就是域名数。</p>
<p>假设第一次请求要100ms，每次请求完<a target="_blank" rel="noopener" href="http://baidu.com后都放入连接池中,下次继续复用,重复29次,耗时2900ms./">http://baidu.com后都放入连接池中，下次继续复用，重复29次，耗时2900ms。</a></p>
<p>第30次请求的时候，连接从建立开始到服务返回前就已经用了3000ms，刚好到设置的3s超时阈值，那么此时客户端就会报超时i&#x2F;o timeout。</p>
<p>虽然这时候服务端其实才花了100ms，但耐不住前面29次加起来的耗时已经很长。</p>
<p>也就是说只要通过<code>http.Transport</code>设置了<code>err = conn.SetDeadline(time.Now().Add(time.Second * 3))</code>，并且用了长连接，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，程序会报超时错误。</p>
<h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。</p>
<p>另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。</p>
<p>基于这两点，改一下代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr = &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">        <span class="comment">// 下面的代码被干掉了</span></span><br><span class="line">        <span class="comment">//Dial: func(netw, addr string) (net.Conn, error) &#123;</span></span><br><span class="line">        <span class="comment">//  conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时</span></span><br><span class="line">        <span class="comment">//  if err != nil &#123;</span></span><br><span class="line">        <span class="comment">//      return nil, err</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时</span></span><br><span class="line">        <span class="comment">//  if err != nil &#123;</span></span><br><span class="line">        <span class="comment">//      return nil, err</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  return conn, nil</span></span><br><span class="line">        <span class="comment">//&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    data, err := json.Marshal(m)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    body := bytes.NewReader(data)</span><br><span class="line">    req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">    req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Transport: tr,</span><br><span class="line">        Timeout: <span class="number">3</span>*time.Second,  <span class="comment">// 超时加在这里，是每次调用的超时</span></span><br><span class="line">    &#125;</span><br><span class="line">    res, err := client.Do(req) </span><br><span class="line">    <span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释会发现，改动的点有两个</p>
<ul>
<li><code>http.Transport</code>里的建立连接时的一些超时设置干掉了。</li>
<li>在发起http请求的时候会场景<code>http.Client</code>，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timeout specifies a time limit forrequestsmade by this Client.</span><br></pre></td></tr></table></figure>

<p>到这里，代码就改好了，实际生产中问题也就解决了。</p>
<p>实例代码里，如果拿去跑的话，其实还会下面的错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get http://www.baidu.com/: EOF</span><br></pre></td></tr></table></figure>

<p>这个是因为调用得太猛了，<a target="_blank" rel="noopener" href="http://www.baidu.com那边主动断开的连接,可以理解为一个限流措施,目的是为了保护服务器,毕竟每个人都像这么搞,服务器是会炸的.../">http://www.baidu.com那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，毕竟每个人都像这么搞，服务器是会炸的。。。</a></p>
<p>解决方案很简单，每次HTTP调用中间加个sleep间隔时间就好。</p>
<p>到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>用的go版本是1.12.7。</p>
<p>从发起一个网络请求开始跟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> do(req *Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里进入 RoundTrip 逻辑</span></span><br><span class="line">/src/net/http/roundtrip.<span class="keyword">go</span>: <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试去获取一个空闲连接，用于发起 http 连接</span></span><br><span class="line">    pconn, err := t.getConn(treq, cm)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点关注这个函数，返回是一个长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getConn(treq *transportRequest, cm connectMethod) (*persistConn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略了大量逻辑，只关注下面两点</span></span><br><span class="line">    <span class="comment">// 有空闲连接就返回</span></span><br><span class="line">    pc := &lt;-t.getIdleConnCh(cm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有创建连接</span></span><br><span class="line">    pc, err := t.dialConn(ctx, cm)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。</p>
<p>最后一个上面的代码里有个<code>getConn</code>方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。</p>
<ul>
<li>如果有空闲连接，就拿空闲连接</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:810</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> getIdleConnCh(cm connectMethod) <span class="keyword">chan</span> *persistConn &#123;</span><br><span class="line">    <span class="comment">// 返回放空闲连接的chan</span></span><br><span class="line">    ch, ok := t.idleConnCh[key]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有空闲连接，就创建长连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:1357</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">  <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次发起一个http请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个读goroutine和一个写goroutine。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351204844-99fdc650-2c23-4dae-ba04-ba54b561202a.png" alt="img"></p>
<p>读写协程</p>
<p>注意上面代码里的<code>t.dial(ctx, &quot;tcp&quot;, cm.addr())</code>，如果像文章开头那样设置了<code>http.Transport</code>的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>那么这里就会在下面的dial里被执行到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dial(ctx context.Context, network, addr <span class="type">string</span>) (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    c, err := t.Dial(network, addr)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面调用的设置超时，会执行到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/net/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> SetDeadline(t time.Time) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.fd.SetDeadline(t)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDeadlineImpl</span><span class="params">(fd *FD, t time.Time, mode <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="type">int64</span>, mode <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置一个定时器事件</span></span><br><span class="line">    rtf = netpollDeadline</span><br><span class="line">    <span class="comment">// 并将事件注册到定时器里</span></span><br><span class="line">    modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个定时器事件，假设时间设了3s，那么这个事件会在3s后发生，然后执行注册事件的逻辑。而这个注册事件就是<code>netpollDeadline</code>。注意这个<code>netpollDeadline</code>，待会会提到。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621351188250-1127f116-5af1-4a96-ae6f-c326b52761f5.png" alt="img"></p>
<p>读写协程定时器事件</p>
<p>设置了超时事件，且超时事件是3s后之后，发生。再次期间正常收发数据。一切如常。</p>
<p>直到3s过后，这时候看读goroutine，会等待网络数据返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/net/http/tansport.go:1642</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> readLoop() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> alive &#123;</span><br><span class="line">        _, err := pc.br.Peek(<span class="number">1</span>)  <span class="comment">// 阻塞读取服务端返回的数据</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是一直跟代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">src/bufio/bufio.<span class="keyword">go</span>: <span class="number">129</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    b.fill() </span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> fill() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err := b.rd.Read(b.buf[b.w:])</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/net/http/transport.<span class="keyword">go</span>: <span class="number">1517</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err = pc.conn.Read(p)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /src/net/net.go: 173</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    n, err := c.fd.Read(b)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    n, err = fd.pfd.Read(p)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/internal/poll/fd_unix.<span class="keyword">go</span>: </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> waitRead(isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pd.wait(<span class="string">&#x27;r&#x27;</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> wait(mode <span class="type">int</span>, isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">    <span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到跟到<code>runtime_pollWait</code>，这个可以简单认为是等待服务端数据返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.如果网络正常返回数据就跳出</span></span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.如果有出错情况也跳出</span></span><br><span class="line">        err = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整条链路跟下来，就是会一直等待数据，等待的结果只有两个</p>
<ul>
<li>有可以读的数据</li>
<li>出现报错</li>
</ul>
<p>这里面的报错，又有那么两种</p>
<ul>
<li>连接关闭</li>
<li>超时</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">// errClosing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中提到的超时，就是指这里面返回的<code>数字2</code>，会通过下面的函数，转化为<code>ErrTimeout</code>， 而<code>ErrTimeout.Error()</code>其实就是i&#x2F;o timeout。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertErr</span><span class="params">(res <span class="type">int</span>, isFile <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> res &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> errClosing(isFile)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> ErrTimeout <span class="comment">// ErrTimeout.Error() 就是 &quot;i/o timeout&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;unreachable: &quot;</span>, res)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了。上面返回的超时错误，也就是返回2的时候的条件是怎么满足的？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得刚刚提到的netpollDeadline吗？</p>
<p>这里面放了定时器3s到点时执行的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计时器到设定时间点了，触发之前注册函数</span></span><br><span class="line">    f(arg, seq) <span class="comment">// 之前注册的是 netpollDeadline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/runtime/netpoll.<span class="keyword">go</span>: <span class="number">428</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="type">uintptr</span>, read, write <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> read &#123;</span><br><span class="line">        pd.rd = <span class="number">-1</span></span><br><span class="line">        rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会设置<code>pd.rd=-1</code>，是指<code>poller descriptor.read deadline</code>，含义网络轮询器文件描述符的读超时时间， 在linux里万物皆文件，这里的文件其实是指这次网络通讯中使用到的socket。</p>
<p>这时候再回去看发生超时的条件就是<code>if (mode == &#39;r&#39; &amp;&amp; pd.rd &lt; 0)</code>。</p>
<p>至此。代码里就收到了io timeout的报错。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>不要在<code>http.Transport</code>中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名io timeout报错。</li>
<li>请求的超时在创建<code>client</code>里设置。</li>
</ul>
<h1 id="Go中Unicode相关包"><a href="#Go中Unicode相关包" class="headerlink" title="Go中Unicode相关包"></a>Go中Unicode相关包</h1><h3 id="Go中Unicode相关包-1"><a href="#Go中Unicode相关包-1" class="headerlink" title="Go中Unicode相关包"></a>Go中Unicode相关包</h3><p>Go 语言让复杂的编码问题变得简单很多，极大的减轻了程序员的心智负担。为了方便对 unicode 字符串进行处理，Go 语言标准库提供三个包：unicode、unicode&#x2F;utf8 和 unicode&#x2F;utf16。</p>
<p>这里简单介绍下三个包的功能：</p>
<ul>
<li><p>unicode：unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。</p>
</li>
<li><p>unicode&#x2F;utf8：用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。</p>
</li>
<li><p>unicode&#x2F;utf16：函数比较少，主要是 UTF-16 序列的编码和解码。</p>
</li>
</ul>
<p>Go 中字符串的写法。</p>
<p>在 Go 语言中，字符串字面值有 4 种写法，比如「徐新华」可以这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;徐新华&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;\u5F90\u65B0\u534E&quot;</span></span><br><span class="line">s3 := <span class="string">&quot;\U00005F90\U000065B0\U0000534E&quot;</span></span><br><span class="line">s4 := <span class="string">&quot;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&quot;</span></span><br></pre></td></tr></table></figure>

<p>简单来生活就是 \u 紧跟四个十六进制数，\U 紧跟八个十六进制数。其中 \u 或 \U 代表后面是 Unicode 码点。而 \x 紧跟两个十六进制数，这些十六进制不是 Unicode 码点，而是 UTF-8 编码。</p>
<p>下面的代码有利于理解：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">`徐新华`</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        buf = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4</span>)</span><br><span class="line">        n   <span class="type">int</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(<span class="string">&quot;字符\tUnicode码点\tUTF-8编码十六进制\tUTF-8编码二进制&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        n = utf8.EncodeRune(buf, r)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%q\t%U\t\t%X\t\t%b\n&quot;</span>, r, r, buf[:n], buf[:n])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s2 := <span class="string">&quot;\u5F90\u65B0\u534E&quot;</span></span><br><span class="line">    s3 := <span class="string">&quot;\U00005F90\U000065B0\U0000534E&quot;</span></span><br><span class="line">    s4 := <span class="string">&quot;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">    fmt.Println(s4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符 Unicode码点 UTF<span class="number">-8</span>编码十六进制 UTF<span class="number">-8</span>编码二进制</span><br><span class="line"><span class="string">&#x27;徐&#x27;</span> U+<span class="number">5</span>F90  E5BE90  [<span class="number">11100101</span> <span class="number">10111110</span> <span class="number">10010000</span>]</span><br><span class="line"><span class="string">&#x27;新&#x27;</span> U+<span class="number">65</span>B0  E696B0  [<span class="number">11100110</span> <span class="number">10010110</span> <span class="number">10110000</span>]</span><br><span class="line"><span class="string">&#x27;华&#x27;</span> U+<span class="number">534</span>E  E58D8E  [<span class="number">11100101</span> <span class="number">10001101</span> <span class="number">10001110</span>]</span><br><span class="line">徐新华</span><br><span class="line">徐新华</span><br><span class="line">徐新华</span><br></pre></td></tr></table></figure>

<p>此外，关于字符串其他方面的处理，比如编码转换等，可以到 <a target="_blank" rel="noopener" href="https://pkg.go.dev/golang.org/x/text">https://pkg.go.dev/golang.org/x/text</a> 里找。</p>
<h3 id="大小端问题（Little-endian-和-Big-endian）"><a href="#大小端问题（Little-endian-和-Big-endian）" class="headerlink" title="大小端问题（Little endian 和 Big endian）"></a>大小端问题（Little endian 和 Big endian）</h3><p>一个字符使用多字节存储时，涉及到哪个在前哪个在后。以汉字「徐」为例，Unicode 码点是 5F90，需要用两个字节存储，一个字节是<code>5F</code>，另一个字节是<code>90</code>。存储的时候，<code>5F</code>在前，<code>90</code> 在后，这就是 Big endian 方式；<code>90</code>在前，<code>5F</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头（Big-endian）敲开还是从小头（Little-endian）敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大端方式”（Big endian），第二个字节在前就是”小端方式”（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大1。</p>
<p>如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式；如果头两个字节是 FF FE，就表示该文件采用小端方式。</p>
<p>但从上面关于 UTF-8 编码的说明可以看出，虽然 UTF-8 存在多字节表示一个字符的情况，但顺序是固定的，没有字节序的问题。Unix 系统下，UTF-8 没有任何前置字符，但 Windows 下记事本保存的 UTF-8 文件会带上 BOM（Byte Order Mark），即 EF BB BF 这三个字节。关于这一点，Unicode 之父 Rob Pike 明确说 UTF-8 不需要 BOM，所以一开始 Go 源文件是不允许有 BOM 的，否则编译不通过，不过现在已经可以有了。但建议还是别带 BOM。</p>
<blockquote>
<p>UTF-8 带 BOM 说不是为了区分字节序，而是为了更方便的知晓这是一个 UTF-8 文件。</p>
</blockquote>
<h1 id="Go-标准库之-unsafe-包"><a href="#Go-标准库之-unsafe-包" class="headerlink" title="Go 标准库之 unsafe 包"></a>Go 标准库之 unsafe 包</h1><h2 id="1-unsafe包"><a href="#1-unsafe包" class="headerlink" title="1.  unsafe包"></a>1.  unsafe包</h2><h2 id="1-1-ArbitraryType"><a href="#1-1-ArbitraryType" class="headerlink" title="1.1.  ArbitraryType"></a>1.1.  <code>ArbitraryType</code></h2><p><code>unsafe</code>包下定义了一个<code>ArbitratyType</code>类型，代表了任意的Go表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-Pointer"><a href="#1-2-Pointer" class="headerlink" title="1.2.  Pointer"></a>1.2.  <code>Pointer</code></h2><p><code>Pointer</code>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p><code>Pointer</code>代表了一个指向任意类型的指针，有四种只适用对<code>Pointer</code>而不适用于其他类型的操作。</p>
<ul>
<li><p>任意类型的指针值可以被转换为一个<code>Pointer</code></p>
</li>
<li><p>一个<code>Pointer</code>可以被转换为任意类型的指针值</p>
</li>
<li><p>一个<code>uintptr</code>可以被转换为一个<code>Pointer</code></p>
</li>
<li><p>一个<code>Pointer</code>也可以被转换为一个<code>uintptr</code></p>
</li>
</ul>
<p>因此，<code>Pointer</code>可以跳过类型系统而直接指向任意类型。所以需要十分小心的使用。</p>
<p>关于使用<code>Pointer</code>的规则，不使用这些规则的代码是不可用的，或者在未来是不可用的。</p>
<h3 id="1-2-1-使用Pointer作为中间者将-T1转换为-T2"><a href="#1-2-1-使用Pointer作为中间者将-T1转换为-T2" class="headerlink" title="1.2.1.  使用Pointer作为中间者将*T1转换为*T2"></a>1.2.1.  使用<code>Pointer</code>作为中间者将<code>*T1</code>转换为<code>*T2</code></h3><p>前提是T2的大小不超过T1，而且两者的内存分布相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="type">float64</span>)</span></span> <span class="type">uint64</span> &#123;  <span class="keyword">return</span> *(*<span class="type">uint64</span>)(unsafe.Pointer(&amp;f))&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-把Pointer转换为uintptr"><a href="#1-2-2-把Pointer转换为uintptr" class="headerlink" title="1.2.2.  把Pointer转换为uintptr"></a>1.2.2.  把<code>Pointer</code>转换为<code>uintptr</code></h3><p>把<code>Pointer</code>转换为<code>uintptr</code>将产生一个指向类型值的<code>int</code>变量。常用来打印一个<code>uintptr</code>。</p>
<p>将<code>uintptr</code>转换为<code>Pointer</code>是不可用的。</p>
<p>因为<code>uintptr</code>是一个整数值，而不是引用。就是说<code>uintptr</code>和指针没有任何关系。可以说是将<code>Pointer</code>指向的地址的值返回给<code>uintptr</code>，即使<code>uintptr</code>中的值对应的地址的对象更新了或者删除了，<code>uintptr</code>也不会改变。</p>
<h3 id="1-2-3-把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算"><a href="#1-2-3-把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算" class="headerlink" title="1.2.3.  把Pointer转为uintptr再转换回Pointer，其中带有uintptr数值运算"></a>1.2.3.  把<code>Pointer</code>转为<code>uintptr</code>再转换回<code>Pointer</code>，其中带有<code>uintptr</code>数值运算</h3><p>如果<code>Pointer</code>指向一个分配的对象，那么如下转换可以把<code>Pointer</code>指针向后移动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = unsafe.Pointer(<span class="type">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure>

<p>最常用的是指向结构体中不同字段或者数组中的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent to f := unsafe.Pointer(&amp;s.f)</span></span><br><span class="line"> f := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br><span class="line"> <span class="comment">// equivalent to e := unsafe.Pointer(&amp;x[i])</span></span><br><span class="line"> e := unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;x[<span class="number">0</span>])) + i*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>这可以用来向前或向后移动指针，通过加或者减<code>offset</code>。指针移动之后，也应该指向该内存范围中。</p>
<p>将<code>Pointer</code>移动超过其对象的原始内存分配范围是不可用的，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INVALID: end points outside allocated space.</span></span><br><span class="line"> <span class="keyword">var</span> s thing</span><br><span class="line"> end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// INVALID: end points outside allocated space.</span></span><br><span class="line"> b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line"> end = unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<p>当然如下代码也是错误的，因为<code>uintptr</code>不可以储存在变量中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">// before conversion back to Pointer.</span></span><br><span class="line">u := <span class="type">uintptr</span>(p)</span><br><span class="line">p = unsafe.Pointer(u + offset)</span><br><span class="line">Pointer<span class="string">`必须指向一个已经分配好的对象，而不能是`</span><span class="literal">nil</span></span><br><span class="line"><span class="comment">// INVALID: conversion of nil pointer</span></span><br><span class="line">u := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">p := unsafe.Pointer(<span class="type">uintptr</span>(u) + offset)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-当调用syscall-Syscall时，需要把Poiner转换为uintptr"><a href="#1-2-4-当调用syscall-Syscall时，需要把Poiner转换为uintptr" class="headerlink" title="1.2.4.  当调用syscall.Syscall时，需要把Poiner转换为uintptr"></a>1.2.4.  当调用<code>syscall.Syscall</code>时，需要把<code>Poiner</code>转换为<code>uintptr</code></h3><p><code>syscall</code>包下的<code>Syscall</code>函数把<code>uintptr</code>参数传递给操作系统，然后根据调用的相关信息，把相应的<code>uintptr</code>再转换为指针。</p>
<p>如果一个指针参数必须被转换为<code>uintptr</code>作为参数的话，这个转换只能在调用函数中的参数表达式完成，因为<code>uintptr</code>是不能储存在变量中的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(p)), <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<p>编译器处理函数调用中的指针时，该指针所指向的对象会被保留到函数调用结束，即使该对象在函数调用时并不使用。</p>
<p>如下是错误的代码，因为<code>uintptr</code>不能保存在变量中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">// before implicit conversion back to Pointer during system call.</span></span><br><span class="line">u := <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">syscall.Syscall(SYS_READ, <span class="type">uintptr</span>(fd), u, <span class="type">uintptr</span>(n))</span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-将reflect-Value-Pointer或者reflect-Value-UnsafeAddr的结果从uintptr转换为Pointer"><a href="#1-2-5-将reflect-Value-Pointer或者reflect-Value-UnsafeAddr的结果从uintptr转换为Pointer" class="headerlink" title="1.2.5.  将reflect.Value.Pointer或者reflect.Value.UnsafeAddr的结果从uintptr转换为Pointer"></a>1.2.5.  将<code>reflect.Value.Pointer</code>或者<code>reflect.Value.UnsafeAddr</code>的结果从<code>uintptr</code>转换为<code>Pointer</code></h3><p>包<code>reflect</code>下<code>Value</code>的<code>Pointer</code>方法和<code>UnsafeAddr</code>方法返回的是<code>uintptr</code>而不是<code>Pointer</code>类型，以便于调用者不使用<code>usafe</code>包就可以转换为任意类型。这也意味着，这两个方法的返回值必须使用<code>Pointer</code>进行转换才可以使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := (*<span class="type">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="type">int</span>)).Pointer()))</span><br></pre></td></tr></table></figure>

<p>因为这两个函数调用的返回值是<code>uintptr</code>，所以也是不可以变量储存的。</p>
<h3 id="1-2-6-reflect-SliceHeader或者reflect-StringHeader的Data字段同Pointer的相互转换"><a href="#1-2-6-reflect-SliceHeader或者reflect-StringHeader的Data字段同Pointer的相互转换" class="headerlink" title="1.2.6.  reflect.SliceHeader或者reflect.StringHeader的Data字段同Pointer的相互转换"></a>1.2.6.  <code>reflect.SliceHeader</code>或者<code>reflect.StringHeader</code>的<code>Data</code>字段同<code>Pointer</code>的相互转换</h3><p>前面说过，返回<code>uintptr</code>是为了调用者可以直接进行不同类型的转换，而不用导入<code>unsafe</code>包。这意味着，只有当指针解析为切片或者字符串时<code>SliceHeader</code>和<code>StringHeader</code>才可以被使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="comment">// case 1</span></span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))              <span class="comment">// case 6 (this case)</span></span><br><span class="line">hdr.Len = n</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>SliceHeader</code>和<code>StringHeader</code>只能作为<code>*SliceHeader</code>和<code>*StringHeader</code>使用，而不可以使用其结构体形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INVALID: a directly-declared header will not hold Data as a reference.</span></span><br><span class="line"><span class="keyword">var</span> hdr reflect.StringHeader</span><br><span class="line">hdr.Data = <span class="type">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;hdr)) <span class="comment">// p possibly already lost</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-Sizeof函数"><a href="#1-3-Sizeof函数" class="headerlink" title="1.3 Sizeof函数"></a>1.3 <code>Sizeof</code>函数</h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p>直接复制标准文档中的内容，下同。</p>
<p><code>Sizeof</code>返回类型v本身数据所占用的字节数。返回值是“顶层”的数据占有的字节数。例如，若v是一个切片，它会返回该切片描述符的大小，而非该切片底层引用的内存的大小。</p>
<h2 id="1-4-Alignof"><a href="#1-4-Alignof" class="headerlink" title="1.4 Alignof"></a>1.4 <code>Alignof</code></h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(v ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p><code>Alignof</code>返回类型v的对齐方式（即类型v在内存中占用的字节数）；若是结构体类型的字段的形式，它会返回字段f在该结构体中的对齐方式。</p>
<h2 id="1-5-Offsetof"><a href="#1-5-Offsetof" class="headerlink" title="1.5 Offsetof"></a>1.5 <code>Offsetof</code></h2><p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(v ArbitraryType)</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>

<p><code>Offsetof</code>返回类型v所代表的结构体字段在结构体中的偏移量，它必须为结构体类型的字段的形式。换句话说，它返回该结构起始处与该字段起始处之间的字节数。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1.2中的<code>Pointer</code>和<code>uintptr</code>的区别：</p>
<p>假设在内存中有一个变量<code>a := 1</code></p>
<p>那么<code>p := Pointer(&amp;a)</code>中，p包含的就是a的实际地址，假设为<code>1000</code>，当a在内存中移动时，p中的地址值也会实时更新。</p>
<p>而<code>uintprt(p)</code>只是<code>1000</code>，就是a的地址值，但是当a在内存中移动时，原来获取的<code>uintptr</code>值并不会发生变化，一直都是1000。</p>
<p>也是因为这个原因，<code>syscall.Syscall</code>传入的<code>uintptr</code>如果代表一个对象的指针，那么该对象在内存中是一直被保留的，而且不能移动，否则的话<code>uintptr</code>指向的就不是原来的对象了，容易内存泄漏。</p>
<p>还有一个就是<code>uintptr</code>不能保存在变量中，只能使用<code>Pointer</code>进行转换然后才能保存。</p>
<h1 id="编码分析"><a href="#编码分析" class="headerlink" title="编码分析"></a>编码分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>HTTP 协议基于文本传输，字符编码将文本变为二进制，二进制编码将二进制变为文本。TCP 协议基于二进制传输，数据读取时需要处理字节序。本文将介绍常见的字符编码、二进制编码及字节序，并一探 Golang 中的实现。</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>引言：如何把“Hello world”变成字节？</p>
<ul>
<li><p>Step1：得到要表示的全量字符（字符表）</p>
</li>
<li><p>Step2：为每个字符指定一个整数编号（编码字符集）</p>
</li>
<li><p>Step3：将编号映射成有限长度比特值（字符编码表）</p>
</li>
</ul>
<p>字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。全世界共使用 5651 种语言，其中使用人数超过 5000 万的语言有 13 种，每种语言有自己的字符。汉语中，一个汉字就是一个字符。英语中，一个字母就是一个字符。甚至看不见的也可以是字符（如控制字符）。<strong>字符的集合即为字符表</strong>，如英文字母表，阿拉伯数字表。ASCII 码表中一共有 128 个字符。</p>
<h2 id="编码字符集（CCS-Coded-Character-Set）"><a href="#编码字符集（CCS-Coded-Character-Set）" class="headerlink" title="编码字符集（CCS:Coded Character Set）"></a>编码字符集（CCS:Coded Character Set）</h2><p>为字符表中的每个字符指定一个编号（<strong>码点，Code Point</strong>），即得到编码字符集。常见有 ASCII 字符集、Unicode 字符集、GB2312 字符集、BIG5 字符集、 GB18030 字符集等。ASCII 字符集中一共有 128 个字符，包括了 94 个可打印字符（英文大小写字母 52 个、阿拉伯数字 10 个、西文符号 32 个）和 34 个控制符或通信专用字符，码点值范围为[0, 128)，如下图所示。Unicode 字符集是一个很大的集合，现有容量将近 2^21 个字符，码点值范围为[0, 2^20+2^16)。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502988-ada45336-1730-4863-a573-2b9db2127675.webp" alt="img"></p>
<p>ASCII字符编码表</p>
<h2 id="字符编码表（CEF-Character-Encoding-Form）"><a href="#字符编码表（CEF-Character-Encoding-Form）" class="headerlink" title="字符编码表（CEF:Character Encoding Form）"></a>字符编码表（CEF:Character Encoding Form）</h2><p><strong>编码字符集只定义了字符与码点的映射</strong>，并没有规定码点的字节表示方式。由于 1 个字节可以表示 256 个编号，足以容纳 ASCII 字符集，因此<strong>ASCII 编码的规则很简单：直接将码点值用 uint8 表示即可</strong>。对于 Unicode 字符集，容纳 2^21 至少需要 3 字节。可以采用类似 ASCII 的编码规则：<strong>直接将编码点值用 uint32 表示即可，这正是 UTF-32 编码</strong>。</p>
<p>这种一刀切的定长编码方式虽然简单粗暴，弊端也很明显：<strong>对于纯英文文本，UTF-32 编码空间占用将是 ACSII 编码的 4 倍</strong>，造成极大的空间浪费，几乎没什么人用。有没有更优雅的解决方案？当然，这就是 UTF-8 和 UTF-16，两种当前比较流行的 Unicode 编码方式。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>历史的经验，成功的设计往往具有包容性。UTF-8 是一个典型，漂亮的实现了<strong>对 ASCII 码的向后兼容</strong>，以保证可以被大众接受。UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长，随码点变换长度（从 1 字节到 4 字节）。text</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536502972-eb8483f5-fb58-4b55-a2b8-a1f52f4d9914.webp" alt="img"></p>
<p>大道至简，优雅的设计一定是简单的，UTF-8 的编码规则也诠释了这一点。编码规则如下：</p>
<ol>
<li>&lt;&#x3D;127（U+7F）的码点采用单字节编码，与 ASCII 保持一致；</li>
<li>&gt;127（U+7F）的码点采用 N 字节（N 属于 2，3，4）编码，首字节的前 N 位为 1，第 N+1 位为 0，剩余 N-1 个字节的前两位都为 10，剩下的二进制位使用字符的码点来填充。</li>
</ol>
<p>其中(U+7F)表示 Unicode 的十六进制码点值，即 127。如果觉得编码规则抽象，结合下表更加清晰：</p>
<table>
<thead>
<tr>
<th>Unicode  码点范围</th>
<th>码点数量</th>
<th>UTF-8 编码格式</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000 ~ 0000 007F</td>
<td>2^7</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 ~ 0000 07FF</td>
<td>2^11 - 2^7</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 ~ 0000 FFFF</td>
<td>2^16 - 2^11</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 ~ 0010 FFFF</td>
<td>2^20</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>举个例子，如“汉”的 Unicode 码点是 U+6C49（110 1100 0100 1001），根据上表可得需要 3 字节编码，填充码点值后得到 0xE6 0xB7 0x89（11100110 10110001 10001001）。</p>
<p>根据编码规则，解码也很简单，关键是如何判断连续的字节数：<strong>首字节连续 1 的个数即为字节数</strong>。</p>
<p>需要一提的是，<strong>在 MySQL 中，utf8 是“虚假的 utf8”</strong>，最大只支持 3 个字节，如果建表时选择 CHARSET&#x3D;utf8，会导致很多特殊字符和 emoji 表情都无法插入。<strong>utf8mb4 才是“真正的 utf8”</strong>，mb4 即most bytes 4。为什么 MySQL 中 utf8 最大只支持 3 字节？历史原因，在 MySQL 刚开发那会儿，Unicode 空间只有 2^16，Unicode 委员会还在做 “65535 个字符足够全世界用了”的美梦呢。</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>在 C&#x2F;C++ 中遇到的wchar_t类型或 Java 中的char类型，这些类型占内存两个字节，因为 Unicode 中常用的字符都处于[U+0, U+FFFF]（基本平面）的范围之内，因此<strong>两个字节几乎可以覆盖大部分的常用字符</strong>，这正是 UTF-16 编码的一个前提。</p>
<p>相比 UTF-32 与 UTF-8，<strong>UTF-16 编码是一个折中：小于（U+FFFF）2^16 的码点（基本平面）使用 2 字节编码，大于（U+FFFF）2^16 的码点（辅助码点）使用 4 字节编码</strong>。由于基础平面空间会占用 2 字节的所有比特位，无法像 UTF-8 那样留有“10”前缀。那么问题来了：<strong>当遇到两个节时，如何判断是 2 字节编码还是 4 字节编码？</strong></p>
<p>UTF-16 的编码的另一个前提：<strong>在基本平面内，</strong>**[U+D800, U+DFFF]**<strong>是一个空段（空间大小为 2^11）</strong>，这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>辅助平面容量为 2^20，至少需要 20 个二进制位，UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 2^10），称为<strong>高位</strong>（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 2^10），称为<strong>低位</strong>（L）。</p>
<p>映射方式采用线性映射。Unicode3.0 中给出了辅助平面字符的转换公式：</p>
<p>H &#x3D; Math.floor((c-0x10000) &#x2F; 0x400) + 0xD800</p>
<p>L &#x3D; (c - 0x10000) % 0x400 + 0xDC00</p>
<p>也就是说，一个辅助平面的码点，被拆成两个基本平面的空段码点表示。如果双字节的值在[U+D800, U+DBFF]中，则要和后续相邻的双字节一同解码。具体编码规则为：</p>
<ol>
<li>&lt;&#x3D; (U+FFFF)的码点采用双字节编码，直接将码点使用 uint16 表示；</li>
<li>&gt; (U+FFFF)的码点采用 4 字节编码，作差计算码点溢出值，将溢出值用 uint20 表示后，前 10 位映射到[U+D800, U+DBFF]，后 10 位映射到[U+DC00, U+DFFF];</li>
</ol>
<p>小结: 定长编码的优点是转换规则简单直观，查找效率高，缺点是空间浪费，以及不可扩展。如果 Unicode 字符集进一步扩充，UTF-16 和 UTF-32 都将不可用，而 UTF-8 具有更强的可扩展性。</p>
<h2 id="Golang-中字符编码"><a href="#Golang-中字符编码" class="headerlink" title="Golang 中字符编码"></a>Golang 中字符编码</h2><p>不像 C++、Java 等语言支持五花八门的字符编码，Golang 遵从“大道至简”的原则：<strong>全用 UTF-8</strong>。所以 go 程序员再也不用担心乱码问题，甚至可以用汉字和表情包写代码，string 与字节数组转换也是直接转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemp</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    来自打工人的问候()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> 来自打工人的问候<span class="params">()</span></span> &#123;</span><br><span class="line">    问候语 := <span class="string">&quot;早安，打工人😁&quot;</span></span><br><span class="line">    fmt.Println(问候语)</span><br><span class="line">    bytes := []<span class="type">byte</span>(问候语)</span><br><span class="line">    fmt.Println(hex.EncodeToString(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 执行结果–&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">早安，打工人😁</span><br><span class="line">e697a9e5ae89efbc8ce68993e5b7a5e4babaf09f9881</span><br></pre></td></tr></table></figure>

<p>值得一提的是，Golang 中 string 的底层模型就是字节数组，所以类型转换过程中无需编解码。也因此，<strong>Golang 中 string 的底层模型是字节数组，其长度并非字符数，而是对应字节数</strong>。如果要取字符数，需要先将字符串转换为字符数组。<strong>字符类型（rune）实际上是 int32 的别名，即用 UTF-32 编码表示字符</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemp</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;早&quot;</span>)) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>([]<span class="type">byte</span>(<span class="string">&quot;早&quot;</span>))) <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>([]<span class="type">rune</span>(<span class="string">&quot;早&quot;</span>)) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>再看一下 go 中 utf-8 编码的具体实现。首先获取字符的码点值，然后根据范围判断字节数，根据对应格式生成编码值。如果是无效的码点值，或码点值位于空段，则返回U+FFFD(即 �)。解码过程不再赘述。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(p []<span class="type">byte</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// Negative values are erroneous. Making it unsigned addresses the problem.</span></span><br><span class="line">    <span class="keyword">switch</span> i := <span class="type">uint32</span>(r); &#123;</span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune1Max:</span><br><span class="line">        p[<span class="number">0</span>] = <span class="type">byte</span>(r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune2Max:</span><br><span class="line">        _ = p[<span class="number">1</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t2 | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> i &gt; MaxRune, surrogateMin &lt;= i &amp;&amp; i &lt;= surrogateMax:</span><br><span class="line">        r = RuneError</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> i &lt;= rune3Max:</span><br><span class="line">        _ = p[<span class="number">2</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t3 | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _ = p[<span class="number">3</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">        p[<span class="number">0</span>] = t4 | <span class="type">byte</span>(r&gt;&gt;<span class="number">18</span>)</span><br><span class="line">        p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">        p[<span class="number">3</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    t1 = <span class="number">0</span>b00000000</span><br><span class="line">    tx = <span class="number">0</span>b10000000</span><br><span class="line">    t2 = <span class="number">0</span>b11000000</span><br><span class="line">    t3 = <span class="number">0</span>b11100000</span><br><span class="line">    t4 = <span class="number">0</span>b11110000</span><br><span class="line">    t5 = <span class="number">0</span>b11111000</span><br><span class="line">    maskx = <span class="number">0</span>b00111111</span><br><span class="line">    mask2 = <span class="number">0</span>b00011111</span><br><span class="line">    mask3 = <span class="number">0</span>b00001111</span><br><span class="line">    mask4 = <span class="number">0</span>b00000111</span><br><span class="line">    rune1Max = <span class="number">1</span>&lt;&lt;<span class="number">7</span> - <span class="number">1</span></span><br><span class="line">    rune2Max = <span class="number">1</span>&lt;&lt;<span class="number">11</span> - <span class="number">1</span></span><br><span class="line">    rune3Max = <span class="number">1</span>&lt;&lt;<span class="number">16</span> - <span class="number">1</span></span><br><span class="line">    RuneError = <span class="string">&#x27;\uFFFD&#x27;</span> <span class="comment">// the &quot;error&quot; Rune or &quot;Unicode replacement character&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code points in the surrogate range are not valid for UTF-8.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    surrogateMin = <span class="number">0xD800</span></span><br><span class="line">    surrogateMax = <span class="number">0xDFFF</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>引言：HTTP 是怎么传输二进制数据的？</p>
<ul>
<li><p>Step1：定义字符集；</p>
</li>
<li><p>Step2：将二进制数据分组；</p>
</li>
<li><p>Step3：将每组映射为字符；</p>
</li>
</ul>
<p>字符编码是「文本」变为「二进制」的过程，那如何将任意「二进制」变为「文本」？答案是进行二进制编码，常见有 Hex 编码与 Base64 编码。</p>
<p>显然<strong>不能按字符编码直接解码</strong>，因为字符编码的结果二进制是满足编码规律的，而非「任意」的，非法格式进行字符解码会出现乱码（比如对0b11xxxxxx进行 UTF-8 解码）。</p>
<h2 id="Hex-编码"><a href="#Hex-编码" class="headerlink" title="Hex 编码"></a>Hex 编码</h2><p>Hex 编码是最直观的二进制编码方式，所见即所得。上文中的十六进制表示就是用的 Hex 编码。规则如下：</p>
<ol>
<li><p>Hex 字符集为0123456789abcdef；</p>
</li>
<li><p>每 4bit 为 1 组(2^4&#x3D;16)；</p>
</li>
<li><p>每组映射为一个 Hex 字符；</p>
</li>
</ol>
<p>计算机中二进制数据都是以字节为单位存储的，1 个字节 8bit，不会出现无法被 4 整除的情况。</p>
<p>每个字节编码为 2 个 Hex 字符，即编码后的字符数是原始数据字节数的 2 倍。<strong>在 ASCII 或 UTF-8 编码下，存储 Hex 结果字符串需要的空间是原始数据的 2 倍，存储效率为 50%。</strong></p>
<h2 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h2><p>Base64 编码，顾名思义，是基于 64 个字符进行编码。规则如下：</p>
<ol>
<li>Base64 字符集（以标准 Base64 为例, 26 大写, 26 小写, 10 数字, 以及+、&#x2F;）为ABC…YZabc…yz012…89+&#x2F;；</li>
<li>每 6bit 为一组（2^6&#x3D;64），即<strong>每 3 个字节为 4 组</strong>；</li>
<li>每组映射为一个 Base64 字符；</li>
</ol>
<p>如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？**标准编码(StdEncoding)**会先在末尾用 0x00 补齐再分组，并将最后 2 个或 1 个 6bit 分组（全为 0 填充）映射为’&#x3D;’，表示补齐的 0 字节数量。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503267-8b0246bc-28ee-459b-8ad3-1d75de4e3f9d.webp" alt="img"></p>
<p>举个例子，以0x12 34 ab cd编码为标准 base64 为例：</p>
<ol>
<li>不足 3 的倍数，先用两个 0 字节补齐 –&gt;0x12 34 ab cd 00 00</li>
<li>0x12 34 ab编码为EjSr</li>
<li>0xcd 00 00二进制为0b1100 1101 0000 0000 0000 0000，分为 4 组后为110011 010000 000000 000000，编码结果为zQ&#x3D;&#x3D;</li>
<li>最终编码结果为EjSrzQ&#x3D;&#x3D;</li>
</ol>
<p>解码过程注意末尾字节的处理即可，此处不再赘述。</p>
<ol>
<li>EjSrzQ&#x3D;&#x3D;–&gt;0x12 34 ab cd 00 00–&gt;0x12 34 ab cd</li>
</ol>
<p><strong>标准编码中编码结果字符长度一定是 4 的倍数，且是原始数据字节数的 4&#x2F;3 倍</strong>，因为会将字节数据补齐至 3 的倍数，每 3 个字节编码为 4 个字符。**在 ASCII 或 UTF-8 编码下，存储结果字符串需要的空间是原始数据的 4&#x2F;3 倍，存储效率为 75%**。</p>
<p>根据字符集的不同，Base64 编码有几个变种，除了标准编码（StdEncoding），常见的还有 URL 编码（URLEncoding）、原始标准编码（RawStdEncoding）以及原始 URL 编码（RawUrlEncoded）。</p>
<p>简单来说，Raw 指的是无 Padding，URL 指的是用-和_取代编码结果中包含的 url 关键字+和&#x2F;。不妨参考 Golang 中encoding&#x2F;base64包中的描述：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StdEncoding is the standard base64 encoding, as defined in</span></span><br><span class="line"><span class="comment">// RFC 4648.</span></span><br><span class="line"><span class="keyword">var</span> StdEncoding = NewEncoding(*encodeStd*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// URLEncoding is the alternate base64 encoding defined in RFC 4648.</span></span><br><span class="line"><span class="comment">// It is typically used in URLs and file names.</span></span><br><span class="line"><span class="keyword">var</span> URLEncoding = NewEncoding(*encodeURL*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RawStdEncoding is the standard raw, unpadded base64 encoding,</span></span><br><span class="line"><span class="comment">// as defined in RFC 4648 section 3.2.</span></span><br><span class="line"><span class="comment">// This is the same as StdEncoding but omits padding characters.</span></span><br><span class="line"><span class="keyword">var</span> RawStdEncoding = StdEncoding.WithPadding(*NoPadding*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.</span></span><br><span class="line"><span class="comment">// It is typically used in URLs and file names.</span></span><br><span class="line"><span class="comment">// This is the same as URLEncoding but omits padding characters.</span></span><br><span class="line"><span class="keyword">var</span> RawURLEncoding = URLEncoding.WithPadding(*NoPadding*)</span><br></pre></td></tr></table></figure>

<p>与标准编码不同的是，<strong>原始编码中，字节数不足 3 的倍数时不会补齐字节数</strong>，采用如下方案：</p>
<ol>
<li>如果剩余 1 字节，则左移 4bit 后转换为 2 字符；</li>
<li>如果剩余 2 字节，则左移 2bit 后转化为 3 字符；</li>
</ol>
<p>即<strong>原始编码方案中，结果字符串长度可以不是 4 的倍数</strong>。</p>
<p>Hex 编码可以看成“Base16 编码”。随着字符数量的增加，存储效率也随之增加。如果有“Base256”编码，存储效率岂不就 100%了？很遗憾，主流字符编码中，单字节能表示的可打印字符只有 92 个。通过扩充多字节字符，或用组合字符实现 base256 意义不大。</p>
<h2 id="Golang-中的二进制编码"><a href="#Golang-中的二进制编码" class="headerlink" title="Golang 中的二进制编码"></a>Golang 中的二进制编码</h2><p>看一下 Golang 中 Base64 编码的实现。首先通过EncodedLen方法确定结果长度，生成输出buf，然后通过Encode方法将编码结果填充到buf并返回结果字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EncodeToString returns the base64 encoding of src.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodeToString(src []<span class="type">byte</span>) <span class="type">string</span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, enc.EncodedLen(<span class="built_in">len</span>(src)))</span><br><span class="line">    enc.Encode(buf, src)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前述，标准编码和原始编码（无 Padding）的结果长度不同：如果需要 Padding，直接根据字节数计算即可，反之则需要根据 bit 数计算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EncodedLen returns the length in bytes of the base64 encoding</span></span><br><span class="line"><span class="comment">// of an input buffer of length n.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodedLen(n <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> enc.padChar == *NoPadding* &#123;</span><br><span class="line">        <span class="keyword">return</span> (n*<span class="number">8</span> + <span class="number">5</span>) / <span class="number">6</span> <span class="comment">// minimum # chars at 6 bits per char</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">2</span>) / <span class="number">3</span> * <span class="number">4</span> <span class="comment">// minimum # 4-char quanta, 3 bytes each</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Encode方法实现了编码细节。首先遍历字节数组，将每 3 个字节编码为 4 个字符。最后处理剩余的 1 或 2 个字节（如有）：首先使用移位运算进行 0bit 填充，然后进行字符转换。如前述，无 Padding 时，剩下 1 字节对应 2 字符，剩下 2 字节对应 3 字符，即至少会有 2 字符。最后在switch代码段中，根据剩余字节数填充第 3 个字符和 Padding 字符（如有）即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> Encode(dst, src []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(src) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// enc is a pointer receiver, so the use of enc.encode within the hot</span></span><br><span class="line">    <span class="comment">// loop below means a nil check at every operation. Lift that nil check</span></span><br><span class="line">    <span class="comment">// outside of the loop to speed up the encoder.</span></span><br><span class="line">    _ = enc.encode</span><br><span class="line">    di, si := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    n := (<span class="built_in">len</span>(src) / <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> si &lt; n &#123;</span><br><span class="line">        <span class="comment">// Convert 3x 8bit source bytes into 4 bytes</span></span><br><span class="line">        val := <span class="type">uint</span>(src[si+<span class="number">0</span>])&lt;&lt;<span class="number">16</span> | <span class="type">uint</span>(src[si+<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="type">uint</span>(src[si+<span class="number">2</span>])</span><br><span class="line">        dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        dst[di+<span class="number">3</span>] = enc.encode[val&amp;<span class="number">0x3F</span>]</span><br><span class="line">        si += <span class="number">3</span></span><br><span class="line">        di += <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    remain := <span class="built_in">len</span>(src) - si</span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add the remaining small block</span></span><br><span class="line">    val := <span class="type">uint</span>(src[si+<span class="number">0</span>]) &lt;&lt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">if</span> remain == <span class="number">2</span> &#123;</span><br><span class="line">        val |= <span class="type">uint</span>(src[si+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">    dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">    dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">    <span class="keyword">switch</span> remain &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]</span><br><span class="line">        <span class="keyword">if</span> enc.padChar != *NoPadding* &#123;</span><br><span class="line">            dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> enc.padChar != *NoPadding* &#123;</span><br><span class="line">            dst[di+<span class="number">2</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">            dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>引言：拿到两个字节，如何解析为整形？</p>
<ul>
<li>Step1：明确字节高低位顺序</li>
<li>Step2：按高低位权重计算结果</li>
</ul>
<p>上述二进制编码主要用于文本传输，能不能不进行编码，直接传输二进制？当然可以，基于二进制传输协议，如 TCP 协议。那么什么是文本传输，什么是二进制传输？简单来说，文本传输，内容为文本，自带描述信息（参数名），如 HTTP 中的字段都以 KV 形式存在。二进制传输，内容为二进制，<strong>以预先定义好的格式拼在一起</strong>，如 TCP 协议报文格式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503068-102c03a4-c199-46de-89b9-c782f90e6276.webp" alt="img"></p>
<h3 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h3><p>聊到二进制传输，一个避不开的话题是<strong>字节序</strong>。什么是字节序？假设读取到一个两字节的 uint16 0x04 0x00，如果从左往右（从高位往低位）解码，得到的是 1024，反过来（从低位往高位）解码则是 4，这就是字节序。<strong>符合人类阅读习惯的（从高位往低位）是大端（BigEndian），反之为小端（LittleEndian）。</strong></p>
<p>另一种大小端的定义：LittleEndian 将低序字节存储在低地址，BigEndian 将高序字节存储在低地址。理解起来有些抽象，本质上是一致的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/396745/1618536503204-018229fe-0d8f-4474-a462-71454212094c.webp" alt="img"></p>
<p>为什么会有小端字节序，统一都用大端不好么？</p>
<p>计算机不这么想，因为计算机中计算都是从低位开始的，电路先处理低位字节效率比较高。但是，人类还是习惯读写大端字节序。所以，<strong>除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</strong></p>
<p>那什么时候程序员需要进行字节序处理呢？当多字节整形（uint16，uint32，uint64）需要和字节数组互相转换时。<strong>字节数组是无字节序的，客户端写入啥，服务端就读取啥，不会出现逆序，写入和读取无需考虑字节序，这点大可放心</strong>。<strong>只有当多字节整形和字节数组互转时必须指明字节序。</strong></p>
<h2 id="Golang-中的字节序"><a href="#Golang-中的字节序" class="headerlink" title="Golang 中的字节序"></a>Golang 中的字节序</h2><p>以 uint16 与字节数组互转为例，看一下 Golang 中 encoding&#x2F;binary 包中的字节序处理与实现。可见实现并不复杂，注意字节顺序即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEndian</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    bytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.LittleEndian.PutUint16(bytes, <span class="number">1024</span>) <span class="comment">// 小端写 --&gt; 0x0004</span></span><br><span class="line">    binary.BigEndian.PutUint16(bytes, <span class="number">1024</span>) <span class="comment">// 大端写 --&gt; 0x0400</span></span><br><span class="line">    binary.LittleEndian.Uint16(bytes) <span class="comment">// 小端读 --&gt; 4</span></span><br><span class="line">    binary.BigEndian.Uint16(bytes) <span class="comment">// 大端读 --&gt; 1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(littleEndian)</span></span> PutUint16(b []<span class="type">byte</span>, v <span class="type">uint16</span>) &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// early bounds check to guarantee safety of writes below</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="type">byte</span>(v)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="type">byte</span>(v &gt;&gt; <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bigEndian)</span></span> PutUint16(b []<span class="type">byte</span>, v <span class="type">uint16</span>) &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// early bounds check to guarantee safety of writes below</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="type">byte</span>(v &gt;&gt; <span class="number">8</span>)</span><br><span class="line">    b[<span class="number">1</span>] = <span class="type">byte</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(littleEndian)</span></span> Uint16(b []<span class="type">byte</span>) <span class="type">uint16</span> &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// bounds check hint to compiler; see golang.org/issue/14808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint16</span>(b[<span class="number">0</span>]) | <span class="type">uint16</span>(b[<span class="number">1</span>])&lt;&lt;<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bigEndian)</span></span> Uint16(b []<span class="type">byte</span>) <span class="type">uint16</span> &#123;</span><br><span class="line">    _ = b[<span class="number">1</span>] <span class="comment">// bounds check hint to compiler; see golang.org/issue/14808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint16</span>(b[<span class="number">1</span>]) | <span class="type">uint16</span>(b[<span class="number">0</span>])&lt;&lt;<span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战：加解密中的编码与字节序"><a href="#实战：加解密中的编码与字节序" class="headerlink" title="实战：加解密中的编码与字节序"></a>实战：加解密中的编码与字节序</h2><p>在加解密场景中，通常会对<strong>明文</strong>加密得到<strong>密文</strong>，对密文解密得到明文。比如对密码”123456”（明文）进行<strong>对称加密</strong>（如 SM4）得到”G7EeTPnuvSU41T68qsuc_g”（密文）。<strong>明文和密文都是由可打印字符构成的文本</strong>，通常明文人类可直接阅读其含义（不考虑二次加密），密文需要解密后才能理解含义。</p>
<p>那么上述明文变成密文，期间经历了哪些编码过程呢？以加密为例：</p>
<ol>
<li>将明文”123456”进行字符解码（如 UTF-8），得到<strong>明文字节序列</strong>0x31 32 33 34 35 36;</li>
<li>将明文字节序列输入 SM4 加密算法，输出<strong>密文字节序列</strong>0x1b b1 1e 4c f9 ee bd 25 38 d5 3e bc aa cb 9c fe；</li>
<li>将密文字节序列进行二进制编码（如 RawURLBase64），得到密文”G7EeTPnuvSU41T68qsuc_g”；</li>
</ol>
<p>同理，将”G7EeTPnuvSU41T68qsuc_g”解密成”123456”过程中，应与加密过程的编码方式对应：先进行 RawRULBase64 解码，再解密，最后再进行 UTF-8 编码。</p>
<p>加解密算法的输入输出都是字节序列，所以要将明文、密文与字节序列进行转换。有两点需要注意：</p>
<ol>
<li><strong>明文解码为明文字节序列，解码方式因场景而定</strong>。对于多次加密场景（如对“G7EeTPnuvSU41T68qsuc_g”再次加密），明文是 Base64 编码得到的，建议采用一致的方式解码。虽然也可以直接进行 UTF-8 解码，但会使加解密流程设计变得复杂。</li>
<li><strong>密文字节序列编码为密文，必须用二进制编码，不能用字符编码</strong>。使用字符编码会产生乱码（意味着数据丢失，无法逆向解码出原始数据）。上述密文序列密文序列进行 UTF-8 编码的结果是 �L���%8�&gt;��˜�。</li>
</ol>
<p>合规要求，加解密场景中应使用<strong>硬件加密机</strong>。通常硬件加密机提供<strong>基于 TCP 的字节流通信方式</strong>，比如约定每次通信数据中的前 2 字节为数据长度，后面的为真实数据。发送时，需要将真实数据长度转为 2 字节拼在前面，接收时，需要先读取前两字节得到真实数据长度 N，再读取 N 字节得到真实数据。其中<strong>长度与字节序列的转换需要关注字节序：发送方和接收方的字节序处理保持一致</strong>即可，比如全用大端。下面给出了数据发送的示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *EncryptMachine)</span></span> sendData(conn net.Conn, data []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// add length</span></span><br><span class="line">    newData := m.addLength(data)</span><br><span class="line">    <span class="comment">// send new data</span></span><br><span class="line">    <span class="keyword">return</span> util.SocketWriteData(conn, newData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *EncryptMachine)</span></span> addLength(data []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">    lengthBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    binary.BigEndian.PutUint16(lengthBytes, <span class="type">uint16</span>(<span class="built_in">len</span>(data)))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(lengthBytes, data...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>编码虽然基础，但却容易出错，切莫眼高手低。希望本文能帮助大家进一步了解字符编码、二进制编码与字节序，避免踩坑。</p>
<p><strong>未完，待续</strong></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://3546514206.github.io/2023/09/04/Go%E8%87%AA%E5%B8%A6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/09/04/RobPike%E8%B0%88GoogGo/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            RobPike谈GoogGo
          
        </div>
      </a>
    
    
      <a href="/2023/09/04/Go%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Go语言参考手册</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> 杨海波（勤奋的全栈开发工程师）
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/SETSUNAYANG.JPG" alt="杨海波（勤奋的全栈开发工程师）"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://github.com/3546514206">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>