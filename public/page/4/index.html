<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 杨海波</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/SETSUNAYANG.JPG" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/3546514206"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">杨海波</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['大丈夫身居天地之间，岂能郁郁久居人下？', '即使处于逆境，也当屈身守分，以待天时。', '夫英雄者，胸怀大志，富有良策，有包藏宇宙之机，吞吐天地之志也！'],
        startDelay: 2,
        typeSpeed: 100,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">第一性原理、长期主义者</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JVM参数概览"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/03/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88/"
    >JVM参数概览(JDK8)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/03/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88/" class="article-date">
  <time datetime="2023-11-03T02:44:38.000Z" itemprop="datePublished">2023-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88(JDK8)/JVM%E5%8F%82%E6%95%B0%E6%A6%82%E8%A7%88(JDK8).png" alt="JVM参数概览(JDK8)"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0/" rel="tag">虚拟机参数</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux性能工具"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/25/Linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/"
    >Linux性能工具</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/25/Linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2023-10-24T16:10:14.000Z" itemprop="datePublished">2023-10-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="性能工具谱图"><a href="#性能工具谱图" class="headerlink" title="性能工具谱图"></a><strong>性能工具谱图</strong></h4><p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/Linux%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88.png" alt="性能工具谱图"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-TCP报文结构和功能简析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/15/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/"
    >TCP报文结构和功能简析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/15/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/" class="article-date">
  <time datetime="2023-09-15T02:38:09.000Z" itemprop="datePublished">2023-09-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a><strong>1、简介</strong></h2><p>&ensp;&ensp;&ensp;&ensp; TCP：传输、控制、协议。</p>
<p>&ensp;&ensp;&ensp;&ensp; TCP 与UDP 最大却别就在那个C上面，它充分实现了数据传输时各种控制功能。可以进行丢包重发控制，还可以对次序乱掉的数据包进行顺序控制，还能控制传输流量，这些是UDP中没有的。即 TCP 提供一种面向连接的、可靠的字节流服务。TCP 是一中面向有链接的协议，只有在确认对端存在的时候，才会发送分数据，从而也可以控制通信流量的浪费。</p>
<p>&ensp;&ensp;&ensp;&ensp; 什么是可靠的传输：不丢包、不损坏、不乱序、不重复。TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制来实现可靠传输。接收端查询就收数据 TCP 首部中的序号和数据长度。将自己下一步应该接受的序列号作为确认应答返送回去。就这样，通过序列号和确认应答，TCP 实现可靠传输。一般使用 TCP 首部用于控制的字段来管理连接。一个连接的建立和断开，正常过程中，至少需要来回共 7 个包才能完成。</p>
<h2 id="2、TCP首部"><a href="#2、TCP首部" class="headerlink" title="2、TCP首部"></a><strong>2、TCP首部</strong></h2><p>&ensp;&ensp;&ensp;&ensp; TCP首部的数据结构如图所示：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/TCP%E9%A6%96%E9%83%A8.webp" alt="TCP首部"></p>
<p>&ensp;&ensp;&ensp;&ensp; 为了便于理解，忽略选项部分，固定首部通常为20个字节，将按作用分类分析。</p>
<h4 id="2-1、端口号-port"><a href="#2-1、端口号-port" class="headerlink" title="2.1、端口号(port)"></a><strong>2.1、端口号(port)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 前 4 个字节来标识了发送方的端口号和接收方的端口号，即该数据包由谁发送，由谁接收。前 2 个字节标识源端口号，紧接着 2 个字节标识目的端口号。</p>
<p>&ensp;&ensp;&ensp;&ensp; 即发送方：(11111111,1111111)2 &#x3D; (65535)10，除去0~1023。</p>
<p>&ensp;&ensp;&ensp;&ensp; 即接收方：(11111111,1111111)2 &#x3D; (65535)10，除去0~1023。</p>
<h4 id="2-2、序号-seq"><a href="#2-2、序号-seq" class="headerlink" title="2.2、序号(seq)"></a><strong>2.2、序号(seq)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。长度为 4 字节，序号是 32bit 的无符号数,序号到达 2(32次方) - 1 后又从 0 开始。</p>
<h4 id="2-3、确认号-ack"><a href="#2-3、确认号-ack" class="headerlink" title="2.3、确认号(ack)"></a><strong>2.3、确认号(ack)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; ack：确认序号，即确认字节的序号，更确切地说，是发送确认的一端所期望收到的下一个序号。所谓的发送确认的一端就是将确认信息发出的一端。比如第二次握手的S端就是发送确认的一端。确认序号为上次接收的最后一个字节序号加1.只有确认标志位(ACK)为1的时候，确认序号才有效。</p>
<h4 id="2-4、数据偏移"><a href="#2-4、数据偏移" class="headerlink" title="2.4、数据偏移"></a><strong>2.4、数据偏移</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 也叫首部长度，占4个bit,它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD%E7%AE%80%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB.webp" alt="TCP首部"></p>
<p>&ensp;&ensp;&ensp;&ensp; 由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。“首部长度”是 4 位二进制数，单位是32位字，能表示的最大十进制数字是 15。(1111)2&#x3D;(15)10,即是 15 个 32 位，一个 32 位是 4 个字节，因此数据偏移的最大值是 15x4&#x3D;60 个字节，这也是 TCP 首部的最大字节。因为固定首部的存在，数据偏移的值最小为20个字节，因此选项长度不能超过40字节*（减去20个字节的固定首部）。</p>
<h4 id="2-5、保留-reserve"><a href="#2-5、保留-reserve" class="headerlink" title="2.5、保留(reserve)"></a><strong>2.5、保留(reserve)</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占 6 位，保留为今后使用，但目前应置为 0。</p>
<h4 id="2-6、紧急URG（urgent）"><a href="#2-6、紧急URG（urgent）" class="headerlink" title="2.6、紧急URG（urgent）"></a><strong>2.6、紧急URG（urgent）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当 URG&#x3D;1 时，表明紧急指针字段有效。</p>
<p>&ensp;&ensp;&ensp;&ensp; 它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。</p>
<p>&ensp;&ensp;&ensp;&ensp; 例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。</p>
<p>&ensp;&ensp;&ensp;&ensp; 当 URG 置为 1 时，应用进程就告诉 TCP 有紧急数据要传送。于是 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p>
<h4 id="2-7、确认ACK（acknowledgment）"><a href="#2-7、确认ACK（acknowledgment）" class="headerlink" title="2.7、确认ACK（acknowledgment）"></a><strong>2.7、确认ACK（acknowledgment）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 仅当ACK &#x3D; 1时确认号字段才有效，当ACK &#x3D; 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
<h4 id="2-8、推送-PSH（push）"><a href="#2-8、推送-PSH（push）" class="headerlink" title="2.8、推送 PSH（push）"></a><strong>2.8、推送 PSH（push）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p>
<h4 id="2-9、复位RST（reset）"><a href="#2-9、复位RST（reset）" class="headerlink" title="2.9、复位RST（reset）"></a><strong>2.9、复位RST（reset）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 当RST&#x3D;1时，表明TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
<h4 id="2-10、同步SYN（synchronization）"><a href="#2-10、同步SYN（synchronization）" class="headerlink" title="2.10、同步SYN（synchronization）"></a><strong>2.10、同步SYN（synchronization）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1。</p>
<p>&ensp;&ensp;&ensp;&ensp; 因此SYN&#x3D;1就表示这是一个连接请求或连接接受报文。</p>
<h4 id="2-11、终止FIN（finis，意思是“完”“终”）"><a href="#2-11、终止FIN（finis，意思是“完”“终”）" class="headerlink" title="2.11、终止FIN（finis，意思是“完”“终”）"></a><strong>2.11、终止FIN（finis，意思是“完”“终”）</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
<h4 id="2-12、窗口"><a href="#2-12、窗口" class="headerlink" title="2.12、窗口"></a><strong>2.12、窗口</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占2字节。窗口值是(0，216 -1)之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）,窗口大小是给对方用的。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方一次发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<p>&ensp;&ensp;&ensp;&ensp; 总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<p>&ensp;&ensp;&ensp;&ensp; 例如，A发送了一个报文段，其确认号是3000，窗口字段是1000.这就是告诉对方B：“从3000算起，A接收缓存空间还可接受1000个字节数据，字节序号是3000-3999”，可以想象到河道的阀门。</p>
<p>&ensp;&ensp;&ensp;&ensp; 总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p>
<h4 id="2-13、检验和"><a href="#2-13、检验和" class="headerlink" title="2.13、检验和"></a><strong>2.13、检验和</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。</p>
<h4 id="2-14、紧急指针"><a href="#2-14、紧急指针" class="headerlink" title="2.14、紧急指针"></a><strong>2.14、紧急指针</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p>
<h4 id="2-15、选项"><a href="#2-15、选项" class="headerlink" title="2.15、选项"></a><strong>2.15、选项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 长度可变，最长可达40个字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<h4 id="2-16、最大报文段长度"><a href="#2-16、最大报文段长度" class="headerlink" title="2.16、最大报文段长度"></a><strong>2.16、最大报文段长度</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 最大报文段长度(MSS:Maximum Segment Size)表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。</p>
<p>&ensp;&ensp;&ensp;&ensp; 当建立一个连接时，每一方都有用于通告它期望接收的MSS选项(MSS选项只能出现在SYN报文段中),如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节(这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报) 。</p>
<p>&ensp;&ensp;&ensp;&ensp; 为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1&#x2F;41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。<br>&ensp;&ensp;&ensp;&ensp; 因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。</p>
<p>&ensp;&ensp;&ensp;&ensp; 由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）&#x3D;556字节。</p>
<p>&ensp;&ensp;&ensp;&ensp; 后来又增加了几个选项如窗口扩大选项、时间戳选项等。</p>
<h4 id="2-17、窗口扩大选项"><a href="#2-17、窗口扩大选项" class="headerlink" title="2.17、窗口扩大选项"></a><strong>2.17、窗口扩大选项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 窗口扩大选项是为了扩大窗口。</p>
<p>&ensp;&ensp;&ensp;&ensp; 我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。</p>
<p>&ensp;&ensp;&ensp;&ensp; 窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2（16+14）-1&#x3D;230-1。</p>
<p>&ensp;&ensp;&ensp;&ensp; 窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S&#x3D;0选项，使窗口大小回到16。</p>
<h4 id="2-18、时间戳选项"><a href="#2-18、时间戳选项" class="headerlink" title="2.18、时间戳选项"></a><strong>2.18、时间戳选项</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：</p>
<p>&ensp;&ensp;&ensp;&ensp; 第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。</p>
<p>&ensp;&ensp;&ensp;&ensp; 第二、 用于处理TCP序号超过232 的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加232 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit&#x2F;s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit&#x2F;s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IP%E6%95%B0%E6%8D%AE%E6%8A%A5/" rel="tag">IP数据报</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-数据链路层"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"
    >数据链路层</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="article-date">
  <time datetime="2023-09-14T03:13:53.000Z" itemprop="datePublished">2023-09-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a><strong>1、概述</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 数据链路层是TCP&#x2F;IP协议栈的第二层！数据链路层的传输单元：帧（也就是传输单位）。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.webp" alt="数据链路层"></p>
<p>&ensp;&ensp;&ensp;&ensp; 帧的结构如下：</p>
<ul>
<li>帧结构的构成：MAC子层 + 上三层数据 + FCS</li>
</ul>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="帧结构"></p>
<ul>
<li>比喻：一个帧我们可以理解为一辆火车，MAC子层是火车头，上三层数据为乘客，FCS为火车尾巴</li>
<li>MAC子层头部包含（也叫帧头）：目标MAC地址（6字节） 源MAC地址（6字节） 类型（2字节）</li>
<li>MAC地址：也称为物理地址，是被固化到网卡的全球唯一标识，如下图：</li>
</ul>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/mac%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="Mac 地址结构"></p>
<p>&ensp;&ensp;&ensp;&ensp; <em>注释：MAC地址&#x3D;厂家标识+内部编号&#x3D;&#x3D;&#x3D;&#x3D;实现了全球唯一！怎么查看自己的MAC地址？开始运行–cmd–ipconfig &#x2F;all</em></p>
<ul>
<li>类型字段的作用：区分上层协议，0806代表上层协议是ARP协议，0800代表上层是IP协议</li>
<li>上三层数据：也就是3层包头+4层包头+5层数据。其中一个帧是有最大承载能力限制的。也就是一个帧中的上三层数据就是乘客，而一辆火车中的乘客是又上限的，一个帧的最大承受能力叫MTU值，目前国际标准为1500字节</li>
<li>MTU:（最大传输单元）1500字节</li>
<li>帧尾：FCS&#x3D;帧校验，长度4个字节，作用是校验整个帧在传输过程中是否发生传输错误。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 帧结构最终效果图如下：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7%E7%BB%93%E6%9E%84%E6%95%88%E6%9E%9C%E5%9B%BE2.png" alt="帧结构效果图"></p>
<p>&ensp;&ensp;&ensp;&ensp; <em>经典问题：请描述一下帧结构?</em></p>
<p>&ensp;&ensp;&ensp;&ensp; <em>答：帧是由帧头+上三层数据+帧尾，帧头包含目MAC，源MAC，类型，帧尾是FCS，MTU：1500</em></p>
<h4 id="2、本层设备"><a href="#2、本层设备" class="headerlink" title="2、本层设备"></a><strong>2、本层设备</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 工作在2层的设备：交换机&#x2F;网桥</p>
<h4 id="3、交换机的工作原理"><a href="#3、交换机的工作原理" class="headerlink" title="3、交换机的工作原理"></a><strong>3、交换机的工作原理</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 经典问题：请描述一下交换机的工作原理。</p>
<p>&ensp;&ensp;&ensp;&ensp; 答：</p>
<p>&ensp;&ensp;&ensp;&ensp; 1）当收到一个帧，首先学习帧中的MAC地址来形成自己的MAC地址表！</p>
<p>&ensp;&ensp;&ensp;&ensp; 2）然后检查帧中的目标MAC地址，并匹配MAC地址表。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 如表中匹配成功，则单播转发！</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 如表中无匹配项，则广播转发！</p>
<p>&ensp;&ensp;&ensp;&ensp; 3）MAC地址表的老化时间是？300秒！</p>
<p>&ensp;&ensp;&ensp;&ensp; 效果图如下：</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.webp" alt="交换机的工作原理"></p>
<h4 id="4、如何配置交换机"><a href="#4、如何配置交换机" class="headerlink" title="4、如何配置交换机"></a><strong>4、如何配置交换机</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 傻瓜式交换机一般是不支持管理和配置的！企业级交换机支持配置高级功能及高级配置，价格要高，一般称为管理型交换机！如购买一台华为或者思科交换机，看下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA.webp" alt="交换机"></p>
<p>&ensp;&ensp;&ensp;&ensp; 一般会自带一根console线！看下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/console%E7%BA%BF.webp" alt="console线"></p>
<p>&ensp;&ensp;&ensp;&ensp; 建议再买一根com口转USB线，看下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/com%E5%8F%A3%E8%BD%ACUSB%E7%BA%BF.webp" alt="com口转USB线"></p>
<p>&ensp;&ensp;&ensp;&ensp; 使用console线+转换usb线，来连接交换机的console口与电脑的USB接口，如下图:</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E7%BA%BF.webp" alt="交换机接线"></p>
<p>&ensp;&ensp;&ensp;&ensp; 然后再电脑上打开超级终端（xp上自带，win7另行下载即可），即可看到配置界面。当然我们可以使用思科的模拟软件来做实验，如cisco packettracer</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" rel="tag">数据链路层</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-谈谈云原生"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/13/%E8%B0%88%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F/"
    >谈谈云原生</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/13/%E8%B0%88%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F/" class="article-date">
  <time datetime="2023-09-13T00:52:00.000Z" itemprop="datePublished">2023-09-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B/">工程</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>&ensp;&ensp;&ensp;&ensp; 之前关于云计算技术底座的部门会谈，我本着程序员实事求是的态度，表示自己其实并不懂云原生。前段时间云技术底座的模型验证，遇到一个测试案例叫做“白屏纳管”，意思是指 CAAS 平台能够对包括云下硬件负载 F5、A10，云上 SLB 等设备进行管理。云原生技术有着太多的这种花里胡哨的名词，将本来很简单的一件事情包装出个能吓住人的词，来提高理解的门槛。作为一个一线开发，我有一种很深切的感受：很多优秀的设计，都是有着简洁优雅的设计原理或者说思想蕴含其中。这种没什么太多内涵的毫无意义的造词运动，对于工程实践，没有任何好处。我们不应该人云亦云盲目从众，也不应该以偏概全一叶障目。</p>
<p>&ensp;&ensp;&ensp;&ensp; 以下是阿里云公众号某产品经理关于云原生的解释，我截了图如下：</p>
<p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E5%8E%9F%E7%94%9F/%E8%B0%88%E8%B0%88%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9F%90%E6%96%87%E7%AB%A0.jpg" alt="阿里云云原生公众号某文章"></p>
<p>&ensp;&ensp;&ensp;&ensp; 这段话讲得没有问题，但是似乎又什么都没讲，对于云原生的定义，这种似是而非的说法显然不是一线开发人员想要的答案。</p>
<p>&ensp;&ensp;&ensp;&ensp; 我们在说云原生的时候，其实是在说“云原生计算”，云原生这个词其实可以拆为“云”和”原生“两个词，这其中其实隐藏了一个词——“云计算”。<strong>云原生一定是云计算，</strong> 这就要求我们事先已经对云计算的发展历史有所了解。云原生与云计算的区别便在“原生”二字上，那么理解云原生，重点就在理解其为何为“原生”。我这里用一句话来总结云原生：云原生是为了发挥出云计算所有优势的最短路径（这句精辟的提炼摘自《阿里云云原生架构实践》一书）。</p>
<p>&ensp;&ensp;&ensp;&ensp; 这些想法和做法归纳为三个方面：应用架构、计算模型、代表技术。</p>
<ul>
<li><p><strong>代表技术</strong> 是最容易理解的。代表技术可以是一些狭义上的云原生基础设施，包含了相关的软件或硬件技术，例如裸金属、docker、K8S；也可以是泛化的一些工程技术体系，比如 Spring Cloud，DevOps，DDD ——它们与云基础设施不一样，很多并非为了云原生而生的，但是在云上环境表现活跃，也可以归纳到云原生代表技术中来。有些人说，使用了容器技术，就是云原生，这肯定是不准确的。容器其实只是改变了我们应用的部署方式，应用运行时的形态，以此来定义云原生是非常片面的。</p>
</li>
<li><p><strong>计算模型，</strong> 既然这个行业这么喜欢遣词造句，那我也造几个词（切，谁还不会啊！！！）。计算模型可以从两个方面来看：</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; <strong>计算的服务模型：</strong> 计算的服务模型是从商业的角度看的。我们从传统的购买硬件送软件，到购买软件和维护再到如今购买云服务，云计算平台将计算、存储、网络像煤电一样卖给我们。需要指出，计算资源的这种服务模型并不是在云原生中才强调的，而是从云计算提出的时候，就已经强调了的。</p>
<p>&ensp;&ensp;&ensp;&ensp; <strong>服务的计算模型：</strong> 这个语境中，“服务”不再是商业上的“服务”，而是指“应用服务”。应用服务的计算模型，强调了应用程序的可伸缩性、弹性、自动化和可维护性，以适应现代云环境中的需求。当然，应用的可伸缩、弹性自动化运维这些并不是应用自身具备的能力，而是在云上环境被赋予的，但是需要从应用侧做一定的改造工作，“以适应现代云环境中的需求”，比如下面要说的——应用架构。</p>
<ul>
<li><strong>应用架构</strong> 为了最大化发挥云原生的计算优势，应用侧应该也要做架构升级——例如微服务化，在弹性扩缩的时候以更细的粒度进行算力分配，更精确的分配云计算底座资源（计算、存储、网络）——当然，这只是我简单作示意的一种说法。这种说法换个侧面来看，单体应用就不能上云计算么？当然可以，但是那就不叫云原生了，因为单体无法发挥出云计算的最大优势。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 所以从我自己目前的工作经历总结如下： <strong>云原生一定是云计算，特别的，云原生是有效发挥出云计算所有优势的最短路径。理解云原生，可以从代表技术、云原生计算模型、云原生应用架构三方面着手理解。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%A2%86%E5%9F%9F/" rel="tag">云计算领域</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-一种git分支模型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/10/%E4%B8%80%E7%A7%8Dgit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/"
    >一种git分支模型</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/10/%E4%B8%80%E7%A7%8Dgit%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2023-09-09T18:49:28.000Z" itemprop="datePublished">2023-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B/">工程</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E7%A8%8B/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="/pic/%E5%B7%A5%E7%A8%8B/%E5%B7%A5%E5%85%B7/git/%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B.png" alt="git 分支模型"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/" rel="tag">分支模型</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-设计模式之模板方法模式和策略模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"
    >设计模式之模板方法模式和策略模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2023-09-09T05:28:20.000Z" itemprop="datePublished">2023-09-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>&ensp;&ensp;&ensp;&ensp; 这篇博客的设计模式应用案例来自于这个仓库，完整代码可以参考本仓库：</p>
<p>&ensp;&ensp;&ensp;&ensp; <a target="_blank" rel="noopener" href="https://github.com/3546514206/WxChatGPT">微信大模型接入</a></p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E4%BB%93%E5%BA%93.png" alt="仓库主页"></p>
<p>&ensp;&ensp;&ensp;&ensp; 简单介绍一下这个仓库：1）实现了微信接入；2）实现了大模型接入；3）将微信的提问发给大模型，将大模型的回答返回给微信（欢迎给个 star）。</p>
<h4 id="1、背景分析"><a href="#1、背景分析" class="headerlink" title="1、背景分析"></a><strong>1、背景分析</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 1）我们预期接入的大模型肯定不止一种，现在市面上除了最牛的 GhatGPT，国内也陆续退出了豆包、文心一言、星火大模型等。为了获得良好的扩展性，我们可以基于策略模式对模型通讯模块进行封装，将不同的模型定义为一种通讯策略，程序中可以通过参数指定不同的模型工作；</p>
<p>&ensp;&ensp;&ensp;&ensp; 2）通讯的过程无非就是三个阶段：通信前参数组装、进行通讯、通讯完成处理结果，这里显然是可以通过模板方法进行封装的。结合策略模式，我们可以规定将来接入新模型的时候，有统一的代码组织形式和良好的扩展接口。</p>
<h4 id="2、知识补充"><a href="#2、知识补充" class="headerlink" title="2、知识补充"></a><strong>2、知识补充</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 我们这里不再对设计模式本身进行专门的讲解。</p>
<p>&ensp;&ensp;&ensp;&ensp; <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/strategy-pattern.html">策略模式</a></p>
<p>&ensp;&ensp;&ensp;&ensp; <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/template-pattern.html">模板方法模式</a></p>
<h4 id="3、代码分析"><a href="#3、代码分析" class="headerlink" title="3、代码分析"></a><strong>3、代码分析</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 如下图所示，DefaultHandler 是程序写给微信接入模块的一个回调（实现了消息处理接口 IMsgHandlerFace），当微信接入模块接收到微信消息，便会触发此回调，执行用户预定义行为。也就是在这个地方，我们接入了大模型，并将模型的问答结果返回给微信。 </p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E7%9A%84%E5%9C%B0%E6%96%B9.png" alt="模型接入的地方"></p>
<p>&ensp;&ensp;&ensp;&ensp; 一下三行代码的作用分别是：获取聊天模型的策略上下文（请参考上文中菜鸟教程——策略模式），返回的策略上下文会包含具体的执行策略，执行策略的选择是程序参数定义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聊天模型策略</span></span><br><span class="line"><span class="type">StrategyContext</span> <span class="variable">context</span> <span class="operator">=</span> getStrategyContext();</span><br><span class="line"><span class="comment">// 构建聊天请求</span></span><br><span class="line"><span class="type">ChatRequest</span> <span class="variable">request</span> <span class="operator">=</span> buildChatRequest(msg);</span><br><span class="line"><span class="comment">// 进行聊天</span></span><br><span class="line"><span class="type">ChatResponse</span> <span class="variable">response</span> <span class="operator">=</span> context.executeStrategy(request);</span><br></pre></td></tr></table></figure>

<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B.png" alt="程序参数指定执行策略"></p>
<h4 id="3、策略模式实现"><a href="#3、策略模式实现" class="headerlink" title="3、策略模式实现"></a><strong>3、策略模式实现</strong></h4><p>&ensp;&ensp;&ensp;&ensp; 首先，定义策略接口，策略接口中的 exec 方法是所有具体的策略类都需要实现的。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3.png" alt="策略接口"></p>
<p>&ensp;&ensp;&ensp;&ensp; 定义策略上下文，上下文是统一交给用户侧的一个”句柄”（可以参考上文 DefaultHandler 的代码，用户侧通过获取策略上下文来执行具体的策略实现的），用于持有具体的策略实现。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="策略上下文"></p>
<p>&ensp;&ensp;&ensp;&ensp; 我们这里的策略实现类稍有不同，没有直接实现 exec 方法，也没有直接实现 IStrategy 接口。这涉及到另外一个设计模式——模板方法模式。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E7%B1%BB.png" alt="策略实现类"></p>
<h4 id="4、-模板方法模式"><a href="#4、-模板方法模式" class="headerlink" title="4、 模板方法模式"></a><strong>4、</strong> 模板方法模式</h4><p>&ensp;&ensp;&ensp;&ensp; 抽象策略类定义了一个算法模板方法，这个模板方法规定了 exec 方法执行时发生的三个算法步骤：postChatRequest (执行前的参数处理)、doExec (执行通讯请求)、postChatResponse(通讯完成之后的响应报文处理)。但是我并没有对这三个步骤进行实现，他们都是抽象的，延迟到了将来的策略实现类去实现。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E7%AD%96%E7%95%A5%E7%B1%BB.jpg" alt="抽象策略类"></p>
<p>&ensp;&ensp;&ensp;&ensp; 所有的策略实现类，实现的不是策略接口 IStrategy，而是继承抽象策略类 AbstractStrategy，也不再去实现 exec 方法，而是实现抽象类中算法模板规定的三个算法步骤。</p>
<p><img src="/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%88%B6%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.jpg" alt="实现抽象策略类中规定的三个既定步骤"></p>
<h4 id="5、-其他一些想法"><a href="#5、-其他一些想法" class="headerlink" title="5、 其他一些想法"></a><strong>5、</strong> 其他一些想法</h4><p>&ensp;&ensp;&ensp;&ensp; 面向对象语言最重要的三个基本特性：封装、多态、继承，是软件工程七大原则开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特原则和合成复用原则的重要支撑点，设计模式是一种如何最大化发挥三个基本特性，从而能够遵循七大原则的一种编码层级上的技术，这也是 Java、C++ 等完美支持 OOP 编程范式语言，在面临庞大复杂工程时，总能将源代码组织得很好的原因之一吧。从这个角度出发，Go 语言在多态、继承的表现力上不足，也许是因为我还比较缺乏 Go 开发的实战经验，所以我不确定在面临复杂的建模场景的时候，Go 语言的编程方式还能不能进行有效表达。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Go基础语法宝典"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9D%E5%85%B8/"
    >Go基础语法宝典</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9D%E5%85%B8/" class="article-date">
  <time datetime="2023-09-03T16:34:10.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言设计的关键字，了解这些关键字有助于命名变量的冲突避免</p>
<h3 id="go的二十五个关键字"><a href="#go的二十五个关键字" class="headerlink" title="go的二十五个关键字"></a>go的二十五个关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p><code>var</code>和<code>const</code> 是 Go语言基础里面的变量和常量申明</p>
</li>
<li><p><code>package</code>和<code>import</code> 用于分包和导入</p>
</li>
<li><p><code>func</code> 用于定义函数和方法</p>
</li>
<li><p><code>return</code> 用于从函数返回</p>
</li>
<li><p><code>defer</code> 用于类似析构函数</p>
</li>
<li><p><code>go</code> 用于并发</p>
</li>
<li><p><code>select</code> 用于选择不同类型的通讯</p>
</li>
<li><p><code>interface</code> 用于定义接口</p>
</li>
<li><p><code>struct</code> 用于定义抽象数据类型</p>
</li>
<li><p><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 用于流程控制</p>
</li>
<li><p><code>chan</code>用于channel通讯</p>
</li>
<li><p><code>type</code>用于声明自定义类型</p>
</li>
<li><p><code>map</code>用于声明map类型数据</p>
</li>
<li><p><code>range</code>用于读取slice、map、channel数据</p>
</li>
</ul>
<h1 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Go语言里面定义变量有多种方式。</p>
<p>使用<code>var</code>关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义多个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义三个类型都是“type”的变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义变量并初始化值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>

<p>同时初始化多个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span>= v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>是不是觉得上面这样的定义有点繁琐？有一种写法可以让它变得简单一点。可以直接忽略类型声明，那么上面的代码变成这样了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    然后Go会根据其相应值的类型来初始化它们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>觉得上面的还是有些繁琐，继续简化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    编译器会根据初始化的值自动推导出相应的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>现在是不是看上去非常简洁了？<code>:=</code>这个符号直接取代了<code>var</code>和<code>type</code>,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用<code>var</code>方式来定义全局变量。</p>
<p><code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，将值<code>35</code>赋予<code>b</code>，并同时丢弃<code>34</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了<code>i</code>但未使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<p>它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>下面是一些常量声明的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> MaxThread = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;astaxie_&quot;</span></span><br></pre></td></tr></table></figure>

<p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给<code>float32</code>自动缩短为<code>32bit</code>，指定给<code>float64</code>自动缩短为<code>64bit</code>，详情参考 <code>http://golang.org/ref/spec#Constants</code> (需科学上网)</p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="type">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="type">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。</p>
<p>如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)</p>
<p>var a int8</p>
<p>var b int32</p>
<p>c:&#x3D;a + b</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p>
<p>Go还支持复数。它的默认类型是<code>complex128</code>（64位实数+64位虚数）。如果需要小一些的，也有<code>complex64</code>(32位实数+32位虚数)。复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。下面是一个使用复数的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="type">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code> </code>）括起来定义，它的类型是<code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="type">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="type">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">    frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但如果真的想要修改怎么办呢？下面的代码可以实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br></pre></td></tr></table></figure>

<p>Go中可以使用<code>+</code>操作符来连接两个字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure>

<p>修改字符串也可写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>

<p>如果要声明一个多行的字符串怎么办？可以通过&#96;&#96;&#96;来声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">    world`</span></span><br></pre></td></tr></table></figure>

<p>`&#96;&#96; 括起的字符串为<code>Raw</code>字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure>

<h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h2><p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。</p>
<p>例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> prefix <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>可以分组写成如下形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    pi <span class="type">float32</span></span><br><span class="line">    prefix <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h2><p>Go里面有一个关键字<code>iota</code>，这个关键字用来声明<code>enum</code>的时候采用，它默认开始值是0，const中每增加一行加1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">    y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">    z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">    w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">    b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">    c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">    d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">    g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p>
<h2 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h2><p>Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
<li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数。</li>
</ul>
<h2 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a><code>array</code>、<code>slice</code>、<code>map</code></h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h3><p><code>array</code>就是数组，它的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">//返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure>

<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组可以使用另一种<code>:=</code>来声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line">b := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure>

<p>Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p>在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和声明array一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>接下来可以声明一个<code>slice</code>，并初始化数据，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="type">byte</span></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"><span class="comment">// b是数组ar的另一个slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure>

<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
<h4 id="slice有一些简便的操作"><a href="#slice有一些简便的操作" class="headerlink" title="slice有一些简便的操作"></a><code>slice</code>有一些简便的操作</h4><ul>
<li><p><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></p>
</li>
<li><p><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></p>
</li>
<li><p>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></p>
</li>
</ul>
<p>下面这个例子展示了更多关于<code>slice</code>的操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="type">byte</span></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:]  <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>]  <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>]  <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:]   <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>aSlice</code>中元素的值，那么<code>bSlice</code>相对应的值也会改变。</p>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li><p>一个指针，指向数组中<code>slice</code>指定的开始位置</p>
</li>
<li><p>长度，即<code>slice</code>的长度</p>
</li>
<li><p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array_a := [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line">    Slice_a := Array_a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="slice有几个有用的内置函数"><a href="#slice有几个有用的内置函数" class="headerlink" title="slice有几个有用的内置函数"></a><code>slice</code>有几个有用的内置函数</h4><ul>
<li><p><code>len</code> 获取<code>slice</code>的长度</p>
</li>
<li><p><code>cap</code> 获取<code>slice</code>的最大容量</p>
</li>
<li><p><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></p>
</li>
<li><p><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</p>
</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。</p>
<p>但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<p>从Go1.2开始<code>slice</code>支持了三个参数的<code>slice</code>，之前一直采用这种方式在<code>slice</code>或者<code>array</code>基础上来获取一个<code>slice</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>上面这个的容量就是<code>7-2</code>，即5。这样这个产生的新的<code>slice</code>就没办法访问最后的三个元素。</p>
<p>如果<code>slice</code>是这样的形式<code>array[:i:j]</code>，即第一个参数为空，默认值就是0。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span><span class="string">`也就是Python中字典的概念，它的格式为`</span><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure>

<p>看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是｀int｀类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure>

<p>这个<code>map</code>就像平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用<code>map</code>过程中需要注意的几点：</p>
<ul>
<li><p><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</p>
</li>
<li><p><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</p>
</li>
<li><p>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</p>
</li>
<li><p><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></p>
</li>
<li><p><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p>
</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure>

<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Bonjour&quot;</span></span><br><span class="line">m1 := m</span><br><span class="line">m1[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Salut&quot;</span>  <span class="comment">// 现在m[&quot;hello&quot;]的值已经是Salut了</span></span><br></pre></td></tr></table></figure>

<h2 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a><code>make</code>、<code>new</code>操作</h2><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<p>内建函数<code>new</code>本质上说跟其它语言中的同名函数功能一样：<code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。有一点非常重要：</p>
<p><code>new</code>返回指针。</p>
<p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个<code>slice</code>，是一个包含指向数据（内部<code>array</code>）的指针、长度和容量的三项描述符；在这些项目被初始化之前，<code>slice</code>为<code>nil</code>。对于<code>slice</code>、<code>map</code>和<code>channel</code>来说，<code>make</code>初始化了内部的数据结构，填充适当的值。</p>
<p><code>make</code>返回初始化后的（非零）值。</p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。</p>
<p>此处罗列 部分类型 的 “零值”</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>     <span class="number">0</span></span><br><span class="line"><span class="type">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="type">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="type">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="type">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="type">rune</span>    <span class="number">0</span> <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="type">byte</span>    <span class="number">0x0</span> <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="type">float32</span> <span class="number">0</span> <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="type">float64</span> <span class="number">0</span> <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="type">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="type">string</span>  <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的<code>if</code>还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>多个条件的时候如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Go有<code>goto</code>语句——请明智地使用它。用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">Here:   <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">goto</span> Here   <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签名是大小写敏感的。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go里面最强大的一个控制逻辑就是<code>for</code>，它既可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，看看下面的例子吧：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure>

<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果忽略<code>expression1</code>和<code>expression3</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，这就是<code>while</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code>   ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure>

<p><code>break</code>和<code>continue</code>还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值</p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>有些时候需要写很多的<code>if-else</code>来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候<code>switch</code>就能很好的解决这个问题。它的语法如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的类型必须一致。Go的<code>switch</code>非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果<code>switch</code>没有表达式，它会匹配<code>true</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第5行中，把很多值聚合在了一个<code>case</code>里面，同时，Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以使用<code>fallthrough</code>强制执行后面的case代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是Go里面的核心设计，它通过关键字<code>func</code>来声明，它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line">    <span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">    <span class="comment">//返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出</p>
<ul>
<li><p>关键字<code>func</code>用来声明一个函数<code>funcName</code></p>
</li>
<li><p>函数可以有一个或者多个参数，每个参数后面带有类型，通过<code>,</code>分隔</p>
</li>
<li><p>函数可以返回多个值</p>
</li>
<li><p>上面返回值声明了两个变量<code>output1</code>和<code>output2</code>，如果不想声明也可以，直接就两个类型</p>
</li>
<li><p>如果只有一个返回值且不声明返回值变量，那么可以省略 包括返回值的括号</p>
</li>
<li><p>如果没有返回值，那么就直接省略最后的返回信息</p>
</li>
<li><p>如果有返回值， 那么必须在函数的外层添加return语句</p>
</li>
</ul>
<p>下面来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line">    max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个里面可以看到<code>max</code>函数有两个参数，它们的类型都是<code>int</code>，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<p>直接看例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子可以看到直接返回了两个参数，当然也可以命名返回参数的变量，这个例子里面只是用了两个类型，也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">    add = A+B</span><br><span class="line">    Multiplied = A*B</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p>
<p>为了验证上面的说法，来看一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a = a+<span class="number">1</span> <span class="comment">// 改变了a的值</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">//返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(x)  <span class="comment">//调用add1(x)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出&quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出&quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然调用了<code>add1</code>函数，并且在<code>add1</code>中执行<code>a = a+1</code>操作，但是上面例子中<code>x</code>变量的值没有发生变化</p>
<p>理由很简单：因为当调用<code>add1</code>的时候，<code>add1</code>接收的参数其实是<code>x</code>的copy，而不是<code>x</code>本身。</p>
<p>如果真的需要传这个<code>x</code>本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p>
<ul>
<li><p>传指针使得多个函数能操作同一个对象。</p>
</li>
<li><p>传指针比较轻量级 (8bytes),只是传内存地址，可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。</p>
</li>
<li><p>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</p>
</li>
</ul>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言中有种不错的设计，即延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有很多重复的代码，Go的<code>defer</code>有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在<code>defer</code>后指定的函数会在函数退出前调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，defer会用在释放数据库连接，关闭文件等需要在函数结束时处理的操作。</p>
<h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在Go中函数也是一种变量，可以通过<code>type</code>来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 inputType1 , input2 inputType2 [, ...])</span></span> (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure>

<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">bool</span> <span class="comment">// 声明了一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="type">int</span>, f testInt)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数当做值和类型在写一些通用接口的时候非常有用，通过上面例子看到<code>testInt</code>这个类型是一个函数类型，然后两个<code>filter</code>函数的参数和返回值与<code>testInt</code>类型是一样的，但是可以实现很多种的逻辑，这样使得程序变得非常的灵活。</p>
<h2 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h2><p>Go没有像Java那样的异常机制，它不能抛出异常，而是使用了<code>panic</code>和<code>recover</code>机制。一定要记住，应当把它作为最后的手段来使用，也就是说，代码中应当没有，或者很少有<code>panic</code>的东西。这是个强大的工具，请明智地使用它。</p>
<p>Panic</p>
<p>是一个内建函数，可以中断原有的控制流程，进入一个<code>panic</code>状态中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。<code>panic</code>可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p>
<p>Recover</p>
<p>是一个内建的函数，可以让进入<code>panic</code>状态的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p>
<p>下面这个函数演示了如何在过程中使用<code>panic</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span></span>) (b <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>defer</code>必须在<code>panic</code>语句之前。</p>
<p><code>recover</code>必须配合<code>defer</code>使用。</p>
<h2 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h2><p>Go里面有两个保留的函数：<code>init</code>函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p>
<p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p>
<p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在写Go代码的时候经常用到import这个命令用来导入包文件，经常看到的方式参考如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后代码里面可以通过如下的方式调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<h3 id="1、相对路径"><a href="#1、相对路径" class="headerlink" title="1、相对路径"></a>1、相对路径</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./model&quot;</span> <span class="comment">//当前文件同一目录的model目录，但是不建议这种方式来import</span></span><br></pre></td></tr></table></figure>

<h3 id="2、绝对路径"><a href="#2、绝对路径" class="headerlink" title="2、绝对路径"></a>2、绝对路径</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;shorturl/model&quot;</span> <span class="comment">//加载gopath/src/shorturl/model模块</span></span><br></pre></td></tr></table></figure>

<p>上面展示了一些import常用的几种方式，但是还有一些</p>
<h3 id="特殊的import"><a href="#特殊的import" class="headerlink" title="特殊的import"></a>特殊的import</h3><h4 id="1、点操作"><a href="#1、点操作" class="headerlink" title="1、点操作"></a>1、点操作</h4><p>有时候会看到如下的方式导入包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个点操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名，也就是前面调用的fmt.Println(“hello world”)可以省略的写成<code>Println(&quot;hello world&quot;)</code></p>
<h4 id="2、别名操作"><a href="#2、别名操作" class="headerlink" title="2、别名操作"></a>2、别名操作</h4><p>别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">        f <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>别名操作的话调用包函数时前缀变成了前缀，即<code>f.Println(&quot;hello world&quot;)</code></p>
<h4 id="3、-操作"><a href="#3、-操作" class="headerlink" title="3、_操作"></a>3、_操作</h4><p>这个操作经常是让很多人费解的一个操作符，请看下面这个<code>import</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/ziutek/mymysql/godrv&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>_</code>操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的<code>init函数</code>。</p>
<h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct类型的声明"><a href="#struct类型的声明" class="headerlink" title="struct类型的声明"></a>struct类型的声明</h2><p>Go语言中，也和C或者其他语言一样，可以声明新的类型，作为其它类型的属性或字段的容器。例如，可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型称之<code>struct</code>。如下代码所示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>struct</code>如此简单，上面的类型包含有两个字段</p>
<ul>
<li>一个<code>string</code>类型的字段name，用来保存用户名称这个属性</li>
<li>一个<code>int</code>类型的字段age，用来保存用户年龄这个属性</li>
</ul>
<p>使用<code>struct</code>看下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值&quot;Astaxie&quot;给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值&quot;25&quot;给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure>

<p>除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p>
<ol>
<li><p>按照顺序提供初始化值<br><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p>
</li>
<li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序<br><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p>
</li>
<li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code><br><code>P := new(person)</code></p>
</li>
</ol>
<p>看一个完整的使用<code>struct</code>的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span></span> (person, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> p1.age&gt;p2.age &#123;  <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tom person</span><br><span class="line">    <span class="comment">// 赋值初始化</span></span><br><span class="line">    tom.name, tom.age = <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span></span><br><span class="line">    <span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">    bob := person&#123;age:<span class="number">25</span>, name:<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">    paul := person&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">43</span>&#125;</span><br><span class="line">    tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">    tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">    bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a><code>struct</code>的匿名字段</h2><p>定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
<p>当匿名字段是一个<code>struct</code>的时候，那么这个<code>struct</code>所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p>
<p>看一个例子，让上面说的这些更具体化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，匿名字段就是这样，能够实现字段的继承。student还能访问Human这个字段作为字段名。请看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mark.Human = Human&#123;<span class="string">&quot;Marcus&quot;</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过匿名访问和修改字段相当的有用，但是不仅仅是<code>struct</code>字段，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">    Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">    <span class="type">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化学生Jane</span></span><br><span class="line">    jane := Student&#123;Human:Human&#123;<span class="string">&quot;Jane&quot;</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">&quot;Biology&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 现在访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her name is &quot;</span>, jane.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her age is &quot;</span>, jane.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her weight is &quot;</span>, jane.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her speciality is &quot;</span>, jane.speciality)</span><br><span class="line">    <span class="comment">// 修改他的skill技能字段</span></span><br><span class="line">    jane.Skills = []<span class="type">string</span>&#123;<span class="string">&quot;anatomy&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills are &quot;</span>, jane.Skills)</span><br><span class="line">    fmt.Println(<span class="string">&quot;She acquired two new ones &quot;</span>)</span><br><span class="line">    jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">&quot;physics&quot;</span>, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills now are &quot;</span>, jane.Skills)</span><br><span class="line">    <span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">    jane.<span class="type">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her preferred number is&quot;</span>, jane.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面例子看出来<code>struct</code>不仅仅能够将<code>struct</code>作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p>
<p>这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p>
<p>Go里面很简单的解决了这个问题，最外层的优先访问，也就是当通过<code>student.phone</code>访问的时候，是访问student里面的字段，而不是human里面的字段。</p>
<p>这样就允许去重载通过匿名字段继承的一些字段，当然如果想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// Human类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段Human</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// 雇员的phone字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">    <span class="comment">// 如果要访问Human的phone字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>函数的另一种形态，带有接收者的函数，称为<code>method</code></p>
<h2 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，定义了一个struct叫做长方形，现在想要计算他的面积，那么按照一般的思路应该会用下面的方式来实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r Rectangle)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, area(r1))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p>
<p>这样实现当然没有问题，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，想计算他们的面积的时候怎么办？那就只能增加新的函数，但是函数名就必须要跟着换了，变成<code>area_rectangle, area_circle, area_triangle...</code></p>
<p> 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p>
<p>很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p>
<p>基于上面的原因所以就有了<code>method</code>的概念，<code>method</code>是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在<code>func</code>后面增加了一个receiver(也就是method所依从的主体)。</p>
<p>用上面提到的形状的例子来说，method <code>area()</code> 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p>
<p>更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p>
<p>用Rob Pike的话来说就是：</p>
<p>“A method is a function with an implicit first argument, called a receiver.”</p>
<p>method的语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r ReceiverType)</span></span> funcName(parameters) (results)</span><br></pre></td></tr></table></figure>

<p>下面用最开始的例子用method来实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用method的时候重要注意几点</p>
<ul>
<li><p>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</p>
</li>
<li><p>method里面可以访问接收者的字段</p>
</li>
<li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p>
</li>
</ul>
<p>在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle&#x2F;Circle 发出的。</p>
<p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p>
<p>那是不是method只能作用在struct上面呢？当然不是，他可以定义在任何自定义的类型、内置类型、struct等各种类型上面。什么叫自定义类型，自定义类型不就是struct，其实不是这样的，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type typeName typeLiteral</span><br></pre></td></tr></table></figure>

<p>请看下面这个申明自定义类型的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ages <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> money <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> months <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m := months &#123;</span><br><span class="line">    <span class="string">&quot;January&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;February&quot;</span>:<span class="number">28</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;December&quot;</span>:<span class="number">31</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int，回到<code>method</code> 可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让看一个复杂一点的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    WHITE = <span class="literal">iota</span></span><br><span class="line">    BLACK</span><br><span class="line">    BLUE</span><br><span class="line">    RED</span><br><span class="line">    YELLOW</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Color <span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height, depth <span class="type">float64</span></span><br><span class="line">    color Color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span></span> Volume() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">    b.color = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> BiggestColor() Color &#123;</span><br><span class="line">    v := <span class="number">0.00</span></span><br><span class="line">    k := Color(WHITE)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        <span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">            v = bv</span><br><span class="line">            k = b.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> PaintItBlack() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        bl[i].SetColor(BLACK)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    strings := []<span class="type">string</span> &#123;<span class="string">&quot;WHITE&quot;</span>, <span class="string">&quot;BLACK&quot;</span>, <span class="string">&quot;BLUE&quot;</span>, <span class="string">&quot;RED&quot;</span>, <span class="string">&quot;YELLOW&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boxes := BoxList &#123;</span><br><span class="line">        Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">        Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">        Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;We have %d boxes in our set\n&quot;</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">    fmt.Println(<span class="string">&quot;The volume of the first one is&quot;</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">&quot;cm³&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the last one is&quot;</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s paint them all black&quot;</span>)</span><br><span class="line">    boxes.PaintItBlack()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the second one is&quot;</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Obviously, now, the biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过const定义了一些常量，然后定义了一些自定义类型</p>
<ul>
<li><p>Color作为byte的别名</p>
</li>
<li><p>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</p>
</li>
<li><p>定义了一个slice:BoxList，含有Box</p>
</li>
</ul>
<p>然后以上面的自定义类型为接收者定义了一些method</p>
<ul>
<li><p>Volume()定义了接收者为Box，返回Box的容量</p>
</li>
<li><p>SetColor(c Color)，把Box的颜色改为c</p>
</li>
<li><p>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</p>
</li>
<li><p>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</p>
</li>
<li><p>String()定义在Color上面，返回Color的具体颜色(字符串格式)</p>
</li>
</ul>
<p>上面的代码通过文字描述出来之后是不是很简单？一般解决问题都是通过问题的描述，去写相应的代码实现。</p>
<h2 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h2><p>现在让回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，可以使用*Box。</p>
<p>定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以需要传入指针。</p>
<p>这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p>
<p>这里也许会问SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,需要读取到指针相应的值。</p>
<p>其实Go里面这两种方式都是正确的，当用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值。PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。这两种方式都可以，因为Go知道receiver是指针，他自动转了。</p>
<p>也就是说：</p>
<p>如果一个method的receiver是*T,可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p>
<p>类似的</p>
<p>如果一个method的receiver是T，可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method</p>
<p>所以不用担心是调用的指针的method还是不是指针的method，Go知道要做的一切，这对于有多年C&#x2F;C++编程经验的同学来说，真是解决了一个很大的痛苦。</p>
<h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>通过字段的继承的学习，发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。来看下面这个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><p>上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些内容，可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>Go语言里面设计最精妙的应该算<code>interface</code>，它让面向对象，内容组织实现非常的方便</p>
<h2 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，<code>interface</code>是一组<code>method</code>签名的组合，通过<code>interface</code>来定义对象的一组行为。</p>
<p>前面例子中<code>Student</code>和<code>Employee</code>都能<code>SayHi</code>，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p>
<p>继续做更多的扩展，<code>Student</code>和<code>Employee</code>实现另一个方法<code>Sing</code>，然后<code>Student</code>实现方法<code>BorrowMoney</code>而<code>Employee</code>实现<code>SpendSalary</code>。</p>
<p>这样<code>Student</code>实现了三个方法：<code>SayHi</code>、<code>Sing</code>、<code>BorrowMoney</code>；而<code>Employee</code>实现了<code>SayHi</code>、<code>Sing</code>、<code>SpendSalary</code>。</p>
<p>上面这些方法的组合称为<code>interface</code>(被对象<code>Student</code>和<code>Employee</code>实现)。例如<code>Student</code>和<code>Employee</code>都实现了<code>interface</code>：<code>SayHi</code>和<code>Sing</code>，也就是这两个对象是该<code>interface</code>类型。而<code>Employee</code>没有实现这个<code>interface：SayHi、Sing</code>和<code>BorrowMoney</code>，因为<code>Employee</code>没有实现<code>BorrowMoney</code>这个方法。</p>
<h2 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h2><p><code>interface</code>类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，interface可以被任意的对象实现。看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p>最后，任意的类型都实现了空interface(这样定义：interface{})，也就是包含0个method的interface。</p>
<h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><p>那么interface里面到底能存什么值呢？如果定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p>因为m能够持有这三种类型的对象，所以可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和传统意义上面的slice有所不同。</p>
<p>来看一下下面这个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">    <span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line">    <span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">    <span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">    <span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，发现<code>interface</code>就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了<code>duck-typing</code>:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure>

<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回<code>interface&#123;&#125;</code>,那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h2 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h2><p>interface的变量可以持有任意实现该interface类型的对象，这给编写函数(包括method)提供了一些额外的思考，是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println是常用的一个函数，是否注意到它可以接受任意类型的数据。打开fmt的源码文件，会看到这样一个定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，任何实现了String方法的类型都能作为参数被<code>fmt.Println</code>调用,来试一试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在再回顾一下前面的Box示例，发现Color结构也定义了一个<code>method：String</code>。其实这也是实现了<code>fmt.Stringer</code>这个<code>interface</code>，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现<code>Stringer</code>这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure>

<p>注：实现了<code>error</code>接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
<h2 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h2><p>interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<ul>
<li>Comma-ok断言</li>
</ul>
<p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok &#x3D; element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p>
<p>通过一个例子来更加深入的理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="type">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否注意到了多个if里面，if里面允许初始化变量。断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。</p>
<ul>
<li>switch测试</li>
</ul>
<p>重写上面的这个实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要强调的是：<code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用<code>comma-ok</code>。</p>
<h2 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h2><p>Go里面真正吸引人的是它内置的逻辑语法，就像在学习Struct时学习的匿名字段，那么相同的逻辑引入到interface里面，更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p>
<p>可以看到源码包<code>container/heap</code>里面有这样的一个定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>sort.Interface</code>其实就是嵌入字段，把<code>sort.Interface</code>的所有<code>method</code>给隐式的包含进来了。也就是下面三个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子就是io包下面的 <code>io.ReadWriter</code> ，它包含了io包下面的<code>Reader</code>和<code>Writer</code>两个<code>interface</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。一般用到的包是<code>reflect</code>包。如何运用<code>reflect</code>包，官方的这篇文章详细的讲解了<code>reflect</code>包的实现原理，<code>laws of reflection</code> 链接地址为 <a target="_blank" rel="noopener" href="http://golang.org/doc/articles/laws_of_reflection.html">http://golang.org/doc/articles/laws_of_reflection.html</a></p>
<p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了<code>空interface</code>)，首先需要把它转化成<code>reflect</code>对象(<code>reflect.Type</code>或者<code>reflect.Value</code>，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>

<p>转化为reflect对象之后就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>

<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>

<p>最后，反射的话，那么反射的字段必须是可修改的，前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<p>如果要修改相应的值，必须这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go从语言层面支持了并行。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><code>goroutine</code>是<code>Go</code>并行设计的核心。<code>goroutine</code>说到底其实就是协程，但是它比线程更小，十几个<code>goroutine</code>可能体现在底层就是五六个线程，Go语言内部实现了这些<code>goroutine</code>之间的内存共享。执行<code>goroutine</code>只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。<code>goroutine</code>比<code>thread</code>更易用、更高效、更轻便。</p>
<p><code>goroutine</code>是通过Go的<code>runtime</code>管理的一个线程管理器。<code>goroutine</code>通过<code>go</code>关键字实现了，其实就是一个普通的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure>

<p>通过关键字go就启动了一个<code>goroutine</code>。来看一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>可以看到go关键字很方便的就实现了并发编程。</p>
<p>上面的多个<code>goroutine</code>运行在同一个进程里面，共享内存数据，不过设计上要遵循：不要通过共享来通信，而要通过通信来共享。</p>
<p><code>runtime.Gosched()</code>表示让CPU把时间片让给别人,下次某个时候继续恢复执行该<code>goroutine</code>。</p>
<p>默认情况下，在Go 1.5将标识并发系统线程个数的<code>runtime.GOMAXPROCS</code>的初始值由1改为了<code>运行环境的CPU核数</code>。</p>
<p>但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要程序中显式调用 <code>runtime.GOMAXPROCS(n)</code> 告诉调度器同时使用多个线程。<code>GOMAXPROCS</code> 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果<code>n &lt; 1</code>，不会改变当前设置。</p>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p><code>goroutine</code>运行在相同的地址空间，因此访问共享内存必须做好同步。那么<code>goroutine</code>之间如何进行数据的通信呢，Go提供了一个很好的通信机制<code>channel</code>。<code>channel</code>可以与<code>Unix shell</code> 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：<code>channel类型</code>。定义一个<code>channel</code>时，也需要定义发送到<code>channel</code>的值的类型。注意，必须使用<code>make</code> 创建<code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><code>channel</code>通过操作符<code>&lt;-</code>来接收和发送数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure>

<p>把这些应用到例子中来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>channel</code>接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得<code>Goroutines</code>同步变的更加的简单，而不需要显式的<code>lock</code>。所谓阻塞，也就是如果读取（<code>value := &lt;-ch</code>）它将会被阻塞，直到有数据接收。其次，任何发送（<code>ch&lt;-5</code>）将会被阻塞，直到数据被读出。无缓冲<code>channel</code>是在多个<code>goroutine</code>之间同步很棒的工具。</p>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。<code>ch:= make(chan bool</code>, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure>

<p>当 <code>value = 0</code> 时，channel 是无缓冲阻塞读写的，当<code>value &gt; 0</code> 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p>
<p>看一下下面这个例子，可以在自己本机测试一下，修改相应的value值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改为1报如下的错误:</span></span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>

<h2 id="Range和Close"><a href="#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h2><p>上面这个例子中，需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for i := range c</code>能够不断的读取<code>channel</code>里面的数据，直到该<code>channel</code>被显式的关闭。上面代码看到可以显式的关闭<code>channel</code>，生产者通过内置函数<code>close</code>关闭<code>channel</code>。关闭<code>channel</code>之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试<code>channel</code>是否被关闭。如果ok返回false，那么说明<code>channel</code>已经没有任何数据并且已经被关闭。</p>
<p>记住应该在生产者的地方关闭<code>channel</code>，而不是消费的地方去关闭它，这样容易引起<code>panic</code></p>
<p>另外记住一点的就是<code>channel</code>不像文件之类的，不需要经常去关闭，只有确实没有任何发送数据了，或者想显式的结束<code>range</code>循环之类的</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>上面介绍的都是只有一个<code>channel</code>的情况，那么如果存在多个<code>channel</code>的时候，该如何操作呢，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听<code>channel</code>上的数据流动。</p>
<p><code>select</code>默认是阻塞的，只有当监听的<code>channel</code>中有发送或接收可以进行时才会运行，当多个<code>channel</code>都准备好的时候，<code>select</code>是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>select</code>里面还有<code>default</code>语法，<code>select</code>其实就是类似<code>switch</code>的功能，<code>default</code>就是当监听的<code>channel</code>都没有准备好的时候，默认执行的（<code>select</code>不再阻塞等待<code>channel</code>）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现<code>goroutine</code>阻塞的情况，那么如何避免整个程序进入阻塞的情况呢？可以利用<code>select</code>来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p><code>runtime</code>包中有几个处理<code>goroutine</code>的函数：</p>
<ul>
<li><p><code>Goexit</code> : 退出当前执行的goroutine，但是defer函数还会继续调用</p>
</li>
<li><p><code>Gosched</code>: 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p><code>NumCPU</code> : 返回 CPU 核数量</p>
</li>
<li><p><code>NumGoroutine</code>: 返回正在执行和排队的任务总数</p>
</li>
<li><p><code>GOMAXPROCS</code> : 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言主要的设计准则是：简洁、明白，简洁是指语法和C类似，相当的简单，明白是指任何语句都是很明显的，不含有任何隐含的东西，在错误处理方案的设计中也贯彻了这一思想。</p>
<p>在C语言里面是通过返回<code>-1</code>或者<code>NULL</code>之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而<code>Go</code>定义了一个叫做<code>error</code>的类型，来显式表达错误。在使用时，通过把返回的<code>error</code>变量与<code>nil</code>的比较，来判定操作是否成功。例如<code>os.Open</code>函数在打开文件失败时将返回一个不为<code>nil</code>的<code>error</code>变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>下面这个例子通过调用<code>os.Open</code>打开一个文件，如果出现错误，那么就会调用<code>log.Fatal</code>来输出错误信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;filename.ext&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于<code>os.Open</code>函数，标准包中所有可能出错的API都会返回一个<code>error</code>变量，以方便错误处理，这个小节将详细地介绍<code>error</code>类型的设计，和讨论开发Web应用中如何更好地处理<code>error</code>。</p>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>error是一个内置的接口类型，可以在<code>/builtin/</code>包下面找到相应的定义。而在很多内部包里面用到的 <code>error</code>是<code>errors</code>包下面的实现的私有结构<code>errorString</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<code>errors.New</code>把一个字符串转化为<code>errorString</code>，以得到一个满足接口<code>error</code>的对象，其内部实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子演示了如何使用<code>errors.New</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，在调用Sqrt的时候传递的一个负数，然后就得到了<code>non-nil</code>的<code>error</code>对象，将此对象与<code>nil</code>比较，结果为<code>true</code>，所以<code>fmt.Println</code>(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := Sqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Error"><a href="#自定义Error" class="headerlink" title="自定义Error"></a>自定义Error</h2><p><code>error</code>是一个<code>interface</code>，所以在实现自己的包的时候，通过定义实现此接口的结构，就可以实现自己的错误定义，请看来自Json包的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="type">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="type">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>

<p><code>Offset</code>字段在调用<code>Error</code>的时候不会被打印，但可以通过类型断言获取错误类型，然后可以打印相应的错误信息，请看下面的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">        line, col := findLine(f, serr.Offset)</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s:%d:%d: %v&quot;</span>, f.Name(), line, col, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数返回自定义错误时，返回值推荐设置为<code>error</code>类型，而非自定义错误类型，特别需要注意的是不应预声明自定义错误类型的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">()</span></span> *SyntaxError &#123; <span class="comment">// 错误，将可能导致上层调用者err!=nil的判断永远为true。</span></span><br><span class="line">    <span class="keyword">var</span> err *SyntaxError     <span class="comment">// 预声明错误变量</span></span><br><span class="line">    <span class="keyword">if</span> 出错条件 &#123;</span><br><span class="line">        err = &amp;SyntaxError&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err               <span class="comment">// 错误，err永远等于非nil，导致上层调用者err!=nil的判断始终为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因见 <code>http://golang.org/doc/faq#nil_error</code> (需科学上网)</p>
<p>上面例子简单的演示了如何自定义Error类型。但是如果还需要更复杂的错误处理呢？此时，来参考一下net包采用的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的地方，通过类型断言<code>err</code>是不是<code>net.Error</code>,来细化错误的处理，例如下面的例子，如果一个网络发生临时性错误，那么将会sleep 1秒之后重试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go在错误处理上采用了与C类似的检查返回值的方式，而不是其他多数主流语言采用的异常方式，这造成了代码编写上的一个很大的缺点:错误处理代码的冗余，对于这种情况是通过复用检测函数来减少类似的代码。</p>
<p>请看下面这个例子代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/view&quot;</span>, viewRecord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中获取数据和模板展示调用时都有检测错误，当有错误发生时，调用了统一的处理函数<code>http.Error</code>，返回给客户端500错误码，并显示相应的错误数据。但是当越来越多的<code>HandleFunc</code>加入之后，这样的错误处理逻辑代码就会越来越多，其实可以通过自定义路由器来缩减代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fn(w, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了自定义的路由器，然后可以通过如下方式来注册函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/view&quot;</span>, appHandler(viewRecord))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求<code>/view</code>的时候逻辑处理可以变成如下代码，和第一种实现方式相比较已经简单了很多。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewTemplate.Execute(w, record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子错误处理的时候所有的错误返回给用户的都是500错误码，然后打印出来相应的错误代码，其实可以把这个错误信息定义的更加友好，调试的时候也方便定位问题，可以自定义返回的错误类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   <span class="type">error</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样自定义路由器可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> *appError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">&quot;%v&quot;</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改完自定义错误之后，逻辑处理可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> *appError &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在访问view的时候可以根据不同的情况获取不同的错误码和错误信息，虽然这个和第一个版本的代码量差不多，但是这个显示的错误更加明显，提示的错误信息更加友好，扩展性也比第一个更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在程序设计中，容错是相当重要的一部分工作，在Go中它是通过错误处理来实现的，error虽然只是一个接口，但是其变化却可以有很多，可以根据自己的需求来实现不同的处理。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Golang新手可能会踩的50个坑"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/Golang%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%8450%E4%B8%AA%E5%9D%91/"
    >Golang新手可能会踩的50个坑</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/Golang%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%8450%E4%B8%AA%E5%9D%91/" class="article-date">
  <time datetime="2023-09-03T16:33:10.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p>
<p>如果花时间学习官方 doc、wiki、<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/golang-nuts">讨论邮件列表</a>、 <a target="_blank" rel="noopener" href="https://github.com/robpike">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p>
<h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-不能单独放一行"><a href="#1-左大括号-不能单独放一行" class="headerlink" title="1. 左大括号 { 不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;    <span class="comment">// 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.&#x2F;main.go: missing function body</p>
</blockquote>
<blockquote>
<p>.&#x2F;main.go: syntax error: unexpected semicolon or newline before {</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p>
<p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span>     <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span>     <span class="comment">// error: one declared and not used</span></span><br><span class="line">    two := <span class="number">2</span>    <span class="comment">// error: two declared and not used</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span>    <span class="comment">// error: three declared and not used</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">    _ = one</span><br><span class="line"></span><br><span class="line">    two := <span class="number">2</span></span><br><span class="line">    <span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">    one = three</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">    four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p>
<p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span>    <span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>    <span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = log.Println</span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>    <span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>, <span class="number">2</span>    <span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">    one, two = two, one    <span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span>    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p>
<p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 2    // 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Go 开发者常犯的错，而且不易被发现。</p>
<p>可使用 <a target="_blank" rel="noopener" href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; go tool vet -shadow main.go</span><br><span class="line">main.go:9: declaration of &quot;x&quot; shadows declaration at main.go:5</span><br></pre></td></tr></table></figure>

<p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a target="_blank" rel="noopener" href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $GOPATH/bin/<span class="keyword">go</span>-nyet main.<span class="keyword">go</span></span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">3</span>:Shadowing variable <span class="string">`x`</span></span><br></pre></td></tr></table></figure>

<h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>    <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11. string 类型的变量值不能为 nil"></a>11. string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;    <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span>    <span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p>
<p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)            <span class="comment">// [1 2 3]    // 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改参数数组：</p>
<ul>
<li>直接传递指向这个数组的指针类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v)    <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;    <span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p>
<p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p>
<p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p>
<ol>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</li>
<li>使用“独立”的切片分两步：</li>
</ol>
<ul>
<li><p>创建外部 slice</p>
</li>
<li><p>对每个内部 slice 进行内存分配<br>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用“共享底层数组”的切片</li>
</ol>
<ul>
<li><p>创建一个存放原始数据的容器 slice</p>
</li>
<li><p>创建其他的 slice</p>
</li>
<li><p>切割原始 slice 来初始化其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化原始 slice</span></span><br><span class="line">    fmt.Println(raw, &amp;raw[<span class="number">4</span>])    <span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">        table[i] = raw[i*w : i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])    <span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于多维数组的参考</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p>
<h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; php -r &#x27;$v = [&quot;x&quot;=&gt;1, &quot;y&quot;=&gt;2]; @var_dump($v[&quot;z&quot;]);&#x27;</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure>

<p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p>
<p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)    <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p>
<p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span>        <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>    <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="type">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">    x = <span class="type">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p>
<p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p>
<ul>
<li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li>
<li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li>
</ul>
<p>雾：<a target="_blank" rel="noopener" href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p>
<h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p>
<p>这种处理方式和其他语言一样，比如 PHP 中：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span>    <span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;中文&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;�&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;中&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>])        <span class="comment">// 97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a target="_blank" rel="noopener" href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p>
<h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p>
<p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>然而在 Go 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内建函数 <code>len()</code> 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。</p>
<p>如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    char := &quot;é&quot;</span><br><span class="line">    fmt.Println(len(char))    // 3</span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    // 2</span><br><span class="line">    fmt.Println(&quot;cafe\u0301&quot;)    // café    // 法文的 cafe，实际上是两个 rune 的组合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.golang.org/normalization">normalization</a></p>
<h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">    z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p>
<h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p>
<h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p>
<p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a target="_blank" rel="noopener" href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去 <a target="_blank" rel="noopener" href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079494-de9e6a55-0bd7-4d37-9cf8-4edc3c9ee978.png" alt="img"></p>
<h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p>
<p>也可以改写 case 为多条件判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code> 只作为运算符而非表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i            <span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">    fmt.Println(data[i++])    <span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(~<span class="number">2</span>)        <span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)        <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p>
<p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000010</span> [A]</span><br><span class="line"><span class="number">00000010</span> [B]</span><br><span class="line"><span class="number">11111101</span> (NOT B)</span><br><span class="line"><span class="number">00000010</span> ^ <span class="number">11111111</span> = <span class="number">11111101</span> [B XOR <span class="number">0xff</span>]</span><br><span class="line"><span class="number">10000010</span> ^ <span class="number">00000010</span> = <span class="number">10000000</span> [A XOR B]</span><br><span class="line"><span class="number">10000010</span> &amp; <span class="number">00000010</span> = <span class="number">00000010</span> [A AND B]</span><br><span class="line"><span class="number">10000010</span> &amp;^<span class="number">00000010</span> = <span class="number">10000000</span> [A <span class="string">&#x27;AND NOT&#x27;</span> B]</span><br><span class="line"><span class="number">10000010</span>&amp;(^<span class="number">00000010</span>)= <span class="number">10000000</span> [A AND (NOT B)]</span><br></pre></td></tr></table></figure>

<h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)    <span class="comment">// &amp; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)    <span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)    <span class="comment">// | 优先 ^</span></span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级列表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>

<h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)    <span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(encoded))    <span class="comment">// &#123;&quot;One&quot;:1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out)     <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079610-d9523090-8363-463a-b6f0-aa4e55a1b7ef.png" alt="img"></p>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079522-5d8f767c-aa6d-4960-bcd3-795aca54b1da.png" alt="img"></p>
<p>看起来好像 goroutine 都执行完了，然而报错：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p>
<p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-48ae068a-8fe5-49b8-ba79-6aecc941525a.png" alt="img"></p>
<h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079544-84c1140a-23ae-4858-80b7-b0adf759ee18.png" alt="img"></p>
<h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p>
<p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p>
<p>向已关闭的 channel 中发送数据会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)        <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)            <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)    <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-645d7d98-a284-417a-94d0-a0b810b6d032.png" alt="img"></p>
<p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079515-81889255-1ad8-424a-9b46-20de774153b4.png" alt="img"></p>
<h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil 的 channel"></a>34. 使用了值为 <code>nil</code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 死锁错误：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>goroutine 1 [chan receive (nil chan)]</p>
<p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inCh</span><br><span class="line">            <span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">                out = outCh</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inCh &lt;- <span class="number">1</span></span><br><span class="line">    inCh &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079586-ec05c601-40cf-4ae1-b8f6-c02b63226d74.png" alt="img"></p>
<h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="type">int</span></span><br><span class="line">    key   *<span class="type">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">    this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc()    <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()    <span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079495-aac01481-dec9-4479-b0be-d9f7165af772.png" alt="img"></p>
<h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<p>应该先检查HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Get <a target="_blank" rel="noopener" href="https://api.ipify.org/?format=json">https://api.ipify.org?format=...</a>: x509: certificate signed by unknown authority</p>
<p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p>
<ul>
<li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li>
<li>手动调用 <code>defer</code> 来关闭响应体：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkError(err)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p>
<p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(ioutil.Discard, resp.Body)    // 手动丢弃读取完毕的数据</span><br></pre></td></tr></table></figure>

<p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.NewDecoder(resp.Body).Decode(&amp;data)</span><br></pre></td></tr></table></figure>

<h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p>
<ul>
<li>直接设置请求变量的 <code>Close</code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li>
<li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)    // 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)    <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需求选择使用场景：</p>
<ul>
<li>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</li>
<li>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</li>
</ul>
<h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])    <span class="comment">// float64</span></span><br><span class="line">    <span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)    <span class="comment">// 类型断言错误</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: interface conversion: interface {} is float64, not int</p>
<p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p>
<ul>
<li>将 int 值转为 float 统一使用</li>
<li>将 decode 后需要的 float 值转为 int 使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">    decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">      decoder.UseNumber()</span><br><span class="line">      <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">      err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">    checkError(err)</span><br><span class="line">       fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">          Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">      checkError(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型<br>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">            StatusCode <span class="type">uint64</span></span><br><span class="line">            StatusName <span class="type">string</span></span><br><span class="line">            Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">            Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">        checkError(err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusName = name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusCode = code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="type">int</span></span><br><span class="line">    fp      <span class="type">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">    str     <span class="type">string</span></span><br><span class="line">    char    <span class="type">rune</span></span><br><span class="line">    yes     <span class="type">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="type">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="type">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>    <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="type">byte</span>            <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared)</p>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">       <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>DeepEqual()</code> 并不总适合于比较 slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code> 和 <code>strings.EqualFold()</code></p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto&#x2F;subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p>
<ul>
<li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 &#x2F; 中断 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 什么都不会捕捉</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)    <span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recobered:  panic: not good</p>
<h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span>    <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])    <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]    <span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p>
<p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAA</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/uffixBBBB    // 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改</p>
<p>解决方法：</p>
<ul>
<li>重新分配新的 slice 并拷贝你需要的数据</li>
<li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]        <span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p>
<h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)    <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)    <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)    <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p>
<p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 类型声明也保留它的方法集：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line">            <span class="comment">//break    // 死循环，一直打印 breaking out...</span></span><br><span class="line">            <span class="keyword">break</span> loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p>
<h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vCopy := v</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vCopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下边这个稍复杂的 3 个示例区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;    <span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>result: 2</p>
<h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)    <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()    <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建 10000 个文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> n in &#123;<span class="number">1.</span><span class="number">.10000</span>&#125;; do</span><br><span class="line">    echo content &gt; <span class="string">&quot;file$&#123;n&#125;.txt&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079519-ec32c68a-4892-4e5c-bced-cd3d864c960f.png" alt="img"></p>
<p>解决办法：defer 延迟执行的函数写入匿名函数中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p>
<h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a target="_blank" rel="noopener" href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a target="_blank" rel="noopener" href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p>
<p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p>
<p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p>
<p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p>
<ul>
<li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel <code>default</code> 语句：<br><code>default</code> 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p>
<h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>()    <span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    in.<span class="built_in">print</span>()    <span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()    <span class="comment">// m[&quot;x&quot;] 是不可寻址的    // 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot use data literal (type data) as type printer in assignment:</p>
<p>data does not implement printer (print method has pointer receiver)</p>
<p>cannot call pointer method on m[“x”]</p>
<p>cannot take the address of m[“x”]</p>
<h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot assign to struct field m[“x”].name in map</p>
<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p>
<p>更新 map 中 struct 元素的字段值，有 2 个方法：</p>
<ul>
<li>使用局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">    r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">    fmt.Println(m)    <span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指向元素的 map 指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span>    <span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])    <span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; false    // data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)    <span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)            <span class="comment">// *struct &#123;&#125;    // res 不是 nil，它的值为 nil</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)            <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>    <span class="comment">// 明确指明返回 nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)    <span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p>
<p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。</p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置：</p>
<p> <img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079583-c6b22446-874e-41ce-8898-39d36c0881b5.png" alt="img"></p>
<h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p>
<p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p>
<p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a target="_blank" rel="noopener" href="https://golang.org/pkg/runtime/">文档</a></p>
<p><code>GOMAXPROCS</code> 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())    <span class="comment">// 4</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> u1()    <span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079530-1ec1022c-6083-4b1a-93fd-982ef37ae959.png" alt="img"></p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p>
<h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)    <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079553-0bfc962d-ba49-426c-b720-43d42581d3af.png" alt="img"></p>
<p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079699-1d179d4e-3e72-4be3-8595-67d600aa223e.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感谢原作者 <a target="_blank" rel="noopener" href="https://twitter.com/kcqon">kcqon</a> 总结的这篇博客，让我受益匪浅。</p>
<p>由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Golang精编100题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/04/Golang%E7%B2%BE%E7%BC%96100%E9%A2%98/"
    >Golang精编100题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/04/Golang%E7%B2%BE%E7%BC%96100%E9%A2%98/" class="article-date">
  <time datetime="2023-09-03T16:28:27.000Z" itemprop="datePublished">2023-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a> / <a class="article-category-link" href="/categories/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="能力模型"><a href="#能力模型" class="headerlink" title="能力模型"></a>能力模型</h2><table>
<thead>
<tr>
<th>级别</th>
<th>模型</th>
</tr>
</thead>
<tbody><tr>
<td>初级</td>
<td></td>
</tr>
<tr>
<td>primary</td>
<td>熟悉基本语法，能够看懂代码的意图；</td>
</tr>
<tr>
<td>在他人指导下能够完成用户故事的开发，编写的代码符合CleanCode规范；</td>
<td></td>
</tr>
<tr>
<td>中级</td>
<td></td>
</tr>
<tr>
<td>intermediate</td>
<td>能够独立完成用户故事的开发和测试；</td>
</tr>
<tr>
<td>能够嗅出代码的坏味道，并知道如何重构达成目标；</td>
<td></td>
</tr>
<tr>
<td>高级</td>
<td></td>
</tr>
<tr>
<td>senior</td>
<td>能够开发出高质量高性能的代码；</td>
</tr>
<tr>
<td>能够熟练使用高级特性，开发编程框架或测试框架；</td>
<td></td>
</tr>
</tbody></table>
<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><h3 id="1、-primary-下面属于关键字的是（）"><a href="#1、-primary-下面属于关键字的是（）" class="headerlink" title="1、**[primary]** 下面属于关键字的是（）"></a>1、**[primary]** 下面属于关键字的是（）</h3><p>A. func</p>
<p>B. def</p>
<p>C. struct</p>
<p>D. class</p>
<p>参考答案：AC</p>
<h3 id="2、-primary-定义一个包内全局字符串变量，下面语法正确的是-（）"><a href="#2、-primary-定义一个包内全局字符串变量，下面语法正确的是-（）" class="headerlink" title="2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）"></a>2、**[primary]** 定义一个包内全局字符串变量，下面语法正确的是 （）</h3><p>A. var str string</p>
<p>B. str :&#x3D; “”</p>
<p>C. str &#x3D; “”</p>
<p>D. var str &#x3D; “”</p>
<p>参考答案：AD</p>
<h3 id="3、-primary-通过指针变量-p-访问其成员变量-name，下面语法正确的是（）"><a href="#3、-primary-通过指针变量-p-访问其成员变量-name，下面语法正确的是（）" class="headerlink" title="3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）"></a>3、**[primary]** 通过指针变量 p 访问其成员变量 name，下面语法正确的是（）</h3><p>A. p.name</p>
<p>B. (*p).name</p>
<p>C. (&amp;p).name</p>
<p>D. p-&gt;name</p>
<p>参考答案：AB</p>
<h3 id="4、-primary-关于接口和类的说法，下面说法正确的是（）"><a href="#4、-primary-关于接口和类的说法，下面说法正确的是（）" class="headerlink" title="4、**[primary]** 关于接口和类的说法，下面说法正确的是（）"></a>4、**[primary]** 关于接口和类的说法，下面说法正确的是（）</h3><p>A. 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口</p>
<p>B. 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理</p>
<p>C. 类实现接口时，需要导入接口所在的包</p>
<p>D. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p>
<p>参考答案：ABD</p>
<h3 id="5、-primary-关于字符串连接，下面语法正确的是（）"><a href="#5、-primary-关于字符串连接，下面语法正确的是（）" class="headerlink" title="5、**[primary]** 关于字符串连接，下面语法正确的是（）"></a>5、**[primary]** 关于字符串连接，下面语法正确的是（）</h3><p>A. str :&#x3D; ‘abc’ + ‘123’</p>
<p>B. str :&#x3D; “abc” + “123”</p>
<p>C. str ：&#x3D; ‘123’ + “abc”</p>
<p>D. fmt.Sprintf(“abc%d”, 123)</p>
<p>参考答案：BD</p>
<h3 id="6、-primary-关于协程，下面说法正确是（）"><a href="#6、-primary-关于协程，下面说法正确是（）" class="headerlink" title="6、**[primary]** 关于协程，下面说法正确是（）"></a>6、**[primary]** 关于协程，下面说法正确是（）</h3><p>A. 协程和线程都可以实现程序的并发执行</p>
<p>B. 线程比协程更轻量级</p>
<p>C. 协程不存在死锁问题</p>
<p>D. 通过channel来进行协程间的通信</p>
<p>参考答案：AD</p>
<h3 id="7、-intermediate-关于init函数，下面说法正确的是（）"><a href="#7、-intermediate-关于init函数，下面说法正确的是（）" class="headerlink" title="7、**[intermediate]** 关于init函数，下面说法正确的是（）"></a>7、**[intermediate]** 关于init函数，下面说法正确的是（）</h3><p>A. 一个包中，可以包含多个init函数</p>
<p>B. 程序编译时，先执行导入包的init函数，再执行本包内的init函数</p>
<p>C. main包中，不能有init函数</p>
<p>D. init函数可以被其他函数调用</p>
<p>参考答案：AB</p>
<h3 id="8、-primary-关于循环语句，下面说法正确的有（）"><a href="#8、-primary-关于循环语句，下面说法正确的有（）" class="headerlink" title="8、**[primary]** 关于循环语句，下面说法正确的有（）"></a>8、**[primary]** 关于循环语句，下面说法正确的有（）</h3><p>A. 循环语句既支持for关键字，也支持while和do-while</p>
<p>B. 关键字for的基本使用方法与C&#x2F;C++中没有任何差异</p>
<p>C. for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环</p>
<p>D. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</p>
<p>参考答案：CD</p>
<h3 id="9、-intermediate-对于函数定义："><a href="#9、-intermediate-对于函数定义：" class="headerlink" title="9、**[intermediate]** 对于函数定义："></a>9、**[intermediate]** 对于函数定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">            sum += arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下面对add函数调用正确的是（）</span><br><span class="line">A. add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">B. add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">C. add([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">D. add([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;...)</span><br></pre></td></tr></table></figure>

<p>参考答案：ABD</p>
<h3 id="10、-primary-关于类型转化，下面语法正确的是（）"><a href="#10、-primary-关于类型转化，下面语法正确的是（）" class="headerlink" title="10、**[primary]** 关于类型转化，下面语法正确的是（）"></a>10、**[primary]** 关于类型转化，下面语法正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = i</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = (MyInt)i</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = MyInt(i)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j MyInt = i.(MyInt)</span><br></pre></td></tr></table></figure>

<p>参考答案：C</p>
<h3 id="11、-primary-关于局部变量的初始化，下面正确的使用方式是（）"><a href="#11、-primary-关于局部变量的初始化，下面正确的使用方式是（）" class="headerlink" title="11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）"></a>11、**[primary]** 关于局部变量的初始化，下面正确的使用方式是（）</h3><p>A. var i int &#x3D; 10</p>
<p>B. var i &#x3D; 10</p>
<p>C. i :&#x3D; 10</p>
<p>D. i &#x3D; 10</p>
<p>参考答案：ABC</p>
<h3 id="12、-primary-关于const常量定义，下面正确的使用方式是（）"><a href="#12、-primary-关于const常量定义，下面正确的使用方式是（）" class="headerlink" title="12、**[primary]** 关于const常量定义，下面正确的使用方式是（）"></a>12、**[primary]** 关于const常量定义，下面正确的使用方式是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi <span class="type">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"><span class="keyword">const</span> zero = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        size <span class="type">int64</span> = <span class="number">1024</span></span><br><span class="line">        eof = <span class="number">-1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        ERR_ELEM_EXIST <span class="type">error</span> = errors.New(<span class="string">&quot;element already exists&quot;</span>)</span><br><span class="line">        ERR_ELEM_NT_EXIST <span class="type">error</span> = errors.New(<span class="string">&quot;element not exists&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u, v <span class="type">float32</span> = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考答案：ABD</p>
<h3 id="13、-primary-关于布尔变量b的赋值，下面错误的用法是（）"><a href="#13、-primary-关于布尔变量b的赋值，下面错误的用法是（）" class="headerlink" title="13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）"></a>13、**[primary]** 关于布尔变量b的赋值，下面错误的用法是（）</h3><p>A. b &#x3D; true</p>
<p>B. b &#x3D; 1</p>
<p>C. b &#x3D; bool(1)</p>
<p>D. b &#x3D; (1 &#x3D;&#x3D; 2)</p>
<p>参考答案：BC</p>
<h3 id="14、-intermediate-下面的程序的运行结果是（）"><a href="#14、-intermediate-下面的程序的运行结果是（）" class="headerlink" title="14、**[intermediate]** 下面的程序的运行结果是（）"></a>14、**[intermediate]** 下面的程序的运行结果是（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A. 321</p>
<p>B. 32</p>
<p>C. 31</p>
<p>D. 13</p>
<p>参考答案：C</p>
<h3 id="15、-primary-关于switch语句，下面说法正确的有（）"><a href="#15、-primary-关于switch语句，下面说法正确的有（）" class="headerlink" title="15、**[primary]** 关于switch语句，下面说法正确的有（）"></a>15、**[primary]** 关于switch语句，下面说法正确的有（）</h3><p>A. 条件表达式必须为常量或者整数</p>
<p>B. 单个case中，可以出现多个结果选项</p>
<p>C. 需要用break来明确退出一个case</p>
<p>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case</p>
<p>参考答案：BD</p>
<h3 id="16、-intermediate-golang中没有隐藏的this指针，这句话的含义是（）"><a href="#16、-intermediate-golang中没有隐藏的this指针，这句话的含义是（）" class="headerlink" title="16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）"></a>16、**[intermediate]** golang中没有隐藏的this指针，这句话的含义是（）</h3><p>A. 方法施加的对象显式传递，没有被隐藏起来</p>
<p>B. golang沿袭了传统面向对象编程中的诸多概念，比如继承、虚函数和构造函数</p>
<p>C. golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达</p>
<p>D. 方法施加的对象不需要非得是指针，也不用非得叫this</p>
<p>参考答案：ACD</p>
<h3 id="17、-intermediate-golang中的引用类型包括（）"><a href="#17、-intermediate-golang中的引用类型包括（）" class="headerlink" title="17、**[intermediate]** golang中的引用类型包括（）"></a>17、**[intermediate]** golang中的引用类型包括（）</h3><p>A. 数组切片</p>
<p>B. map</p>
<p>C. channel</p>
<p>D. interface</p>
<p>参考答案：ABCD</p>
<h3 id="18、-intermediate-golang中的指针运算包括（）"><a href="#18、-intermediate-golang中的指针运算包括（）" class="headerlink" title="18、**[intermediate]** golang中的指针运算包括（）"></a>18、**[intermediate]** golang中的指针运算包括（）</h3><p>A. 可以对指针进行自增或自减运算</p>
<p>B. 可以通过“&amp;”取指针的地址</p>
<p>C. 可以通过“*”取指针指向的数据</p>
<p>D. 可以对指针进行下标运算</p>
<p>参考答案：BC</p>
<h3 id="19、-primary-关于main函数（可执行程序的执行起点），下面说法正确的是（）"><a href="#19、-primary-关于main函数（可执行程序的执行起点），下面说法正确的是（）" class="headerlink" title="19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）"></a>19、**[primary]** 关于main函数（可执行程序的执行起点），下面说法正确的是（）</h3><p>A. main函数不能带参数</p>
<p>B. main函数不能定义返回值</p>
<p>C. main函数所在的包必须为main包</p>
<p>D. main函数中可以使用flag包来获取和解析命令行参数</p>
<p>参考答案：ABCD</p>
<h3 id="20、-intermediate-下面赋值正确的是（）"><a href="#20、-intermediate-下面赋值正确的是（）" class="headerlink" title="20、**[intermediate]** 下面赋值正确的是（）"></a>20、**[intermediate]** 下面赋值正确的是（）</h3><p>A. var x &#x3D; nil</p>
<p>B. var x interface{} &#x3D; nil</p>
<p>C. var x string &#x3D; nil</p>
<p>D. var x error &#x3D; nil</p>
<p>参考答案：BD</p>
<h3 id="21、-intermediate-关于整型切片的初始化，下面正确的是（）"><a href="#21、-intermediate-关于整型切片的初始化，下面正确的是（）" class="headerlink" title="21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）"></a>21、**[intermediate]** 关于整型切片的初始化，下面正确的是（）</h3><p>A. s :&#x3D; make([]int)</p>
<p>B. s :&#x3D; make([]int, 0)</p>
<p>C. s :&#x3D; make([]int, 5, 10)</p>
<p>D. s :&#x3D; []int{1, 2, 3, 4, 5}</p>
<p>参考答案：BCD</p>
<h3 id="22、-intermediate-从切片中删除一个元素，下面的算法实现正确的是（）"><a href="#22、-intermediate-从切片中删除一个元素，下面的算法实现正确的是（）" class="headerlink" title="22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）"></a>22、**[intermediate]** 从切片中删除一个元素，下面的算法实现正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                <span class="keyword">if</span> i== <span class="built_in">len</span>(*s) - <span class="number">1</span> &#123;</span><br><span class="line">                    *s = (*s)[:i]</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">2</span>:]...)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                <span class="built_in">delete</span>(*s, v)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span></span>Remove(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> *s &#123;</span><br><span class="line">            <span class="keyword">if</span> isEqual(value, v) &#123;</span><br><span class="line">                *s = <span class="built_in">append</span>((*s)[:i],(*s)[i + <span class="number">1</span>:]...)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERR_ELEM_NT_EXIST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：D</p>
<h3 id="23、-primary-对于局部变量整型切片x的赋值，下面定义正确的是（）"><a href="#23、-primary-对于局部变量整型切片x的赋值，下面定义正确的是（）" class="headerlink" title="23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）"></a>23、**[primary]** 对于局部变量整型切片x的赋值，下面定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：ACD</p>
<h3 id="24、-primary-关于变量的自增和自减操作，下面语句正确的是（）"><a href="#24、-primary-关于变量的自增和自减操作，下面语句正确的是（）" class="headerlink" title="24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）"></a>24、**[primary]** 关于变量的自增和自减操作，下面语句正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">i++</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">j = i++</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">++i</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line">i--</span><br></pre></td></tr></table></figure>



<p>参考答案：AD</p>
<h3 id="25、-intermediate-关于函数声明，下面语法错误的是（）"><a href="#25、-intermediate-关于函数声明，下面语法错误的是（）" class="headerlink" title="25、**[intermediate]** 关于函数声明，下面语法错误的是（）"></a>25、**[intermediate]** 关于函数声明，下面语法错误的是（）</h3><p>A. func f(a, b int) (value int, err error)</p>
<p>B. func f(a int, b int) (value int, err error)</p>
<p>C. func f(a, b int) (value int, error)</p>
<p>D. func f(a int, b int) (int, int, error)</p>
<p>参考答案：C</p>
<h3 id="26、-intermediate-如果Add函数的调用代码为："><a href="#26、-intermediate-如果Add函数的调用代码为：" class="headerlink" title="26、**[intermediate]** 如果Add函数的调用代码为："></a>26、**[intermediate]** 如果Add函数的调用代码为：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = &amp;a</span><br><span class="line">        sum := i.(*Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27、则Add函数定义正确的是（）"><a href="#27、则Add函数定义正确的是（）" class="headerlink" title="27、则Add函数定义正确的是（）"></a>27、则Add函数定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：AC</p>
<h3 id="28、-intermediate-如果Add函数的调用代码为："><a href="#28、-intermediate-如果Add函数的调用代码为：" class="headerlink" title="28、**[intermediate]** 如果Add函数的调用代码为："></a>28、**[intermediate]** 如果Add函数的调用代码为：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line">        sum := i.(Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="29、则Add函数定义正确的是（）"><a href="#29、则Add函数定义正确的是（）" class="headerlink" title="29、则Add函数定义正确的是（）"></a>29、则Add函数定义正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;</span><br><span class="line">        <span class="keyword">return</span> *a + *b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：A</p>
<h3 id="30、-intermediate-关于GetPodAction定义，下面赋值正确的是（）"><a href="#30、-intermediate-关于GetPodAction定义，下面赋值正确的是（）" class="headerlink" title="30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）"></a>30、**[intermediate]** 关于GetPodAction定义，下面赋值正确的是（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fragment <span class="keyword">interface</span> &#123;</span><br><span class="line">        Exec(transInfo *TransInfo) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GetPodAction <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g GetPodAction)</span></span> Exec(transInfo *TransInfo) <span class="type">error</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>A. var fragment Fragment &#x3D; new(GetPodAction)</p>
<p>B. var fragment Fragment &#x3D; GetPodAction</p>
<p>C. var fragment Fragment &#x3D; &amp;GetPodAction{}</p>
<p>D. var fragment Fragment &#x3D; GetPodAction{}</p>
<p>参考答案：ACD</p>
<h3 id="31、-intermediate-关于GoMock，下面说法正确的是（）"><a href="#31、-intermediate-关于GoMock，下面说法正确的是（）" class="headerlink" title="31、**[intermediate]** 关于GoMock，下面说法正确的是（）"></a>31、**[intermediate]** 关于GoMock，下面说法正确的是（）</h3><p>A. GoMock可以对interface打桩</p>
<p>B. GoMock可以对类的成员函数打桩</p>
<p>C. GoMock可以对函数打桩</p>
<p>D. GoMock打桩后的依赖注入可以通过GoStub完成</p>
<p>参考答案：AD</p>
<h3 id="32、-intermediate-关于接口，下面说法正确的是（）"><a href="#32、-intermediate-关于接口，下面说法正确的是（）" class="headerlink" title="32、**[intermediate]** 关于接口，下面说法正确的是（）"></a>32、**[intermediate]** 关于接口，下面说法正确的是（）</h3><p>A. 只要两个接口拥有相同的方法列表（次序不同不要紧），那么它们就是等价的，可以相互赋值</p>
<p>B. 如果接口A的方法列表是接口B的方法列表的子集，那么接口B可以赋值给接口A</p>
<p>C. 接口查询是否成功，要在运行期才能够确定</p>
<p>D. 接口赋值是否可行，要在运行期才能够确定</p>
<p>参考答案：ABC</p>
<h3 id="33、-primary-关于channel，下面语法正确的是（）"><a href="#33、-primary-关于channel，下面语法正确的是（）" class="headerlink" title="33、**[primary]** 关于channel，下面语法正确的是（）"></a>33、**[primary]** 关于channel，下面语法正确的是（）</h3><p>A. var ch chan int</p>
<p>B. ch :&#x3D; make(chan int)</p>
<p>C. &lt;- ch</p>
<p>D. ch &lt;-</p>
<p>参考答案：ABC</p>
<h3 id="34、-primary-关于同步锁，下面说法正确的是（）"><a href="#34、-primary-关于同步锁，下面说法正确的是（）" class="headerlink" title="34、**[primary]** 关于同步锁，下面说法正确的是（）"></a>34、**[primary]** 关于同步锁，下面说法正确的是（）</h3><p>A. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex</p>
<p>B. RWMutex在读锁占用的情况下，会阻止写，但不阻止读</p>
<p>C. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占</p>
<p>D. Lock()操作需要保证有Unlock()或RUnlock()调用与之对应</p>
<p>参考答案：ABC</p>
<h3 id="35、-intermediate-golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）"><a href="#35、-intermediate-golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）" class="headerlink" title="35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）"></a>35、**[intermediate]** golang中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外（）</h3><p>A. 指针</p>
<p>B. channel</p>
<p>C. complex</p>
<p>D. 函数</p>
<p>参考答案：BCD</p>
<h3 id="36、-intermediate-关于go-vendor，下面说法正确的是（）"><a href="#36、-intermediate-关于go-vendor，下面说法正确的是（）" class="headerlink" title="36、**[intermediate]** 关于go vendor，下面说法正确的是（）"></a>36、**[intermediate]** 关于go vendor，下面说法正确的是（）</h3><p>A. 基本思路是将引用的外部包的源代码放在当前工程的vendor目录下面</p>
<p>B. 编译go代码会优先从vendor目录先寻找依赖包</p>
<p>C. 可以指定引用某个特定版本的外部包</p>
<p>D. 有了vendor目录后，打包当前的工程代码到其他机器的$GOPATH&#x2F;src下都可以通过编译</p>
<p>参考答案：ABD</p>
<h3 id="37、-primary-flag是bool型变量，下面if表达式符合编码规范的是（）"><a href="#37、-primary-flag是bool型变量，下面if表达式符合编码规范的是（）" class="headerlink" title="37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）"></a>37、**[primary]** flag是bool型变量，下面if表达式符合编码规范的是（）</h3><p>A. if flag &#x3D;&#x3D; 1</p>
<p>B. if flag</p>
<p>C. if flag &#x3D;&#x3D; false</p>
<p>D. if !flag</p>
<p>参考答案：BD</p>
<h3 id="38、-primary-value是整型变量，下面if表达式符合编码规范的是（）"><a href="#38、-primary-value是整型变量，下面if表达式符合编码规范的是（）" class="headerlink" title="38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）"></a>38、**[primary]** value是整型变量，下面if表达式符合编码规范的是（）</h3><p>A. if value &#x3D;&#x3D; 0</p>
<p>B. if value</p>
<p>C. if value !&#x3D; 0</p>
<p>D. if !value</p>
<p>参考答案：AC</p>
<h3 id="39、-intermediate-关于函数返回值的错误设计，下面说法正确的是（）"><a href="#39、-intermediate-关于函数返回值的错误设计，下面说法正确的是（）" class="headerlink" title="39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）"></a>39、**[intermediate]** 关于函数返回值的错误设计，下面说法正确的是（）</h3><p>A. 如果失败原因只有一个，则返回bool</p>
<p>B. 如果失败原因超过一个，则返回error</p>
<p>C. 如果没有失败原因，则不返回bool或error</p>
<p>D. 如果重试几次可以避免失败，则不要立即返回bool或error</p>
<p>参考答案：ABCD</p>
<h3 id="40、-intermediate-关于异常设计，下面说法正确的是（）"><a href="#40、-intermediate-关于异常设计，下面说法正确的是（）" class="headerlink" title="40、**[intermediate]** 关于异常设计，下面说法正确的是（）"></a>40、**[intermediate]** 关于异常设计，下面说法正确的是（）</h3><p>A. 在程序开发阶段，坚持速错，让程序异常崩溃</p>
<p>B. 在程序部署后，应恢复异常避免程序终止</p>
<p>C. 一切皆错误，不用进行异常设计</p>
<p>D. 对于不应该出现的分支，使用异常处理</p>
<p>参考答案：ABD</p>
<h3 id="41、-intermediate-关于slice或map操作，下面正确的是（）"><a href="#41、-intermediate-关于slice或map操作，下面正确的是（）" class="headerlink" title="41、**[intermediate]** 关于slice或map操作，下面正确的是（）"></a>41、**[intermediate]** 关于slice或map操作，下面正确的是（）</h3><p>A.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>B.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>C.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<p>D.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>参考答案：ACD</p>
<h3 id="42、-intermediate-关于channel的特性，下面说法正确的是（）"><a href="#42、-intermediate-关于channel的特性，下面说法正确的是（）" class="headerlink" title="42、**[intermediate]** 关于channel的特性，下面说法正确的是（）"></a>42、**[intermediate]** 关于channel的特性，下面说法正确的是（）</h3><p>A. 给一个 nil channel 发送数据，造成永远阻塞</p>
<p>B. 从一个 nil channel 接收数据，造成永远阻塞</p>
<p>C. 给一个已经关闭的 channel 发送数据，引起 panic</p>
<p>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</p>
<p>参考答案：ABCD</p>
<h3 id="43、-intermediate-关于无缓冲和有冲突的channel，下面说法正确的是（）"><a href="#43、-intermediate-关于无缓冲和有冲突的channel，下面说法正确的是（）" class="headerlink" title="43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）"></a>43、**[intermediate]** 关于无缓冲和有冲突的channel，下面说法正确的是（）</h3><p>A. 无缓冲的channel是默认的缓冲为1的channel</p>
<p>B. 无缓冲的channel和有缓冲的channel都是同步的</p>
<p>C. 无缓冲的channel和有缓冲的channel都是非同步的</p>
<p>D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的</p>
<p>参考答案：D</p>
<h3 id="44、-intermediate-关于异常的触发，下面说法正确的是（）"><a href="#44、-intermediate-关于异常的触发，下面说法正确的是（）" class="headerlink" title="44、**[intermediate]** 关于异常的触发，下面说法正确的是（）"></a>44、**[intermediate]** 关于异常的触发，下面说法正确的是（）</h3><p>A. 空指针解析</p>
<p>B. 下标越界</p>
<p>C. 除数为0</p>
<p>D. 调用panic函数</p>
<p>参考答案：ABCD</p>
<h3 id="45、-intermediate-关于cap函数的适用类型，下面说法正确的是（）"><a href="#45、-intermediate-关于cap函数的适用类型，下面说法正确的是（）" class="headerlink" title="45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）"></a>45、**[intermediate]** 关于cap函数的适用类型，下面说法正确的是（）</h3><p>A. array</p>
<p>B. slice</p>
<p>C. map</p>
<p>D. channel</p>
<p>参考答案：ABD</p>
<h3 id="46、-intermediate-关于beego框架，下面说法正确的是（）"><a href="#46、-intermediate-关于beego框架，下面说法正确的是（）" class="headerlink" title="46、**[intermediate]** 关于beego框架，下面说法正确的是（）"></a>46、**[intermediate]** 关于beego框架，下面说法正确的是（）</h3><p>A. beego是一个golang实现的轻量级HTTP框架</p>
<p>B. beego可以通过注释路由、正则路由等多种方式完成url路由注入</p>
<p>C. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译</p>
<p>D. beego框架只提供了对url路由的处理， 而对于MVC架构中的数据库部分未提供框架支持</p>
<p>参考答案：ABC</p>
<h3 id="47、-intermediate-关于goconvey，下面说法正确的是（）"><a href="#47、-intermediate-关于goconvey，下面说法正确的是（）" class="headerlink" title="47、**[intermediate]** 关于goconvey，下面说法正确的是（）"></a>47、**[intermediate]** 关于goconvey，下面说法正确的是（）</h3><p>A. goconvey是一个支持golang的单元测试框架</p>
<p>B. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面</p>
<p>C. goconvey提供了丰富的断言简化测试用例的编写</p>
<p>D. goconvey无法与go test集成</p>
<p>参考答案：ABC</p>
<h3 id="48、-intermediate-关于go-vet，下面说法正确的是（）"><a href="#48、-intermediate-关于go-vet，下面说法正确的是（）" class="headerlink" title="48、**[intermediate]** 关于go vet，下面说法正确的是（）"></a>48、**[intermediate]** 关于go vet，下面说法正确的是（）</h3><p>A. go vet是golang自带工具go tool vet的封装</p>
<p>B. 当执行go vet database时，可以对database所在目录下的所有子文件夹进行递归检测</p>
<p>C. go vet可以使用绝对路径、相对路径或相对GOPATH的路径指定待检测的包</p>
<p>D. go vet可以检测出死代码</p>
<p>参考答案：ACD</p>
<h3 id="49、-intermediate-关于map，下面说法正确的是（）"><a href="#49、-intermediate-关于map，下面说法正确的是（）" class="headerlink" title="49、**[intermediate]** 关于map，下面说法正确的是（）"></a>49、**[intermediate]** 关于map，下面说法正确的是（）</h3><p>A. map反序列化时json.unmarshal的入参必须为map的地址</p>
<p>B. 在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改</p>
<p>C. 在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改</p>
<p>D. 不能使用内置函数delete删除map的元素</p>
<p>参考答案：A</p>
<h3 id="50、-intermediate-关于GoStub，下面说法正确的是（）"><a href="#50、-intermediate-关于GoStub，下面说法正确的是（）" class="headerlink" title="50、**[intermediate]** 关于GoStub，下面说法正确的是（）"></a>50、**[intermediate]** 关于GoStub，下面说法正确的是（）</h3><p>A. GoStub可以对全局变量打桩</p>
<p>B. GoStub可以对函数打桩</p>
<p>C. GoStub可以对类的成员方法打桩</p>
<p>D. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为</p>
<p>参考答案：ABD</p>
<h3 id="51、-primary-关于select机制，下面说法正确的是（）"><a href="#51、-primary-关于select机制，下面说法正确的是（）" class="headerlink" title="51、**[primary]** 关于select机制，下面说法正确的是（）"></a>51、**[primary]** 关于select机制，下面说法正确的是（）</h3><p>A. select机制用来处理异步IO问题</p>
<p>B. select机制最大的一条限制就是每个case语句里必须是一个IO操作</p>
<p>C. golang在语言级别支持select关键字</p>
<p>D. select关键字的用法与switch语句非常类似，后面要带判断条件</p>
<p>参考答案：ABC</p>
<h3 id="52、-primary-关于内存泄露，下面说法正确的是（）"><a href="#52、-primary-关于内存泄露，下面说法正确的是（）" class="headerlink" title="52、**[primary]** 关于内存泄露，下面说法正确的是（）"></a>52、**[primary]** 关于内存泄露，下面说法正确的是（）</h3><p>A. golang有自动垃圾回收，不存在内存泄露</p>
<p>B. golang中检测内存泄露主要依靠的是pprof包</p>
<p>C. 内存泄露可以在编译阶段发现</p>
<p>D. 应定期使用浏览器来查看系统的实时内存信息，及时发现内存泄露问题</p>
<p>参考答案：BD</p>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="1、-primary-声明一个整型变量i"><a href="#1、-primary-声明一个整型变量i" class="headerlink" title="1、**[primary]** 声明一个整型变量i__________"></a>1、**[primary]** 声明一个整型变量i__________</h3><p>参考答案：var i int</p>
<h3 id="2、-primary-声明一个含有10个元素的整型数组a"><a href="#2、-primary-声明一个含有10个元素的整型数组a" class="headerlink" title="2、**[primary]** 声明一个含有10个元素的整型数组a__________"></a>2、**[primary]** 声明一个含有10个元素的整型数组a__________</h3><p>参考答案：var a [10]int</p>
<h3 id="3、-primary-声明一个整型数组切片s"><a href="#3、-primary-声明一个整型数组切片s" class="headerlink" title="3、**[primary]** 声明一个整型数组切片s__________"></a>3、**[primary]** 声明一个整型数组切片s__________</h3><p>参考答案：var s []int</p>
<h3 id="4、-primary-声明一个整型指针变量p"><a href="#4、-primary-声明一个整型指针变量p" class="headerlink" title="4、**[primary]** 声明一个整型指针变量p__________"></a>4、**[primary]** 声明一个整型指针变量p__________</h3><p>参考答案：var p *int</p>
<h3 id="5、-primary-声明一个key为字符串型value为整型的map变量m"><a href="#5、-primary-声明一个key为字符串型value为整型的map变量m" class="headerlink" title="5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________"></a>5、**[primary]** 声明一个key为字符串型value为整型的map变量m__________</h3><p>参考答案：var m map[string]int</p>
<h3 id="6、-primary-声明一个入参和返回值均为整型的函数变量f"><a href="#6、-primary-声明一个入参和返回值均为整型的函数变量f" class="headerlink" title="6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________"></a>6、**[primary]** 声明一个入参和返回值均为整型的函数变量f__________</h3><p>参考答案：var f func(a int) int</p>
<h3 id="7、-primary-声明一个只用于读取int数据的单向channel变量ch"><a href="#7、-primary-声明一个只用于读取int数据的单向channel变量ch" class="headerlink" title="7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________"></a>7、**[primary]** 声明一个只用于读取int数据的单向channel变量ch__________</h3><p>参考答案：var ch &lt;-chan int</p>
<h3 id="8、-primary-假设源文件的命名为slice-go，则测试文件的命名为"><a href="#8、-primary-假设源文件的命名为slice-go，则测试文件的命名为" class="headerlink" title="8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________"></a>8、**[primary]** 假设源文件的命名为slice.go，则测试文件的命名为__________</h3><p>参考答案：slice_test.go</p>
<h3 id="9、-primary-go-test要求测试函数的前缀必须命名为"><a href="#9、-primary-go-test要求测试函数的前缀必须命名为" class="headerlink" title="9、**[primary]** go test要求测试函数的前缀必须命名为__________"></a>9、**[primary]** go test要求测试函数的前缀必须命名为__________</h3><p>参考答案：Test</p>
<h3 id="10、-intermediate-下面的程序的运行结果是"><a href="#10、-intermediate-下面的程序的运行结果是" class="headerlink" title="10、**[intermediate]** 下面的程序的运行结果是__________"></a>10、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：4 3 2 1 0</p>
<h3 id="11、-intermediate-下面的程序的运行结果是"><a href="#11、-intermediate-下面的程序的运行结果是" class="headerlink" title="11、**[intermediate]** 下面的程序的运行结果是__________"></a>11、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            x := <span class="number">2</span></span><br><span class="line">            fmt.Print(x)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：21</p>
<h3 id="12、-intermediate-下面的程序的运行结果是"><a href="#12、-intermediate-下面的程序的运行结果是" class="headerlink" title="12、**[intermediate]** 下面的程序的运行结果是__________"></a>12、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        strs := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">                fmt.Printf(<span class="string">&quot;%s &quot;</span>, s)</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：three three three</p>
<h3 id="13、-intermediate-下面的程序的运行结果是"><a href="#13、-intermediate-下面的程序的运行结果是" class="headerlink" title="13、**[intermediate]** 下面的程序的运行结果是__________"></a>13、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">            fmt.Print(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：012</p>
<h3 id="14、-intermediate-下面的程序的运行结果是"><a href="#14、-intermediate-下面的程序的运行结果是" class="headerlink" title="14、**[intermediate]** 下面的程序的运行结果是__________"></a>14、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">            fmt.Print(v)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：abc</p>
<h3 id="15、-primary-下面的程序的运行结果是"><a href="#15、-primary-下面的程序的运行结果是" class="headerlink" title="15、**[primary]** 下面的程序的运行结果是__________"></a>15、**[primary]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">       i := <span class="number">1</span></span><br><span class="line">       j := <span class="number">2</span></span><br><span class="line">       i, j = j, i</span><br><span class="line">       fmt.Printf(<span class="string">&quot;%d%d\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：21</p>
<h3 id="16、-primary-下面的程序的运行结果是"><a href="#16、-primary-下面的程序的运行结果是" class="headerlink" title="16、**[primary]** 下面的程序的运行结果是__________"></a>16、**[primary]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        *p++</span><br><span class="line">        <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        v := <span class="number">1</span></span><br><span class="line">        incr(&amp;v)</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：2</p>
<h3 id="17、-primary-启动一个goroutine的关键字是"><a href="#17、-primary-启动一个goroutine的关键字是" class="headerlink" title="17、**[primary]** 启动一个goroutine的关键字是__________"></a>17、**[primary]** 启动一个goroutine的关键字是__________</h3><p>参考答案：go</p>
<h3 id="18、-intermediate-下面的程序的运行结果是"><a href="#18、-intermediate-下面的程序的运行结果是" class="headerlink" title="18、**[intermediate]** 下面的程序的运行结果是__________"></a>18、**[intermediate]** 下面的程序的运行结果是__________</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">()</span></span> Slice &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">make</span>(Slice, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s* Slice)</span></span> Add(elem <span class="type">int</span>) *Slice &#123;</span><br><span class="line">         *s = <span class="built_in">append</span>(*s, elem)</span><br><span class="line">         fmt.Print(elem)</span><br><span class="line">         <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">         s := NewSlice()</span><br><span class="line">         <span class="keyword">defer</span> s.Add(<span class="number">1</span>).Add(<span class="number">2</span>)</span><br><span class="line">         s.Add(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：132</p>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><h3 id="1、-primary-数组是一个值类型（）"><a href="#1、-primary-数组是一个值类型（）" class="headerlink" title="1、**[primary]** 数组是一个值类型（）"></a>1、**[primary]** 数组是一个值类型（）</h3><p>参考答案：T</p>
<h3 id="2、-primary-使用map不需要引入任何库（）"><a href="#2、-primary-使用map不需要引入任何库（）" class="headerlink" title="2、**[primary]** 使用map不需要引入任何库（）"></a>2、**[primary]** 使用map不需要引入任何库（）</h3><p>参考答案：T</p>
<h3 id="3、-intermediate-内置函数delete可以删除数组切片内的元素（）"><a href="#3、-intermediate-内置函数delete可以删除数组切片内的元素（）" class="headerlink" title="3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）"></a>3、**[intermediate]** 内置函数delete可以删除数组切片内的元素（）</h3><p>参考答案：F</p>
<h3 id="4、-primary-指针是基础类型（）"><a href="#4、-primary-指针是基础类型（）" class="headerlink" title="4、**[primary]** 指针是基础类型（）"></a>4、**[primary]** 指针是基础类型（）</h3><p>参考答案：F</p>
<h3 id="5、-primary-interface-是可以指向任意对象的Any类型（）"><a href="#5、-primary-interface-是可以指向任意对象的Any类型（）" class="headerlink" title="5、**[primary]** interface{}是可以指向任意对象的Any类型（）"></a>5、**[primary]** interface{}是可以指向任意对象的Any类型（）</h3><p>参考答案：T</p>
<h3 id="6、-intermediate-下面关于文件操作的代码可能触发异常（）"><a href="#6、-intermediate-下面关于文件操作的代码可能触发异常（）" class="headerlink" title="6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）"></a>6、**[intermediate]** 下面关于文件操作的代码可能触发异常（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;open file failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>参考答案：T</p>
<h3 id="7、-primary-Golang不支持自动垃圾回收（）"><a href="#7、-primary-Golang不支持自动垃圾回收（）" class="headerlink" title="7、**[primary]** Golang不支持自动垃圾回收（）"></a>7、**[primary]** Golang不支持自动垃圾回收（）</h3><p>参考答案：F</p>
<h3 id="8、-primary-Golang支持反射，反射最常见的使用场景是做对象的序列化（）"><a href="#8、-primary-Golang支持反射，反射最常见的使用场景是做对象的序列化（）" class="headerlink" title="8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）"></a>8、**[primary]** Golang支持反射，反射最常见的使用场景是做对象的序列化（）</h3><p>参考答案：T</p>
<h3 id="9、-primary-Golang可以复用C-C-的模块，这个功能叫Cgo（）"><a href="#9、-primary-Golang可以复用C-C-的模块，这个功能叫Cgo（）" class="headerlink" title="9、**[primary]** Golang可以复用C&#x2F;C++的模块，这个功能叫Cgo（）"></a>9、**[primary]** Golang可以复用C&#x2F;C++的模块，这个功能叫Cgo（）</h3><p>参考答案：F</p>
<h3 id="10、-primary-下面代码中两个斜点之间的代码，比如json-x-，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）"><a href="#10、-primary-下面代码中两个斜点之间的代码，比如json-x-，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）" class="headerlink" title="10、**[primary]** 下面代码中两个斜点之间的代码，比如json:&quot;x&quot;，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）"></a>10、**[primary]** 下面代码中两个斜点之间的代码，比如<code>json:&quot;x&quot;</code>，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;</span><br><span class="line">        X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">        Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">        Z <span class="type">int</span> <span class="string">`json:&quot;z&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：T</p>
<h3 id="11、-primary-通过成员变量或函数首字母的大小写来决定其作用域（）"><a href="#11、-primary-通过成员变量或函数首字母的大小写来决定其作用域（）" class="headerlink" title="11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）"></a>11、**[primary]** 通过成员变量或函数首字母的大小写来决定其作用域（）</h3><p>参考答案：T</p>
<h3 id="12、-primary-对于常量定义zero-const-zero-0-0-，zero是浮点型常量（）"><a href="#12、-primary-对于常量定义zero-const-zero-0-0-，zero是浮点型常量（）" class="headerlink" title="12、**[primary]** 对于常量定义zero(const zero &#x3D; 0.0)，zero是浮点型常量（）"></a>12、**[primary]** 对于常量定义zero(const zero &#x3D; 0.0)，zero是浮点型常量（）</h3><p>参考答案：F</p>
<h3 id="13、-primary-对变量x的取反操作是-x（）"><a href="#13、-primary-对变量x的取反操作是-x（）" class="headerlink" title="13、**[primary]** 对变量x的取反操作是~x（）"></a>13、**[primary]** 对变量x的取反操作是~x（）</h3><p>参考答案：F</p>
<h3 id="14、-primary-下面的程序的运行结果是xello（）"><a href="#14、-primary-下面的程序的运行结果是xello（）" class="headerlink" title="14、**[primary]** 下面的程序的运行结果是xello（）"></a>14、**[primary]** 下面的程序的运行结果是xello（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">        fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="15、-primary-golang支持goto语句（）"><a href="#15、-primary-golang支持goto语句（）" class="headerlink" title="15、**[primary]** golang支持goto语句（）"></a>15、**[primary]** golang支持goto语句（）</h3><p>参考答案：T</p>
<h3 id="16、-primary-下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）"><a href="#16、-primary-下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）" class="headerlink" title="16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）"></a>16、**[primary]** 下面代码中的指针p为野指针，因为返回的栈内存在函数结束时会被释放（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TimesMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">        base <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimesMatcher</span><span class="params">(base <span class="type">int</span>)</span></span> *TimesMatcher&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TimesMatcher&#123;base:base&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p := NewTimesMatcher(<span class="number">3</span>)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="17、-primary-匿名函数可以直接赋值给一个变量或者直接执行（）"><a href="#17、-primary-匿名函数可以直接赋值给一个变量或者直接执行（）" class="headerlink" title="17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）"></a>17、**[primary]** 匿名函数可以直接赋值给一个变量或者直接执行（）</h3><p>参考答案：T</p>
<h3 id="18、-primary-如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“-”来跳过这个返回值，该下划线对应的变量叫匿名变量（）"><a href="#18、-primary-如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“-”来跳过这个返回值，该下划线对应的变量叫匿名变量（）" class="headerlink" title="18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）"></a>18、**[primary]** 如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（）</h3><p>参考答案：T</p>
<h3 id="19、-primary-在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）"><a href="#19、-primary-在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）" class="headerlink" title="19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）"></a>19、**[primary]** 在函数的多返回值中，如果有error或bool类型，则一般放在最后一个（）</h3><p>参考答案：T</p>
<h3 id="20、-primary-错误是业务过程的一部分，而异常不是（）"><a href="#20、-primary-错误是业务过程的一部分，而异常不是（）" class="headerlink" title="20、**[primary]** 错误是业务过程的一部分，而异常不是（）"></a>20、**[primary]** 错误是业务过程的一部分，而异常不是（）</h3><p>参考答案：T</p>
<h3 id="21、-primary-函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）"><a href="#21、-primary-函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）" class="headerlink" title="21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）"></a>21、**[primary]** 函数执行时，如果由于panic导致了异常，则延迟函数不会执行（）</h3><p>参考答案：F</p>
<h3 id="22、-intermediate-当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）"><a href="#22、-intermediate-当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）" class="headerlink" title="22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）"></a>22、**[intermediate]** 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，其他携程的终止过程也是重复发生：函数停止执行，调用延迟执行函数（）</h3><p>参考答案：F</p>
<h3 id="23、-primary-同级文件的包名不允许有多个（）"><a href="#23、-primary-同级文件的包名不允许有多个（）" class="headerlink" title="23、**[primary]** 同级文件的包名不允许有多个（）"></a>23、**[primary]** 同级文件的包名不允许有多个（）</h3><p>参考答案：T</p>
<h3 id="24、-intermediate-可以给任意类型添加相应的方法（）"><a href="#24、-intermediate-可以给任意类型添加相应的方法（）" class="headerlink" title="24、**[intermediate]** 可以给任意类型添加相应的方法（）"></a>24、**[intermediate]** 可以给任意类型添加相应的方法（）</h3><p>参考答案：F</p>
<h3 id="25、-primary-golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）"><a href="#25、-primary-golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）" class="headerlink" title="25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）"></a>25、**[primary]** golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（）</h3><p>参考答案：T</p>
<h3 id="26、-primary-使用for-range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）"><a href="#26、-primary-使用for-range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）" class="headerlink" title="26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）"></a>26、**[primary]** 使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（）</h3><p>参考答案：T</p>
<h3 id="27、-primary-switch后面可以不跟表达式（）"><a href="#27、-primary-switch后面可以不跟表达式（）" class="headerlink" title="27、**[primary]** switch后面可以不跟表达式（）"></a>27、**[primary]** switch后面可以不跟表达式（）</h3><p>参考答案：T</p>
<h3 id="28、-intermediate-结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）"><a href="#28、-intermediate-结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）" class="headerlink" title="28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）"></a>28、**[intermediate]** 结构体在序列化时非导出变量（以小写字母开头的变量名）不会被encode，因此在decode时这些非导出变量的值为其类型的零值（）</h3><p>参考答案：T</p>
<h3 id="29、-primary-golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）"><a href="#29、-primary-golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）" class="headerlink" title="29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）"></a>29、**[primary]** golang中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名（）</h3><p>参考答案：T</p>
<h3 id="30、-intermediate-当函数deferDemo返回失败时，并不能destroy已create成功的资源（）"><a href="#30、-intermediate-当函数deferDemo返回失败时，并不能destroy已create成功的资源（）" class="headerlink" title="30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）"></a>30、**[intermediate]** 当函数deferDemo返回失败时，并不能destroy已create成功的资源（）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        err := createResource1()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                destroyResource1()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        err = createResource2()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                destroyResource2()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        err = createResource3()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考答案：F</p>
<h3 id="31、-intermediate-channel本身必然是同时支持读写的，所以不存在单向channel（）"><a href="#31、-intermediate-channel本身必然是同时支持读写的，所以不存在单向channel（）" class="headerlink" title="31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）"></a>31、**[intermediate]** channel本身必然是同时支持读写的，所以不存在单向channel（）</h3><p>参考答案：F</p>
<h3 id="32、-primary-import后面的最后一个元素是包名（）"><a href="#32、-primary-import后面的最后一个元素是包名（）" class="headerlink" title="32、**[primary]** import后面的最后一个元素是包名（）"></a>32、**[primary]** import后面的最后一个元素是包名（）</h3><p>参考答案：F</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2024
        <i class="ri-heart-fill heart_icon"></i> 杨海波
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/SETSUNAYANG.JPG" alt="杨海波"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://github.com/3546514206">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>