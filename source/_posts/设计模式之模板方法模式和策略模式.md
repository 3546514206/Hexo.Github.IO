---
title: 设计模式之模板方法模式和策略模式
date: 2023-09-09 13:28:20
categories: 
- 基本功
- 编程基础
- 设计模式
- 策略模式、模板方法
tags:
- 设计模式
- Java
---

&ensp;&ensp;&ensp;&ensp; 这篇博客的设计模式应用案例来自于这个仓库，完整代码可以参考本仓库：

&ensp;&ensp;&ensp;&ensp; [微信大模型接入](https://github.com/3546514206/WxChatGPT)

![仓库主页](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E4%BB%93%E5%BA%93.png?raw=true)

&ensp;&ensp;&ensp;&ensp; 简单介绍一下这个仓库：1）实现了微信接入；2）实现了大模型接入；3）将微信的提问发给大模型，将大模型的回答返回给微信（欢迎给个 star）。

#### __1、背景分析__

&ensp;&ensp;&ensp;&ensp; 1）我们预期接入的大模型肯定不止一种，现在市面上除了最牛的 GhatGPT，国内也陆续退出了豆包、文心一言、星火大模型等。为了获得良好的扩展性，我们可以基于策略模式对模型通讯模块进行封装，将不同的模型定义为一种通讯策略，程序中可以通过参数指定不同的模型工作；

&ensp;&ensp;&ensp;&ensp; 2）通讯的过程无非就是三个阶段：通信前参数组装、进行通讯、通讯完成处理结果，这里显然是可以通过模板方法进行封装的。结合策略模式，我们可以规定将来接入新模型的时候，有统一的代码组织形式和良好的扩展接口。

#### __2、知识补充__

&ensp;&ensp;&ensp;&ensp; 我们这里不再对设计模式本身进行专门的讲解。

&ensp;&ensp;&ensp;&ensp; [策略模式](https://www.runoob.com/design-pattern/strategy-pattern.html)

&ensp;&ensp;&ensp;&ensp; [模板方法模式](https://www.runoob.com/design-pattern/template-pattern.html)

#### __3、代码分析__

&ensp;&ensp;&ensp;&ensp; 如下图所示，DefaultHandler 是程序写给微信接入模块的一个回调（实现了消息处理接口 IMsgHandlerFace），当微信接入模块接收到微信消息，便会触发此回调，执行用户预定义行为。也就是在这个地方，我们接入了大模型，并将模型的问答结果返回给微信。 

![模型接入的地方](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E7%9A%84%E5%9C%B0%E6%96%B9.png?raw=true)

&ensp;&ensp;&ensp;&ensp; 一下三行代码的作用分别是：获取聊天模型的策略上下文（请参考上文中菜鸟教程——策略模式），返回的策略上下文会包含具体的执行策略，执行策略的选择是程序参数定义的。

```Java
// 聊天模型策略
StrategyContext context = getStrategyContext();
// 构建聊天请求
ChatRequest request = buildChatRequest(msg);
// 进行聊天
ChatResponse response = context.executeStrategy(request);
```

![程序参数指定执行策略](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E8%81%8A%E5%A4%A9%E6%A8%A1%E5%9E%8B.png?raw=true)

#### __3、策略模式实现__

&ensp;&ensp;&ensp;&ensp; 首先，定义策略接口，策略接口中的 exec 方法是所有具体的策略类都需要实现的。

![策略接口](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%8E%A5%E5%8F%A3.png?raw=true)

&ensp;&ensp;&ensp;&ensp; 定义策略上下文，上下文是统一交给用户侧的一个”句柄”（可以参考上文 DefaultHandler 的代码，用户侧通过获取策略上下文来执行具体的策略实现的），用于持有具体的策略实现。

![策略上下文](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E4%B8%8A%E4%B8%8B%E6%96%87.png?raw=true)

&ensp;&ensp;&ensp;&ensp; 我们这里的策略实现类稍有不同，没有直接实现 exec 方法，也没有直接实现 IStrategy 接口。这涉及到另外一个设计模式——模板方法模式。

![策略实现类](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E7%B1%BB.png?raw=true)

#### __4、__ 模板方法模式

&ensp;&ensp;&ensp;&ensp; 抽象策略类定义了一个算法模板方法，这个模板方法规定了 exec 方法执行时发生的三个算法步骤：postChatRequest (执行前的参数处理)、doExec (执行通讯请求)、postChatResponse(通讯完成之后的响应报文处理)。但是我并没有对这三个步骤进行实现，他们都是抽象的，延迟到了将来的策略实现类去实现。

![抽象策略类](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E7%AD%96%E7%95%A5%E7%B1%BB.jpg?raw=true)



&ensp;&ensp;&ensp;&ensp; 所有的策略实现类，实现的不是策略接口 IStrategy，而是继承抽象策略类 AbstractStrategy，也不再去实现 exec 方法，而是实现抽象类中算法模板规定的三个算法步骤。

![实现抽象策略类中规定的三个既定步骤](https://github.com/3546514206/ImageHost.Github.IO/blob/main/%E5%9F%BA%E6%9C%AC%E5%8A%9F/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%88%B6%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.jpg?raw=true)

#### __5、__ 其他一些想法

&ensp;&ensp;&ensp;&ensp; 面向对象语言最重要的三个基本特性：封装、多态、继承，是软件工程七大原则开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特原则和合成复用原则的重要支撑点，设计模式是一种如何最大化发挥三个基本特性，从而能够遵循七大原则的一种编码层级上的技术，这也是 Java、C++ 等完美支持 OOP 编程范式语言，在面临庞大复杂工程时，总能将源代码组织得很好的原因之一吧。从这个角度出发，Go 语言在多态、继承的表现力上不足，也许是因为我还比较缺乏 Go 开发的实战经验，所以我不确定在面临复杂的建模场景的时候，Go 语言的编程方式还能不能进行有效表达。